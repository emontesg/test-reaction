[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar meteorInstall = Package.modules.meteorInstall;\nvar EJSON = Package.ejson.EJSON;\n\n/* Package-scope variables */\nvar OAuthEncryption;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"oauth-encryption\":{\"encrypt.js\":function(require,exports){\n\n//////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                      //\n// packages/oauth-encryption/encrypt.js                                                 //\n//                                                                                      //\n//////////////////////////////////////////////////////////////////////////////////////////\n                                                                                        //\nvar crypto = require(\"crypto\");\nvar gcmKey = null;\nvar OAuthEncryption = exports.OAuthEncryption = {};\nvar objToStr = Object.prototype.toString;\n\nfunction isString(value) {\n  return objToStr.call(value) === \"[object String]\";\n}\n\n// Node leniently ignores non-base64 characters when parsing a base64\n// string, but we want to provide a more informative error message if\n// the developer doesn't use base64 encoding.\n//\n// Note that an empty string is valid base64 (denoting 0 bytes).\n//\n// Exported for the convenience of tests.\n//\nOAuthEncryption._isBase64 = function (str) {\n  return isString(str) && /^[A-Za-z0-9\\+\\/]*\\={0,2}$/.test(str);\n};\n\n\n// Loads the OAuth secret key, which must be 16 bytes in length\n// encoded in base64.\n//\n// The key may be `null` which reverts to having no key (mainly used\n// by tests).\n//\nOAuthEncryption.loadKey = function (key) {\n  if (key === null) {\n    gcmKey = null;\n    return;\n  }\n\n  if (! OAuthEncryption._isBase64(key))\n    throw new Error(\"The OAuth encryption key must be encoded in base64\");\n\n  var buf = Buffer.from(key, \"base64\");\n\n  if (buf.length !== 16)\n    throw new Error(\"The OAuth encryption AES-128-GCM key must be 16 bytes in length\");\n\n  gcmKey = buf;\n};\n\n\n// Encrypt `data`, which may be any EJSON-compatible object, using the\n// previously loaded OAuth secret key.\n//\n// The `userId` argument is optional. The data is encrypted as { data:\n// *, userId: * }. When the result of `seal` is passed to `open`, the\n// same user id must be supplied, which prevents user specific\n// credentials such as access tokens from being used by a different\n// user.\n//\n// We might someday like the user id to be AAD (additional authenticated\n// data), but the Node 0.10.x crypto API did not support specifying AAD,\n// and it's not clear that we want to incur the compatibility issues of\n// relying on that feature, even though it's now supported by Node 4.\n//\nOAuthEncryption.seal = function (data, userId) {\n  if (! gcmKey) {\n    throw new Error(\"No OAuth encryption key loaded\");\n  }\n\n  var plaintext = Buffer.from(EJSON.stringify({\n    data: data,\n    userId: userId\n  }));\n\n  var iv = crypto.randomBytes(12);\n  var cipher = crypto.createCipheriv(\"aes-128-gcm\", gcmKey, iv);\n  cipher.setAAD(Buffer.from([]));\n  var chunks = [cipher.update(plaintext)];\n  chunks.push(cipher.final());\n  var encrypted = Buffer.concat(chunks);\n\n  return {\n    iv: iv.toString(\"base64\"),\n    ciphertext: encrypted.toString(\"base64\"),\n    algorithm: \"aes-128-gcm\",\n    authTag: cipher.getAuthTag().toString(\"base64\")\n  };\n};\n\n// Decrypt the passed ciphertext (as returned from `seal`) using the\n// previously loaded OAuth secret key.\n//\n// `userId` must match the user id passed to `seal`: if the user id\n// wasn't specified, it must not be specified here, if it was\n// specified, it must be the same user id.\n//\n// To prevent an attacker from breaking the encryption key by\n// observing the result of sending manipulated ciphertexts, `open`\n// throws \"decryption unsuccessful\" on any error.\nOAuthEncryption.open = function (ciphertext, userId) {\n  if (! gcmKey)\n    throw new Error(\"No OAuth encryption key loaded\");\n\n  try {\n    if (ciphertext.algorithm !== \"aes-128-gcm\") {\n      throw new Error();\n    }\n\n    var decipher = crypto.createDecipheriv(\n      \"aes-128-gcm\",\n      gcmKey,\n      Buffer.from(ciphertext.iv, \"base64\")\n    );\n\n    decipher.setAAD(Buffer.from([]));\n    decipher.setAuthTag(Buffer.from(ciphertext.authTag, \"base64\"));\n    var chunks = [decipher.update(\n      Buffer.from(ciphertext.ciphertext, \"base64\"))];\n    chunks.push(decipher.final());\n    var plaintext = Buffer.concat(chunks).toString(\"utf8\");\n\n    var err;\n    var data;\n\n    try {\n      data = EJSON.parse(plaintext);\n    } catch (e) {\n      err = new Error();\n    }\n\n    if (data.userId !== userId) {\n      err = new Error();\n    }\n\n    if (err) {\n      throw err;\n    } else {\n      return data.data;\n    }\n  } catch (e) {\n    throw new Error(\"decryption failed\");\n  }\n};\n\n\nOAuthEncryption.isSealed = function (maybeCipherText) {\n  return maybeCipherText &&\n    OAuthEncryption._isBase64(maybeCipherText.iv) &&\n    OAuthEncryption._isBase64(maybeCipherText.ciphertext) &&\n    OAuthEncryption._isBase64(maybeCipherText.authTag) &&\n    isString(maybeCipherText.algorithm);\n};\n\n\nOAuthEncryption.keyIsLoaded = function () {\n  return !! gcmKey;\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////\n\n}}}}},{\n  \"extensions\": [\n    \".js\",\n    \".json\"\n  ]\n});\nvar exports = require(\"/node_modules/meteor/oauth-encryption/encrypt.js\");\n\n/* Exports */\nPackage._define(\"oauth-encryption\", exports, {\n  OAuthEncryption: OAuthEncryption\n});\n\n})();\n","servePath":"/packages/oauth-encryption.js"}]