[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar _ = Package.underscore._;\nvar check = Package.check.check;\nvar Match = Package.check.Match;\nvar MongoInternals = Package.mongo.MongoInternals;\nvar Mongo = Package.mongo.Mongo;\nvar Log = Package.logging.Log;\n\n/* Package-scope variables */\nvar Migrations;\n\n(function(){\n\n//////////////////////////////////////////////////////////////////////////////////////\n//                                                                                  //\n// packages/percolate_migrations/migrations_server.js                               //\n//                                                                                  //\n//////////////////////////////////////////////////////////////////////////////////////\n                                                                                    //\n/*\n  Adds migration capabilities. Migrations are defined like:\n\n  Migrations.add({\n    up: function() {}, //*required* code to run to migrate upwards\n    version: 1, //*required* number to identify migration order\n    down: function() {}, //*optional* code to run to migrate downwards\n    name: 'Something' //*optional* display name for the migration\n  });\n\n  The ordering of migrations is determined by the version you set.\n\n  To run the migrations, set the MIGRATE environment variable to either\n  'latest' or the version number you want to migrate to. Optionally, append\n  ',exit' if you want the migrations to exit the meteor process, e.g if you're\n  migrating from a script (remember to pass the --once parameter).\n\n  e.g:\n  MIGRATE=\"latest\" mrt # ensure we'll be at the latest version and run the app\n  MIGRATE=\"latest,exit\" mrt --once # ensure we'll be at the latest version and exit\n  MIGRATE=\"2,exit\" mrt --once # migrate to version 2 and exit\n\n  Note: Migrations will lock ensuring only 1 app can be migrating at once. If\n  a migration crashes, the control record in the migrations collection will\n  remain locked and at the version it was at previously, however the db could\n  be in an inconsistant state.\n*/\n\n// since we'll be at version 0 by default, we should have a migration set for\n// it.\nvar DefaultMigration = {version: 0, up: function(){}};\n\nMigrations = {\n  _list: [DefaultMigration],\n  options: {\n    // false disables logging\n    log: true,\n    // null or a function\n    logger: null,\n    // enable/disable info log \"already at latest.\"\n    logIfLatest: true,\n    // migrations collection name\n    collectionName: \"migrations\"\n  },\n  config: function(opts) {\n    this.options = _.extend({}, this.options, opts);\n  },\n}\n\n/*\n  Logger factory function. Takes a prefix string and options object\n  and uses an injected `logger` if provided, else falls back to\n  Meteor's `Log` package.\n  Will send a log object to the injected logger, on the following form:\n    message: String\n    level: String (info, warn, error, debug)\n    tag: 'Migrations'\n*/\nfunction createLogger(prefix) {\n  check(prefix, String);\n\n  // Return noop if logging is disabled.\n  if(Migrations.options.log === false) {\n    return function() {};\n  }\n\n  return function(level, message) {\n    check(level, Match.OneOf('info', 'error', 'warn', 'debug'));\n    check(message, String);\n\n    var logger = Migrations.options && Migrations.options.logger;\n\n    if(logger && _.isFunction(logger)) {\n\n      logger({\n        level: level,\n        message: message,\n        tag: prefix\n      });\n\n    } else {\n      Log[level]({ message: prefix + ': ' + message });\n    }\n  }\n}\n\nvar log;\n\nMeteor.startup(function () {\n  var options = Migrations.options;\n\n  // collection holding the control record\n  Migrations._collection = new Mongo.Collection(options.collectionName);\n\n  log = createLogger('Migrations');\n\n  ['info', 'warn', 'error', 'debug'].forEach(function(level) {\n    log[level] = _.partial(log, level);\n  });\n\n  if (process.env.MIGRATE)\n    Migrations.migrateTo(process.env.MIGRATE);\n});\n\n// Add a new migration:\n// {up: function *required\n//  version: Number *required\n//  down: function *optional\n//  name: String *optional\n// }\nMigrations.add = function(migration) {\n  if (typeof migration.up !== 'function')\n    throw new Meteor.Error('Migration must supply an up function.');\n\n  if (typeof migration.version !== 'number')\n    throw new Meteor.Error('Migration must supply a version number.');\n\n  if (migration.version <= 0)\n    throw new Meteor.Error('Migration version must be greater than 0');\n\n  // Freeze the migration object to make it hereafter immutable\n  Object.freeze(migration);\n\n  this._list.push(migration);\n  this._list = _.sortBy(this._list, function(m) {return m.version;});\n}\n\n// Attempts to run the migrations using command in the form of:\n// e.g 'latest', 'latest,exit', 2\n// use 'XX,rerun' to re-run the migration at that version\nMigrations.migrateTo = function(command) {\n  if (_.isUndefined(command) || command === '' || this._list.length === 0)\n    throw new Error(\"Cannot migrate using invalid command: \" + command);\n\n  if (typeof command === 'number') {\n    var version = command;\n  } else {\n    var version = command.split(',')[0];\n    var subcommand = command.split(',')[1];\n  }\n\n  if (version === 'latest') {\n    this._migrateTo(_.last(this._list).version);\n  } else {\n    this._migrateTo(parseInt(version), (subcommand === 'rerun'));\n  }\n\n  // remember to run meteor with --once otherwise it will restart\n  if (subcommand === 'exit')\n    process.exit(0);\n}\n\n// just returns the current version\nMigrations.getVersion = function() {\n  return this._getControl().version;\n}\n\n// migrates to the specific version passed in\nMigrations._migrateTo = function(version, rerun) {\n  var self = this;\n  var control = this._getControl(); // Side effect: upserts control document.\n  var currentVersion = control.version;\n\n  if (lock() === false) {\n    log.info('Not migrating, control is locked.');\n    return;\n  }\n\n  if (rerun) {\n    log.info('Rerunning version ' + version);\n    migrate('up', version);\n    log.info('Finished migrating.');\n    unlock();\n    return;\n  }\n\n  if (currentVersion === version) {\n    if (Migrations.options.logIfLatest) {\n      log.info('Not migrating, already at version ' + version);\n    }\n    unlock();\n    return;\n  }\n\n  var startIdx = this._findIndexByVersion(currentVersion);\n  var endIdx = this._findIndexByVersion(version);\n\n  // log.info('startIdx:' + startIdx + ' endIdx:' + endIdx);\n  log.info('Migrating from version ' + this._list[startIdx].version\n    + ' -> ' + this._list[endIdx].version);\n\n  // run the actual migration\n  function migrate(direction, idx) {\n    var migration = self._list[idx];\n\n    if (typeof migration[direction] !== 'function') {\n      unlock();\n      throw new Meteor.Error('Cannot migrate ' + direction + ' on version '\n        + migration.version);\n    }\n\n    function maybeName() {\n      return migration.name ? ' (' + migration.name + ')' : '';\n    }\n\n    log.info('Running ' + direction + '() on version '\n      + migration.version + maybeName());\n\n    migration[direction](migration);\n  }\n\n  // Returns true if lock was acquired.\n  function lock() {\n    // This is atomic. The selector ensures only one caller at a time will see\n    // the unlocked control, and locking occurs in the same update's modifier.\n    // All other simultaneous callers will get false back from the update.\n    return self._collection.update(\n      {_id: 'control', locked: false}, {$set: {locked: true, lockedAt: new Date()}}\n    ) === 1;\n  }\n\n  // Side effect: saves version.\n  function unlock() {\n    self._setControl({locked: false, version: currentVersion});\n  }\n\n  if (currentVersion < version) {\n    for (var i = startIdx;i < endIdx;i++) {\n      migrate('up', i + 1);\n      currentVersion = self._list[i + 1].version;\n    }\n  } else {\n    for (var i = startIdx;i > endIdx;i--) {\n      migrate('down', i);\n      currentVersion = self._list[i - 1].version;\n    }\n  }\n\n  unlock();\n  log.info('Finished migrating.');\n}\n\n// gets the current control record, optionally creating it if non-existant\nMigrations._getControl = function() {\n  var control = this._collection.findOne({_id: 'control'});\n\n  return control || this._setControl({version: 0, locked: false});\n}\n\n// sets the control record\nMigrations._setControl = function(control) {\n  // be quite strict\n  check(control.version, Number);\n  check(control.locked, Boolean);\n\n  this._collection.update({_id: 'control'},\n    {$set: {version: control.version, locked: control.locked}}, {upsert: true});\n\n  return control;\n}\n\n// returns the migration index in _list or throws if not found\nMigrations._findIndexByVersion = function(version) {\n  for (var i = 0;i < this._list.length;i++) {\n    if (this._list[i].version === version)\n      return i;\n  }\n\n  throw new Meteor.Error('Can\\'t find migration version ' + version);\n}\n\n//reset (mainly intended for tests)\nMigrations._reset = function() {\n  this._list = [{version: 0, up: function(){}}];\n  this._collection.remove({});\n}\n\n//////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nPackage._define(\"percolate:migrations\", {\n  Migrations: Migrations\n});\n\n})();\n","servePath":"/packages/percolate_migrations.js"}]