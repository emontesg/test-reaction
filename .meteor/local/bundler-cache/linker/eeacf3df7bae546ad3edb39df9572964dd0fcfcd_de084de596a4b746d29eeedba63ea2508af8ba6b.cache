[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar MongoInternals = Package.mongo.MongoInternals;\nvar Mongo = Package.mongo.Mongo;\nvar _ = Package.underscore._;\nvar LocalCollection = Package.minimongo.LocalCollection;\nvar Minimongo = Package.minimongo.Minimongo;\nvar Random = Package.random.Random;\nvar EJSON = Package.ejson.EJSON;\nvar ECMAScript = Package.ecmascript.ECMAScript;\nvar MongoID = Package['mongo-id'].MongoID;\nvar meteorInstall = Package.modules.meteorInstall;\nvar meteorBabelHelpers = Package['babel-runtime'].meteorBabelHelpers;\nvar Promise = Package.promise.Promise;\n\n/* Package-scope variables */\nvar rulesByCollection, addFuncForAll, ensureCreated, ensureDefaultAllow, getRulesForCollectionAndType, getCollectionName, Security, types, collections, arg, fieldNames;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"ongoworks:security\":{\"lib\":{\"server\":{\"utility.js\":function(){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// packages/ongoworks_security/lib/server/utility.js                                                                 //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n/* global _, rulesByCollection:true, addFuncForAll:true, ensureCreated:true, ensureDefaultAllow:true */\nrulesByCollection = {};\nvar created = {\n  allow: {\n    insert: {},\n    update: {},\n    remove: {},\n    download: {} // for use with CollectionFS packages\n\n  },\n  deny: {\n    insert: {},\n    update: {},\n    remove: {},\n    download: {} // for use with CollectionFS packages\n\n  }\n};\n/**\n * Adds the given function as an allow or deny function for all specified collections and types.\n * @param {Array(Mongo.Collection)} collections Array of Mongo.Collection instances\n * @param {String}                  allowOrDeny \"allow\" or \"deny\"\n * @param {Array(String)}           types       Array of types (\"insert\", \"update\", \"remove\")\n * @param {Array(String)|null}      fetch       `fetch` property to use\n * @param {Function}                func        The function\n */\n\naddFuncForAll = function addFuncForAll(collections, allowOrDeny, types, fetch, func) {\n  // We always disable transformation, but we transform for specific\n  // rules upon running our deny function if requested.\n  var rules = {\n    transform: null\n  };\n\n  if (_.isArray(fetch)) {\n    rules.fetch = fetch;\n  }\n\n  _.each(types, function (t) {\n    rules[t] = func;\n  });\n\n  _.each(collections, function (c) {\n    c[allowOrDeny](rules);\n  });\n};\n/**\n * Creates the allow or deny function for the given collections if not already created. This ensures that this package only ever creates up to one allow and one deny per collection.\n * @param   {String}                  allowOrDeny \"allow\" or \"deny\"\n * @param   {Array(Mongo.Collection)} collections An array of collections\n * @param   {Array(String)}           types       An array of types (\"insert\", \"update\", \"remove\")\n * @param   {Array(String)|null}      fetch       `fetch` property to use\n * @param   {Function}                func        The function\n */\n\n\nensureCreated = function ensureCreated(allowOrDeny, collections, types, fetch, func) {\n  _.each(types, t => {\n    // Ignore \"read\"\n    if (!_.contains(['insert', 'update', 'remove', 'download'], t)) return;\n    collections = _.reject(collections, c => {\n      return _.has(created[allowOrDeny][t], getCollectionName(c));\n    });\n    addFuncForAll(collections, allowOrDeny, [t], null, func); // mark that we've defined function for collection-type combo\n\n    _.each(collections, c => {\n      created[allowOrDeny][t][getCollectionName(c)] = true;\n    });\n  });\n};\n/**\n * Sets up default allow functions for the collections and types.\n * @param   {Array(Mongo.Collection)} collections Array of Mongo.Collection instances\n * @param   {Array(String)}           types       Array of types (\"insert\", \"update\", \"remove\")\n */\n\n\nensureDefaultAllow = function ensureDefaultAllow(collections, types) {\n  ensureCreated(\"allow\", collections, types, [], function () {\n    return true;\n  });\n};\n/**\n * Return only those rules that apply to the given collection and operation type\n */\n\n\ngetRulesForCollectionAndType = function getRulesForCollectionAndType(collectionName, type) {\n  var rules = rulesByCollection[collectionName] || [];\n  return _.select(rules, function (rule) {\n    return _.contains(rule._types, type);\n  });\n};\n\ngetCollectionName = function getCollectionName(collection) {\n  // CollectionFS has underlying collection on `files` property\n  return collection._name || collection.files && collection.files._name;\n};\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"Security.js\":function(){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// packages/ongoworks_security/lib/server/Security.js                                                                //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n// The `Security` object is exported and provides the package API\nSecurity = {\n  // Putting these on the exported object allows package users to override if necessary\n  errorMessages: {\n    multipleCan: 'You may not combine more than one insert, update, or remove on a Security.can chain',\n    notAllowed: 'Action not allowed',\n    requiresDefinition: 'Security.defineMethod requires a \"definition\" argument',\n    requiresAllow: 'Security.defineMethod requires an \"allow\" function',\n    collectionsArg: 'The collections argument must be a Mongo.Collection instance or an array of them',\n    noCollectionOrType: 'At a minimum, you must call permit and collections methods for a security rule.'\n  },\n  // the starting point of the chain\n  permit: function permit(types) {\n    return new Security.Rule(types);\n  },\n  can: function can(userId) {\n    return new Security.Check(userId);\n  },\n  defineMethod: function securityDefineMethod(name, definition) {\n    // Check whether a rule with the given name already exists; can't overwrite\n    if (Security.Rule.prototype[name]) {\n      throw new Error('A security method with the name \"' + name + '\" has already been defined');\n    }\n\n    if (!definition) throw new Error(Security.errorMessages.requiresDefinition); // If \"deny\" is used, convert to \"allow\" for backwards compatibility\n\n    if (definition.deny) {\n      definition.allow = (...args) => {\n        return !definition.deny(...args);\n      };\n    } // Make sure the definition argument is an object that has an `allow` property\n\n\n    if (!definition.allow) throw new Error(Security.errorMessages.requiresAllow); // Wrap transform, if provided\n\n    if (definition.transform) {\n      definition.transform = LocalCollection.wrapTransform(definition.transform);\n    }\n\n    Security.Rule.prototype[name] = function (arg) {\n      this._restrictions.push({\n        definition,\n        arg\n      });\n\n      return this;\n    };\n  }\n};\n\nMongo.Collection.prototype.permit = function (types) {\n  return Security.permit(types).collections(this);\n};\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"Security.Rule.js\":function(){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// packages/ongoworks_security/lib/server/Security.Rule.js                                                           //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nSecurity.Rule = class {\n  constructor(types) {\n    if (!_.isArray(types)) types = [types];\n    this._types = types;\n    this._restrictions = [];\n  }\n\n  collections(collections) {\n    // Make sure the `collections` argument is either a `Mongo.Collection` instance or\n    // an array of them. If it's a single collection, convert it to a one-item array.\n    if (!_.isArray(collections)) collections = [collections]; // Keep list keyed by collection name\n\n    _.each(collections, collection => {\n      if (!(collection instanceof Mongo.Collection) && // CollectionFS has underlying collection on `files` property\n      !(collection.files instanceof Mongo.Collection)) {\n        throw new Error(Security.errorMessages.collectionsArg);\n      } // CollectionFS has underlying collection on `files` property\n\n\n      const collectionName = getCollectionName(collection);\n      rulesByCollection[collectionName] = rulesByCollection[collectionName] || [];\n      rulesByCollection[collectionName].push(this);\n    });\n\n    this._collections = collections;\n    return this;\n  }\n\n  combinedFetch() {\n    // We need a combined `fetch` array. The `fetch` is optional and can be either an array\n    // or a function that takes the argument passed to the restriction method and returns an array.\n    let fetch = [];\n\n    _.every(this._restrictions, restriction => {\n      if (_.isArray(restriction.definition.fetch)) {\n        fetch = _.union(fetch, restriction.definition.fetch);\n      } else if (typeof restriction.definition.fetch === \"function\") {\n        fetch = _.union(fetch, restriction.definition.fetch(restriction.arg));\n      } else if (!restriction.definition.hasOwnProperty('fetch')) {\n        // If `fetch` property isn't present, we should fetch the full doc.\n        fetch = null;\n        return false; // Exit loop\n      }\n\n      return true;\n    });\n\n    return fetch;\n  }\n\n  allowInClientCode() {\n    if (!this._collections || !this._types) throw new Error(Security.errorMessages.noCollectionOrType);\n    ensureSecureDeny(this._collections, this._types);\n  }\n\n  allow(type, collection, userId, doc, modifier, ...args) {\n    let fields;\n    if (type === 'update') fields = computeChangedFieldsFromModifier(modifier); // Loop through all defined restrictions. Restrictions are additive for this chained\n    // rule, so if any allow function returns false, this function should return false.\n\n    return _.every(this._restrictions, restriction => {\n      // Clone the doc in case we need to transform it. Transformations\n      // should apply to only the one restriction.\n      let loopDoc = _.clone(doc); // If transform is a function, apply that\n\n\n      let transform = restriction.definition.transform;\n\n      if (transform !== null) {\n        transform = transform || collection._transform;\n\n        if (typeof transform === 'function') {\n          let addedRandomId = false;\n\n          if (type === 'insert' && !loopDoc._id) {\n            // The wrapped transform requires an _id, but we\n            // don't have access to the generatedId from Meteor API,\n            // so we'll fudge one and then remove it.\n            loopDoc._id = Random.id();\n            addedRandomId = true;\n          }\n\n          loopDoc = transform(loopDoc);\n          if (addedRandomId) delete loopDoc._id;\n        }\n      }\n\n      return restriction.definition.allow(type, restriction.arg, userId, loopDoc, fields, modifier, ...args);\n    });\n  }\n\n};\n\nfunction ensureSecureDeny(collections, types) {\n  // If we haven't yet done so, set up a default, permissive `allow` function for all of\n  // the given collections and types. We control all security through `deny` functions only, but\n  // there must first be at least one `allow` function for each collection or all writes\n  // will be denied.\n  ensureDefaultAllow(collections, types);\n\n  _.each(types, t => {\n    _.each(collections, collection => {\n      ensureCreated('deny', [collection], [t], null, function (...args) {\n        const userId = args.shift(); // If type is update, remove the `fields` argument. We will create our own\n        // for consistency.\n\n        if (t === 'update') args = [args[0], args[2]];\n        return !Security.can(userId)[t](...args).for(collection).check();\n      });\n    });\n  });\n}\n\nfunction computeChangedFieldsFromModifier(modifier) {\n  var fields = []; // This is the same logic Meteor's mongo package uses in\n  // https://github.com/meteor/meteor/blob/devel/packages/mongo/collection.js\n\n  _.each(modifier, function (params) {\n    _.each(_.keys(params), function (field) {\n      // treat dotted fields as if they are replacing their\n      // top-level part\n      if (field.indexOf('.') !== -1) field = field.substring(0, field.indexOf('.')); // record the field we are trying to change\n\n      if (!_.contains(fields, field)) fields.push(field);\n    });\n  });\n\n  return fields;\n}\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"Security.Check.js\":function(){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// packages/ongoworks_security/lib/server/Security.Check.js                                                          //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nSecurity.Check = class {\n  constructor(userId) {\n    this.userId = userId || null;\n  }\n\n  for(collection) {\n    this.collection = collection;\n    this.collectionName = getCollectionName(collection);\n    return this;\n  }\n\n  insert(doc, ...args) {\n    if (this.type) throw new Error(Security.errorMessages.multipleCan);\n    this.type = 'insert';\n    this.doc = doc;\n    this.args = args;\n    return this;\n  }\n\n  update(doc, modifier, ...args) {\n    if (this.type) throw new Error(Security.errorMessages.multipleCan);\n    this.type = 'update';\n    this.doc = doc;\n    this.modifier = modifier;\n    this.args = args;\n    return this;\n  }\n\n  remove(doc, ...args) {\n    if (this.type) throw new Error(Security.errorMessages.multipleCan);\n    this.type = 'remove';\n    this.doc = doc;\n    this.args = args;\n    return this;\n  }\n\n  read(doc, ...args) {\n    if (this.type) throw new Error(Security.errorMessages.multipleCan);\n    this.type = 'read';\n    this.doc = doc;\n    this.args = args;\n    return this;\n  }\n\n  download(doc, ...args) {\n    if (this.type) throw new Error(Security.errorMessages.multipleCan);\n    this.type = 'download';\n    this.doc = doc;\n    this.args = args;\n    return this;\n  } // EXAMPLES:\n  // Security.can(userId).insert(doc).for(MyCollection).check()\n  // Security.can(userId).update(id, modifier).for(MyCollection).check()\n  // Security.can(userId).remove(id).for(MyCollection).check()\n\n\n  check() {\n    // Select only those rules that apply to this operation type\n    const rules = getRulesForCollectionAndType(this.collectionName, this.type); // If this.doc is an ID, we will look up the doc, fetching only the fields needed.\n    // To find out which fields are needed, we will combine all the `fetch` arrays from\n    // all the restrictions in all the rules.\n\n    if (typeof this.doc === 'string' || this.doc instanceof MongoID.ObjectID) {\n      let fields = {};\n\n      _.every(rules, rule => {\n        const fetch = rule.combinedFetch();\n\n        if (fetch === null) {\n          fields = null;\n          return false; // Exit loop\n        }\n\n        rule.combinedFetch().forEach(field => {\n          fields[field] = 1;\n        });\n        return true;\n      });\n\n      let options = {};\n\n      if (fields) {\n        if (_.isEmpty(fields)) {\n          options = {\n            _id: 1\n          };\n        } else {\n          options = {\n            fields\n          };\n        }\n      }\n\n      this.doc = this.collection.findOne(this.doc, options);\n    } // Loop through all defined rules for this collection. There is an OR relationship among\n    // all rules for the collection, so if any \"allow\" function DO return true, we allow.\n\n\n    return _.any(rules, rule => rule.allow(this.type, this.collection, this.userId, this.doc, this.modifier, ...this.args));\n  } // EXAMPLES:\n  // Security.can(userId).insert(doc).for(MyCollection).throw()\n  // Security.can(userId).update(id, modifier).for(MyCollection).throw()\n  // Security.can(userId).remove(id).for(MyCollection).throw()\n\n\n  throw() {\n    if (!this.check()) throw new Meteor.Error('access-denied', Security.errorMessages.notAllowed);\n  }\n\n};\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}},\"builtInRules.js\":function(){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// packages/ongoworks_security/lib/builtInRules.js                                                                   //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n/*\n * This file defines built-in restriction methods\n */\n\n/*\n * No one\n */\nSecurity.defineMethod(\"never\", {\n  fetch: [],\n  transform: null,\n\n  allow() {\n    return false;\n  }\n\n});\n/*\n * Logged In\n */\n\nSecurity.defineMethod(\"ifLoggedIn\", {\n  fetch: [],\n  transform: null,\n\n  allow(type, arg, userId) {\n    return !!userId;\n  }\n\n});\n/*\n * Specific User ID\n */\n\nSecurity.defineMethod(\"ifHasUserId\", {\n  fetch: [],\n  transform: null,\n\n  allow(type, arg, userId) {\n    return userId === arg;\n  }\n\n});\n/*\n * Specific Roles\n */\n\n/*\n * alanning:roles support\n */\n\nif (Package && Package[\"alanning:roles\"]) {\n  var Roles = Package[\"alanning:roles\"].Roles;\n  Security.defineMethod(\"ifHasRole\", {\n    fetch: [],\n    transform: null,\n\n    allow(type, arg, userId) {\n      if (!arg) throw new Error('ifHasRole security rule method requires an argument');\n\n      if (arg.role) {\n        return Roles.userIsInRole(userId, arg.role, arg.group);\n      } else {\n        return Roles.userIsInRole(userId, arg);\n      }\n    }\n\n  });\n}\n/*\n * nicolaslopezj:roles support\n * Note: doesn't support groups\n */\n\n\nif (Package && Package[\"nicolaslopezj:roles\"]) {\n  var Roles = Package[\"nicolaslopezj:roles\"].Roles;\n  Security.defineMethod(\"ifHasRole\", {\n    fetch: [],\n    transform: null,\n\n    allow(type, arg, userId) {\n      if (!arg) throw new Error('ifHasRole security rule method requires an argument');\n      return Roles.userHasRole(userId, arg);\n    }\n\n  });\n}\n/*\n * Specific Properties\n */\n\n\nSecurity.defineMethod(\"onlyProps\", {\n  fetch: [],\n  transform: null,\n\n  allow(type, arg, userId, doc, fieldNames) {\n    if (!_.isArray(arg)) arg = [arg];\n    fieldNames = fieldNames || _.keys(doc);\n    return _.every(fieldNames, function (fieldName) {\n      return _.contains(arg, fieldName);\n    });\n  }\n\n});\nSecurity.defineMethod(\"exceptProps\", {\n  fetch: [],\n  transform: null,\n\n  allow(type, arg, userId, doc, fieldNames) {\n    if (!_.isArray(arg)) arg = [arg];\n    fieldNames = fieldNames || _.keys(doc);\n    return !_.any(fieldNames, function (fieldName) {\n      return _.contains(arg, fieldName);\n    });\n  }\n\n});\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}}}},{\n  \"extensions\": [\n    \".js\",\n    \".json\"\n  ]\n});\nrequire(\"/node_modules/meteor/ongoworks:security/lib/server/utility.js\");\nrequire(\"/node_modules/meteor/ongoworks:security/lib/server/Security.js\");\nrequire(\"/node_modules/meteor/ongoworks:security/lib/server/Security.Rule.js\");\nrequire(\"/node_modules/meteor/ongoworks:security/lib/server/Security.Check.js\");\nrequire(\"/node_modules/meteor/ongoworks:security/lib/builtInRules.js\");\n\n/* Exports */\nPackage._define(\"ongoworks:security\", {\n  Security: Security\n});\n\n})();\n","servePath":"/packages/ongoworks_security.js","sourceMap":{"version":3,"sources":["packages/ongoworks:security/lib/server/utility.js","packages/ongoworks:security/lib/server/Security.js","packages/ongoworks:security/lib/server/Security.Rule.js","packages/ongoworks:security/lib/server/Security.Check.js","packages/ongoworks:security/lib/builtInRules.js"],"names":["rulesByCollection","created","allow","insert","update","remove","download","deny","addFuncForAll","collections","allowOrDeny","types","fetch","func","rules","transform","_","isArray","each","t","c","ensureCreated","contains","reject","has","getCollectionName","ensureDefaultAllow","getRulesForCollectionAndType","collectionName","type","select","rule","_types","collection","_name","files","Security","errorMessages","multipleCan","notAllowed","requiresDefinition","requiresAllow","collectionsArg","noCollectionOrType","permit","Rule","can","userId","Check","defineMethod","securityDefineMethod","name","definition","prototype","Error","args","LocalCollection","wrapTransform","arg","_restrictions","push","Mongo","Collection","constructor","_collections","combinedFetch","every","restriction","union","hasOwnProperty","allowInClientCode","ensureSecureDeny","doc","modifier","fields","computeChangedFieldsFromModifier","loopDoc","clone","_transform","addedRandomId","_id","Random","id","shift","for","check","params","keys","field","indexOf","substring","read","MongoID","ObjectID","forEach","options","isEmpty","findOne","any","throw","Meteor","Package","Roles","role","userIsInRole","group","userHasRole","fieldNames","fieldName"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAEAA,oBAAoB,EAApB;AAEA,IAAIC,UAAU;AACZC,SAAO;AACLC,YAAQ,EADH;AAELC,YAAQ,EAFH;AAGLC,YAAQ,EAHH;AAILC,cAAU,EAJL,CAIQ;;AAJR,GADK;AAOZC,QAAM;AACJJ,YAAQ,EADJ;AAEJC,YAAQ,EAFJ;AAGJC,YAAQ,EAHJ;AAIJC,cAAU,EAJN,CAIS;;AAJT;AAPM,CAAd;AAeA;;;;;;;;;AAQAE,gBAAgB,SAASA,aAAT,CAAuBC,WAAvB,EAAoCC,WAApC,EAAiDC,KAAjD,EAAwDC,KAAxD,EAA+DC,IAA/D,EAAqE;AACnF;AACA;AACA,MAAIC,QAAQ;AAACC,eAAW;AAAZ,GAAZ;;AACA,MAAIC,EAAEC,OAAF,CAAUL,KAAV,CAAJ,EAAsB;AACpBE,UAAMF,KAAN,GAAcA,KAAd;AACD;;AACDI,IAAEE,IAAF,CAAOP,KAAP,EAAc,UAAUQ,CAAV,EAAa;AACzBL,UAAMK,CAAN,IAAWN,IAAX;AACD,GAFD;;AAGAG,IAAEE,IAAF,CAAOT,WAAP,EAAoB,UAAUW,CAAV,EAAa;AAC/BA,MAAEV,WAAF,EAAeI,KAAf;AACD,GAFD;AAGD,CAbD;AAeA;;;;;;;;;;AAQAO,gBAAgB,SAASA,aAAT,CAAuBX,WAAvB,EAAoCD,WAApC,EAAiDE,KAAjD,EAAwDC,KAAxD,EAA+DC,IAA/D,EAAqE;AACnFG,IAAEE,IAAF,CAAOP,KAAP,EAAcQ,KAAK;AACjB;AACA,QAAI,CAACH,EAAEM,QAAF,CAAW,CAAC,QAAD,EAAW,QAAX,EAAqB,QAArB,EAA+B,UAA/B,CAAX,EAAuDH,CAAvD,CAAL,EAAgE;AAEhEV,kBAAcO,EAAEO,MAAF,CAASd,WAAT,EAAsBW,KAAK;AACvC,aAAOJ,EAAEQ,GAAF,CAAMvB,QAAQS,WAAR,EAAqBS,CAArB,CAAN,EAA+BM,kBAAkBL,CAAlB,CAA/B,CAAP;AACD,KAFa,CAAd;AAGAZ,kBAAcC,WAAd,EAA2BC,WAA3B,EAAwC,CAACS,CAAD,CAAxC,EAA6C,IAA7C,EAAmDN,IAAnD,EAPiB,CAQjB;;AACAG,MAAEE,IAAF,CAAOT,WAAP,EAAoBW,KAAK;AACvBnB,cAAQS,WAAR,EAAqBS,CAArB,EAAwBM,kBAAkBL,CAAlB,CAAxB,IAAgD,IAAhD;AACD,KAFD;AAGD,GAZD;AAaD,CAdD;AAgBA;;;;;;;AAKAM,qBAAqB,SAASA,kBAAT,CAA4BjB,WAA5B,EAAyCE,KAAzC,EAAgD;AACnEU,gBAAc,OAAd,EAAuBZ,WAAvB,EAAoCE,KAApC,EAA2C,EAA3C,EAA+C,YAAY;AACzD,WAAO,IAAP;AACD,GAFD;AAGD,CAJD;AAMA;;;;;AAGAgB,+BAA+B,SAASA,4BAAT,CAAsCC,cAAtC,EAAsDC,IAAtD,EAA4D;AACzF,MAAIf,QAAQd,kBAAkB4B,cAAlB,KAAqC,EAAjD;AACA,SAAOZ,EAAEc,MAAF,CAAShB,KAAT,EAAgB,UAAUiB,IAAV,EAAgB;AACrC,WAAOf,EAAEM,QAAF,CAAWS,KAAKC,MAAhB,EAAwBH,IAAxB,CAAP;AACD,GAFM,CAAP;AAGD,CALD;;AAOAJ,oBAAoB,SAASA,iBAAT,CAA2BQ,UAA3B,EAAuC;AACzD;AACA,SAAOA,WAAWC,KAAX,IAAqBD,WAAWE,KAAX,IAAoBF,WAAWE,KAAX,CAAiBD,KAAjE;AACD,CAHD,C;;;;;;;;;;;ACvFA;AACAE,WAAW;AACT;AACAC,iBAAe;AACbC,iBAAa,qFADA;AAEbC,gBAAY,oBAFC;AAGbC,wBAAoB,wDAHP;AAIbC,mBAAe,oDAJF;AAKbC,oBAAgB,kFALH;AAMbC,wBAAoB;AANP,GAFN;AAUT;AACAC,UAAQ,SAASA,MAAT,CAAgBjC,KAAhB,EAAuB;AAC7B,WAAO,IAAIyB,SAASS,IAAb,CAAkBlC,KAAlB,CAAP;AACD,GAbQ;AAcTmC,OAAK,SAASA,GAAT,CAAaC,MAAb,EAAqB;AACxB,WAAO,IAAIX,SAASY,KAAb,CAAmBD,MAAnB,CAAP;AACD,GAhBQ;AAiBTE,gBAAc,SAASC,oBAAT,CAA8BC,IAA9B,EAAoCC,UAApC,EAAgD;AAC5D;AACA,QAAIhB,SAASS,IAAT,CAAcQ,SAAd,CAAwBF,IAAxB,CAAJ,EAAmC;AACjC,YAAM,IAAIG,KAAJ,CAAU,sCAAsCH,IAAtC,GAA6C,4BAAvD,CAAN;AACD;;AACD,QAAI,CAACC,UAAL,EAAiB,MAAM,IAAIE,KAAJ,CAAUlB,SAASC,aAAT,CAAuBG,kBAAjC,CAAN,CAL2C,CAM5D;;AACA,QAAIY,WAAW7C,IAAf,EAAqB;AACnB6C,iBAAWlD,KAAX,GAAmB,CAAC,GAAGqD,IAAJ,KAAa;AAC9B,eAAO,CAACH,WAAW7C,IAAX,CAAgB,GAAGgD,IAAnB,CAAR;AACD,OAFD;AAGD,KAX2D,CAY5D;;;AACA,QAAI,CAACH,WAAWlD,KAAhB,EAAuB,MAAM,IAAIoD,KAAJ,CAAUlB,SAASC,aAAT,CAAuBI,aAAjC,CAAN,CAbqC,CAc5D;;AACA,QAAIW,WAAWrC,SAAf,EAA0B;AACxBqC,iBAAWrC,SAAX,GAAuByC,gBAAgBC,aAAhB,CAA8BL,WAAWrC,SAAzC,CAAvB;AACD;;AACDqB,aAASS,IAAT,CAAcQ,SAAd,CAAwBF,IAAxB,IAAgC,UAAUO,GAAV,EAAe;AAC7C,WAAKC,aAAL,CAAmBC,IAAnB,CAAwB;AACtBR,kBADsB;AAEtBM;AAFsB,OAAxB;;AAIA,aAAO,IAAP;AACD,KAND;AAOD;AA1CQ,CAAX;;AA6CAG,MAAMC,UAAN,CAAiBT,SAAjB,CAA2BT,MAA3B,GAAoC,UAAUjC,KAAV,EAAiB;AACnD,SAAOyB,SAASQ,MAAT,CAAgBjC,KAAhB,EAAuBF,WAAvB,CAAmC,IAAnC,CAAP;AACD,CAFD,C;;;;;;;;;;;AC9CA2B,SAASS,IAAT,GAAgB,MAAM;AACpBkB,cAAYpD,KAAZ,EAAmB;AACjB,QAAI,CAACK,EAAEC,OAAF,CAAUN,KAAV,CAAL,EAAuBA,QAAQ,CAACA,KAAD,CAAR;AACvB,SAAKqB,MAAL,GAAcrB,KAAd;AACA,SAAKgD,aAAL,GAAqB,EAArB;AACD;;AAEDlD,cAAYA,WAAZ,EAAyB;AACvB;AACA;AACA,QAAI,CAACO,EAAEC,OAAF,CAAUR,WAAV,CAAL,EAA6BA,cAAc,CAACA,WAAD,CAAd,CAHN,CAKvB;;AACAO,MAAEE,IAAF,CAAOT,WAAP,EAAoBwB,cAAc;AAChC,UAAI,EAAEA,sBAAsB4B,MAAMC,UAA9B,KACA;AACF,QAAE7B,WAAWE,KAAX,YAA4B0B,MAAMC,UAApC,CAFF,EAEmD;AACjD,cAAM,IAAIR,KAAJ,CAAUlB,SAASC,aAAT,CAAuBK,cAAjC,CAAN;AACD,OAL+B,CAMhC;;;AACA,YAAMd,iBAAiBH,kBAAkBQ,UAAlB,CAAvB;AACAjC,wBAAkB4B,cAAlB,IAAoC5B,kBAAkB4B,cAAlB,KAAqC,EAAzE;AACA5B,wBAAkB4B,cAAlB,EAAkCgC,IAAlC,CAAuC,IAAvC;AACD,KAVD;;AAYA,SAAKI,YAAL,GAAoBvD,WAApB;AAEA,WAAO,IAAP;AACD;;AAEDwD,kBAAgB;AACd;AACA;AACA,QAAIrD,QAAQ,EAAZ;;AACAI,MAAEkD,KAAF,CAAQ,KAAKP,aAAb,EAA4BQ,eAAe;AACzC,UAAInD,EAAEC,OAAF,CAAUkD,YAAYf,UAAZ,CAAuBxC,KAAjC,CAAJ,EAA6C;AAC3CA,gBAAQI,EAAEoD,KAAF,CAAQxD,KAAR,EAAeuD,YAAYf,UAAZ,CAAuBxC,KAAtC,CAAR;AACD,OAFD,MAEO,IAAI,OAAOuD,YAAYf,UAAZ,CAAuBxC,KAA9B,KAAwC,UAA5C,EAAwD;AAC7DA,gBAAQI,EAAEoD,KAAF,CAAQxD,KAAR,EAAeuD,YAAYf,UAAZ,CAAuBxC,KAAvB,CAA6BuD,YAAYT,GAAzC,CAAf,CAAR;AACD,OAFM,MAEA,IAAI,CAACS,YAAYf,UAAZ,CAAuBiB,cAAvB,CAAsC,OAAtC,CAAL,EAAqD;AAC1D;AACAzD,gBAAQ,IAAR;AACA,eAAO,KAAP,CAH0D,CAG5C;AACf;;AACD,aAAO,IAAP;AACD,KAXD;;AAYA,WAAOA,KAAP;AACD;;AAED0D,sBAAoB;AAClB,QAAI,CAAC,KAAKN,YAAN,IAAsB,CAAC,KAAKhC,MAAhC,EAAwC,MAAM,IAAIsB,KAAJ,CAAUlB,SAASC,aAAT,CAAuBM,kBAAjC,CAAN;AACxC4B,qBAAiB,KAAKP,YAAtB,EAAoC,KAAKhC,MAAzC;AACD;;AAED9B,QAAM2B,IAAN,EAAYI,UAAZ,EAAwBc,MAAxB,EAAgCyB,GAAhC,EAAqCC,QAArC,EAA+C,GAAGlB,IAAlD,EAAwD;AACtD,QAAImB,MAAJ;AACA,QAAI7C,SAAS,QAAb,EAAuB6C,SAASC,iCAAiCF,QAAjC,CAAT,CAF+B,CAItD;AACA;;AACA,WAAOzD,EAAEkD,KAAF,CAAQ,KAAKP,aAAb,EAA4BQ,eAAe;AAChD;AACA;AACA,UAAIS,UAAU5D,EAAE6D,KAAF,CAAQL,GAAR,CAAd,CAHgD,CAKhD;;;AACA,UAAIzD,YAAYoD,YAAYf,UAAZ,CAAuBrC,SAAvC;;AACA,UAAIA,cAAc,IAAlB,EAAwB;AACtBA,oBAAYA,aAAakB,WAAW6C,UAApC;;AACA,YAAI,OAAO/D,SAAP,KAAqB,UAAzB,EAAqC;AACnC,cAAIgE,gBAAgB,KAApB;;AACA,cAAIlD,SAAS,QAAT,IAAqB,CAAC+C,QAAQI,GAAlC,EAAuC;AACrC;AACA;AACA;AACAJ,oBAAQI,GAAR,GAAcC,OAAOC,EAAP,EAAd;AACAH,4BAAgB,IAAhB;AACD;;AACDH,oBAAU7D,UAAU6D,OAAV,CAAV;AACA,cAAIG,aAAJ,EAAmB,OAAOH,QAAQI,GAAf;AACpB;AACF;;AAED,aAAOb,YAAYf,UAAZ,CAAuBlD,KAAvB,CAA6B2B,IAA7B,EAAmCsC,YAAYT,GAA/C,EAAoDX,MAApD,EAA4D6B,OAA5D,EAAqEF,MAArE,EAA6ED,QAA7E,EAAuF,GAAGlB,IAA1F,CAAP;AACD,KAxBM,CAAP;AAyBD;;AArFmB,CAAtB;;AAwFA,SAASgB,gBAAT,CAA0B9D,WAA1B,EAAuCE,KAAvC,EAA8C;AAC5C;AACA;AACA;AACA;AACAe,qBAAmBjB,WAAnB,EAAgCE,KAAhC;;AAEAK,IAAEE,IAAF,CAAOP,KAAP,EAAcQ,KAAK;AACjBH,MAAEE,IAAF,CAAOT,WAAP,EAAoBwB,cAAc;AAChCZ,oBAAc,MAAd,EAAsB,CAACY,UAAD,CAAtB,EAAoC,CAACd,CAAD,CAApC,EAAyC,IAAzC,EAA+C,UAAU,GAAGoC,IAAb,EAAmB;AAChE,cAAMR,SAASQ,KAAK4B,KAAL,EAAf,CADgE,CAGhE;AACA;;AACA,YAAIhE,MAAM,QAAV,EAAoBoC,OAAO,CAACA,KAAK,CAAL,CAAD,EAAUA,KAAK,CAAL,CAAV,CAAP;AAEpB,eAAO,CAACnB,SAASU,GAAT,CAAaC,MAAb,EAAqB5B,CAArB,EAAwB,GAAGoC,IAA3B,EAAiC6B,GAAjC,CAAqCnD,UAArC,EAAiDoD,KAAjD,EAAR;AACD,OARD;AASD,KAVD;AAWD,GAZD;AAaD;;AAED,SAASV,gCAAT,CAA0CF,QAA1C,EAAoD;AAClD,MAAIC,SAAS,EAAb,CADkD,CAElD;AACA;;AACA1D,IAAEE,IAAF,CAAOuD,QAAP,EAAiB,UAAUa,MAAV,EAAkB;AACjCtE,MAAEE,IAAF,CAAOF,EAAEuE,IAAF,CAAOD,MAAP,CAAP,EAAuB,UAAUE,KAAV,EAAiB;AACtC;AACA;AACA,UAAIA,MAAMC,OAAN,CAAc,GAAd,MAAuB,CAAC,CAA5B,EACED,QAAQA,MAAME,SAAN,CAAgB,CAAhB,EAAmBF,MAAMC,OAAN,CAAc,GAAd,CAAnB,CAAR,CAJoC,CAMtC;;AACA,UAAI,CAACzE,EAAEM,QAAF,CAAWoD,MAAX,EAAmBc,KAAnB,CAAL,EACEd,OAAOd,IAAP,CAAY4B,KAAZ;AACH,KATD;AAUD,GAXD;;AAYA,SAAOd,MAAP;AACD,C;;;;;;;;;;;AC/HDtC,SAASY,KAAT,GAAiB,MAAM;AACrBe,cAAYhB,MAAZ,EAAoB;AAClB,SAAKA,MAAL,GAAcA,UAAU,IAAxB;AACD;;AAEDqC,MAAInD,UAAJ,EAAgB;AACd,SAAKA,UAAL,GAAkBA,UAAlB;AACA,SAAKL,cAAL,GAAsBH,kBAAkBQ,UAAlB,CAAtB;AACA,WAAO,IAAP;AACD;;AAED9B,SAAOqE,GAAP,EAAY,GAAGjB,IAAf,EAAqB;AACnB,QAAI,KAAK1B,IAAT,EAAe,MAAM,IAAIyB,KAAJ,CAAUlB,SAASC,aAAT,CAAuBC,WAAjC,CAAN;AACf,SAAKT,IAAL,GAAY,QAAZ;AACA,SAAK2C,GAAL,GAAWA,GAAX;AACA,SAAKjB,IAAL,GAAYA,IAAZ;AACA,WAAO,IAAP;AACD;;AAEDnD,SAAOoE,GAAP,EAAYC,QAAZ,EAAsB,GAAGlB,IAAzB,EAA+B;AAC7B,QAAI,KAAK1B,IAAT,EAAe,MAAM,IAAIyB,KAAJ,CAAUlB,SAASC,aAAT,CAAuBC,WAAjC,CAAN;AACf,SAAKT,IAAL,GAAY,QAAZ;AACA,SAAK2C,GAAL,GAAWA,GAAX;AACA,SAAKC,QAAL,GAAgBA,QAAhB;AACA,SAAKlB,IAAL,GAAYA,IAAZ;AACA,WAAO,IAAP;AACD;;AAEDlD,SAAOmE,GAAP,EAAY,GAAGjB,IAAf,EAAqB;AACnB,QAAI,KAAK1B,IAAT,EAAe,MAAM,IAAIyB,KAAJ,CAAUlB,SAASC,aAAT,CAAuBC,WAAjC,CAAN;AACf,SAAKT,IAAL,GAAY,QAAZ;AACA,SAAK2C,GAAL,GAAWA,GAAX;AACA,SAAKjB,IAAL,GAAYA,IAAZ;AACA,WAAO,IAAP;AACD;;AAEDoC,OAAKnB,GAAL,EAAU,GAAGjB,IAAb,EAAmB;AACjB,QAAI,KAAK1B,IAAT,EAAe,MAAM,IAAIyB,KAAJ,CAAUlB,SAASC,aAAT,CAAuBC,WAAjC,CAAN;AACf,SAAKT,IAAL,GAAY,MAAZ;AACA,SAAK2C,GAAL,GAAWA,GAAX;AACA,SAAKjB,IAAL,GAAYA,IAAZ;AACA,WAAO,IAAP;AACD;;AAEDjD,WAASkE,GAAT,EAAc,GAAGjB,IAAjB,EAAuB;AACrB,QAAI,KAAK1B,IAAT,EAAe,MAAM,IAAIyB,KAAJ,CAAUlB,SAASC,aAAT,CAAuBC,WAAjC,CAAN;AACf,SAAKT,IAAL,GAAY,UAAZ;AACA,SAAK2C,GAAL,GAAWA,GAAX;AACA,SAAKjB,IAAL,GAAYA,IAAZ;AACA,WAAO,IAAP;AACD,GAlDoB,CAoDrB;AACA;AACA;AACA;;;AACA8B,UAAQ;AACN;AACA,UAAMvE,QAAQa,6BAA6B,KAAKC,cAAlC,EAAkD,KAAKC,IAAvD,CAAd,CAFM,CAIN;AACA;AACA;;AACA,QAAI,OAAO,KAAK2C,GAAZ,KAAoB,QAApB,IAAgC,KAAKA,GAAL,YAAoBoB,QAAQC,QAAhE,EAA0E;AACxE,UAAInB,SAAS,EAAb;;AACA1D,QAAEkD,KAAF,CAAQpD,KAAR,EAAeiB,QAAQ;AACrB,cAAMnB,QAAQmB,KAAKkC,aAAL,EAAd;;AACA,YAAIrD,UAAU,IAAd,EAAoB;AAClB8D,mBAAS,IAAT;AACA,iBAAO,KAAP,CAFkB,CAEJ;AACf;;AACD3C,aAAKkC,aAAL,GAAqB6B,OAArB,CAA6BN,SAAS;AACpCd,iBAAOc,KAAP,IAAgB,CAAhB;AACD,SAFD;AAGA,eAAO,IAAP;AACD,OAVD;;AAYA,UAAIO,UAAU,EAAd;;AACA,UAAIrB,MAAJ,EAAY;AACV,YAAI1D,EAAEgF,OAAF,CAAUtB,MAAV,CAAJ,EAAuB;AACrBqB,oBAAU;AAACf,iBAAK;AAAN,WAAV;AACD,SAFD,MAEO;AACLe,oBAAU;AAACrB;AAAD,WAAV;AACD;AACF;;AACD,WAAKF,GAAL,GAAW,KAAKvC,UAAL,CAAgBgE,OAAhB,CAAwB,KAAKzB,GAA7B,EAAkCuB,OAAlC,CAAX;AACD,KA9BK,CAgCN;AACA;;;AACA,WAAO/E,EAAEkF,GAAF,CAAMpF,KAAN,EAAaiB,QAAQA,KAAK7B,KAAL,CAAW,KAAK2B,IAAhB,EAAsB,KAAKI,UAA3B,EAAuC,KAAKc,MAA5C,EAAoD,KAAKyB,GAAzD,EAA8D,KAAKC,QAAnE,EAA6E,GAAG,KAAKlB,IAArF,CAArB,CAAP;AACD,GA3FoB,CA6FrB;AACA;AACA;AACA;;;AACA4C,UAAQ;AACN,QAAI,CAAC,KAAKd,KAAL,EAAL,EAAmB,MAAM,IAAIe,OAAO9C,KAAX,CAAiB,eAAjB,EAAkClB,SAASC,aAAT,CAAuBE,UAAzD,CAAN;AACpB;;AAnGoB,CAAvB,C;;;;;;;;;;;ACAA;;;;AAIA;;;AAIAH,SAASa,YAAT,CAAsB,OAAtB,EAA+B;AAC7BrC,SAAO,EADsB;AAE7BG,aAAW,IAFkB;;AAG7Bb,UAAQ;AACN,WAAO,KAAP;AACD;;AAL4B,CAA/B;AAQA;;;;AAIAkC,SAASa,YAAT,CAAsB,YAAtB,EAAoC;AAClCrC,SAAO,EAD2B;AAElCG,aAAW,IAFuB;;AAGlCb,QAAM2B,IAAN,EAAY6B,GAAZ,EAAiBX,MAAjB,EAAyB;AACvB,WAAO,CAAC,CAACA,MAAT;AACD;;AALiC,CAApC;AAQA;;;;AAIAX,SAASa,YAAT,CAAsB,aAAtB,EAAqC;AACnCrC,SAAO,EAD4B;AAEnCG,aAAW,IAFwB;;AAGnCb,QAAM2B,IAAN,EAAY6B,GAAZ,EAAiBX,MAAjB,EAAyB;AACvB,WAAOA,WAAWW,GAAlB;AACD;;AALkC,CAArC;AAQA;;;;AAIA;;;;AAGA,IAAI2C,WAAWA,QAAQ,gBAAR,CAAf,EAA0C;AAExC,MAAIC,QAAQD,QAAQ,gBAAR,EAA0BC,KAAtC;AAEAlE,WAASa,YAAT,CAAsB,WAAtB,EAAmC;AACjCrC,WAAO,EAD0B;AAEjCG,eAAW,IAFsB;;AAGjCb,UAAM2B,IAAN,EAAY6B,GAAZ,EAAiBX,MAAjB,EAAyB;AACvB,UAAI,CAACW,GAAL,EAAU,MAAM,IAAIJ,KAAJ,CAAU,qDAAV,CAAN;;AACV,UAAII,IAAI6C,IAAR,EAAc;AACZ,eAAOD,MAAME,YAAN,CAAmBzD,MAAnB,EAA2BW,IAAI6C,IAA/B,EAAqC7C,IAAI+C,KAAzC,CAAP;AACD,OAFD,MAEO;AACL,eAAOH,MAAME,YAAN,CAAmBzD,MAAnB,EAA2BW,GAA3B,CAAP;AACD;AACF;;AAVgC,GAAnC;AAaD;AAED;;;;;;AAIA,IAAI2C,WAAWA,QAAQ,qBAAR,CAAf,EAA+C;AAE7C,MAAIC,QAAQD,QAAQ,qBAAR,EAA+BC,KAA3C;AAEAlE,WAASa,YAAT,CAAsB,WAAtB,EAAmC;AACjCrC,WAAO,EAD0B;AAEjCG,eAAW,IAFsB;;AAGjCb,UAAM2B,IAAN,EAAY6B,GAAZ,EAAiBX,MAAjB,EAAyB;AACvB,UAAI,CAACW,GAAL,EAAU,MAAM,IAAIJ,KAAJ,CAAU,qDAAV,CAAN;AACV,aAAOgD,MAAMI,WAAN,CAAkB3D,MAAlB,EAA0BW,GAA1B,CAAP;AACD;;AANgC,GAAnC;AASD;AAED;;;;;AAIAtB,SAASa,YAAT,CAAsB,WAAtB,EAAmC;AACjCrC,SAAO,EAD0B;AAEjCG,aAAW,IAFsB;;AAGjCb,QAAM2B,IAAN,EAAY6B,GAAZ,EAAiBX,MAAjB,EAAyByB,GAAzB,EAA8BmC,UAA9B,EAA0C;AACxC,QAAI,CAAC3F,EAAEC,OAAF,CAAUyC,GAAV,CAAL,EAAqBA,MAAM,CAACA,GAAD,CAAN;AAErBiD,iBAAaA,cAAc3F,EAAEuE,IAAF,CAAOf,GAAP,CAA3B;AAEA,WAAOxD,EAAEkD,KAAF,CAAQyC,UAAR,EAAoB,UAAUC,SAAV,EAAqB;AAC9C,aAAO5F,EAAEM,QAAF,CAAWoC,GAAX,EAAgBkD,SAAhB,CAAP;AACD,KAFM,CAAP;AAGD;;AAXgC,CAAnC;AAcAxE,SAASa,YAAT,CAAsB,aAAtB,EAAqC;AACnCrC,SAAO,EAD4B;AAEnCG,aAAW,IAFwB;;AAGnCb,QAAM2B,IAAN,EAAY6B,GAAZ,EAAiBX,MAAjB,EAAyByB,GAAzB,EAA8BmC,UAA9B,EAA0C;AACxC,QAAI,CAAC3F,EAAEC,OAAF,CAAUyC,GAAV,CAAL,EAAqBA,MAAM,CAACA,GAAD,CAAN;AAErBiD,iBAAaA,cAAc3F,EAAEuE,IAAF,CAAOf,GAAP,CAA3B;AAEA,WAAO,CAACxD,EAAEkF,GAAF,CAAMS,UAAN,EAAkB,UAAUC,SAAV,EAAqB;AAC7C,aAAO5F,EAAEM,QAAF,CAAWoC,GAAX,EAAgBkD,SAAhB,CAAP;AACD,KAFO,CAAR;AAGD;;AAXkC,CAArC,E","file":"/packages/ongoworks_security.js","sourcesContent":["/* global _, rulesByCollection:true, addFuncForAll:true, ensureCreated:true, ensureDefaultAllow:true */\n\nrulesByCollection = {};\n\nvar created = {\n  allow: {\n    insert: {},\n    update: {},\n    remove: {},\n    download: {} // for use with CollectionFS packages\n  },\n  deny: {\n    insert: {},\n    update: {},\n    remove: {},\n    download: {} // for use with CollectionFS packages\n  }\n};\n\n/**\n * Adds the given function as an allow or deny function for all specified collections and types.\n * @param {Array(Mongo.Collection)} collections Array of Mongo.Collection instances\n * @param {String}                  allowOrDeny \"allow\" or \"deny\"\n * @param {Array(String)}           types       Array of types (\"insert\", \"update\", \"remove\")\n * @param {Array(String)|null}      fetch       `fetch` property to use\n * @param {Function}                func        The function\n */\naddFuncForAll = function addFuncForAll(collections, allowOrDeny, types, fetch, func) {\n  // We always disable transformation, but we transform for specific\n  // rules upon running our deny function if requested.\n  var rules = {transform: null};\n  if (_.isArray(fetch)) {\n    rules.fetch = fetch;\n  }\n  _.each(types, function (t) {\n    rules[t] = func;\n  });\n  _.each(collections, function (c) {\n    c[allowOrDeny](rules);\n  });\n};\n\n/**\n * Creates the allow or deny function for the given collections if not already created. This ensures that this package only ever creates up to one allow and one deny per collection.\n * @param   {String}                  allowOrDeny \"allow\" or \"deny\"\n * @param   {Array(Mongo.Collection)} collections An array of collections\n * @param   {Array(String)}           types       An array of types (\"insert\", \"update\", \"remove\")\n * @param   {Array(String)|null}      fetch       `fetch` property to use\n * @param   {Function}                func        The function\n */\nensureCreated = function ensureCreated(allowOrDeny, collections, types, fetch, func) {\n  _.each(types, t => {\n    // Ignore \"read\"\n    if (!_.contains(['insert', 'update', 'remove', 'download'], t)) return;\n\n    collections = _.reject(collections, c => {\n      return _.has(created[allowOrDeny][t], getCollectionName(c));\n    });\n    addFuncForAll(collections, allowOrDeny, [t], null, func);\n    // mark that we've defined function for collection-type combo\n    _.each(collections, c => {\n      created[allowOrDeny][t][getCollectionName(c)] = true;\n    });\n  });\n};\n\n/**\n * Sets up default allow functions for the collections and types.\n * @param   {Array(Mongo.Collection)} collections Array of Mongo.Collection instances\n * @param   {Array(String)}           types       Array of types (\"insert\", \"update\", \"remove\")\n */\nensureDefaultAllow = function ensureDefaultAllow(collections, types) {\n  ensureCreated(\"allow\", collections, types, [], function () {\n    return true;\n  });\n};\n\n/**\n * Return only those rules that apply to the given collection and operation type\n */\ngetRulesForCollectionAndType = function getRulesForCollectionAndType(collectionName, type) {\n  var rules = rulesByCollection[collectionName] || [];\n  return _.select(rules, function (rule) {\n    return _.contains(rule._types, type);\n  });\n};\n\ngetCollectionName = function getCollectionName(collection) {\n  // CollectionFS has underlying collection on `files` property\n  return collection._name || (collection.files && collection.files._name);\n};\n","// The `Security` object is exported and provides the package API\nSecurity = {\n  // Putting these on the exported object allows package users to override if necessary\n  errorMessages: {\n    multipleCan: 'You may not combine more than one insert, update, or remove on a Security.can chain',\n    notAllowed: 'Action not allowed',\n    requiresDefinition: 'Security.defineMethod requires a \"definition\" argument',\n    requiresAllow: 'Security.defineMethod requires an \"allow\" function',\n    collectionsArg: 'The collections argument must be a Mongo.Collection instance or an array of them',\n    noCollectionOrType: 'At a minimum, you must call permit and collections methods for a security rule.',\n  },\n  // the starting point of the chain\n  permit: function permit(types) {\n    return new Security.Rule(types);\n  },\n  can: function can(userId) {\n    return new Security.Check(userId);\n  },\n  defineMethod: function securityDefineMethod(name, definition) {\n    // Check whether a rule with the given name already exists; can't overwrite\n    if (Security.Rule.prototype[name]) {\n      throw new Error('A security method with the name \"' + name + '\" has already been defined');\n    }\n    if (!definition) throw new Error(Security.errorMessages.requiresDefinition);\n    // If \"deny\" is used, convert to \"allow\" for backwards compatibility\n    if (definition.deny) {\n      definition.allow = (...args) => {\n        return !definition.deny(...args);\n      };\n    }\n    // Make sure the definition argument is an object that has an `allow` property\n    if (!definition.allow) throw new Error(Security.errorMessages.requiresAllow);\n    // Wrap transform, if provided\n    if (definition.transform) {\n      definition.transform = LocalCollection.wrapTransform(definition.transform);\n    }\n    Security.Rule.prototype[name] = function (arg) {\n      this._restrictions.push({\n        definition,\n        arg,\n      });\n      return this;\n    };\n  }\n};\n\nMongo.Collection.prototype.permit = function (types) {\n  return Security.permit(types).collections(this);\n};\n","Security.Rule = class {\n  constructor(types) {\n    if (!_.isArray(types)) types = [types];\n    this._types = types;\n    this._restrictions = [];\n  }\n\n  collections(collections) {\n    // Make sure the `collections` argument is either a `Mongo.Collection` instance or\n    // an array of them. If it's a single collection, convert it to a one-item array.\n    if (!_.isArray(collections)) collections = [collections];\n\n    // Keep list keyed by collection name\n    _.each(collections, collection => {\n      if (!(collection instanceof Mongo.Collection) &&\n          // CollectionFS has underlying collection on `files` property\n        !(collection.files instanceof Mongo.Collection)) {\n        throw new Error(Security.errorMessages.collectionsArg);\n      }\n      // CollectionFS has underlying collection on `files` property\n      const collectionName = getCollectionName(collection);\n      rulesByCollection[collectionName] = rulesByCollection[collectionName] || [];\n      rulesByCollection[collectionName].push(this);\n    });\n\n    this._collections = collections;\n\n    return this;\n  }\n\n  combinedFetch() {\n    // We need a combined `fetch` array. The `fetch` is optional and can be either an array\n    // or a function that takes the argument passed to the restriction method and returns an array.\n    let fetch = [];\n    _.every(this._restrictions, restriction => {\n      if (_.isArray(restriction.definition.fetch)) {\n        fetch = _.union(fetch, restriction.definition.fetch);\n      } else if (typeof restriction.definition.fetch === \"function\") {\n        fetch = _.union(fetch, restriction.definition.fetch(restriction.arg));\n      } else if (!restriction.definition.hasOwnProperty('fetch')) {\n        // If `fetch` property isn't present, we should fetch the full doc.\n        fetch = null;\n        return false; // Exit loop\n      }\n      return true;\n    });\n    return fetch;\n  }\n\n  allowInClientCode() {\n    if (!this._collections || !this._types) throw new Error(Security.errorMessages.noCollectionOrType);\n    ensureSecureDeny(this._collections, this._types);\n  }\n\n  allow(type, collection, userId, doc, modifier, ...args) {\n    let fields;\n    if (type === 'update') fields = computeChangedFieldsFromModifier(modifier);\n\n    // Loop through all defined restrictions. Restrictions are additive for this chained\n    // rule, so if any allow function returns false, this function should return false.\n    return _.every(this._restrictions, restriction => {\n      // Clone the doc in case we need to transform it. Transformations\n      // should apply to only the one restriction.\n      let loopDoc = _.clone(doc);\n\n      // If transform is a function, apply that\n      let transform = restriction.definition.transform;\n      if (transform !== null) {\n        transform = transform || collection._transform;\n        if (typeof transform === 'function') {\n          let addedRandomId = false;\n          if (type === 'insert' && !loopDoc._id) {\n            // The wrapped transform requires an _id, but we\n            // don't have access to the generatedId from Meteor API,\n            // so we'll fudge one and then remove it.\n            loopDoc._id = Random.id();\n            addedRandomId = true;\n          }\n          loopDoc = transform(loopDoc);\n          if (addedRandomId) delete loopDoc._id;\n        }\n      }\n\n      return restriction.definition.allow(type, restriction.arg, userId, loopDoc, fields, modifier, ...args);\n    });\n  }\n}\n\nfunction ensureSecureDeny(collections, types) {\n  // If we haven't yet done so, set up a default, permissive `allow` function for all of\n  // the given collections and types. We control all security through `deny` functions only, but\n  // there must first be at least one `allow` function for each collection or all writes\n  // will be denied.\n  ensureDefaultAllow(collections, types);\n\n  _.each(types, t => {\n    _.each(collections, collection => {\n      ensureCreated('deny', [collection], [t], null, function (...args) {\n        const userId = args.shift();\n\n        // If type is update, remove the `fields` argument. We will create our own\n        // for consistency.\n        if (t === 'update') args = [args[0], args[2]];\n\n        return !Security.can(userId)[t](...args).for(collection).check();\n      });\n    });\n  });\n}\n\nfunction computeChangedFieldsFromModifier(modifier) {\n  var fields = [];\n  // This is the same logic Meteor's mongo package uses in\n  // https://github.com/meteor/meteor/blob/devel/packages/mongo/collection.js\n  _.each(modifier, function (params) {\n    _.each(_.keys(params), function (field) {\n      // treat dotted fields as if they are replacing their\n      // top-level part\n      if (field.indexOf('.') !== -1)\n        field = field.substring(0, field.indexOf('.'));\n\n      // record the field we are trying to change\n      if (!_.contains(fields, field))\n        fields.push(field);\n    });\n  });\n  return fields;\n}\n","Security.Check = class {\n  constructor(userId) {\n    this.userId = userId || null;\n  }\n\n  for(collection) {\n    this.collection = collection;\n    this.collectionName = getCollectionName(collection);\n    return this;\n  }\n\n  insert(doc, ...args) {\n    if (this.type) throw new Error(Security.errorMessages.multipleCan);\n    this.type = 'insert';\n    this.doc = doc;\n    this.args = args;\n    return this;\n  }\n\n  update(doc, modifier, ...args) {\n    if (this.type) throw new Error(Security.errorMessages.multipleCan);\n    this.type = 'update';\n    this.doc = doc;\n    this.modifier = modifier;\n    this.args = args;\n    return this;\n  }\n\n  remove(doc, ...args) {\n    if (this.type) throw new Error(Security.errorMessages.multipleCan);\n    this.type = 'remove';\n    this.doc = doc;\n    this.args = args;\n    return this;\n  }\n\n  read(doc, ...args) {\n    if (this.type) throw new Error(Security.errorMessages.multipleCan);\n    this.type = 'read';\n    this.doc = doc;\n    this.args = args;\n    return this;\n  }\n\n  download(doc, ...args) {\n    if (this.type) throw new Error(Security.errorMessages.multipleCan);\n    this.type = 'download';\n    this.doc = doc;\n    this.args = args;\n    return this;\n  }\n\n  // EXAMPLES:\n  // Security.can(userId).insert(doc).for(MyCollection).check()\n  // Security.can(userId).update(id, modifier).for(MyCollection).check()\n  // Security.can(userId).remove(id).for(MyCollection).check()\n  check() {\n    // Select only those rules that apply to this operation type\n    const rules = getRulesForCollectionAndType(this.collectionName, this.type);\n\n    // If this.doc is an ID, we will look up the doc, fetching only the fields needed.\n    // To find out which fields are needed, we will combine all the `fetch` arrays from\n    // all the restrictions in all the rules.\n    if (typeof this.doc === 'string' || this.doc instanceof MongoID.ObjectID) {\n      let fields = {};\n      _.every(rules, rule => {\n        const fetch = rule.combinedFetch();\n        if (fetch === null) {\n          fields = null;\n          return false; // Exit loop\n        }\n        rule.combinedFetch().forEach(field => {\n          fields[field] = 1;\n        });\n        return true;\n      });\n\n      let options = {};\n      if (fields) {\n        if (_.isEmpty(fields)) {\n          options = {_id: 1};\n        } else {\n          options = {fields};\n        }\n      }\n      this.doc = this.collection.findOne(this.doc, options);\n    }\n\n    // Loop through all defined rules for this collection. There is an OR relationship among\n    // all rules for the collection, so if any \"allow\" function DO return true, we allow.\n    return _.any(rules, rule => rule.allow(this.type, this.collection, this.userId, this.doc, this.modifier, ...this.args));\n  }\n\n  // EXAMPLES:\n  // Security.can(userId).insert(doc).for(MyCollection).throw()\n  // Security.can(userId).update(id, modifier).for(MyCollection).throw()\n  // Security.can(userId).remove(id).for(MyCollection).throw()\n  throw() {\n    if (!this.check()) throw new Meteor.Error('access-denied', Security.errorMessages.notAllowed);\n  }\n}\n","/*\n * This file defines built-in restriction methods\n */\n\n/*\n * No one\n */\n\nSecurity.defineMethod(\"never\", {\n  fetch: [],\n  transform: null,\n  allow() {\n    return false;\n  },\n});\n\n/*\n * Logged In\n */\n\nSecurity.defineMethod(\"ifLoggedIn\", {\n  fetch: [],\n  transform: null,\n  allow(type, arg, userId) {\n    return !!userId;\n  },\n});\n\n/*\n * Specific User ID\n */\n\nSecurity.defineMethod(\"ifHasUserId\", {\n  fetch: [],\n  transform: null,\n  allow(type, arg, userId) {\n    return userId === arg;\n  },\n});\n\n/*\n * Specific Roles\n */\n\n/*\n * alanning:roles support\n */\nif (Package && Package[\"alanning:roles\"]) {\n\n  var Roles = Package[\"alanning:roles\"].Roles;\n\n  Security.defineMethod(\"ifHasRole\", {\n    fetch: [],\n    transform: null,\n    allow(type, arg, userId) {\n      if (!arg) throw new Error('ifHasRole security rule method requires an argument');\n      if (arg.role) {\n        return Roles.userIsInRole(userId, arg.role, arg.group);\n      } else {\n        return Roles.userIsInRole(userId, arg);\n      }\n    },\n  });\n\n}\n\n/*\n * nicolaslopezj:roles support\n * Note: doesn't support groups\n */\nif (Package && Package[\"nicolaslopezj:roles\"]) {\n\n  var Roles = Package[\"nicolaslopezj:roles\"].Roles;\n\n  Security.defineMethod(\"ifHasRole\", {\n    fetch: [],\n    transform: null,\n    allow(type, arg, userId) {\n      if (!arg) throw new Error('ifHasRole security rule method requires an argument');\n      return Roles.userHasRole(userId, arg);\n    }\n  });\n\n}\n\n/*\n * Specific Properties\n */\n\nSecurity.defineMethod(\"onlyProps\", {\n  fetch: [],\n  transform: null,\n  allow(type, arg, userId, doc, fieldNames) {\n    if (!_.isArray(arg)) arg = [arg];\n\n    fieldNames = fieldNames || _.keys(doc);\n\n    return _.every(fieldNames, function (fieldName) {\n      return _.contains(arg, fieldName);\n    });\n  },\n});\n\nSecurity.defineMethod(\"exceptProps\", {\n  fetch: [],\n  transform: null,\n  allow(type, arg, userId, doc, fieldNames) {\n    if (!_.isArray(arg)) arg = [arg];\n\n    fieldNames = fieldNames || _.keys(doc);\n\n    return !_.any(fieldNames, function (fieldName) {\n      return _.contains(arg, fieldName);\n    });\n  },\n});\n"]}}]