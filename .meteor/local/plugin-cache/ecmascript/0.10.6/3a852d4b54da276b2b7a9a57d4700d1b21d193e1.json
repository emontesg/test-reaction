{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$1$2","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"ast":true,"babelrc":false,"sourceFileName":"packages/ongoworks:security/lib/server/Security.Rule.js","filename":"packages/ongoworks:security/lib/server/Security.Rule.js","sourceMaps":true,"envName":"development","cwd":"/Users/estebandev/test-knowledge","passPerPreset":false,"presets":[],"parserOpts":{"sourceType":"module","sourceFileName":"packages/ongoworks:security/lib/server/Security.Rule.js","plugins":["jsx","jsx","flow","flow","objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties"]},"generatorOpts":{"filename":"packages/ongoworks:security/lib/server/Security.Rule.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/ongoworks:security/lib/server/Security.Rule.js"}},"code":"Security.Rule = class {\n  constructor(types) {\n    if (!_.isArray(types)) types = [types];\n    this._types = types;\n    this._restrictions = [];\n  }\n\n  collections(collections) {\n    // Make sure the `collections` argument is either a `Mongo.Collection` instance or\n    // an array of them. If it's a single collection, convert it to a one-item array.\n    if (!_.isArray(collections)) collections = [collections]; // Keep list keyed by collection name\n\n    _.each(collections, collection => {\n      if (!(collection instanceof Mongo.Collection) && // CollectionFS has underlying collection on `files` property\n      !(collection.files instanceof Mongo.Collection)) {\n        throw new Error(Security.errorMessages.collectionsArg);\n      } // CollectionFS has underlying collection on `files` property\n\n\n      const collectionName = getCollectionName(collection);\n      rulesByCollection[collectionName] = rulesByCollection[collectionName] || [];\n      rulesByCollection[collectionName].push(this);\n    });\n\n    this._collections = collections;\n    return this;\n  }\n\n  combinedFetch() {\n    // We need a combined `fetch` array. The `fetch` is optional and can be either an array\n    // or a function that takes the argument passed to the restriction method and returns an array.\n    let fetch = [];\n\n    _.every(this._restrictions, restriction => {\n      if (_.isArray(restriction.definition.fetch)) {\n        fetch = _.union(fetch, restriction.definition.fetch);\n      } else if (typeof restriction.definition.fetch === \"function\") {\n        fetch = _.union(fetch, restriction.definition.fetch(restriction.arg));\n      } else if (!restriction.definition.hasOwnProperty('fetch')) {\n        // If `fetch` property isn't present, we should fetch the full doc.\n        fetch = null;\n        return false; // Exit loop\n      }\n\n      return true;\n    });\n\n    return fetch;\n  }\n\n  allowInClientCode() {\n    if (!this._collections || !this._types) throw new Error(Security.errorMessages.noCollectionOrType);\n    ensureSecureDeny(this._collections, this._types);\n  }\n\n  allow(type, collection, userId, doc, modifier, ...args) {\n    let fields;\n    if (type === 'update') fields = computeChangedFieldsFromModifier(modifier); // Loop through all defined restrictions. Restrictions are additive for this chained\n    // rule, so if any allow function returns false, this function should return false.\n\n    return _.every(this._restrictions, restriction => {\n      // Clone the doc in case we need to transform it. Transformations\n      // should apply to only the one restriction.\n      let loopDoc = _.clone(doc); // If transform is a function, apply that\n\n\n      let transform = restriction.definition.transform;\n\n      if (transform !== null) {\n        transform = transform || collection._transform;\n\n        if (typeof transform === 'function') {\n          let addedRandomId = false;\n\n          if (type === 'insert' && !loopDoc._id) {\n            // The wrapped transform requires an _id, but we\n            // don't have access to the generatedId from Meteor API,\n            // so we'll fudge one and then remove it.\n            loopDoc._id = Random.id();\n            addedRandomId = true;\n          }\n\n          loopDoc = transform(loopDoc);\n          if (addedRandomId) delete loopDoc._id;\n        }\n      }\n\n      return restriction.definition.allow(type, restriction.arg, userId, loopDoc, fields, modifier, ...args);\n    });\n  }\n\n};\n\nfunction ensureSecureDeny(collections, types) {\n  // If we haven't yet done so, set up a default, permissive `allow` function for all of\n  // the given collections and types. We control all security through `deny` functions only, but\n  // there must first be at least one `allow` function for each collection or all writes\n  // will be denied.\n  ensureDefaultAllow(collections, types);\n\n  _.each(types, t => {\n    _.each(collections, collection => {\n      ensureCreated('deny', [collection], [t], null, function (...args) {\n        const userId = args.shift(); // If type is update, remove the `fields` argument. We will create our own\n        // for consistency.\n\n        if (t === 'update') args = [args[0], args[2]];\n        return !Security.can(userId)[t](...args).for(collection).check();\n      });\n    });\n  });\n}\n\nfunction computeChangedFieldsFromModifier(modifier) {\n  var fields = []; // This is the same logic Meteor's mongo package uses in\n  // https://github.com/meteor/meteor/blob/devel/packages/mongo/collection.js\n\n  _.each(modifier, function (params) {\n    _.each(_.keys(params), function (field) {\n      // treat dotted fields as if they are replacing their\n      // top-level part\n      if (field.indexOf('.') !== -1) field = field.substring(0, field.indexOf('.')); // record the field we are trying to change\n\n      if (!_.contains(fields, field)) fields.push(field);\n    });\n  });\n\n  return fields;\n}","map":{"version":3,"sources":["packages/ongoworks:security/lib/server/Security.Rule.js"],"names":["Security","Rule","constructor","types","_","isArray","_types","_restrictions","collections","each","collection","Mongo","Collection","files","Error","errorMessages","collectionsArg","collectionName","getCollectionName","rulesByCollection","push","_collections","combinedFetch","fetch","every","restriction","definition","union","arg","hasOwnProperty","allowInClientCode","noCollectionOrType","ensureSecureDeny","allow","type","userId","doc","modifier","args","fields","computeChangedFieldsFromModifier","loopDoc","clone","transform","_transform","addedRandomId","_id","Random","id","ensureDefaultAllow","t","ensureCreated","shift","can","for","check","params","keys","field","indexOf","substring","contains"],"mappings":"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","sourcesContent":["Security.Rule = class {\n  constructor(types) {\n    if (!_.isArray(types)) types = [types];\n    this._types = types;\n    this._restrictions = [];\n  }\n\n  collections(collections) {\n    // Make sure the `collections` argument is either a `Mongo.Collection` instance or\n    // an array of them. If it's a single collection, convert it to a one-item array.\n    if (!_.isArray(collections)) collections = [collections];\n\n    // Keep list keyed by collection name\n    _.each(collections, collection => {\n      if (!(collection instanceof Mongo.Collection) &&\n          // CollectionFS has underlying collection on `files` property\n        !(collection.files instanceof Mongo.Collection)) {\n        throw new Error(Security.errorMessages.collectionsArg);\n      }\n      // CollectionFS has underlying collection on `files` property\n      const collectionName = getCollectionName(collection);\n      rulesByCollection[collectionName] = rulesByCollection[collectionName] || [];\n      rulesByCollection[collectionName].push(this);\n    });\n\n    this._collections = collections;\n\n    return this;\n  }\n\n  combinedFetch() {\n    // We need a combined `fetch` array. The `fetch` is optional and can be either an array\n    // or a function that takes the argument passed to the restriction method and returns an array.\n    let fetch = [];\n    _.every(this._restrictions, restriction => {\n      if (_.isArray(restriction.definition.fetch)) {\n        fetch = _.union(fetch, restriction.definition.fetch);\n      } else if (typeof restriction.definition.fetch === \"function\") {\n        fetch = _.union(fetch, restriction.definition.fetch(restriction.arg));\n      } else if (!restriction.definition.hasOwnProperty('fetch')) {\n        // If `fetch` property isn't present, we should fetch the full doc.\n        fetch = null;\n        return false; // Exit loop\n      }\n      return true;\n    });\n    return fetch;\n  }\n\n  allowInClientCode() {\n    if (!this._collections || !this._types) throw new Error(Security.errorMessages.noCollectionOrType);\n    ensureSecureDeny(this._collections, this._types);\n  }\n\n  allow(type, collection, userId, doc, modifier, ...args) {\n    let fields;\n    if (type === 'update') fields = computeChangedFieldsFromModifier(modifier);\n\n    // Loop through all defined restrictions. Restrictions are additive for this chained\n    // rule, so if any allow function returns false, this function should return false.\n    return _.every(this._restrictions, restriction => {\n      // Clone the doc in case we need to transform it. Transformations\n      // should apply to only the one restriction.\n      let loopDoc = _.clone(doc);\n\n      // If transform is a function, apply that\n      let transform = restriction.definition.transform;\n      if (transform !== null) {\n        transform = transform || collection._transform;\n        if (typeof transform === 'function') {\n          let addedRandomId = false;\n          if (type === 'insert' && !loopDoc._id) {\n            // The wrapped transform requires an _id, but we\n            // don't have access to the generatedId from Meteor API,\n            // so we'll fudge one and then remove it.\n            loopDoc._id = Random.id();\n            addedRandomId = true;\n          }\n          loopDoc = transform(loopDoc);\n          if (addedRandomId) delete loopDoc._id;\n        }\n      }\n\n      return restriction.definition.allow(type, restriction.arg, userId, loopDoc, fields, modifier, ...args);\n    });\n  }\n}\n\nfunction ensureSecureDeny(collections, types) {\n  // If we haven't yet done so, set up a default, permissive `allow` function for all of\n  // the given collections and types. We control all security through `deny` functions only, but\n  // there must first be at least one `allow` function for each collection or all writes\n  // will be denied.\n  ensureDefaultAllow(collections, types);\n\n  _.each(types, t => {\n    _.each(collections, collection => {\n      ensureCreated('deny', [collection], [t], null, function (...args) {\n        const userId = args.shift();\n\n        // If type is update, remove the `fields` argument. We will create our own\n        // for consistency.\n        if (t === 'update') args = [args[0], args[2]];\n\n        return !Security.can(userId)[t](...args).for(collection).check();\n      });\n    });\n  });\n}\n\nfunction computeChangedFieldsFromModifier(modifier) {\n  var fields = [];\n  // This is the same logic Meteor's mongo package uses in\n  // https://github.com/meteor/meteor/blob/devel/packages/mongo/collection.js\n  _.each(modifier, function (params) {\n    _.each(_.keys(params), function (field) {\n      // treat dotted fields as if they are replacing their\n      // top-level part\n      if (field.indexOf('.') !== -1)\n        field = field.substring(0, field.indexOf('.'));\n\n      // record the field we are trying to change\n      if (!_.contains(fields, field))\n        fields.push(field);\n    });\n  });\n  return fields;\n}\n"]},"sourceType":"script","hash":"3a852d4b54da276b2b7a9a57d4700d1b21d193e1"}
