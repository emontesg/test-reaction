{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$1$2","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"ast":true,"babelrc":false,"sourceFileName":"server/api/core/importer.js","filename":"server/api/core/importer.js","sourceMaps":true,"envName":"development","cwd":"/Users/estebandev/test-knowledge","passPerPreset":false,"presets":[],"parserOpts":{"sourceType":"module","sourceFileName":"server/api/core/importer.js","plugins":["jsx","jsx","flow","flow","objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties"]},"generatorOpts":{"filename":"server/api/core/importer.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"server/api/core/importer.js"}},"code":"module.export({\n  Importer: () => Importer,\n  Fixture: () => Fixture\n});\nlet Hooks;\nmodule.watch(require(\"@reactioncommerce/hooks\"), {\n  default(v) {\n    Hooks = v;\n  }\n\n}, 0);\nlet Logger;\nmodule.watch(require(\"@reactioncommerce/logger\"), {\n  default(v) {\n    Logger = v;\n  }\n\n}, 1);\nlet Mongo, MongoInternals;\nmodule.watch(require(\"meteor/mongo\"), {\n  Mongo(v) {\n    Mongo = v;\n  },\n\n  MongoInternals(v) {\n    MongoInternals = v;\n  }\n\n}, 2);\nlet EJSON;\nmodule.watch(require(\"meteor/ejson\"), {\n  EJSON(v) {\n    EJSON = v;\n  }\n\n}, 3);\nlet check, Match;\nmodule.watch(require(\"meteor/check\"), {\n  check(v) {\n    check = v;\n  },\n\n  Match(v) {\n    Match = v;\n  }\n\n}, 4);\nlet Random;\nmodule.watch(require(\"meteor/random\"), {\n  Random(v) {\n    Random = v;\n  }\n\n}, 5);\nlet Collections;\nmodule.watch(require(\"../../../lib/collections\"), {\n  \"*\"(v) {\n    Collections = v;\n  }\n\n}, 6);\nconst Importer = {};\nImporter._buffers = {};\nImporter._contexts = {};\nImporter._count = {};\nImporter._indications = {};\nImporter._limit = 1000;\n\nImporter._name = function (collection) {\n  return collection._name;\n};\n\nImporter._upsert = function () {\n  return true;\n}; //\n// TODO Verify if Importer.startup is deprecated\n//\n\n\nImporter.startup = function () {\n  return true;\n};\n\nImporter.load = function (key, object) {\n  check(object, Object);\n  this.object(this.identify(object), key, object);\n};\n\nImporter.indication = function (field, collection, probability) {\n  check(field, String);\n  check(collection, Mongo.Collection);\n  check(probability, Number);\n  this._indications[field] = {\n    collection,\n    probability\n  };\n};\n/**\n * Importer.identify\n * @name identify\n * @method\n * @memberof Importer\n * @summary Tries to identify the schema associated with a document.\n * @param {Object} document - A document with unknown schema\n * @returns {Mongo.Collection} Returns a MongoDB collection in which the\n * document can be inserted.\n * @throws {Error} Throws an error if the schema couldn't be determined.\n *\n * The algorithm initially assumes the document can be anything. It associates\n * with each field in the document a probability that it isn't following some\n * schema other than the one the field is associated with.\n *\n * Afterwards the schema with the maximal probability is selected. An error is\n * thrown if the schema cannot be determined.\n */\n\n\nImporter.identify = function (document) {\n  check(document, Object);\n  const probabilities = {};\n\n  for (const key of Object.keys(document)) {\n    if (this._indications[key]) {\n      const collection = this._name(this._indications[key].collection);\n\n      probabilities[collection] = probabilities[collection] || 1.0 * this._indications[key].probability;\n    }\n  }\n\n  let total = 1.0;\n\n  for (const key of Object.keys(probabilities)) {\n    total *= probabilities[key];\n  }\n\n  let max = 0.0;\n  let name;\n\n  for (const key of Object.keys(probabilities)) {\n    const probability = total / probabilities[key];\n\n    if (probability > max) {\n      max = probability;\n      name = key;\n    } else if (probability === max) {\n      name = undefined;\n    }\n  }\n\n  if (name && max > 0.3) {\n    return Collections[name];\n  }\n\n  throw new Error(\"Couldn't determine the schema associated with this document\");\n};\n/**\n * @name commit\n * @method\n * @memberof Importer\n * @summary Commit the buffer for a given collection to the database.\n * @param {Mongo.Collection} collection The target collection to be flushed to disk\n * @returns {undefined}\n */\n\n\nImporter.commit = function (collection) {\n  check(collection, Mongo.Collection); // Construct a collection identifier.\n\n  const name = this._name(collection); // Only commit if the buffer isn't empty (otherwise it'll throw).\n\n\n  if (this._count[name]) {\n    this.buffer(collection).execute((error, result) => {\n      // Inserted document counts don't affect the modified document count, so we\n      // throw everything together.\n      const nImported = result.nModified + result.nInserted + result.nUpserted;\n      const nTouched = result.nMatched + result.nInserted + result.nUpserted;\n      const {\n        nRemoved\n      } = result; // Log some information about the Importer.\n\n      if (nTouched) {\n        let message = `Modified ${nImported}${nImported === 1 ? \" document\" : \" documents\"}`;\n        message += ` while importing ${nTouched} to ${name}`;\n        Logger.debug(message);\n      }\n\n      if (nRemoved) {\n        let message = `Removed ${nRemoved}${nRemoved === 1 ? \" document\" : \" documents\"}`;\n        message += ` from ${name}`;\n        Logger.debug(message);\n      } // Log any errors returned.\n\n\n      const message = `Error while importing to ${name}`;\n      const writeErrors = result.getWriteErrors();\n\n      for (let i = 0; i < writeErrors.length; i += 1) {\n        Logger.warn(`${message}: ${writeErrors[i].errmsg}`);\n      }\n\n      const writeConcernError = result.getWriteConcernError();\n\n      if (writeConcernError) {\n        Logger.warn(`${message}: ${writeConcernError.errmsg}`);\n      }\n    }); // Reset the buffer.\n\n    delete this._buffers[name];\n    this._count[name] = 0;\n  }\n};\n/**\n * @name flush\n * @method\n * @memberof Importer\n * @summary Process the buffer for a given collection and commit the database.\n * @param {Mongo.Collection} collection optional - supply a Mongo collection, or leave empty to commit all buffer entries\n * @returns {undefined}\n */\n\n\nImporter.flush = function (collection) {\n  if (!collection) {\n    for (const name of Object.keys(this._buffers)) {\n      this.commit(Collections[name]);\n    }\n\n    return;\n  }\n\n  this.commit(collection);\n};\n/**\n * @name context\n * @method\n * @memberof Importer\n * @summary Get a validation context for a given collection.\n * @param {Mongo.Collection} collection The target collection\n * @param {Object} [selector] A selector object to retrieve the correct schema.\n * @returns {SimpleSchema.ValidationContext} A validation context.\n *\n * The validation context is requested from the schema associated with the\n * collection.\n */\n\n\nImporter.context = function (collection, selector) {\n  check(collection, Mongo.Collection);\n  check(selector, Match.Optional(Object)); // Construct a context identifier.\n\n  let name = this._name(collection);\n\n  if (selector && selector.type) {\n    name = `${name}_${selector.type}`;\n  }\n\n  return collection.simpleSchema(selector).namedContext(name);\n};\n/**\n * @name buffer\n * @method\n * @memberof Importer\n * @summary Get an import buffer for a given collection.\n * @param {Object} collection The target collection\n * @returns {Object} return buffer\n * If no buffer is presented, a new one will be constructed.\n */\n\n\nImporter.buffer = function (collection) {\n  check(collection, Mongo.Collection);\n\n  if (!MongoInternals.NpmModule.Collection.prototype.initializeUnorderedBulkOp) {\n    throw Error(\"Couldn't detect the MongoDB bulk API, are you using MongoDB 2.6 or above?\");\n  } // Construct a buffer identifier.\n\n\n  const name = this._name(collection); // Construct a new buffer if necessary.\n\n\n  if (this._buffers[name]) {\n    return this._buffers[name];\n  }\n\n  this._count[name] = 0;\n  this._buffers[name] = collection.rawCollection().initializeUnorderedBulkOp();\n  return this._buffers[name];\n};\n/**\n * @name product\n * @method\n * @memberof Importer\n * @summary Store a product in the import buffer.\n * @param {Object} key A key to look up the product\n * @param {Object} product The product data to be updated\n * @returns {Object}\n * Importing a variant currently consists of the following steps:\n *\n * * Pull the variant from non-matching parent products.\n * * Push the variant if it doesn't exist.\n * * Update the variant.\n */\n\n\nImporter.product = function (key, product) {\n  // If product has an _id, we use it to look up the product before\n  // updating the product so as to avoid trying to change the _id\n  // which is immutable.\n  if (product._id && !key._id) {\n    key._id = product._id;\n  }\n\n  return this.object(Collections.Products, key, product);\n};\n/**\n * @name package\n * @method\n * @memberof Importer\n * @summary Store a package in the import buffer.\n * @param {Object} pkg The package data to be updated\n * @param {String} shopId The package data to be updated\n * @returns {undefined}\n */\n\n\nImporter.package = function (pkg, shopId) {\n  check(pkg, Object);\n  check(shopId, String);\n  const key = {\n    name: pkg.name,\n    shopId\n  };\n  return this.object(Collections.Packages, key, pkg);\n}; //\n// Importer.translation\n// server/startup/i18n.js\n//\n\n/**\n * @name template\n * @method\n * @memberof Importer\n * @summary Store a template in the import buffer.\n * @param {Object} templateInfo The template data to be updated\n * @returns {undefined}\n */\n\n\nImporter.template = function (templateInfo) {\n  check(templateInfo, Object);\n  const key = {\n    name: templateInfo.name,\n    type: templateInfo.type || \"template\"\n  };\n  return this.object(Collections.Templates, key, templateInfo);\n};\n/**\n * @name translation\n * @method\n * @memberof Importer\n * @summary Store a translation in the import buffer.\n * @param {Object} key A key to look up the translation\n * @param {Object} translation The translation data to be updated\n * @returns {Object} updated translation buffer\n */\n\n\nImporter.translation = function (key, translation) {\n  const modifiedKey = Object.assign(key, {\n    ns: translation.ns\n  });\n  return this.object(Collections.Translations, modifiedKey, translation);\n};\n/**\n * @name shop\n * @method\n * @memberof Importer\n * @summary Store a shop in the import buffer.\n * @param {Object} key A key to look up the shop\n * @param {Object} shop The shop data to be updated\n * @returns {Object} this shop\n */\n\n\nImporter.shop = function (key, shop) {\n  return this.object(Collections.Shops, key, shop);\n};\n/**\n * @name layout\n * @method\n * @memberof Importer\n * @summary store a shop layout in the import buffer\n * @param {Array} layout - an array of layouts to be added to shop\n * @param {String} shopId shopId\n * @returns {Object} this shop\n */\n\n\nImporter.layout = function (layout, shopId) {\n  const key = {\n    _id: shopId\n  };\n  return this.object(Collections.Shops, key, {\n    _id: shopId,\n    layout\n  });\n};\n/**\n * @name shipping\n * @method\n * @memberof Importer\n * @summary Store shipping in the import buffer.\n * @param {Object} key A shipping service key used in combination with provider\n * @param {Object} shipping The shipping data to be updated\n * @returns {Object} this shipping\n */\n\n\nImporter.shipping = function (key, shipping) {\n  let importKey = {}; //\n  // we have a bit of a strange structure in Shipping\n  // and don't really have a key that is good for\n  // determining if we imported this before\n  // so we're just saying that if this service\n  // already exists then we're not going to import\n  //\n\n  const result = Collections.Shipping.findOne(key);\n\n  if (result) {\n    importKey = {\n      _id: result._id,\n      shopId: result.shopId\n    };\n    delete shipping.methods;\n  }\n\n  const modifiedKey = Object.assign({}, key, importKey);\n  return this.object(Collections.Shipping, modifiedKey, shipping);\n};\n/**\n * @name tag\n * @method\n * @memberof Importer\n * @summary Store a tag in the import buffer.\n * @param {Object} key A key to look up the tag\n * @param {Object} tag The tag data to be updated\n * @returns {Object} this tag\n */\n\n\nImporter.tag = function (key, tag) {\n  return this.object(Collections.Tags, key, tag);\n};\n/**\n * @name object\n * @method\n * @memberof Importer\n * @summary Push a new upsert document to the import buffer.\n * @param {Mongo.Collection} collection The target collection\n * @param {Object} key A key to look up the object\n * @param {Object} object The object data to be updated\n * @returns {undefined}\n */\n\n\nImporter.object = function (collection, key, object) {\n  check(collection, Mongo.Collection);\n  check(key, Object);\n  check(object, Object); // enforce strings instead of Mongo.ObjectId\n\n  if (!collection.findOne(key) && !object._id) {\n    key._id = Random.id();\n  } // hooks for additional import manipulation.\n\n\n  const importObject = Hooks.Events.run(`onImport${this._name(collection)}`, object); // Cleaning the object adds default values from schema, if value doesn't exist\n\n  const cleanedModifier = collection.simpleSchema(importObject).clean({\n    $set: importObject\n  }, {\n    isModifier: true,\n    extendAutoValueContext: {\n      isUpsert: true\n    }\n  }); // And validate the object against the schema\n\n  this.context(collection, importObject).validate(cleanedModifier, {\n    modifier: true,\n    upsert: true\n  }); // Upsert the object.\n  // With the upsert option set to true, if no matching documents exist for the Bulk.find() condition,\n  // then the update or the replacement operation performs an insert.\n  // https://docs.mongodb.com/manual/reference/method/Bulk.find.upsert/\n\n  this.buffer(collection).find(key).upsert().update(cleanedModifier);\n  this._count[this._name(collection)] += 1;\n\n  if (this._count[this._name(collection)] >= this._limit) {\n    this.flush(collection);\n  }\n};\n/**\n * @name process\n * @method\n * @memberof Importer\n * @summary Process a json array of import documents using a callback.\n * @param {Object[]} json An array containing the import documents\n * @param {string[]} keys Fields that should be used as the import key.\n * @param {Function} callback A callback accepting two parameters.\n * The callback should accept a key document to consult the database as a first\n * parameter and an update document as the second parameter.\n * @returns {undefined}\n */\n\n\nImporter.process = function (json, keys, callback) {\n  check(json, String);\n  check(keys, Array);\n  check(callback, Function);\n  const array = EJSON.parse(json);\n\n  for (let i = 0; i < array.length; i += 1) {\n    const key = {};\n\n    for (let j = 0; j < keys.length; j += 1) {\n      key[keys[j]] = array[i][keys[j]];\n    }\n\n    callback.call(this, key, array[i]);\n  }\n};\n\nImporter.indication(\"i18n\", Collections.Translations, 0.2);\nImporter.indication(\"hashtags\", Collections.Products, 0.5);\nImporter.indication(\"barcode\", Collections.Products, 0.5);\nImporter.indication(\"price\", Collections.Products, 0.5);\nImporter.indication(\"ancestors\", Collections.Products, 0.5);\nImporter.indication(\"languages\", Collections.Shops, 0.5);\nImporter.indication(\"currencies\", Collections.Shops, 0.5);\nImporter.indication(\"timezone\", Collections.Shops, 0.5);\nImporter.indication(\"isTopLevel\", Collections.Tags, 0.4);\nImporter.indication(\"slug\", Collections.Tags, 0.5);\nImporter.indication(\"provider\", Collections.Shipping, 0.2); //\n// exporting Fixture\n// use this instead of Import if you want\n// Bulk.find.upsert() to equal false\n//\n\nconst Fixture = Object.assign({}, Importer, {\n  _upsert: () => false\n});","map":{"version":3,"sources":["server/api/core/importer.js"],"names":["module","export","Importer","Fixture","Hooks","watch","require","default","v","Logger","Mongo","MongoInternals","EJSON","check","Match","Random","Collections","_buffers","_contexts","_count","_indications","_limit","_name","collection","_upsert","startup","load","key","object","Object","identify","indication","field","probability","String","Collection","Number","document","probabilities","keys","total","max","name","undefined","Error","commit","buffer","execute","error","result","nImported","nModified","nInserted","nUpserted","nTouched","nMatched","nRemoved","message","debug","writeErrors","getWriteErrors","i","length","warn","errmsg","writeConcernError","getWriteConcernError","flush","context","selector","Optional","type","simpleSchema","namedContext","NpmModule","prototype","initializeUnorderedBulkOp","rawCollection","product","_id","Products","package","pkg","shopId","Packages","template","templateInfo","Templates","translation","modifiedKey","assign","ns","Translations","shop","Shops","layout","shipping","importKey","Shipping","findOne","methods","tag","Tags","id","importObject","Events","run","cleanedModifier","clean","$set","isModifier","extendAutoValueContext","isUpsert","validate","modifier","upsert","find","update","process","json","callback","Array","Function","array","parse","j","call"],"mappings":"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","sourcesContent":["import Hooks from \"@reactioncommerce/hooks\";\nimport Logger from \"@reactioncommerce/logger\";\nimport { Mongo, MongoInternals } from \"meteor/mongo\";\nimport { EJSON } from \"meteor/ejson\";\nimport { check, Match } from \"meteor/check\";\nimport { Random } from \"meteor/random\";\nimport * as Collections from \"/lib/collections\";\n\n/**\n * @file Exposes the Importer object implementing methods for bulk imports.\n * @author Tom De Caluwé\n * @namespace Importer\n */\n\nexport const Importer = {};\n\nImporter._buffers = {};\nImporter._contexts = {};\nImporter._count = {};\nImporter._indications = {};\nImporter._limit = 1000;\n\nImporter._name = function (collection) {\n  return collection._name;\n};\n\nImporter._upsert = function () {\n  return true;\n};\n\n//\n// TODO Verify if Importer.startup is deprecated\n//\nImporter.startup = function () {\n  return true;\n};\n\nImporter.load = function (key, object) {\n  check(object, Object);\n\n  this.object(this.identify(object), key, object);\n};\n\nImporter.indication = function (field, collection, probability) {\n  check(field, String);\n  check(collection, Mongo.Collection);\n  check(probability, Number);\n\n  this._indications[field] = { collection, probability };\n};\n\n/**\n * Importer.identify\n * @name identify\n * @method\n * @memberof Importer\n * @summary Tries to identify the schema associated with a document.\n * @param {Object} document - A document with unknown schema\n * @returns {Mongo.Collection} Returns a MongoDB collection in which the\n * document can be inserted.\n * @throws {Error} Throws an error if the schema couldn't be determined.\n *\n * The algorithm initially assumes the document can be anything. It associates\n * with each field in the document a probability that it isn't following some\n * schema other than the one the field is associated with.\n *\n * Afterwards the schema with the maximal probability is selected. An error is\n * thrown if the schema cannot be determined.\n */\nImporter.identify = function (document) {\n  check(document, Object);\n\n  const probabilities = {};\n\n  for (const key of Object.keys(document)) {\n    if (this._indications[key]) {\n      const collection = this._name(this._indications[key].collection);\n      probabilities[collection] = probabilities[collection] || 1.0 * this._indications[\n        key].probability;\n    }\n  }\n\n  let total = 1.0;\n  for (const key of Object.keys(probabilities)) {\n    total *= probabilities[key];\n  }\n\n  let max = 0.0;\n  let name;\n  for (const key of Object.keys(probabilities)) {\n    const probability = total / probabilities[key];\n    if (probability > max) {\n      max = probability;\n      name = key;\n    } else if (probability === max) {\n      name = undefined;\n    }\n  }\n\n  if (name && max > 0.3) {\n    return Collections[name];\n  }\n  throw new Error(\"Couldn't determine the schema associated with this document\");\n};\n\n/**\n * @name commit\n * @method\n * @memberof Importer\n * @summary Commit the buffer for a given collection to the database.\n * @param {Mongo.Collection} collection The target collection to be flushed to disk\n * @returns {undefined}\n */\nImporter.commit = function (collection) {\n  check(collection, Mongo.Collection);\n  // Construct a collection identifier.\n  const name = this._name(collection);\n\n  // Only commit if the buffer isn't empty (otherwise it'll throw).\n  if (this._count[name]) {\n    this.buffer(collection).execute((error, result) => {\n      // Inserted document counts don't affect the modified document count, so we\n      // throw everything together.\n      const nImported = result.nModified + result.nInserted + result.nUpserted;\n      const nTouched = result.nMatched + result.nInserted + result.nUpserted;\n      const { nRemoved } = result;\n      // Log some information about the Importer.\n      if (nTouched) {\n        let message = `Modified ${nImported}${nImported === 1 ? \" document\" : \" documents\"}`;\n        message += ` while importing ${nTouched} to ${name}`;\n        Logger.debug(message);\n      }\n      if (nRemoved) {\n        let message = `Removed ${nRemoved}${nRemoved === 1 ? \" document\" : \" documents\"}`;\n        message += ` from ${name}`;\n        Logger.debug(message);\n      }\n      // Log any errors returned.\n      const message = `Error while importing to ${name}`;\n      const writeErrors = result.getWriteErrors();\n\n      for (let i = 0; i < writeErrors.length; i += 1) {\n        Logger.warn(`${message}: ${writeErrors[i].errmsg}`);\n      }\n      const writeConcernError = result.getWriteConcernError();\n      if (writeConcernError) {\n        Logger.warn(`${message}: ${writeConcernError.errmsg}`);\n      }\n    });\n    // Reset the buffer.\n    delete this._buffers[name];\n    this._count[name] = 0;\n  }\n};\n\n/**\n * @name flush\n * @method\n * @memberof Importer\n * @summary Process the buffer for a given collection and commit the database.\n * @param {Mongo.Collection} collection optional - supply a Mongo collection, or leave empty to commit all buffer entries\n * @returns {undefined}\n */\nImporter.flush = function (collection) {\n  if (!collection) {\n    for (const name of Object.keys(this._buffers)) {\n      this.commit(Collections[name]);\n    }\n    return;\n  }\n  this.commit(collection);\n};\n\n/**\n * @name context\n * @method\n * @memberof Importer\n * @summary Get a validation context for a given collection.\n * @param {Mongo.Collection} collection The target collection\n * @param {Object} [selector] A selector object to retrieve the correct schema.\n * @returns {SimpleSchema.ValidationContext} A validation context.\n *\n * The validation context is requested from the schema associated with the\n * collection.\n */\nImporter.context = function (collection, selector) {\n  check(collection, Mongo.Collection);\n  check(selector, Match.Optional(Object));\n\n  // Construct a context identifier.\n  let name = this._name(collection);\n  if (selector && selector.type) {\n    name = `${name}_${selector.type}`;\n  }\n  return collection.simpleSchema(selector).namedContext(name);\n};\n\n/**\n * @name buffer\n * @method\n * @memberof Importer\n * @summary Get an import buffer for a given collection.\n * @param {Object} collection The target collection\n * @returns {Object} return buffer\n * If no buffer is presented, a new one will be constructed.\n */\nImporter.buffer = function (collection) {\n  check(collection, Mongo.Collection);\n\n  if (!MongoInternals.NpmModule.Collection.prototype.initializeUnorderedBulkOp) {\n    throw Error(\"Couldn't detect the MongoDB bulk API, are you using MongoDB 2.6 or above?\");\n  }\n\n  // Construct a buffer identifier.\n  const name = this._name(collection);\n\n  // Construct a new buffer if necessary.\n  if (this._buffers[name]) {\n    return this._buffers[name];\n  }\n  this._count[name] = 0;\n  this._buffers[name] = collection.rawCollection().initializeUnorderedBulkOp();\n  return this._buffers[name];\n};\n\n/**\n * @name product\n * @method\n * @memberof Importer\n * @summary Store a product in the import buffer.\n * @param {Object} key A key to look up the product\n * @param {Object} product The product data to be updated\n * @returns {Object}\n * Importing a variant currently consists of the following steps:\n *\n * * Pull the variant from non-matching parent products.\n * * Push the variant if it doesn't exist.\n * * Update the variant.\n */\nImporter.product = function (key, product) {\n  // If product has an _id, we use it to look up the product before\n  // updating the product so as to avoid trying to change the _id\n  // which is immutable.\n  if (product._id && !key._id) {\n    key._id = product._id;\n  }\n  return this.object(Collections.Products, key, product);\n};\n\n/**\n * @name package\n * @method\n * @memberof Importer\n * @summary Store a package in the import buffer.\n * @param {Object} pkg The package data to be updated\n * @param {String} shopId The package data to be updated\n * @returns {undefined}\n */\nImporter.package = function (pkg, shopId) {\n  check(pkg, Object);\n  check(shopId, String);\n  const key = {\n    name: pkg.name,\n    shopId\n  };\n  return this.object(Collections.Packages, key, pkg);\n};\n\n//\n// Importer.translation\n// server/startup/i18n.js\n//\n\n/**\n * @name template\n * @method\n * @memberof Importer\n * @summary Store a template in the import buffer.\n * @param {Object} templateInfo The template data to be updated\n * @returns {undefined}\n */\nImporter.template = function (templateInfo) {\n  check(templateInfo, Object);\n\n  const key = {\n    name: templateInfo.name,\n    type: templateInfo.type || \"template\"\n  };\n\n  return this.object(Collections.Templates, key, templateInfo);\n};\n\n/**\n * @name translation\n * @method\n * @memberof Importer\n * @summary Store a translation in the import buffer.\n * @param {Object} key A key to look up the translation\n * @param {Object} translation The translation data to be updated\n * @returns {Object} updated translation buffer\n */\nImporter.translation = function (key, translation) {\n  const modifiedKey = Object.assign(key, { ns: translation.ns });\n  return this.object(Collections.Translations, modifiedKey, translation);\n};\n\n/**\n * @name shop\n * @method\n * @memberof Importer\n * @summary Store a shop in the import buffer.\n * @param {Object} key A key to look up the shop\n * @param {Object} shop The shop data to be updated\n * @returns {Object} this shop\n */\nImporter.shop = function (key, shop) {\n  return this.object(Collections.Shops, key, shop);\n};\n\n/**\n * @name layout\n * @method\n * @memberof Importer\n * @summary store a shop layout in the import buffer\n * @param {Array} layout - an array of layouts to be added to shop\n * @param {String} shopId shopId\n * @returns {Object} this shop\n */\nImporter.layout = function (layout, shopId) {\n  const key = {\n    _id: shopId\n  };\n  return this.object(Collections.Shops, key, {\n    _id: shopId,\n    layout\n  });\n};\n\n/**\n * @name shipping\n * @method\n * @memberof Importer\n * @summary Store shipping in the import buffer.\n * @param {Object} key A shipping service key used in combination with provider\n * @param {Object} shipping The shipping data to be updated\n * @returns {Object} this shipping\n */\nImporter.shipping = function (key, shipping) {\n  let importKey = {};\n  //\n  // we have a bit of a strange structure in Shipping\n  // and don't really have a key that is good for\n  // determining if we imported this before\n  // so we're just saying that if this service\n  // already exists then we're not going to import\n  //\n  const result = Collections.Shipping.findOne(key);\n  if (result) {\n    importKey = {\n      _id: result._id,\n      shopId: result.shopId\n    };\n    delete shipping.methods;\n  }\n  const modifiedKey = Object.assign({}, key, importKey);\n  return this.object(Collections.Shipping, modifiedKey, shipping);\n};\n\n/**\n * @name tag\n * @method\n * @memberof Importer\n * @summary Store a tag in the import buffer.\n * @param {Object} key A key to look up the tag\n * @param {Object} tag The tag data to be updated\n * @returns {Object} this tag\n */\nImporter.tag = function (key, tag) {\n  return this.object(Collections.Tags, key, tag);\n};\n\n/**\n * @name object\n * @method\n * @memberof Importer\n * @summary Push a new upsert document to the import buffer.\n * @param {Mongo.Collection} collection The target collection\n * @param {Object} key A key to look up the object\n * @param {Object} object The object data to be updated\n * @returns {undefined}\n */\nImporter.object = function (collection, key, object) {\n  check(collection, Mongo.Collection);\n  check(key, Object);\n  check(object, Object);\n\n  // enforce strings instead of Mongo.ObjectId\n  if (!collection.findOne(key) && !object._id) {\n    key._id = Random.id();\n  }\n\n  // hooks for additional import manipulation.\n  const importObject = Hooks.Events.run(`onImport${this._name(collection)}`, object);\n\n  // Cleaning the object adds default values from schema, if value doesn't exist\n  const cleanedModifier = collection.simpleSchema(importObject).clean({\n    $set: importObject\n  }, {\n    isModifier: true,\n    extendAutoValueContext: { isUpsert: true }\n  });\n\n  // And validate the object against the schema\n  this.context(collection, importObject).validate(cleanedModifier, {\n    modifier: true,\n    upsert: true\n  });\n\n  // Upsert the object.\n  // With the upsert option set to true, if no matching documents exist for the Bulk.find() condition,\n  // then the update or the replacement operation performs an insert.\n  // https://docs.mongodb.com/manual/reference/method/Bulk.find.upsert/\n  this.buffer(collection).find(key).upsert().update(cleanedModifier);\n\n  this._count[this._name(collection)] += 1;\n  if (this._count[this._name(collection)] >= this._limit) {\n    this.flush(collection);\n  }\n};\n\n/**\n * @name process\n * @method\n * @memberof Importer\n * @summary Process a json array of import documents using a callback.\n * @param {Object[]} json An array containing the import documents\n * @param {string[]} keys Fields that should be used as the import key.\n * @param {Function} callback A callback accepting two parameters.\n * The callback should accept a key document to consult the database as a first\n * parameter and an update document as the second parameter.\n * @returns {undefined}\n */\nImporter.process = function (json, keys, callback) {\n  check(json, String);\n  check(keys, Array);\n  check(callback, Function);\n\n  const array = EJSON.parse(json);\n\n  for (let i = 0; i < array.length; i += 1) {\n    const key = {};\n    for (let j = 0; j < keys.length; j += 1) {\n      key[keys[j]] = array[i][keys[j]];\n    }\n    callback.call(this, key, array[i]);\n  }\n};\n\nImporter.indication(\"i18n\", Collections.Translations, 0.2);\nImporter.indication(\"hashtags\", Collections.Products, 0.5);\nImporter.indication(\"barcode\", Collections.Products, 0.5);\nImporter.indication(\"price\", Collections.Products, 0.5);\nImporter.indication(\"ancestors\", Collections.Products, 0.5);\nImporter.indication(\"languages\", Collections.Shops, 0.5);\nImporter.indication(\"currencies\", Collections.Shops, 0.5);\nImporter.indication(\"timezone\", Collections.Shops, 0.5);\nImporter.indication(\"isTopLevel\", Collections.Tags, 0.4);\nImporter.indication(\"slug\", Collections.Tags, 0.5);\nImporter.indication(\"provider\", Collections.Shipping, 0.2);\n\n//\n// exporting Fixture\n// use this instead of Import if you want\n// Bulk.find.upsert() to equal false\n//\nexport const Fixture = Object.assign({}, Importer, {\n  _upsert: () => false\n});\n"]},"sourceType":"script","hash":"707052ec731cf819509eae5ec1e6e5fb3e7462b3"}
