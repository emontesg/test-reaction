{"metadata":{},"options":{"plugins":[{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$2","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":false}},{"key":"base$0$3","visitor":{"_exploded":{},"_verified":{},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}},{"key":"base$0$4","visitor":{"FunctionExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"ForInStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$6","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$0$1$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$1$2","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$2","visitor":{"ArrowFunctionExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$3","visitor":{"BlockStatement":{"enter":[null]},"SwitchCase":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$4","visitor":{"VariableDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"_exploded":true,"BlockStatement":{"enter":[null]},"SwitchStatement":{"enter":[null]},"Program":{"enter":[null]},"_verified":true,"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"base$0$0$5","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"base$0$0$6","visitor":{"ObjectExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"base$0$0$7","visitor":{"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"VariableDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"base$0$0$8","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"base$0$0$9","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$10","visitor":{"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$11","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]}},"options":{}},{"key":"base$0$0$12","visitor":{"ObjectMethod":{"enter":[null]},"ObjectProperty":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$13","visitor":{"ArrayExpression":{"enter":[null]},"CallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$14","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$15","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"base$0$0$16","visitor":{"UnaryExpression":{"enter":[null]},"_exploded":true,"_verified":true,"BlockStatement":{"enter":[null]},"CatchClause":{"enter":[null]},"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"Program":{"enter":[null]},"ObjectMethod":{"enter":[null]},"SwitchStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"ForOfStatement":{"enter":[null]},"ClassMethod":{"enter":[null]}},"options":{}},{"key":"base$0$0$17","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$18","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$19","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"base$0$0$20","visitor":{"ObjectProperty":{"exit":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$21","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$0$22","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$23","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"regenerator-transform","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{}}],"presets":[],"compact":false,"ast":true,"babelrc":false,"sourceFileName":"imports/plugins/core/components/lib/components.js","filename":"imports/plugins/core/components/lib/components.js","sourceMaps":true,"envName":"development","cwd":"/Users/estebandev/test-knowledge","passPerPreset":false,"parserOpts":{"sourceType":"module","sourceFileName":"imports/plugins/core/components/lib/components.js","plugins":["dynamicImport","classProperties","jsx","jsx","flow","asyncGenerators","objectRestSpread","objectRestSpread","flow","asyncGenerators"]},"generatorOpts":{"filename":"imports/plugins/core/components/lib/components.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"imports/plugins/core/components/lib/components.js"}},"code":"function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nmodule.export({\n  Components: function () {\n    return Components;\n  },\n  ComponentsTable: function () {\n    return ComponentsTable;\n  },\n  registerComponent: function () {\n    return registerComponent;\n  },\n  registerHOC: function () {\n    return registerHOC;\n  },\n  getComponent: function () {\n    return getComponent;\n  },\n  replaceComponent: function () {\n    return replaceComponent;\n  },\n  getRawComponent: function () {\n    return getRawComponent;\n  },\n  getHOCs: function () {\n    return getHOCs;\n  },\n  copyHOCs: function () {\n    return copyHOCs;\n  },\n  loadRegisteredComponents: function () {\n    return loadRegisteredComponents;\n  }\n});\n\nvar _setDisplayName;\n\nmodule.watch(require(\"recompose/setDisplayName\"), {\n  \"default\": function (v) {\n    _setDisplayName = v;\n  }\n}, 0);\n\nvar _compose;\n\nmodule.watch(require(\"recompose/compose\"), {\n  \"default\": function (v) {\n    _compose = v;\n  }\n}, 1);\nvar Components = {};\nvar ComponentsTable = {};\n\nfunction registerComponent(name, rawComponent) {\n  var hocs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n  if (!name || !rawComponent) {\n    throw new Error(\"A name and component are required for registerComponent\");\n  } // store the component in the table\n\n\n  ComponentsTable[name] = {\n    name: name,\n    rawComponent: rawComponent,\n    hocs: Array.isArray(hocs) ? hocs : [hocs]\n  };\n}\n\nfunction registerHOC(name) {\n  var hocs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n  if (!name || !hocs) {\n    throw new Error(\"A name and HOC(s) are required for registerHOC\");\n  }\n\n  var newHOCs = Array.isArray(hocs) ? hocs : [hocs];\n  var existingComponent = ComponentsTable[name]; // Check to see if this component has already been registered and whether it has\n  // HOC's to merge with our new ones. If not, just register it like a new component.\n  // This allows us to register HOCs _before_ registering the UI component.\n  // Just keep in mind that the resulting component will definitely throw an error\n  // if a UI component doesn't eventually get registered.\n\n  if (!!existingComponent && !!existingComponent.hocs) {\n    var existingHOCs = existingComponent.hocs;\n    ComponentsTable[name] = {\n      name: name,\n      hocs: _toConsumableArray(newHOCs).concat(_toConsumableArray(existingHOCs))\n    };\n  } else {\n    ComponentsTable[name] = {\n      name: name,\n      hocs: newHOCs\n    };\n  }\n}\n\nfunction getComponent(name) {\n  var component = ComponentsTable[name];\n\n  if (!component) {\n    throw new Error(\"Component \" + name + \" not registered.\");\n  }\n\n  var hocs = component.hocs.map(function (hoc) {\n    return Array.isArray(hoc) ? hoc[0](hoc[1]) : hoc;\n  });\n  return _compose.apply(void 0, _toConsumableArray(hocs).concat([_setDisplayName(\"Reaction(\" + name + \")\")]))(component.rawComponent);\n}\n\nfunction replaceComponent(name, newComponent) {\n  var hocs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var previousComponent = ComponentsTable[name];\n\n  if (!previousComponent) {\n    throw new Error(\"Component '\" + name + \"' not found. Use registerComponent to create it.\");\n  }\n\n  var newHocs = Array.isArray(hocs) ? hocs : [hocs];\n  return registerComponent(name, newComponent, _toConsumableArray(newHocs).concat(_toConsumableArray(previousComponent.hocs)));\n}\n\nvar getRawComponent = function (name) {\n  return ComponentsTable[name].rawComponent;\n};\n\nvar getHOCs = function (name) {\n  return ComponentsTable[name].hocs;\n};\n\nfunction copyHOCs(sourceComponentName, targetComponent) {\n  var sourceComponent = ComponentsTable[sourceComponentName];\n  return _compose.apply(void 0, _toConsumableArray(sourceComponent.hocs))(targetComponent);\n}\n\nfunction loadRegisteredComponents() {\n  Object.keys(ComponentsTable).forEach(function (name) {\n    Components[name] = getComponent(name);\n  });\n  return Components;\n}","map":{"version":3,"sources":["imports/plugins/core/components/lib/components.js"],"names":["module","export","Components","ComponentsTable","registerComponent","registerHOC","getComponent","replaceComponent","getRawComponent","getHOCs","copyHOCs","loadRegisteredComponents","_setDisplayName","watch","require","v","_compose","name","rawComponent","hocs","Error","Array","isArray","newHOCs","existingComponent","existingHOCs","component","map","hoc","newComponent","previousComponent","newHocs","sourceComponentName","targetComponent","sourceComponent","Object","keys","forEach"],"mappings":"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","sourcesContent":["import { compose, setDisplayName } from \"recompose\";\n\nexport const Components = {}; // populated with final wrapped components\nexport const ComponentsTable = {}; // storage for separate elements of each component\n\n/**\n * @example // Register a component and container(s) with a name.\n * // The raw component can then be extended or replaced.\n *\n * // Structure of a component in the list:\n *\n * ComponentsTable.MyComponent = {\n *    name: 'MyComponent',\n *    hocs: [fn1, fn2],\n *    rawComponent: React.Component\n * }\n * @name registerComponent\n * @method\n * @memberof Components\n * @param {String} name The name of the component to register.\n * @param {React.Component} rawComponent Interchangeable/extendable component.\n * @param {Function|Array} hocs The HOCs to wrap around the raw component.\n *\n * @returns {React.Component} returns the final wrapped component\n */\nexport function registerComponent(name, rawComponent, hocs = []) {\n  if (!name || !rawComponent) {\n    throw new Error(\"A name and component are required for registerComponent\");\n  }\n\n  // store the component in the table\n  ComponentsTable[name] = {\n    name,\n    rawComponent,\n    hocs: Array.isArray(hocs) ? hocs : [hocs]\n  };\n}\n\n\n/**\n * @name registerHOC\n * @method\n * @summary Register containers (HOC) with a name.\n * If some containers already exist for the component, they will be extended.\n * @param {String} name The name of the component to register.\n * @param {Function|Array} hocs The HOCs to wrap around the raw component.\n * @memberof Components\n * @returns {undefined}\n */\nexport function registerHOC(name, hocs = []) {\n  if (!name || !hocs) {\n    throw new Error(\"A name and HOC(s) are required for registerHOC\");\n  }\n\n  const newHOCs = Array.isArray(hocs) ? hocs : [hocs];\n\n  const existingComponent = ComponentsTable[name];\n\n  // Check to see if this component has already been registered and whether it has\n  // HOC's to merge with our new ones. If not, just register it like a new component.\n  // This allows us to register HOCs _before_ registering the UI component.\n  // Just keep in mind that the resulting component will definitely throw an error\n  // if a UI component doesn't eventually get registered.\n  if (!!existingComponent && !!existingComponent.hocs) {\n    const existingHOCs = existingComponent.hocs;\n\n    ComponentsTable[name] = {\n      name,\n      hocs: [...newHOCs, ...existingHOCs]\n    };\n  } else {\n    ComponentsTable[name] = {\n      name,\n      hocs: newHOCs\n    };\n  }\n}\n\n\n/**\n * @name getComponent\n * @method\n * @summary Get a component registered with registerComponent(name, component, ...hocs).\n * @param {String} name The name of the component to get.\n * @return {Function|React.Component} A (wrapped) React component\n * @memberof Components\n */\nexport function getComponent(name) {\n  const component = ComponentsTable[name];\n\n  if (!component) {\n    throw new Error(`Component ${name} not registered.`);\n  }\n\n  const hocs = component.hocs.map((hoc) => (Array.isArray(hoc) ? hoc[0](hoc[1]) : hoc));\n\n  return compose(...hocs, setDisplayName(`Reaction(${name})`))(component.rawComponent);\n}\n\n\n/**\n * @name replaceComponent\n * @method\n * @summary Replace a Reaction component with a new component and optionally add one or more higher order components.\n * This function keeps track of the previous HOCs and wraps the new HOCs around previous ones\n * @param {String} name The name of the component to register.\n * @param {React.Component} newComponent Interchangeable/extendable component.\n * @param {Function|Array} hocs The HOCs to compose with the raw component.\n * @returns {Function|React.Component} A component callable with Components[name]\n * @memberof Components\n */\nexport function replaceComponent(name, newComponent, hocs = []) {\n  const previousComponent = ComponentsTable[name];\n\n  if (!previousComponent) {\n    throw new Error(`Component '${name}' not found. Use registerComponent to create it.`);\n  }\n\n  const newHocs = Array.isArray(hocs) ? hocs : [hocs];\n\n  return registerComponent(name, newComponent, [...newHocs, ...previousComponent.hocs]);\n}\n\n\n/**\n * @name getRawComponent\n * @method\n * @summary Get the raw UI component without any possible HOCs wrapping it.\n * @param {String} name The name of the component to get.\n * @returns {Function|React.Component} A React component\n * @memberof Components\n */\nexport const getRawComponent = (name) => ComponentsTable[name].rawComponent;\n\n\n/**\n * @name getHOCs\n * @method\n * @summary Get the raw UI component without any possible HOCs wrapping it.\n * @param {String} name The name of the component to get.\n * @returns {Function|React.Component} Array of HOCs\n * @memberof Components\n */\nexport const getHOCs = (name) => ComponentsTable[name].hocs;\n\n\n/**\n * @name copyHOCs\n * @method\n * @summary Wrap a new component with the HOCs from a different component\n * @param {String} sourceComponentName The name of the component to get the HOCs from\n * @param {Function|React.Component} targetComponent Component to wrap\n * @returns {Function|React.Component} A new component wrapped with the HOCs of the source component\n * @memberof Components\n */\nexport function copyHOCs(sourceComponentName, targetComponent) {\n  const sourceComponent = ComponentsTable[sourceComponentName];\n  return compose(...sourceComponent.hocs)(targetComponent);\n}\n\n\n/**\n * @name loadRegisteredComponents\n * @method\n * @summary Populate the final Components object with the contents of the lookup table.\n * This should only be called once on app startup.\n * @returns {Object} An object containing all of the registered components\n * @memberof Components\n **/\nexport function loadRegisteredComponents() {\n  Object.keys(ComponentsTable).forEach((name) => {\n    Components[name] = getComponent(name);\n  });\n\n  return Components;\n}\n"]},"sourceType":"script","hash":"3a5d9a1d2cdeb3c5d77cccc2ae729ca489f522a2"}
