{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$1$2","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"ast":true,"babelrc":false,"sourceFileName":"imports/plugins/core/revisions/server/functions.js","filename":"imports/plugins/core/revisions/server/functions.js","sourceMaps":true,"envName":"development","cwd":"/Users/estebandev/test-knowledge","passPerPreset":false,"presets":[],"parserOpts":{"sourceType":"module","sourceFileName":"imports/plugins/core/revisions/server/functions.js","plugins":["jsx","jsx","flow","flow","objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties"]},"generatorOpts":{"filename":"imports/plugins/core/revisions/server/functions.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"imports/plugins/core/revisions/server/functions.js"}},"code":"var _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/builtin/objectSpread\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nmodule.export({\n  insertRevision: () => insertRevision,\n  updateRevision: () => updateRevision,\n  markRevisionAsDeleted: () => markRevisionAsDeleted\n});\n\nlet _isEmpty;\n\nmodule.watch(require(\"lodash/isEmpty\"), {\n  default(v) {\n    _isEmpty = v;\n  }\n\n}, 0);\nlet Meteor;\nmodule.watch(require(\"meteor/meteor\"), {\n  Meteor(v) {\n    Meteor = v;\n  }\n\n}, 1);\nlet Products, Revisions, Tags;\nmodule.watch(require(\"../../../../../lib/collections\"), {\n  Products(v) {\n    Products = v;\n  },\n\n  Revisions(v) {\n    Revisions = v;\n  },\n\n  Tags(v) {\n    Tags = v;\n  }\n\n}, 2);\nlet Hooks, Logger;\nmodule.watch(require(\"../../../../../server/api\"), {\n  Hooks(v) {\n    Hooks = v;\n  },\n\n  Logger(v) {\n    Logger = v;\n  }\n\n}, 3);\nlet RevisionApi;\nmodule.watch(require(\"../lib/api\"), {\n  RevisionApi(v) {\n    RevisionApi = v;\n  }\n\n}, 4);\nlet ProductRevision;\nmodule.watch(require(\"./hooks\"), {\n  ProductRevision(v) {\n    ProductRevision = v;\n  }\n\n}, 5);\nlet getSlug;\nmodule.watch(require(\"../../../../../lib/api\"), {\n  getSlug(v) {\n    getSlug = v;\n  }\n\n}, 6);\n\nfunction insertRevision(product) {\n  if (RevisionApi.isRevisionControlEnabled() === false) {\n    return true;\n  }\n\n  if (product.workflow && Array.isArray(product.workflow.workflow) && product.workflow.workflow.indexOf(\"imported\") !== -1) {\n    // Mark imported products as published by default.\n    return true;\n  }\n\n  const productRevision = Revisions.findOne({\n    \"documentId\": product._id,\n    \"workflow.status\": {\n      $nin: [\"revision/published\"]\n    }\n  }); // Prevent this product from being created if a parent product / variant ancestor is deleted.\n  //\n  // This will prevent cases where a parent variant has been deleted and a user tries to create a\n  // child variant. You cannot create the child variant because the parent will no longer exist when\n  // changes have been published; resulting in a broken inheritance and UI\n\n  const productHasAncestors = Array.isArray(product.ancestors);\n\n  if (productHasAncestors) {\n    // Verify there are no deleted ancestors,\n    // Variants cannot be restored if their parent product / variant is deleted\n    const archivedCount = Revisions.find({\n      \"documentId\": {\n        $in: product.ancestors\n      },\n      \"documentData.isDeleted\": true,\n      \"workflow.status\": {\n        $nin: [\"revision/published\"]\n      }\n    }).count();\n\n    if (archivedCount > 0) {\n      Logger.debug(`Cannot create product ${product._id} as a product/variant higher in it's ancestors tree is marked as 'isDeleted'.`);\n      throw new Meteor.Error(\"unable-to-create-variant\", \"Unable to create product variant\");\n    }\n  }\n\n  if (!productRevision) {\n    Logger.debug(`No revision found for product ${product._id}. Creating new revision`);\n    Revisions.insert({\n      documentId: product._id,\n      documentData: product\n    });\n  }\n}\n\nfunction updateRevision(product, options = {}) {\n  if (RevisionApi.isRevisionControlEnabled() === false) {\n    return true;\n  }\n\n  const {\n    userId,\n    modifier\n  } = options;\n  let productRevision = Revisions.findOne({\n    \"documentId\": product._id,\n    \"workflow.status\": {\n      $nin: [\"revision/published\"]\n    }\n  }); // Prevent this product revision from being restored from isDeleted state if a product / variant\n  // ancestor is also deleted.\n  //\n  // This will prevent cases where a parent variant has been deleted and a user tries to restore a\n  // child variant. You cannot restore the child variant, because the parent will no longer exist when\n  // changes have been published; resulting in a broken inheritance and UI\n\n  const revisionHasAncestors = productRevision && productRevision.documentData && Array.isArray(productRevision.documentData.ancestors);\n  const modifierContainsIsDeleted = modifier.$set && modifier.$set.isDeleted === false;\n\n  if (revisionHasAncestors && modifierContainsIsDeleted) {\n    // Verify there are no deleted ancestors,\n    // Variants cannot be restored if their parent product / variant is deleted\n    const archivedCount = Revisions.find({\n      \"documentId\": {\n        $in: productRevision.documentData.ancestors\n      },\n      \"documentData.isDeleted\": true,\n      \"workflow.status\": {\n        $nin: [\"revision/published\"]\n      }\n    }).count();\n\n    if (archivedCount > 0) {\n      Logger.debug(`Cannot restore product ${product._id} as a product/variant higher in it's ancestors tree is marked as 'isDeleted'.`);\n      throw new Meteor.Error(\"unable-to-delete-variant\", \"Unable to delete product variant\");\n    }\n  }\n\n  if (!productRevision) {\n    Logger.debug(`No revision found for product ${product._id}. Creating new revision`); // Create a new revision\n\n    Revisions.insert({\n      documentId: product._id,\n      documentData: product\n    }); // Fetch newly created revision\n\n    productRevision = Revisions.findOne({\n      documentId: product._id\n    });\n  } // Create a new selector for the revision\n  //\n  // This is especially important since we may need to update some fields\n  // like metadata, and the selector is very important to that.\n\n\n  const revisionSelector = {\n    \"documentId\": product._id,\n    \"workflow.status\": {\n      $nin: [\"revision/published\"]\n    }\n  }; // Create a new modifier for the revision\n\n  const revisionModifier = {\n    $set: {\n      \"workflow.status\": \"revision/update\"\n    }\n  };\n  let publish = false;\n\n  if (Object.prototype.hasOwnProperty.call(options, \"publish\")) {\n    ({\n      publish\n    } = options);\n  }\n\n  if (publish === true || product.workflow && product.workflow.status === \"product/publish\") {\n    // Maybe mark the revision as published\n    Logger.debug(`Publishing revision for product ${product._id}.`);\n    Revisions.update(revisionSelector, {\n      $set: {\n        \"workflow.status\": \"revision/published\"\n      }\n    });\n    Hooks.Events.run(\"afterRevisionsUpdate\", userId, (0, _objectSpread2.default)({}, productRevision, {\n      workflow: (0, _objectSpread2.default)({}, productRevision.workflow, {\n        status: \"revisions/published\"\n      })\n    }));\n    return true;\n  }\n\n  const hasAncestors = Array.isArray(product.ancestors) && product.ancestors.length > 0;\n\n  for (const operation in modifier) {\n    if (Object.hasOwnProperty.call(modifier, operation)) {\n      if (!revisionModifier[operation]) {\n        revisionModifier[operation] = {};\n      }\n\n      for (const property in modifier[operation]) {\n        if ({}.hasOwnProperty.call(modifier[operation], property)) {\n          if (operation === \"$set\" && property === \"metafields.$\") {\n            // Special handling for meta fields with $ operator\n            // We need to update the selector otherwise the operation would completely fail.\n            //\n            // This does NOT apply to metafield.0, metafield.1, metafield.n operations\n            // where 0, 1, n represent an array index.\n            // const originalSelector = options.selector;\n            revisionSelector[\"documentData.metafields\"] = options.metafields;\n            revisionModifier.$set[`documentData.${property}`] = modifier.$set[property];\n          } else if (operation === \"$push\" && property === \"hashtags\") {\n            if (!revisionModifier.$addToSet) {\n              revisionModifier.$addToSet = {};\n            }\n\n            revisionModifier.$addToSet[`documentData.${property}`] = modifier.$push[property];\n          } else if (operation === \"$set\" && property === \"price\" && hasAncestors) {\n            Revisions.update(revisionSelector, {\n              $set: {\n                \"documentData.price\": modifier.$set.price\n              }\n            });\n            Hooks.Events.run(\"afterRevisionsUpdate\", userId, (0, _objectSpread2.default)({}, productRevision, {\n              documentData: (0, _objectSpread2.default)({}, productRevision.documentData, {\n                price: modifier.$set.price\n              })\n            }));\n            const updateId = product.ancestors[0] || product._id;\n            const priceRange = ProductRevision.getProductPriceRange(updateId);\n            Meteor.call(\"products/updateProductField\", updateId, \"price\", priceRange);\n          } else if (operation === \"$set\" && property === \"isVisible\" && hasAncestors) {\n            Revisions.update(revisionSelector, {\n              $set: {\n                \"documentData.isVisible\": modifier.$set.isVisible\n              }\n            });\n            Hooks.Events.run(\"afterRevisionsUpdate\", userId, (0, _objectSpread2.default)({}, productRevision, {\n              documentData: (0, _objectSpread2.default)({}, productRevision.documentData, {\n                isVisible: modifier.$set.isVisible\n              })\n            }));\n            const updateId = product.ancestors[0] || product._id;\n            const priceRange = ProductRevision.getProductPriceRange(updateId);\n            Meteor.call(\"products/updateProductField\", updateId, \"price\", priceRange);\n          } else if (operation === \"$set\" && (property === \"title\" || property === \"handle\") && hasAncestors === false) {\n            // Special handling for product title and handle\n            //\n            // Summary:\n            // When a user updates the product title, if the handle matches the product id,\n            // then update the handle to be a slugified version of the title\n            //\n            // This block ensures that the handle is either a custom slug, slug of the title, or\n            // the _id of the product, but is never blank\n            // New data\n            const newValue = modifier.$set[property];\n            const newTitle = modifier.$set.title;\n            const newHandle = modifier.$set.handle; // Current revision data\n\n            const {\n              documentId\n            } = productRevision;\n            const slugDocId = getSlug(documentId);\n            const revisionTitle = productRevision.documentData.title;\n            const revisionHandle = productRevision.documentData.handle; // Checks\n\n            const hasNewHandle = _isEmpty(newHandle) === false;\n            const hasExistingTitle = _isEmpty(revisionTitle) === false;\n            const hasNewTitle = _isEmpty(newTitle) === false;\n            const hasHandle = _isEmpty(revisionHandle) === false;\n            const handleMatchesId = revisionHandle === documentId || revisionHandle === slugDocId || newValue === documentId || newValue === slugDocId; // Continue to set the title / handle as originally requested\n            // Handle will get changed if conditions are met in the below if block\n\n            revisionModifier.$set[`documentData.${property}`] = newValue;\n\n            if ((handleMatchesId || hasHandle === false) && (hasExistingTitle || hasNewTitle) && hasNewHandle === false) {\n              // Set the handle to be the slug of the product.title\n              // when documentId (product._id) matches the handle, then handle is empty, and a title exists\n              revisionModifier.$set[\"documentData.handle\"] = getSlug(newTitle || revisionTitle);\n            } else if (hasHandle === false && hasExistingTitle === false && hasNewHandle === false) {\n              // If the handle & title is empty, the handle becomes the product id\n              revisionModifier.$set[\"documentData.handle\"] = documentId;\n            } else if (hasNewHandle === false && property === \"handle\") {\n              // If the handle is empty, the handle becomes the slugified product title, or document id if title does not exist.\n              // const newTitle = modifier.$set[\"title\"];\n              revisionModifier.$set[\"documentData.handle\"] = hasExistingTitle ? getSlug(newTitle || revisionTitle) : documentId;\n            }\n          } else if (operation === \"$unset\" && property === \"handle\" && hasAncestors === false) {\n            // Special handling for product handle when it is going to be unset\n            //\n            // Summary:\n            // When a user updates the handle to a black string e.g. deletes all text in field in UI and saves,\n            // the handle will be adjusted so it will not be blank\n            const newValue = modifier.$unset[property];\n            const revisionTitle = productRevision.documentData.title;\n            const hasExistingTitle = _isEmpty(revisionTitle) === false; // If the new handle is going to be empty, the handle becomes the slugified product title, or document id if title does not exist.\n\n            if (_isEmpty(newValue)) {\n              revisionModifier.$set[\"documentData.handle\"] = hasExistingTitle ? getSlug(revisionTitle) : productRevision.documentId;\n            }\n          } else {\n            // Let everything else through\n            revisionModifier[operation][`documentData.${property}`] = modifier[operation][property];\n          }\n        }\n      }\n    }\n  }\n\n  Revisions.update(revisionSelector, revisionModifier);\n  const updatedRevision = Revisions.findOne({\n    documentId: product._id\n  });\n  Hooks.Events.run(\"afterRevisionsUpdate\", userId, updatedRevision);\n  Logger.debug(`Revision updated for product ${product._id}.`);\n\n  if (modifier.$pull && modifier.$pull.hashtags) {\n    const tagId = modifier.$pull.hashtags;\n    const productCount = Products.find({\n      hashtags: tagId\n    }).count();\n    const relatedTagsCount = Tags.find({\n      relatedTagIds: tagId\n    }).count();\n\n    if (productCount === 0 && relatedTagsCount === 0) {\n      // Mark tag as deleted\n      Tags.update({\n        _id: tagId\n      }, {\n        $set: {\n          isDeleted: true\n        }\n      });\n    } else {\n      Tags.update({\n        _id: tagId\n      }, {\n        $set: {\n          isDeleted: false\n        }\n      });\n    }\n  } // If we are using $set or $inc, and the fields are one of the ignoredFields,\n  // allow product to be updated without going through revision control\n\n\n  if ((modifier.$set || modifier.$inc) && !modifier.$pull && !modifier.$push) {\n    const newSet = {};\n    const newInc = {};\n    let hasIgnoredFields = false;\n    const ignoredFields = [\"isLowQuantity\", \"isSoldOut\", \"inventoryQuantity\"];\n\n    for (const field of ignoredFields) {\n      if (modifier.$set && (typeof modifier.$set[field] === \"number\" || typeof modifier.$set[field] === \"boolean\" || typeof modifier.$set[field] === \"string\")) {\n        newSet[field] = modifier.$set[field];\n        hasIgnoredFields = true;\n      }\n\n      if (modifier.$inc && (typeof modifier.$inc[field] === \"number\" || typeof modifier.$inc[field] === \"boolean\" || typeof modifier.$set[field] === \"string\")) {\n        newInc[field] = modifier.$inc[field];\n        hasIgnoredFields = true;\n      }\n    }\n\n    if (_isEmpty(newSet) === false) {\n      modifier.$set = newSet;\n    }\n\n    if (_isEmpty(newInc) === false) {\n      modifier.$inc = newInc;\n    }\n\n    return hasIgnoredFields === true;\n  } // prevent the underlying document from being modified as it is in draft mode\n\n\n  return false;\n}\n\nfunction markRevisionAsDeleted(product, options) {\n  if (RevisionApi.isRevisionControlEnabled() === false) {\n    return true;\n  }\n\n  const {\n    userId\n  } = options;\n  let productRevision = Revisions.findOne({\n    documentId: product._id\n  });\n\n  if (!productRevision) {\n    Logger.debug(`No revision found for product ${product._id}. Creating new revision`);\n    Revisions.insert({\n      documentId: product._id,\n      documentData: product\n    });\n    productRevision = Revisions.findOne({\n      documentId: product._id\n    });\n  } // Set the revision as deleted \"isDeleted: true\"\n\n\n  Revisions.update({\n    documentId: product._id\n  }, {\n    $set: {\n      \"documentData.isDeleted\": true,\n      \"workflow.status\": \"revision/remove\"\n    }\n  });\n  Hooks.Events.run(\"afterRevisionsUpdate\", userId, (0, _objectSpread2.default)({}, productRevision, {\n    documentData: (0, _objectSpread2.default)({}, productRevision.documentData, {\n      isDeleted: true\n    }),\n    workflow: (0, _objectSpread2.default)({}, productRevision.workflow, {\n      workflow: \"revision/remove\"\n    })\n  }));\n  Logger.debug(`Revision updated for product ${product._id}.`);\n  Logger.debug(`Product ${product._id} is now marked as deleted.`); // If the original product is deleted, and the user is trying to delete it again,\n  // then actually remove it completely.\n  //\n  // This acts like a trash. Where the product is sent to trash before it can actually\n  // be deleted permanently.\n\n  if (product.isDeleted === true) {\n    Logger.debug(`Allowing write to product ${product._id} for Collection.remove().`);\n    return true;\n  }\n\n  Logger.debug(`Preventing write to product ${product._id} for Collection.remove().`);\n  return false;\n}","map":{"version":3,"sources":["imports/plugins/core/revisions/server/functions.js"],"names":["module","export","insertRevision","updateRevision","markRevisionAsDeleted","_isEmpty","watch","require","default","v","Meteor","Products","Revisions","Tags","Hooks","Logger","RevisionApi","ProductRevision","getSlug","product","isRevisionControlEnabled","workflow","Array","isArray","indexOf","productRevision","findOne","_id","$nin","productHasAncestors","ancestors","archivedCount","find","$in","count","debug","Error","insert","documentId","documentData","options","userId","modifier","revisionHasAncestors","modifierContainsIsDeleted","$set","isDeleted","revisionSelector","revisionModifier","publish","Object","prototype","hasOwnProperty","call","status","update","Events","run","hasAncestors","length","operation","property","metafields","$addToSet","$push","price","updateId","priceRange","getProductPriceRange","isVisible","newValue","newTitle","title","newHandle","handle","slugDocId","revisionTitle","revisionHandle","hasNewHandle","hasExistingTitle","hasNewTitle","hasHandle","handleMatchesId","$unset","updatedRevision","$pull","hashtags","tagId","productCount","relatedTagsCount","relatedTagIds","$inc","newSet","newInc","hasIgnoredFields","ignoredFields","field"],"mappings":"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","sourcesContent":["\nimport _ from \"lodash\";\nimport { Meteor } from \"meteor/meteor\";\nimport { Products, Revisions, Tags } from \"/lib/collections\";\nimport { Hooks, Logger } from \"/server/api\";\nimport { RevisionApi } from \"../lib/api\";\nimport { ProductRevision } from \"./hooks\";\nimport { getSlug } from \"/lib/api\";\n\n\n/**\n * @method insertRevision\n * @summary Inserts a new revision for a given product\n *\n * @param {Object} product\n * @returns {undefined}\n */\nexport function insertRevision(product) {\n  if (RevisionApi.isRevisionControlEnabled() === false) {\n    return true;\n  }\n\n  if (product.workflow && Array.isArray(product.workflow.workflow) && product.workflow.workflow.indexOf(\"imported\") !== -1) {\n    // Mark imported products as published by default.\n    return true;\n  }\n\n  const productRevision = Revisions.findOne({\n    \"documentId\": product._id,\n    \"workflow.status\": {\n      $nin: [\n        \"revision/published\"\n      ]\n    }\n  });\n\n  // Prevent this product from being created if a parent product / variant ancestor is deleted.\n  //\n  // This will prevent cases where a parent variant has been deleted and a user tries to create a\n  // child variant. You cannot create the child variant because the parent will no longer exist when\n  // changes have been published; resulting in a broken inheritance and UI\n  const productHasAncestors = Array.isArray(product.ancestors);\n\n  if (productHasAncestors) {\n    // Verify there are no deleted ancestors,\n    // Variants cannot be restored if their parent product / variant is deleted\n    const archivedCount = Revisions.find({\n      \"documentId\": { $in: product.ancestors },\n      \"documentData.isDeleted\": true,\n      \"workflow.status\": {\n        $nin: [\n          \"revision/published\"\n        ]\n      }\n    }).count();\n\n    if (archivedCount > 0) {\n      Logger.debug(`Cannot create product ${product._id} as a product/variant higher in it's ancestors tree is marked as 'isDeleted'.`);\n      throw new Meteor.Error(\"unable-to-create-variant\", \"Unable to create product variant\");\n    }\n  }\n\n\n  if (!productRevision) {\n    Logger.debug(`No revision found for product ${product._id}. Creating new revision`);\n\n    Revisions.insert({\n      documentId: product._id,\n      documentData: product\n    });\n  }\n}\n\n/**\n * @method updateRevision\n * @summary Update a product's revision\n *\n * @param {String} userId\n * @param {Object} product - Product to update\n * @param {Object} options - Options include userId, modifier and validation properties\n * @returns {Boolean} true if underlying product should be updated, otherwise false.\n */\nexport function updateRevision(product, options = {}) {\n  if (RevisionApi.isRevisionControlEnabled() === false) {\n    return true;\n  }\n\n  const { userId, modifier } = options;\n\n  let productRevision = Revisions.findOne({\n    \"documentId\": product._id,\n    \"workflow.status\": {\n      $nin: [\"revision/published\"]\n    }\n  });\n\n  // Prevent this product revision from being restored from isDeleted state if a product / variant\n  // ancestor is also deleted.\n  //\n  // This will prevent cases where a parent variant has been deleted and a user tries to restore a\n  // child variant. You cannot restore the child variant, because the parent will no longer exist when\n  // changes have been published; resulting in a broken inheritance and UI\n  const revisionHasAncestors =\n    productRevision && productRevision.documentData && Array.isArray(productRevision.documentData.ancestors);\n  const modifierContainsIsDeleted = modifier.$set && modifier.$set.isDeleted === false;\n\n  if (revisionHasAncestors && modifierContainsIsDeleted) {\n    // Verify there are no deleted ancestors,\n    // Variants cannot be restored if their parent product / variant is deleted\n    const archivedCount = Revisions.find({\n      \"documentId\": { $in: productRevision.documentData.ancestors },\n      \"documentData.isDeleted\": true,\n      \"workflow.status\": {\n        $nin: [\"revision/published\"]\n      }\n    }).count();\n\n    if (archivedCount > 0) {\n      Logger.debug(`Cannot restore product ${\n        product._id\n      } as a product/variant higher in it's ancestors tree is marked as 'isDeleted'.`);\n      throw new Meteor.Error(\"unable-to-delete-variant\", \"Unable to delete product variant\");\n    }\n  }\n\n\n  if (!productRevision) {\n    Logger.debug(`No revision found for product ${product._id}. Creating new revision`);\n\n    // Create a new revision\n    Revisions.insert({\n      documentId: product._id,\n      documentData: product\n    });\n\n    // Fetch newly created revision\n    productRevision = Revisions.findOne({\n      documentId: product._id\n    });\n  }\n\n  // Create a new selector for the revision\n  //\n  // This is especially important since we may need to update some fields\n  // like metadata, and the selector is very important to that.\n  const revisionSelector = {\n    \"documentId\": product._id,\n    \"workflow.status\": {\n      $nin: [\"revision/published\"]\n    }\n  };\n\n  // Create a new modifier for the revision\n  const revisionModifier = {\n    $set: {\n      \"workflow.status\": \"revision/update\"\n    }\n  };\n\n  let publish = false;\n  if (Object.prototype.hasOwnProperty.call(options, \"publish\")) {\n    ({ publish } = options);\n  }\n\n  if (publish === true || (product.workflow && product.workflow.status === \"product/publish\")) {\n    // Maybe mark the revision as published\n\n    Logger.debug(`Publishing revision for product ${product._id}.`);\n    Revisions.update(revisionSelector, {\n      $set: {\n        \"workflow.status\": \"revision/published\"\n      }\n    });\n    Hooks.Events.run(\"afterRevisionsUpdate\", userId, {\n      ...productRevision,\n      workflow: { ...productRevision.workflow, status: \"revisions/published\" }\n    });\n    return true;\n  }\n\n  const hasAncestors = Array.isArray(product.ancestors) && product.ancestors.length > 0;\n\n  for (const operation in modifier) {\n    if (Object.hasOwnProperty.call(modifier, operation)) {\n      if (!revisionModifier[operation]) {\n        revisionModifier[operation] = {};\n      }\n\n      for (const property in modifier[operation]) {\n        if ({}.hasOwnProperty.call(modifier[operation], property)) {\n          if (operation === \"$set\" && property === \"metafields.$\") {\n            // Special handling for meta fields with $ operator\n            // We need to update the selector otherwise the operation would completely fail.\n            //\n            // This does NOT apply to metafield.0, metafield.1, metafield.n operations\n            // where 0, 1, n represent an array index.\n\n            // const originalSelector = options.selector;\n            revisionSelector[\"documentData.metafields\"] = options.metafields;\n            revisionModifier.$set[`documentData.${property}`] = modifier.$set[property];\n          } else if (operation === \"$push\" && property === \"hashtags\") {\n            if (!revisionModifier.$addToSet) {\n              revisionModifier.$addToSet = {};\n            }\n            revisionModifier.$addToSet[`documentData.${property}`] = modifier.$push[property];\n          } else if (operation === \"$set\" && property === \"price\" && hasAncestors) {\n            Revisions.update(revisionSelector, {\n              $set: {\n                \"documentData.price\": modifier.$set.price\n              }\n            });\n            Hooks.Events.run(\"afterRevisionsUpdate\", userId, {\n              ...productRevision,\n              documentData: { ...productRevision.documentData, price: modifier.$set.price }\n            });\n\n            const updateId = product.ancestors[0] || product._id;\n            const priceRange = ProductRevision.getProductPriceRange(updateId);\n\n            Meteor.call(\"products/updateProductField\", updateId, \"price\", priceRange);\n          } else if (operation === \"$set\" && property === \"isVisible\" && hasAncestors) {\n            Revisions.update(revisionSelector, {\n              $set: {\n                \"documentData.isVisible\": modifier.$set.isVisible\n              }\n            });\n            Hooks.Events.run(\"afterRevisionsUpdate\", userId, {\n              ...productRevision,\n              documentData: { ...productRevision.documentData, isVisible: modifier.$set.isVisible }\n            });\n\n            const updateId = product.ancestors[0] || product._id;\n            const priceRange = ProductRevision.getProductPriceRange(updateId);\n\n            Meteor.call(\"products/updateProductField\", updateId, \"price\", priceRange);\n          } else if (\n            operation === \"$set\" &&\n            (property === \"title\" || property === \"handle\") &&\n            hasAncestors === false\n          ) {\n            // Special handling for product title and handle\n            //\n            // Summary:\n            // When a user updates the product title, if the handle matches the product id,\n            // then update the handle to be a slugified version of the title\n            //\n            // This block ensures that the handle is either a custom slug, slug of the title, or\n            // the _id of the product, but is never blank\n\n            // New data\n            const newValue = modifier.$set[property];\n            const newTitle = modifier.$set.title;\n            const newHandle = modifier.$set.handle;\n\n            // Current revision data\n            const { documentId } = productRevision;\n            const slugDocId = getSlug(documentId);\n            const revisionTitle = productRevision.documentData.title;\n            const revisionHandle = productRevision.documentData.handle;\n\n            // Checks\n            const hasNewHandle = _.isEmpty(newHandle) === false;\n            const hasExistingTitle = _.isEmpty(revisionTitle) === false;\n            const hasNewTitle = _.isEmpty(newTitle) === false;\n            const hasHandle = _.isEmpty(revisionHandle) === false;\n            const handleMatchesId =\n              revisionHandle === documentId ||\n              revisionHandle === slugDocId ||\n              newValue === documentId ||\n              newValue === slugDocId;\n\n            // Continue to set the title / handle as originally requested\n            // Handle will get changed if conditions are met in the below if block\n            revisionModifier.$set[`documentData.${property}`] = newValue;\n\n            if (\n              (handleMatchesId || hasHandle === false) &&\n              (hasExistingTitle || hasNewTitle) &&\n              hasNewHandle === false\n            ) {\n              // Set the handle to be the slug of the product.title\n              // when documentId (product._id) matches the handle, then handle is empty, and a title exists\n              revisionModifier.$set[\"documentData.handle\"] = getSlug(newTitle || revisionTitle);\n            } else if (hasHandle === false && hasExistingTitle === false && hasNewHandle === false) {\n              // If the handle & title is empty, the handle becomes the product id\n              revisionModifier.$set[\"documentData.handle\"] = documentId;\n            } else if (hasNewHandle === false && property === \"handle\") {\n              // If the handle is empty, the handle becomes the slugified product title, or document id if title does not exist.\n              // const newTitle = modifier.$set[\"title\"];\n              revisionModifier.$set[\"documentData.handle\"] = hasExistingTitle\n                ? getSlug(newTitle || revisionTitle)\n                : documentId;\n            }\n          } else if (operation === \"$unset\" && property === \"handle\" && hasAncestors === false) {\n            // Special handling for product handle when it is going to be unset\n            //\n            // Summary:\n            // When a user updates the handle to a black string e.g. deletes all text in field in UI and saves,\n            // the handle will be adjusted so it will not be blank\n            const newValue = modifier.$unset[property];\n            const revisionTitle = productRevision.documentData.title;\n            const hasExistingTitle = _.isEmpty(revisionTitle) === false;\n\n            // If the new handle is going to be empty, the handle becomes the slugified product title, or document id if title does not exist.\n            if (_.isEmpty(newValue)) {\n              revisionModifier.$set[\"documentData.handle\"] = hasExistingTitle\n                ? getSlug(revisionTitle)\n                : productRevision.documentId;\n            }\n          } else {\n            // Let everything else through\n            revisionModifier[operation][`documentData.${property}`] = modifier[operation][property];\n          }\n        }\n      }\n    }\n  }\n\n  Revisions.update(revisionSelector, revisionModifier);\n  const updatedRevision = Revisions.findOne({ documentId: product._id });\n  Hooks.Events.run(\"afterRevisionsUpdate\", userId, updatedRevision);\n\n  Logger.debug(`Revision updated for product ${product._id}.`);\n\n  if (modifier.$pull && modifier.$pull.hashtags) {\n    const tagId = modifier.$pull.hashtags;\n\n    const productCount = Products.find({\n      hashtags: tagId\n    }).count();\n\n    const relatedTagsCount = Tags.find({\n      relatedTagIds: tagId\n    }).count();\n\n    if (productCount === 0 && relatedTagsCount === 0) {\n      // Mark tag as deleted\n      Tags.update(\n        {\n          _id: tagId\n        },\n        {\n          $set: {\n            isDeleted: true\n          }\n        }\n      );\n    } else {\n      Tags.update(\n        {\n          _id: tagId\n        },\n        {\n          $set: {\n            isDeleted: false\n          }\n        }\n      );\n    }\n  }\n\n  // If we are using $set or $inc, and the fields are one of the ignoredFields,\n  // allow product to be updated without going through revision control\n  if ((modifier.$set || modifier.$inc) && !modifier.$pull && !modifier.$push) {\n    const newSet = {};\n    const newInc = {};\n    let hasIgnoredFields = false;\n    const ignoredFields = [\"isLowQuantity\", \"isSoldOut\", \"inventoryQuantity\"];\n\n    for (const field of ignoredFields) {\n      if (modifier.$set && (\n        typeof modifier.$set[field] === \"number\" ||\n        typeof modifier.$set[field] === \"boolean\" ||\n        typeof modifier.$set[field] === \"string\"\n      )) {\n        newSet[field] = modifier.$set[field];\n        hasIgnoredFields = true;\n      }\n\n      if (modifier.$inc && (\n        typeof modifier.$inc[field] === \"number\" ||\n        typeof modifier.$inc[field] === \"boolean\" ||\n        typeof modifier.$set[field] === \"string\"\n      )) {\n        newInc[field] = modifier.$inc[field];\n        hasIgnoredFields = true;\n      }\n    }\n    if (_.isEmpty(newSet) === false) {\n      modifier.$set = newSet;\n    }\n\n    if (_.isEmpty(newInc) === false) {\n      modifier.$inc = newInc;\n    }\n\n    return hasIgnoredFields === true;\n  }\n\n  // prevent the underlying document from being modified as it is in draft mode\n  return false;\n}\n/**\n * @method markRevisionAsDeleted\n * @summary Flag a product's revision as deleted\n *\n * @param {Object} product - The product whose revision will be flagged as deleted.\n * @param {Object} options - Contains userId\n * @returns {undefined}\n */\nexport function markRevisionAsDeleted(product, options) {\n  if (RevisionApi.isRevisionControlEnabled() === false) {\n    return true;\n  }\n\n  const { userId } = options;\n\n  let productRevision = Revisions.findOne({\n    documentId: product._id\n  });\n\n  if (!productRevision) {\n    Logger.debug(`No revision found for product ${product._id}. Creating new revision`);\n\n    Revisions.insert({\n      documentId: product._id,\n      documentData: product\n    });\n    productRevision = Revisions.findOne({\n      documentId: product._id\n    });\n  }\n\n  // Set the revision as deleted \"isDeleted: true\"\n  Revisions.update({\n    documentId: product._id\n  }, {\n    $set: {\n      \"documentData.isDeleted\": true,\n      \"workflow.status\": \"revision/remove\"\n    }\n  });\n  Hooks.Events.run(\"afterRevisionsUpdate\", userId, {\n    ...productRevision,\n    documentData: { ...productRevision.documentData, isDeleted: true },\n    workflow: { ...productRevision.workflow, workflow: \"revision/remove\" }\n  });\n\n  Logger.debug(`Revision updated for product ${product._id}.`);\n  Logger.debug(`Product ${product._id} is now marked as deleted.`);\n\n  // If the original product is deleted, and the user is trying to delete it again,\n  // then actually remove it completely.\n  //\n  // This acts like a trash. Where the product is sent to trash before it can actually\n  // be deleted permanently.\n  if (product.isDeleted === true) {\n    Logger.debug(`Allowing write to product ${product._id} for Collection.remove().`);\n\n    return true;\n  }\n\n  Logger.debug(`Preventing write to product ${product._id} for Collection.remove().`);\n  return false;\n}\n"]},"sourceType":"script","hash":"bcbd03a184042104d2c397c8b207f64aacc9174a"}
