{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$1$2","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"ast":true,"babelrc":false,"sourceFileName":"imports/plugins/core/versions/server/migrations/5_update_defaultRoles_to_groups.js","filename":"imports/plugins/core/versions/server/migrations/5_update_defaultRoles_to_groups.js","sourceMaps":true,"envName":"development","cwd":"/Users/estebandev/test-knowledge","passPerPreset":false,"presets":[],"parserOpts":{"sourceType":"module","sourceFileName":"imports/plugins/core/versions/server/migrations/5_update_defaultRoles_to_groups.js","plugins":["jsx","jsx","flow","flow","objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties"]},"generatorOpts":{"filename":"imports/plugins/core/versions/server/migrations/5_update_defaultRoles_to_groups.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"imports/plugins/core/versions/server/migrations/5_update_defaultRoles_to_groups.js"}},"code":"let _uniq;\n\nmodule.watch(require(\"lodash/uniq\"), {\n  default(v) {\n    _uniq = v;\n  }\n\n}, 0);\nlet Meteor;\nmodule.watch(require(\"meteor/meteor\"), {\n  Meteor(v) {\n    Meteor = v;\n  }\n\n}, 1);\nlet Roles;\nmodule.watch(require(\"meteor/alanning:roles\"), {\n  Roles(v) {\n    Roles = v;\n  }\n\n}, 2);\nlet Migrations;\nmodule.watch(require(\"meteor/percolate:migrations\"), {\n  Migrations(v) {\n    Migrations = v;\n  }\n\n}, 3);\nlet Reaction, Logger;\nmodule.watch(require(\"../../../../../../server/api\"), {\n  Reaction(v) {\n    Reaction = v;\n  },\n\n  Logger(v) {\n    Logger = v;\n  }\n\n}, 4);\nlet Accounts, Groups, Shops;\nmodule.watch(require(\"../../../../../../lib/collections\"), {\n  Accounts(v) {\n    Accounts = v;\n  },\n\n  Groups(v) {\n    Groups = v;\n  },\n\n  Shops(v) {\n    Shops = v;\n  }\n\n}, 5);\n\n/**\n * Migration file created for moving from previous admin permission management to permission groups\n * On up, it creates the default groups for all shops in the app, then update accounts belonging to the\n * default groups. It also creates custom groups for every unique set of permission and assigns accounts\n * with such permissions to the custom group they belong.\n */\nMigrations.add({\n  version: 5,\n\n  up() {\n    const shops = Shops.find({}).fetch(); // needed to ensure restart in case of a migration that failed before finishing\n\n    Groups.remove({});\n    Accounts.update({}, {\n      $set: {\n        groups: []\n      }\n    }, {\n      bypassCollection2: true,\n      multi: true\n    });\n\n    if (shops && shops.length) {\n      shops.forEach(shop => {\n        const defaultGroupAccounts = createDefaultGroupsForShop(shop); // retrieves remaining permission sets that doesn't fit the default sets\n\n        const customPermissions = Meteor.users.find({\n          _id: {\n            $nin: defaultGroupAccounts\n          }\n        }).fetch().map(user => user.roles && user.roles[shop._id]); // sorts the array of permission sets to contain only unique sets to avoid creating groups with same permissions\n\n        const permissionsArray = sortUniqueArray(customPermissions);\n        permissionsArray.forEach((permissions, index) => {\n          if (!permissions) {\n            return null;\n          }\n\n          Logger.debug(`creating custom group for shop ${shop.name}`);\n          const groupId = Groups.insert({\n            name: `custom ${index + 1}`,\n            slug: `custom${index + 1}`,\n            permissions,\n            shopId: shop._id\n          }, {\n            bypassCollection2: true\n          });\n          updateAccountsInGroup({\n            shopId: shop._id,\n            permissions,\n            groupId\n          });\n        });\n      });\n    }\n\n    function createDefaultGroupsForShop(shop) {\n      let defaultGroupAccounts = [];\n      const {\n        defaultRoles,\n        defaultVisitorRole\n      } = shop;\n      let ownerRoles = Roles.getAllRoles().fetch().map(role => role.name); // See detailed comment in `/server/api/core/groups.js`. The code here follows similar pattern.\n\n      ownerRoles = ownerRoles.concat(Reaction.defaultCustomerRoles);\n      ownerRoles = _uniq(ownerRoles);\n      const shopManagerRoles = ownerRoles.filter(role => role !== \"owner\");\n      const roles = {\n        \"shop manager\": shopManagerRoles,\n        \"customer\": defaultRoles || Reaction.defaultCustomerRoles,\n        \"guest\": defaultVisitorRole || Reaction.defaultVisitorRoles,\n        \"owner\": ownerRoles\n      };\n      Object.keys(roles).forEach(groupKeys => {\n        Logger.debug(`creating group ${groupKeys} for shop ${shop.name}`);\n        const groupId = Groups.insert({\n          name: groupKeys,\n          slug: groupKeys,\n          permissions: roles[groupKeys],\n          shopId: shop._id\n        });\n        Logger.debug(`new group \"${groupKeys}\" created with id \"${groupId}\"`);\n        const updatedAccounts = updateAccountsInGroup({\n          shopId: shop._id,\n          permissions: roles[groupKeys],\n          groupId\n        });\n        defaultGroupAccounts = defaultGroupAccounts.concat(updatedAccounts);\n      });\n      return defaultGroupAccounts;\n    } // finds all accounts with a permission set and assigns them to matching group\n\n\n    function updateAccountsInGroup({\n      shopId,\n      permissions = [],\n      groupId\n    }) {\n      const query = {\n        [`roles.${shopId}`]: {\n          $size: permissions.length,\n          $all: permissions\n        }\n      };\n      const matchingUserIds = Meteor.users.find(query).fetch().map(user => user._id);\n\n      if (matchingUserIds.length) {\n        Logger.debug(`updating following matching Accounts to new group: ${matchingUserIds}`);\n      }\n\n      Accounts.update({\n        _id: {\n          $in: matchingUserIds\n        },\n        shopId\n      }, {\n        $addToSet: {\n          groups: groupId\n        }\n      }, {\n        bypassCollection2: true,\n        multi: true\n      });\n      return matchingUserIds;\n    }\n  },\n\n  down() {\n    const shops = Shops.find({}).fetch();\n\n    if (shops && shops.length) {\n      shops.forEach(shop => removeGroupsForShop(shop));\n    }\n\n    function removeGroupsForShop(shop) {\n      const shopGroups = Groups.find({\n        shopId: shop._id\n      }).fetch();\n      const keys = {\n        customer: \"defaultRoles\",\n        guest: \"defaultVisitorRole\"\n      };\n      shopGroups.forEach(group => {\n        const shopkey = keys[group.slug];\n        Shops.update({\n          _id: shop._id\n        }, {\n          $set: {\n            [shopkey]: group.permissions\n          }\n        });\n        Accounts.update({\n          shopId: shop._id\n        }, {\n          $unset: {\n            groups: \"\"\n          }\n        }, {\n          bypassCollection2: true,\n          multi: true\n        });\n      });\n    }\n  }\n\n});\n/*\n * helper func created to limit the permission sets available to unique values without duplicates.\n * It takes a two dimentional array like this:\n * [\n *   [\"tag\", \"product\"],\n *   [\"product\", \"tag\"],\n *   [\"tag\", \"product\", \"shop\"],\n *   [\"tag\", \"shop\"],\n *   [\"shop\", \"tag\"]\n * ]\n * and returns this: [[\"product\", \"tag\"], [\"product\", \"shop\", \"tag\"], [\"shop\", \"tag\"]]\n */\n\nfunction sortUniqueArray(multiArray) {\n  const sorted = multiArray.map(x => {\n    if (!x) {\n      return [];\n    }\n\n    return x.sort();\n  }).sort();\n  const uniqueArray = [];\n  uniqueArray.push(sorted[0]);\n\n  for (let i = 1; i < sorted.length; i += 1) {\n    if (JSON.stringify(sorted[i]) !== JSON.stringify(sorted[i - 1])) {\n      uniqueArray.push(sorted[i]);\n    }\n  }\n\n  return uniqueArray;\n}","map":{"version":3,"sources":["imports/plugins/core/versions/server/migrations/5_update_defaultRoles_to_groups.js"],"names":["_uniq","module","watch","require","default","v","Meteor","Roles","Migrations","Reaction","Logger","Accounts","Groups","Shops","add","version","up","shops","find","fetch","remove","update","$set","groups","bypassCollection2","multi","length","forEach","shop","defaultGroupAccounts","createDefaultGroupsForShop","customPermissions","users","_id","$nin","map","user","roles","permissionsArray","sortUniqueArray","permissions","index","debug","name","groupId","insert","slug","shopId","updateAccountsInGroup","defaultRoles","defaultVisitorRole","ownerRoles","getAllRoles","role","concat","defaultCustomerRoles","shopManagerRoles","filter","defaultVisitorRoles","Object","keys","groupKeys","updatedAccounts","query","$size","$all","matchingUserIds","$in","$addToSet","down","removeGroupsForShop","shopGroups","customer","guest","group","shopkey","$unset","multiArray","sorted","x","sort","uniqueArray","push","i","JSON","stringify"],"mappings":"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","sourcesContent":["import _ from \"lodash\";\nimport { Meteor } from \"meteor/meteor\";\nimport { Roles } from \"meteor/alanning:roles\";\nimport { Migrations } from \"meteor/percolate:migrations\";\nimport { Reaction, Logger } from \"/server/api\";\nimport { Accounts, Groups, Shops } from \"/lib/collections\";\n\n/**\n * Migration file created for moving from previous admin permission management to permission groups\n * On up, it creates the default groups for all shops in the app, then update accounts belonging to the\n * default groups. It also creates custom groups for every unique set of permission and assigns accounts\n * with such permissions to the custom group they belong.\n */\nMigrations.add({\n  version: 5,\n  up() {\n    const shops = Shops.find({}).fetch();\n\n    // needed to ensure restart in case of a migration that failed before finishing\n    Groups.remove({});\n    Accounts.update({}, { $set: { groups: [] } }, { bypassCollection2: true, multi: true });\n\n    if (shops && shops.length) {\n      shops.forEach((shop) => {\n        const defaultGroupAccounts = createDefaultGroupsForShop(shop);\n        // retrieves remaining permission sets that doesn't fit the default sets\n        const customPermissions = Meteor.users\n          .find({ _id: { $nin: defaultGroupAccounts } })\n          .fetch()\n          .map((user) => user.roles && user.roles[shop._id]);\n        // sorts the array of permission sets to contain only unique sets to avoid creating groups with same permissions\n        const permissionsArray = sortUniqueArray(customPermissions);\n        permissionsArray.forEach((permissions, index) => {\n          if (!permissions) { return null; }\n          Logger.debug(`creating custom group for shop ${shop.name}`);\n          const groupId = Groups.insert({\n            name: `custom ${index + 1}`,\n            slug: `custom${index + 1}`,\n            permissions,\n            shopId: shop._id\n          }, { bypassCollection2: true });\n          updateAccountsInGroup({\n            shopId: shop._id,\n            permissions,\n            groupId\n          });\n        });\n      });\n    }\n\n    function createDefaultGroupsForShop(shop) {\n      let defaultGroupAccounts = [];\n      const { defaultRoles, defaultVisitorRole } = shop;\n      let ownerRoles = Roles.getAllRoles().fetch().map((role) => role.name);\n\n      // See detailed comment in `/server/api/core/groups.js`. The code here follows similar pattern.\n      ownerRoles = ownerRoles.concat(Reaction.defaultCustomerRoles);\n      ownerRoles = _.uniq(ownerRoles);\n\n      const shopManagerRoles = ownerRoles.filter((role) => role !== \"owner\");\n      const roles = {\n        \"shop manager\": shopManagerRoles,\n        \"customer\": defaultRoles || Reaction.defaultCustomerRoles,\n        \"guest\": defaultVisitorRole || Reaction.defaultVisitorRoles,\n        \"owner\": ownerRoles\n      };\n\n      Object.keys(roles).forEach((groupKeys) => {\n        Logger.debug(`creating group ${groupKeys} for shop ${shop.name}`);\n        const groupId = Groups.insert({\n          name: groupKeys,\n          slug: groupKeys,\n          permissions: roles[groupKeys],\n          shopId: shop._id\n        });\n        Logger.debug(`new group \"${groupKeys}\" created with id \"${groupId}\"`);\n        const updatedAccounts = updateAccountsInGroup({\n          shopId: shop._id,\n          permissions: roles[groupKeys],\n          groupId\n        });\n        defaultGroupAccounts = defaultGroupAccounts.concat(updatedAccounts);\n      });\n      return defaultGroupAccounts;\n    }\n\n    // finds all accounts with a permission set and assigns them to matching group\n    function updateAccountsInGroup({ shopId, permissions = [], groupId }) {\n      const query = { [`roles.${shopId}`]: { $size: permissions.length, $all: permissions } };\n      const matchingUserIds = Meteor.users.find(query).fetch().map((user) => user._id);\n\n      if (matchingUserIds.length) {\n        Logger.debug(`updating following matching Accounts to new group: ${matchingUserIds}`);\n      }\n      Accounts.update(\n        { _id: { $in: matchingUserIds }, shopId },\n        { $addToSet: { groups: groupId } },\n        { bypassCollection2: true, multi: true }\n      );\n      return matchingUserIds;\n    }\n  },\n  down() {\n    const shops = Shops.find({}).fetch();\n\n    if (shops && shops.length) {\n      shops.forEach((shop) => removeGroupsForShop(shop));\n    }\n    function removeGroupsForShop(shop) {\n      const shopGroups = Groups.find({ shopId: shop._id }).fetch();\n\n      const keys = {\n        customer: \"defaultRoles\",\n        guest: \"defaultVisitorRole\"\n      };\n\n      shopGroups.forEach((group) => {\n        const shopkey = keys[group.slug];\n        Shops.update({ _id: shop._id }, { $set: { [shopkey]: group.permissions } });\n        Accounts.update({ shopId: shop._id }, { $unset: { groups: \"\" } }, { bypassCollection2: true, multi: true });\n      });\n    }\n  }\n});\n\n/*\n * helper func created to limit the permission sets available to unique values without duplicates.\n * It takes a two dimentional array like this:\n * [\n *   [\"tag\", \"product\"],\n *   [\"product\", \"tag\"],\n *   [\"tag\", \"product\", \"shop\"],\n *   [\"tag\", \"shop\"],\n *   [\"shop\", \"tag\"]\n * ]\n * and returns this: [[\"product\", \"tag\"], [\"product\", \"shop\", \"tag\"], [\"shop\", \"tag\"]]\n */\nfunction sortUniqueArray(multiArray) {\n  const sorted = multiArray.map((x) => {\n    if (!x) { return []; }\n    return x.sort();\n  }).sort();\n  const uniqueArray = [];\n  uniqueArray.push(sorted[0]);\n\n  for (let i = 1; i < sorted.length; i += 1) {\n    if (JSON.stringify(sorted[i]) !== JSON.stringify(sorted[i - 1])) {\n      uniqueArray.push(sorted[i]);\n    }\n  }\n  return uniqueArray;\n}\n"]},"sourceType":"script","hash":"f4121beff9a38acbfa5d13c684fd3ebcc78c97da"}
