{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$1$2","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"ast":true,"babelrc":false,"sourceFileName":"imports/plugins/included/inventory/server/methods/inventory.js","filename":"imports/plugins/included/inventory/server/methods/inventory.js","sourceMaps":true,"envName":"development","cwd":"/Users/estebandev/test-knowledge","passPerPreset":false,"presets":[],"parserOpts":{"sourceType":"module","sourceFileName":"imports/plugins/included/inventory/server/methods/inventory.js","plugins":["jsx","jsx","flow","flow","objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties"]},"generatorOpts":{"filename":"imports/plugins/included/inventory/server/methods/inventory.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"imports/plugins/included/inventory/server/methods/inventory.js"}},"code":"module.export({\n  registerInventory: () => registerInventory\n});\nlet Meteor;\nmodule.watch(require(\"meteor/meteor\"), {\n  Meteor(v) {\n    Meteor = v;\n  }\n\n}, 0);\nlet Catalog;\nmodule.watch(require(\"../../../../../../lib/api\"), {\n  Catalog(v) {\n    Catalog = v;\n  }\n\n}, 1);\nlet Inventory, Products;\nmodule.watch(require(\"../../../../../../lib/collections\"), {\n  Inventory(v) {\n    Inventory = v;\n  },\n\n  Products(v) {\n    Products = v;\n  }\n\n}, 2);\nlet Logger, Reaction;\nmodule.watch(require(\"../../../../../../server/api\"), {\n  Logger(v) {\n    Logger = v;\n  },\n\n  Reaction(v) {\n    Reaction = v;\n  }\n\n}, 3);\n\nfunction registerInventory(product) {\n  // Retrieve schemas\n  // TODO: Permit product type registration and iterate through product types and schemas\n  Products.simpleSchema(product).validate(product);\n  const {\n    type\n  } = product;\n  let totalNewInventory = 0;\n  const productId = type === \"variant\" ? product.ancestors[0] : product._id;\n  const variants = Catalog.getVariants(productId); // we'll check each variant to see if it has been fully registered\n\n  for (const variant of variants) {\n    const inventory = Inventory.find({\n      productId,\n      variantId: variant._id,\n      shopId: product.shopId\n    }); // we'll return this as well\n\n    const inventoryVariantCount = inventory.count(); // if the variant exists already we're remove from the inventoryVariants\n    // so that we don't process it as an insert\n\n    if (inventoryVariantCount < variant.inventoryQuantity) {\n      const newQty = variant.inventoryQuantity || 0;\n      let i = inventoryVariantCount + 1;\n      Logger.debug(`inserting ${newQty - inventoryVariantCount} new inventory items for ${variant._id}`);\n\n      const batch = Inventory._collection.rawCollection().initializeUnorderedBulkOp();\n\n      while (i <= newQty) {\n        const id = Inventory._makeNewID();\n\n        batch.insert({\n          _id: id,\n          productId,\n          variantId: variant._id,\n          shopId: product.shopId,\n          createdAt: new Date(),\n          updatedAt: new Date(),\n          workflow: {\n            // we add this line because `batchInsert` doesn't know\n            status: \"new\" // about SimpleSchema, so `defaultValue` will not\n\n          }\n        });\n        i += 1;\n      } // took from: http://guide.meteor.com/collections.html#bulk-data-changes\n\n\n      const execute = Meteor.wrapAsync(batch.execute, batch);\n      const inventoryItem = execute();\n      const inserted = inventoryItem.nInserted;\n\n      if (!inserted) {\n        // or maybe `inventory.length === 0`?\n        // throw new Meteor.Error(\"Inventory Anomaly Detected. Abort! Abort!\");\n        return totalNewInventory;\n      }\n\n      Logger.debug(`registered ${inserted}`);\n      totalNewInventory += inserted;\n    }\n  } // returns the total amount of new inventory created\n\n\n  return totalNewInventory;\n}\n\nfunction adjustInventory(product, userId, context) {\n  // TODO: This can fail even if updateVariant succeeds.\n  Products.simpleSchema(product).validate(product);\n  const {\n    type\n  } = product;\n  let results; // calledByServer is only true if this method was triggered by the server, such as from a webhook.\n  // there will be a null connection and no userId.\n\n  const calledByServer = context && context.connection === null && !Meteor.userId(); // if this method is calledByServer, skip permission check.\n  // user needs createProduct permission to adjust inventory\n  // REVIEW: Should this be checking shop permission instead?\n\n  if (!calledByServer && !Reaction.hasPermission(\"createProduct\", userId, product.shopId)) {\n    throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n  } // Quantity and variants of this product's variant inventory\n\n\n  if (type === \"variant\") {\n    const variant = {\n      _id: product._id,\n      qty: product.inventoryQuantity || 0\n    };\n    const inventory = Inventory.find({\n      productId: product.ancestors[0],\n      variantId: product._id\n    });\n    const itemCount = inventory.count();\n\n    if (itemCount !== variant.qty) {\n      if (itemCount < variant.qty) {\n        // we need to register some new variants to inventory\n        results = itemCount + Meteor.call(\"inventory/register\", product);\n      } else if (itemCount > variant.qty) {\n        // determine how many records to delete\n        const removeQty = itemCount - variant.qty; // we're only going to delete records that are new\n\n        const removeInventory = Inventory.find({\n          \"variantId\": variant._id,\n          \"workflow.status\": \"new\"\n        }, {\n          sort: {\n            updatedAt: -1\n          },\n          limit: removeQty\n        }).fetch();\n        results = itemCount; // delete latest inventory \"status:new\" records\n\n        for (const inventoryItem of removeInventory) {\n          results -= Meteor.call(\"inventory/remove\", inventoryItem); // we could add handling for the case when aren't enough \"new\" items\n        }\n      }\n\n      Logger.debug(`adjust variant ${variant._id} from ${itemCount} to ${results}`);\n    }\n  }\n}\n\nMeteor.methods({\n  \"inventory/register\"(product) {\n    if (!Reaction.hasPermission(\"createProduct\", this.userId, product.shopId)) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    registerInventory(product);\n  },\n\n  \"inventory/adjust\"(product) {\n    // TODO: this should be variant\n    Products.simpleSchema(product).validate(product);\n    adjustInventory(product, this.userId, this);\n  }\n\n});","map":{"version":3,"sources":["imports/plugins/included/inventory/server/methods/inventory.js"],"names":["module","export","registerInventory","Meteor","watch","require","v","Catalog","Inventory","Products","Logger","Reaction","product","simpleSchema","validate","type","totalNewInventory","productId","ancestors","_id","variants","getVariants","variant","inventory","find","variantId","shopId","inventoryVariantCount","count","inventoryQuantity","newQty","i","debug","batch","_collection","rawCollection","initializeUnorderedBulkOp","id","_makeNewID","insert","createdAt","Date","updatedAt","workflow","status","execute","wrapAsync","inventoryItem","inserted","nInserted","adjustInventory","userId","context","results","calledByServer","connection","hasPermission","Error","qty","itemCount","call","removeQty","removeInventory","sort","limit","fetch","methods"],"mappings":"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","sourcesContent":["import { Meteor } from \"meteor/meteor\";\nimport { Catalog } from \"/lib/api\";\nimport { Inventory, Products } from \"/lib/collections\";\nimport { Logger, Reaction } from \"/server/api\";\n\n/**\n * inventory/register\n * @summary check a product and update Inventory collection with inventory documents.\n * @param {Object} product - valid Schemas.Product object\n * @return {Number} - returns the total amount of new inventory created\n */\nexport function registerInventory(product) {\n  // Retrieve schemas\n  // TODO: Permit product type registration and iterate through product types and schemas\n  Products.simpleSchema(product).validate(product);\n  const { type } = product;\n\n  let totalNewInventory = 0;\n  const productId = type === \"variant\" ? product.ancestors[0] : product._id;\n  const variants = Catalog.getVariants(productId);\n\n  // we'll check each variant to see if it has been fully registered\n  for (const variant of variants) {\n    const inventory = Inventory.find({\n      productId,\n      variantId: variant._id,\n      shopId: product.shopId\n    });\n    // we'll return this as well\n    const inventoryVariantCount = inventory.count();\n    // if the variant exists already we're remove from the inventoryVariants\n    // so that we don't process it as an insert\n    if (inventoryVariantCount < variant.inventoryQuantity) {\n      const newQty = variant.inventoryQuantity || 0;\n      let i = inventoryVariantCount + 1;\n\n      Logger.debug(`inserting ${newQty - inventoryVariantCount} new inventory items for ${variant._id}`);\n\n      const batch = Inventory._collection.rawCollection().initializeUnorderedBulkOp();\n      while (i <= newQty) {\n        const id = Inventory._makeNewID();\n        batch.insert({\n          _id: id,\n          productId,\n          variantId: variant._id,\n          shopId: product.shopId,\n          createdAt: new Date(),\n          updatedAt: new Date(),\n          workflow: { // we add this line because `batchInsert` doesn't know\n            status: \"new\" // about SimpleSchema, so `defaultValue` will not\n          }\n        });\n        i += 1;\n      }\n\n      // took from: http://guide.meteor.com/collections.html#bulk-data-changes\n      const execute = Meteor.wrapAsync(batch.execute, batch);\n      const inventoryItem = execute();\n      const inserted = inventoryItem.nInserted;\n\n      if (!inserted) { // or maybe `inventory.length === 0`?\n        // throw new Meteor.Error(\"Inventory Anomaly Detected. Abort! Abort!\");\n        return totalNewInventory;\n      }\n      Logger.debug(`registered ${inserted}`);\n      totalNewInventory += inserted;\n    }\n  }\n  // returns the total amount of new inventory created\n  return totalNewInventory;\n}\n\nfunction adjustInventory(product, userId, context) {\n  // TODO: This can fail even if updateVariant succeeds.\n  Products.simpleSchema(product).validate(product);\n  const { type } = product;\n  let results;\n\n  // calledByServer is only true if this method was triggered by the server, such as from a webhook.\n  // there will be a null connection and no userId.\n  const calledByServer = (context && context.connection === null && !Meteor.userId());\n  // if this method is calledByServer, skip permission check.\n  // user needs createProduct permission to adjust inventory\n  // REVIEW: Should this be checking shop permission instead?\n  if (!calledByServer && !Reaction.hasPermission(\"createProduct\", userId, product.shopId)) {\n    throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n  }\n\n  // Quantity and variants of this product's variant inventory\n  if (type === \"variant\") {\n    const variant = {\n      _id: product._id,\n      qty: product.inventoryQuantity || 0\n    };\n\n    const inventory = Inventory.find({\n      productId: product.ancestors[0],\n      variantId: product._id\n    });\n    const itemCount = inventory.count();\n\n    if (itemCount !== variant.qty) {\n      if (itemCount < variant.qty) {\n        // we need to register some new variants to inventory\n        results = itemCount + Meteor.call(\"inventory/register\", product);\n      } else if (itemCount > variant.qty) {\n        // determine how many records to delete\n        const removeQty = itemCount - variant.qty;\n        // we're only going to delete records that are new\n        const removeInventory = Inventory.find({\n          \"variantId\": variant._id,\n          \"workflow.status\": \"new\"\n        }, {\n          sort: {\n            updatedAt: -1\n          },\n          limit: removeQty\n        }).fetch();\n\n        results = itemCount;\n        // delete latest inventory \"status:new\" records\n        for (const inventoryItem of removeInventory) {\n          results -= Meteor.call(\"inventory/remove\", inventoryItem);\n          // we could add handling for the case when aren't enough \"new\" items\n        }\n      }\n      Logger.debug(`adjust variant ${variant._id} from ${itemCount} to ${results}`);\n    }\n  }\n}\n\nMeteor.methods({\n  \"inventory/register\"(product) {\n    if (!Reaction.hasPermission(\"createProduct\", this.userId, product.shopId)) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n    registerInventory(product);\n  },\n  \"inventory/adjust\"(product) { // TODO: this should be variant\n    Products.simpleSchema(product).validate(product);\n    adjustInventory(product, this.userId, this);\n  }\n});\n"]},"sourceType":"script","hash":"b7f22ccfd7b073707a35c8d07cab92265b9076cf"}
