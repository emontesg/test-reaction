{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$1$2","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"ast":true,"babelrc":false,"sourceFileName":"lib/api/catalog.js","filename":"lib/api/catalog.js","sourceMaps":true,"envName":"development","cwd":"/Users/estebandev/test-knowledge","passPerPreset":false,"presets":[],"parserOpts":{"sourceType":"module","sourceFileName":"lib/api/catalog.js","plugins":["jsx","jsx","flow","flow","objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties"]},"generatorOpts":{"filename":"lib/api/catalog.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"lib/api/catalog.js"}},"code":"let _max;\n\nmodule.watch(require(\"lodash/max\"), {\n  default(v) {\n    _max = v;\n  }\n\n}, 0);\n\nlet _min;\n\nmodule.watch(require(\"lodash/min\"), {\n  default(v) {\n    _min = v;\n  }\n\n}, 1);\nlet Products;\nmodule.watch(require(\"../collections\"), {\n  Products(v) {\n    Products = v;\n  }\n\n}, 2);\nlet ReactionProduct;\nmodule.watch(require(\"./index\"), {\n  ReactionProduct(v) {\n    ReactionProduct = v;\n  }\n\n}, 3);\nlet applyProductRevision;\nmodule.watch(require(\"./products\"), {\n  applyProductRevision(v) {\n    applyProductRevision = v;\n  }\n\n}, 4);\nmodule.exportDefault({\n  /**\n   * @method setProduct\n   * @memberof Catalog\n   * @summary method to set default/parameterized product variant\n   * @param {String} currentProductId - set current productId\n   * @param {String} currentVariantId - set current variantId\n   * @return {undefined} return nothing, sets in session\n   */\n  setProduct(currentProductId, currentVariantId) {\n    let productId = currentProductId;\n    const variantId = currentVariantId;\n\n    if (!productId.match(/^[A-Za-z0-9]{17}$/)) {\n      const product = Products.findOne({\n        handle: productId.toLowerCase()\n      });\n\n      if (product) {\n        productId = product._id;\n      }\n    }\n\n    ReactionProduct.setCurrentVariant(variantId);\n  },\n\n  /**\n   * @method getProductPriceRange\n   * @memberof Catalog\n   * @summary get price range of a product\n   * if only one price available, return it\n   * otherwise return a string range\n   * @todo move all this methods this to export function after 1.3\n   * @param {String} [productId] - current product _id\n   * @return {Object} range, min, max\n   */\n  getProductPriceRange(productId) {\n    const product = applyProductRevision(Products.findOne(productId));\n\n    if (!product) {\n      return {\n        range: \"0\",\n        min: 0,\n        max: 0\n      };\n    }\n\n    const variants = this.getTopVariants(product._id); // if we have variants we have a price range.\n    // this processing will default on the server\n\n    const visibileVariant = variants.filter(variant => variant.isVisible === true);\n\n    if (visibileVariant.length > 0) {\n      const variantPrices = [];\n      variants.forEach(variant => {\n        if (variant.isVisible === true) {\n          const range = this.getVariantPriceRange(variant._id);\n\n          if (typeof range === \"string\") {\n            const firstPrice = parseFloat(range.substr(0, range.indexOf(\" \")));\n            const lastPrice = parseFloat(range.substr(range.lastIndexOf(\" \") + 1));\n            variantPrices.push(firstPrice, lastPrice);\n          } else {\n            variantPrices.push(range);\n          }\n        } else {\n          variantPrices.push(0, 0);\n        }\n      });\n\n      const priceMin = _min(variantPrices);\n\n      const priceMax = _max(variantPrices);\n\n      let priceRange = `${priceMin} - ${priceMax}`; // if we don't have a range\n\n      if (priceMin === priceMax) {\n        priceRange = priceMin.toString();\n      }\n\n      return {\n        range: priceRange,\n        min: priceMin,\n        max: priceMax\n      };\n    }\n\n    if (!product.price) {\n      return {\n        range: \"0\",\n        min: 0,\n        max: 0\n      };\n    } // if we have no variants subscribed to (client)\n    // we'll get the price object previously from the product\n\n\n    return product.price;\n  },\n\n  /**\n   * @method getVariantPriceRange\n   * @memberof Catalog\n   * @summary get price range of a variant if it has child options.\n   * if no child options, return main price value\n   * @todo remove string return and replace with object\n   * @param {String} [variantId] - current variant _Id\n   * @return {String} formatted price or price range\n   */\n  getVariantPriceRange(variantId) {\n    const children = this.getVariants(variantId);\n    const visibleChildren = children.filter(child => child.isVisible);\n\n    switch (visibleChildren.length) {\n      case 0:\n        {\n          const topVariant = applyProductRevision(Products.findOne(variantId)); // topVariant could be undefined when we removing last top variant\n\n          return topVariant && topVariant.price;\n        }\n\n      case 1:\n        {\n          return visibleChildren[0].price;\n        }\n\n      default:\n        {\n          let priceMin = Number.POSITIVE_INFINITY;\n          let priceMax = Number.NEGATIVE_INFINITY;\n          children.forEach(child => {\n            if (child.isVisible === true) {\n              if (child.price < priceMin) {\n                priceMin = child.price;\n              }\n\n              if (child.price > priceMax) {\n                priceMax = child.price;\n              }\n            }\n          });\n\n          if (priceMin === priceMax) {\n            // TODO check impact on i18n/formatPrice from moving return to string\n            return priceMin.toString();\n          }\n\n          return `${priceMin} - ${priceMax}`;\n        }\n    }\n  },\n\n  /**\n   * @method getVariantQuantity\n   * @memberof Catalog\n   * @description calculate a sum of descendants `inventoryQuantity`\n   * @param {Object} variant - top-level variant\n   * @return {Number} summary of options quantity\n   */\n  getVariantQuantity(variant) {\n    const options = this.getVariants(variant._id);\n\n    if (options && options.length) {\n      return options.reduce((sum, option) => sum + parseInt(option.inventoryQuantity, 10) || 0, 0);\n    }\n\n    return variant.inventoryQuantity || 0;\n  },\n\n  /**\n   * @method getPublishedOrRevision\n   * @memberof Catalog\n   * @description return top product revision if available\n   * @param {Object} product product or variant document\n   * @return {Object} product document\n   */\n  getPublishedOrRevision(product) {\n    return applyProductRevision(product);\n  },\n\n  /**\n  * @method getProduct\n  * @method\n  * @memberof ReactionProduct\n  * @summary Get product object. Could be useful for products and for top level variants\n  * @param {String} [id] - product _id\n  * @return {Object} Product data\n  */\n  getProduct(id) {\n    return Products.findOne(id);\n  },\n\n  /**\n   * @method getVariants\n   * @memberof Catalog\n   * @description Get all parent variants\n   * @summary could be useful for products and for top level variants\n   * @param {String} [id] - product _id\n   * @param {String} [type] - type of variant\n   * @return {Array} Parent variants or empty array\n   */\n  getVariants(id, type) {\n    return Products.find({\n      ancestors: {\n        $in: [id]\n      },\n      type: type || \"variant\"\n    }).map(this.getPublishedOrRevision);\n  },\n\n  /**\n   * @method getVariantParent\n   * @memberof Catalog\n   * @description Get direct parent variant\n   * @summary could be useful for lower level variants to get direct parents\n   * @param {Object} [variant] - product / variant object\n   * @return {Array} Parent variant or empty\n   */\n  getVariantParent(variant) {\n    const parent = Products.findOne({\n      _id: {\n        $in: variant.ancestors\n      },\n      type: \"variant\"\n    });\n    return this.getPublishedOrRevision(parent);\n  },\n\n  /**\n   * @method getSiblings\n   * @memberof Catalog\n   * @description Get all sibling variants - variants with the same ancestor tree\n   * @summary could be useful for child variants relationships with top-level variants\n   * @param {Object} [variant] - product / variant object\n   * @param {String} [type] - type of variant\n   * @param {Boolean} [includeSelf] - include current variant in results\n   * @return {Array} Sibling variants or empty array\n   */\n  getSiblings(variant, type) {\n    return Products.find({\n      ancestors: variant.ancestors,\n      type: type || \"variant\"\n    }).map(this.getPublishedOrRevision);\n  },\n\n  /**\n   * @method getTopVariants\n   * @memberof Catalog\n   * @description Get only product top level variants\n   * @param {String} [id] - product _id\n   * @return {Array} Product top level variants or empty array\n   */\n  getTopVariants(id) {\n    return Products.find({\n      ancestors: [id],\n      type: \"variant\"\n    }).map(this.getPublishedOrRevision);\n  }\n\n});","map":{"version":3,"sources":["lib/api/catalog.js"],"names":["_max","module","watch","require","default","v","_min","Products","ReactionProduct","applyProductRevision","exportDefault","setProduct","currentProductId","currentVariantId","productId","variantId","match","product","findOne","handle","toLowerCase","_id","setCurrentVariant","getProductPriceRange","range","min","max","variants","getTopVariants","visibileVariant","filter","variant","isVisible","length","variantPrices","forEach","getVariantPriceRange","firstPrice","parseFloat","substr","indexOf","lastPrice","lastIndexOf","push","priceMin","priceMax","priceRange","toString","price","children","getVariants","visibleChildren","child","topVariant","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","getVariantQuantity","options","reduce","sum","option","parseInt","inventoryQuantity","getPublishedOrRevision","getProduct","id","type","find","ancestors","$in","map","getVariantParent","parent","getSiblings"],"mappings":"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","sourcesContent":["import _ from \"lodash\";\nimport { Products } from \"/lib/collections\";\nimport { ReactionProduct } from \"/lib/api\";\nimport { applyProductRevision } from \"/lib/api/products\";\n\n/**\n * @file Catalog methods\n *\n * @namespace Catalog\n */\n\nexport default {\n  /**\n   * @method setProduct\n   * @memberof Catalog\n   * @summary method to set default/parameterized product variant\n   * @param {String} currentProductId - set current productId\n   * @param {String} currentVariantId - set current variantId\n   * @return {undefined} return nothing, sets in session\n   */\n  setProduct(currentProductId, currentVariantId) {\n    let productId = currentProductId;\n    const variantId = currentVariantId;\n    if (!productId.match(/^[A-Za-z0-9]{17}$/)) {\n      const product = Products.findOne({\n        handle: productId.toLowerCase()\n      });\n      if (product) {\n        productId = product._id;\n      }\n    }\n    ReactionProduct.setCurrentVariant(variantId);\n  },\n\n  /**\n   * @method getProductPriceRange\n   * @memberof Catalog\n   * @summary get price range of a product\n   * if only one price available, return it\n   * otherwise return a string range\n   * @todo move all this methods this to export function after 1.3\n   * @param {String} [productId] - current product _id\n   * @return {Object} range, min, max\n   */\n  getProductPriceRange(productId) {\n    const product = applyProductRevision(Products.findOne(productId));\n    if (!product) {\n      return {\n        range: \"0\",\n        min: 0,\n        max: 0\n      };\n    }\n\n    const variants = this.getTopVariants(product._id);\n    // if we have variants we have a price range.\n    // this processing will default on the server\n    const visibileVariant = variants.filter((variant) => variant.isVisible === true);\n\n    if (visibileVariant.length > 0) {\n      const variantPrices = [];\n      variants.forEach((variant) => {\n        if (variant.isVisible === true) {\n          const range = this.getVariantPriceRange(variant._id);\n          if (typeof range === \"string\") {\n            const firstPrice = parseFloat(range.substr(0, range.indexOf(\" \")));\n            const lastPrice = parseFloat(range.substr(range.lastIndexOf(\" \") + 1));\n            variantPrices.push(firstPrice, lastPrice);\n          } else {\n            variantPrices.push(range);\n          }\n        } else {\n          variantPrices.push(0, 0);\n        }\n      });\n      const priceMin = _.min(variantPrices);\n      const priceMax = _.max(variantPrices);\n      let priceRange = `${priceMin} - ${priceMax}`;\n      // if we don't have a range\n      if (priceMin === priceMax) {\n        priceRange = priceMin.toString();\n      }\n      return {\n        range: priceRange,\n        min: priceMin,\n        max: priceMax\n      };\n    }\n\n    if (!product.price) {\n      return {\n        range: \"0\",\n        min: 0,\n        max: 0\n      };\n    }\n\n    // if we have no variants subscribed to (client)\n    // we'll get the price object previously from the product\n    return product.price;\n  },\n\n  /**\n   * @method getVariantPriceRange\n   * @memberof Catalog\n   * @summary get price range of a variant if it has child options.\n   * if no child options, return main price value\n   * @todo remove string return and replace with object\n   * @param {String} [variantId] - current variant _Id\n   * @return {String} formatted price or price range\n   */\n  getVariantPriceRange(variantId) {\n    const children = this.getVariants(variantId);\n    const visibleChildren = children.filter((child) => child.isVisible);\n\n    switch (visibleChildren.length) {\n      case 0: {\n        const topVariant = applyProductRevision(Products.findOne(variantId));\n        // topVariant could be undefined when we removing last top variant\n        return topVariant && topVariant.price;\n      }\n      case 1: {\n        return visibleChildren[0].price;\n      }\n      default: {\n        let priceMin = Number.POSITIVE_INFINITY;\n        let priceMax = Number.NEGATIVE_INFINITY;\n\n        children.forEach((child) => {\n          if (child.isVisible === true) {\n            if (child.price < priceMin) {\n              priceMin = child.price;\n            }\n            if (child.price > priceMax) {\n              priceMax = child.price;\n            }\n          }\n        });\n\n        if (priceMin === priceMax) {\n          // TODO check impact on i18n/formatPrice from moving return to string\n          return priceMin.toString();\n        }\n        return `${priceMin} - ${priceMax}`;\n      }\n    }\n  },\n\n  /**\n   * @method getVariantQuantity\n   * @memberof Catalog\n   * @description calculate a sum of descendants `inventoryQuantity`\n   * @param {Object} variant - top-level variant\n   * @return {Number} summary of options quantity\n   */\n  getVariantQuantity(variant) {\n    const options = this.getVariants(variant._id);\n    if (options && options.length) {\n      return options.reduce((sum, option) =>\n        sum + parseInt(option.inventoryQuantity, 10) || 0, 0);\n    }\n    return variant.inventoryQuantity || 0;\n  },\n\n  /**\n   * @method getPublishedOrRevision\n   * @memberof Catalog\n   * @description return top product revision if available\n   * @param {Object} product product or variant document\n   * @return {Object} product document\n   */\n  getPublishedOrRevision(product) {\n    return applyProductRevision(product);\n  },\n\n  /**\n  * @method getProduct\n  * @method\n  * @memberof ReactionProduct\n  * @summary Get product object. Could be useful for products and for top level variants\n  * @param {String} [id] - product _id\n  * @return {Object} Product data\n  */\n  getProduct(id) {\n    return Products.findOne(id);\n  },\n\n  /**\n   * @method getVariants\n   * @memberof Catalog\n   * @description Get all parent variants\n   * @summary could be useful for products and for top level variants\n   * @param {String} [id] - product _id\n   * @param {String} [type] - type of variant\n   * @return {Array} Parent variants or empty array\n   */\n  getVariants(id, type) {\n    return Products.find({\n      ancestors: { $in: [id] },\n      type: type || \"variant\"\n    }).map(this.getPublishedOrRevision);\n  },\n\n  /**\n   * @method getVariantParent\n   * @memberof Catalog\n   * @description Get direct parent variant\n   * @summary could be useful for lower level variants to get direct parents\n   * @param {Object} [variant] - product / variant object\n   * @return {Array} Parent variant or empty\n   */\n  getVariantParent(variant) {\n    const parent = Products.findOne({\n      _id: { $in: variant.ancestors },\n      type: \"variant\"\n    });\n    return this.getPublishedOrRevision(parent);\n  },\n\n  /**\n   * @method getSiblings\n   * @memberof Catalog\n   * @description Get all sibling variants - variants with the same ancestor tree\n   * @summary could be useful for child variants relationships with top-level variants\n   * @param {Object} [variant] - product / variant object\n   * @param {String} [type] - type of variant\n   * @param {Boolean} [includeSelf] - include current variant in results\n   * @return {Array} Sibling variants or empty array\n   */\n  getSiblings(variant, type) {\n    return Products.find({\n      ancestors: variant.ancestors,\n      type: type || \"variant\"\n    }).map(this.getPublishedOrRevision);\n  },\n\n  /**\n   * @method getTopVariants\n   * @memberof Catalog\n   * @description Get only product top level variants\n   * @param {String} [id] - product _id\n   * @return {Array} Product top level variants or empty array\n   */\n  getTopVariants(id) {\n    return Products.find({\n      ancestors: [id],\n      type: \"variant\"\n    }).map(this.getPublishedOrRevision);\n  }\n};\n"]},"sourceType":"script","hash":"362da3eaef6739cfed81cd486d287af71a5395b1"}
