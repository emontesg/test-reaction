{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$1$2","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"ast":true,"babelrc":false,"sourceFileName":"server/startup/accounts.js","filename":"server/startup/accounts.js","sourceMaps":true,"envName":"development","cwd":"/Users/estebandev/test-knowledge","passPerPreset":false,"presets":[],"parserOpts":{"sourceType":"module","sourceFileName":"server/startup/accounts.js","plugins":["jsx","jsx","flow","flow","objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties"]},"generatorOpts":{"filename":"server/startup/accounts.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"server/startup/accounts.js"}},"code":"let _set;\n\nmodule.watch(require(\"lodash/set\"), {\n  default(v) {\n    _set = v;\n  }\n\n}, 0);\n\nlet _filter;\n\nmodule.watch(require(\"lodash/filter\"), {\n  default(v) {\n    _filter = v;\n  }\n\n}, 1);\nlet Meteor;\nmodule.watch(require(\"meteor/meteor\"), {\n  Meteor(v) {\n    Meteor = v;\n  }\n\n}, 2);\nlet Random;\nmodule.watch(require(\"meteor/random\"), {\n  Random(v) {\n    Random = v;\n  }\n\n}, 3);\nlet Accounts;\nmodule.watch(require(\"meteor/accounts-base\"), {\n  Accounts(v) {\n    Accounts = v;\n  }\n\n}, 4);\nlet Collections;\nmodule.watch(require(\"../../lib/collections\"), {\n  \"*\"(v) {\n    Collections = v;\n  }\n\n}, 5);\nlet Hooks, Logger, Reaction;\nmodule.watch(require(\"../api\"), {\n  Hooks(v) {\n    Hooks = v;\n  },\n\n  Logger(v) {\n    Logger = v;\n  },\n\n  Reaction(v) {\n    Reaction = v;\n  }\n\n}, 6);\nmodule.exportDefault(function () {\n  /**\n   * Make sure initial admin user has verified their\n   * email before allowing them to login.\n   *\n   * http://docs.meteor.com/#/full/accounts_validateloginattempt\n   */\n  Accounts.validateLoginAttempt(attempt => {\n    if (!attempt.allowed) {\n      return false;\n    } // confirm this is the accounts-password login method\n\n\n    if (attempt.type !== \"password\" || attempt.methodName !== \"login\") {\n      return attempt.allowed;\n    }\n\n    if (!attempt.user) {\n      return attempt.allowed;\n    }\n\n    const loginEmail = attempt.methodArguments[0].user.email;\n    const adminEmail = process.env.REACTION_EMAIL;\n\n    if (loginEmail && loginEmail === adminEmail) {\n      // filter out the matching login email from any existing emails\n      const userEmail = _filter(attempt.user.emails, email => email.address === loginEmail); // check if the email is verified\n\n\n      if (!userEmail.length || !userEmail[0].verified) {\n        throw new Meteor.Error(\"access-denied\", \"Oops! Please validate your email first.\");\n      }\n    }\n\n    return attempt.allowed;\n  });\n  /**\n   * Reaction Accounts handlers\n   * creates a login type \"anonymous\"\n   * default for all unauthenticated visitors\n   */\n\n  Accounts.registerLoginHandler(options => {\n    if (!options.anonymous) return {};\n\n    const stampedToken = Accounts._generateStampedLoginToken();\n\n    const userId = Accounts.insertUserDoc({\n      services: {\n        anonymous: true\n      },\n      token: stampedToken.token\n    });\n    const loginHandler = {\n      type: \"anonymous\",\n      userId\n    };\n    return loginHandler;\n  });\n  /**\n   * Accounts.onCreateUser event\n   * adding either a guest or anonymous role to the user on create\n   * adds Accounts record for reaction user profiles\n   * we clone the user into accounts, as the user collection is\n   * only to be used for authentication.\n   * - defaultVisitorRole\n   * - defaultRoles\n   * can be overriden from Shops\n   *\n   * @see: http://docs.meteor.com/#/full/accounts_oncreateuser\n   */\n\n  Accounts.onCreateUser((options, user) => {\n    const shopId = Reaction.getShopId(); // current shop; not primary shop\n\n    const groupToAddUser = options.groupId;\n    const roles = {};\n    const additionals = {\n      name: options && options.name,\n      profile: Object.assign({}, options && options.profile)\n    };\n    if (!user.emails) user.emails = []; // init default user roles\n    // we won't create users unless we have a shop.\n\n    if (shopId) {\n      // retain language when user has defined a language\n      // perhaps should be treated as additionals\n      // or in onLogin below, or in the anonymous method options\n      if (!(Meteor.users.find().count() === 0)) {\n        // dont set on inital admin\n        if (!user.profile) user.profile = {};\n        const currentUser = Meteor.user(user);\n\n        if (currentUser && currentUser.profile) {\n          if (currentUser.profile.lang && !user.profile.lang) {\n            user.profile.lang = currentUser.profile.lang;\n          }\n\n          if (currentUser.profile.currency && !user.profile.currency) {\n            user.profile.currency = currentUser.profile.currency;\n          }\n        }\n      } // if we don't have user.services we're an anonymous user\n\n\n      if (!user.services) {\n        const group = Collections.Groups.findOne({\n          slug: \"guest\",\n          shopId\n        });\n        const defaultGuestRoles = group.permissions; // if no defaultGuestRoles retrieved from DB, use the default Reaction set\n\n        roles[shopId] = defaultGuestRoles || Reaction.defaultVisitorRoles;\n        additionals.groups = [group._id];\n      } else {\n        let group;\n\n        if (groupToAddUser) {\n          group = Collections.Groups.findOne({\n            _id: groupToAddUser,\n            shopId\n          });\n        } else {\n          group = Collections.Groups.findOne({\n            slug: \"customer\",\n            shopId\n          });\n        } // if no group or customer permissions retrieved from DB, use the default Reaction customer set\n\n\n        roles[shopId] = group.permissions || Reaction.defaultCustomerRoles;\n        additionals.groups = [group._id]; // also add services with email defined to user.emails[]\n\n        const userServices = user.services;\n\n        for (const service in userServices) {\n          if ({}.hasOwnProperty.call(userServices, service)) {\n            const serviceObj = userServices[service];\n\n            if (serviceObj.email) {\n              const email = {\n                provides: \"default\",\n                address: serviceObj.email,\n                verified: true\n              };\n              user.emails.push(email);\n            }\n\n            if (serviceObj.name) {\n              user.username = serviceObj.name;\n              additionals.profile.name = serviceObj.name;\n            } // TODO: For now we have here instagram, twitter and google avatar cases\n            // need to make complete list\n\n\n            if (serviceObj.picture) {\n              additionals.profile.picture = user.services[service].picture;\n            } else if (serviceObj.profile_image_url_https) {\n              additionals.profile.picture = user.services[service].dprofile_image_url_https;\n            } else if (serviceObj.profile_picture) {\n              additionals.profile.picture = user.services[service].profile_picture;\n            } // Correctly map Instagram profile data to Meteor user / Accounts\n\n\n            if (userServices.instagram) {\n              user.username = serviceObj.username;\n              user.name = serviceObj.full_name;\n              additionals.name = serviceObj.full_name;\n              additionals.profile.picture = serviceObj.profile_picture;\n              additionals.profile.bio = serviceObj.bio;\n              additionals.profile.name = serviceObj.full_name;\n              additionals.profile.username = serviceObj.username;\n            }\n          }\n        }\n      } // clone before adding roles\n\n\n      const account = Object.assign({}, user, additionals);\n      account.userId = user._id;\n      Collections.Accounts.insert(account);\n      Hooks.Events.run(\"afterAccountsInsert\", account.userId, user._id);\n      const userDetails = Collections.Accounts.findOne({\n        _id: user._id\n      }); // send a welcome email to new users,\n      // but skip the first default admin user and anonymous users\n      // (default admins already get a verification email)\n\n      if (userDetails.emails && userDetails.emails.length > 0 && !(Meteor.users.find().count() === 0) && !userDetails.profile.invited) {\n        const token = Random.secret();\n        Meteor.call(\"accounts/sendWelcomeEmail\", shopId, user._id, token);\n        const defaultEmail = userDetails.emails.find(email => email.provides === \"default\");\n        const when = new Date();\n        const tokenObj = {\n          address: defaultEmail.address,\n          token,\n          when\n        };\n\n        _set(user, \"services.email.verificationTokens\", [tokenObj]);\n      } // assign default user roles\n\n\n      user.roles = roles; // run onCreateUser hooks\n      // (the user object must be returned by all callbacks)\n\n      const userDoc = Hooks.Events.run(\"onCreateUser\", user, options);\n      return userDoc;\n    }\n  });\n  /**\n   * Accounts.onLogin event\n   * let's remove \"anonymous\" role, if the login type isn't \"anonymous\"\n   * @param {Object} options - user account creation options\n   * @fires \"cart/mergeCart\" Method\n   */\n\n  Accounts.onLogin(opts => {\n    // run onLogin hooks\n    // (the options object must be returned by all callbacks)\n    const options = Hooks.Events.run(\"onLogin\", opts); // remove anonymous role\n    // all users are guest, but anonymous user don't have profile access\n    // or ability to order history, etc. so ensure its removed upon login.\n\n    if (options.type !== \"anonymous\" && options.type !== \"resume\") {\n      const update = {\n        $pullAll: {}\n      };\n      update.$pullAll[`roles.${Reaction.getShopId()}`] = [\"anonymous\"];\n      Meteor.users.update({\n        _id: options.user._id\n      }, update, {\n        multi: true\n      }); // debug info\n\n      Logger.debug(`removed anonymous role from user: ${options.user._id}`); // do not call `cart/mergeCart` on methodName === `createUser`, because\n      // in this case `cart/mergeCart` calls from cart publication\n\n      if (options.methodName === \"createUser\") return true; // onLogin, we want to merge session cart into user cart.\n\n      const cart = Collections.Cart.findOne({\n        userId: options.user._id\n      }); // for a rare use cases\n\n      if (typeof cart !== \"object\") return false; // in current version currentSessionId will be available for anonymous\n      // users only, because it is unknown for me how to pass sessionId when user\n      // logged in\n\n      let currentSessionId;\n\n      if (options.methodArguments && options.methodArguments.length === 1 && options.methodArguments[0].sessionId) {\n        currentSessionId = options.methodArguments[0].sessionId;\n      } // changing of workflow status from now happens within `cart/mergeCart`\n\n\n      return Meteor.call(\"cart/mergeCart\", cart._id, currentSessionId);\n    }\n  });\n});","map":{"version":3,"sources":["server/startup/accounts.js"],"names":["_set","module","watch","require","default","v","_filter","Meteor","Random","Accounts","Collections","Hooks","Logger","Reaction","exportDefault","validateLoginAttempt","attempt","allowed","type","methodName","user","loginEmail","methodArguments","email","adminEmail","process","env","REACTION_EMAIL","userEmail","emails","address","length","verified","Error","registerLoginHandler","options","anonymous","stampedToken","_generateStampedLoginToken","userId","insertUserDoc","services","token","loginHandler","onCreateUser","shopId","getShopId","groupToAddUser","groupId","roles","additionals","name","profile","Object","assign","users","find","count","currentUser","lang","currency","group","Groups","findOne","slug","defaultGuestRoles","permissions","defaultVisitorRoles","groups","_id","defaultCustomerRoles","userServices","service","hasOwnProperty","call","serviceObj","provides","push","username","picture","profile_image_url_https","dprofile_image_url_https","profile_picture","instagram","full_name","bio","account","insert","Events","run","userDetails","invited","secret","defaultEmail","when","Date","tokenObj","userDoc","onLogin","opts","update","$pullAll","multi","debug","cart","Cart","currentSessionId","sessionId"],"mappings":"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","sourcesContent":["import _ from \"lodash\";\nimport { Meteor } from \"meteor/meteor\";\nimport { Random } from \"meteor/random\";\nimport { Accounts } from \"meteor/accounts-base\";\nimport * as Collections from \"/lib/collections\";\nimport { Hooks, Logger, Reaction } from \"/server/api\";\n\nexport default function () {\n  /**\n   * Make sure initial admin user has verified their\n   * email before allowing them to login.\n   *\n   * http://docs.meteor.com/#/full/accounts_validateloginattempt\n   */\n\n  Accounts.validateLoginAttempt((attempt) => {\n    if (!attempt.allowed) {\n      return false;\n    }\n\n    // confirm this is the accounts-password login method\n    if (attempt.type !== \"password\" || attempt.methodName !== \"login\") {\n      return attempt.allowed;\n    }\n\n    if (!attempt.user) {\n      return attempt.allowed;\n    }\n\n    const loginEmail = attempt.methodArguments[0].user.email;\n    const adminEmail = process.env.REACTION_EMAIL;\n\n    if (loginEmail && loginEmail === adminEmail) {\n      // filter out the matching login email from any existing emails\n      const userEmail = _.filter(attempt.user.emails, (email) => email.address === loginEmail);\n\n      // check if the email is verified\n      if (!userEmail.length || !userEmail[0].verified) {\n        throw new Meteor.Error(\"access-denied\", \"Oops! Please validate your email first.\");\n      }\n    }\n\n    return attempt.allowed;\n  });\n\n  /**\n   * Reaction Accounts handlers\n   * creates a login type \"anonymous\"\n   * default for all unauthenticated visitors\n   */\n  Accounts.registerLoginHandler((options) => {\n    if (!options.anonymous) return {};\n\n    const stampedToken = Accounts._generateStampedLoginToken();\n    const userId = Accounts.insertUserDoc({\n      services: {\n        anonymous: true\n      },\n      token: stampedToken.token\n    });\n    const loginHandler = {\n      type: \"anonymous\",\n      userId\n    };\n    return loginHandler;\n  });\n\n  /**\n   * Accounts.onCreateUser event\n   * adding either a guest or anonymous role to the user on create\n   * adds Accounts record for reaction user profiles\n   * we clone the user into accounts, as the user collection is\n   * only to be used for authentication.\n   * - defaultVisitorRole\n   * - defaultRoles\n   * can be overriden from Shops\n   *\n   * @see: http://docs.meteor.com/#/full/accounts_oncreateuser\n   */\n  Accounts.onCreateUser((options, user) => {\n    const shopId = Reaction.getShopId(); // current shop; not primary shop\n    const groupToAddUser = options.groupId;\n    const roles = {};\n    const additionals = {\n      name: options && options.name,\n      profile: Object.assign({}, options && options.profile)\n    };\n    if (!user.emails) user.emails = [];\n    // init default user roles\n    // we won't create users unless we have a shop.\n    if (shopId) {\n      // retain language when user has defined a language\n      // perhaps should be treated as additionals\n      // or in onLogin below, or in the anonymous method options\n      if (!(Meteor.users.find().count() === 0)) { // dont set on inital admin\n        if (!user.profile) user.profile = {};\n        const currentUser = Meteor.user(user);\n        if (currentUser && currentUser.profile) {\n          if (currentUser.profile.lang && !user.profile.lang) {\n            user.profile.lang = currentUser.profile.lang;\n          }\n          if (currentUser.profile.currency && !user.profile.currency) {\n            user.profile.currency = currentUser.profile.currency;\n          }\n        }\n      }\n      // if we don't have user.services we're an anonymous user\n      if (!user.services) {\n        const group = Collections.Groups.findOne({ slug: \"guest\", shopId });\n        const defaultGuestRoles = group.permissions;\n        // if no defaultGuestRoles retrieved from DB, use the default Reaction set\n        roles[shopId] = defaultGuestRoles || Reaction.defaultVisitorRoles;\n        additionals.groups = [group._id];\n      } else {\n        let group;\n        if (groupToAddUser) {\n          group = Collections.Groups.findOne({ _id: groupToAddUser, shopId });\n        } else {\n          group = Collections.Groups.findOne({ slug: \"customer\", shopId });\n        }\n        // if no group or customer permissions retrieved from DB, use the default Reaction customer set\n        roles[shopId] = group.permissions || Reaction.defaultCustomerRoles;\n        additionals.groups = [group._id];\n        // also add services with email defined to user.emails[]\n        const userServices = user.services;\n        for (const service in userServices) {\n          if ({}.hasOwnProperty.call(userServices, service)) {\n            const serviceObj = userServices[service];\n            if (serviceObj.email) {\n              const email = {\n                provides: \"default\",\n                address: serviceObj.email,\n                verified: true\n              };\n              user.emails.push(email);\n            }\n            if (serviceObj.name) {\n              user.username = serviceObj.name;\n              additionals.profile.name = serviceObj.name;\n            }\n            // TODO: For now we have here instagram, twitter and google avatar cases\n            // need to make complete list\n            if (serviceObj.picture) {\n              additionals.profile.picture = user.services[service].picture;\n            } else if (serviceObj.profile_image_url_https) {\n              additionals.profile.picture = user.services[service].dprofile_image_url_https;\n            } else if (serviceObj.profile_picture) {\n              additionals.profile.picture = user.services[service].profile_picture;\n            }\n            // Correctly map Instagram profile data to Meteor user / Accounts\n            if (userServices.instagram) {\n              user.username = serviceObj.username;\n              user.name = serviceObj.full_name;\n              additionals.name = serviceObj.full_name;\n              additionals.profile.picture = serviceObj.profile_picture;\n              additionals.profile.bio = serviceObj.bio;\n              additionals.profile.name = serviceObj.full_name;\n              additionals.profile.username = serviceObj.username;\n            }\n          }\n        }\n      }\n\n      // clone before adding roles\n      const account = Object.assign({}, user, additionals);\n      account.userId = user._id;\n      Collections.Accounts.insert(account);\n      Hooks.Events.run(\"afterAccountsInsert\", account.userId, user._id);\n\n      const userDetails = Collections.Accounts.findOne({ _id: user._id });\n\n      // send a welcome email to new users,\n      // but skip the first default admin user and anonymous users\n      // (default admins already get a verification email)\n      if (userDetails.emails && userDetails.emails.length > 0\n        && (!(Meteor.users.find().count() === 0) && !userDetails.profile.invited)) {\n        const token = Random.secret();\n        Meteor.call(\"accounts/sendWelcomeEmail\", shopId, user._id, token);\n        const defaultEmail = userDetails.emails.find((email) => email.provides === \"default\");\n        const when = new Date();\n        const tokenObj = {\n          address: defaultEmail.address,\n          token,\n          when\n        };\n        _.set(user, \"services.email.verificationTokens\", [tokenObj]);\n      }\n\n      // assign default user roles\n      user.roles = roles;\n\n      // run onCreateUser hooks\n      // (the user object must be returned by all callbacks)\n      const userDoc = Hooks.Events.run(\"onCreateUser\", user, options);\n      return userDoc;\n    }\n  });\n\n  /**\n   * Accounts.onLogin event\n   * let's remove \"anonymous\" role, if the login type isn't \"anonymous\"\n   * @param {Object} options - user account creation options\n   * @fires \"cart/mergeCart\" Method\n   */\n  Accounts.onLogin((opts) => {\n    // run onLogin hooks\n    // (the options object must be returned by all callbacks)\n    const options = Hooks.Events.run(\"onLogin\", opts);\n\n    // remove anonymous role\n    // all users are guest, but anonymous user don't have profile access\n    // or ability to order history, etc. so ensure its removed upon login.\n    if (options.type !== \"anonymous\" && options.type !== \"resume\") {\n      const update = {\n        $pullAll: {}\n      };\n\n      update.$pullAll[`roles.${Reaction.getShopId()}`] = [\"anonymous\"];\n\n      Meteor.users.update({\n        _id: options.user._id\n      }, update, {\n        multi: true\n      });\n      // debug info\n      Logger.debug(`removed anonymous role from user: ${options.user._id}`);\n\n      // do not call `cart/mergeCart` on methodName === `createUser`, because\n      // in this case `cart/mergeCart` calls from cart publication\n      if (options.methodName === \"createUser\") return true;\n\n      // onLogin, we want to merge session cart into user cart.\n      const cart = Collections.Cart.findOne({\n        userId: options.user._id\n      });\n\n      // for a rare use cases\n      if (typeof cart !== \"object\") return false;\n      // in current version currentSessionId will be available for anonymous\n      // users only, because it is unknown for me how to pass sessionId when user\n      // logged in\n      let currentSessionId;\n      if (options.methodArguments && options.methodArguments.length === 1 && options.methodArguments[0].sessionId) {\n        currentSessionId = options.methodArguments[0].sessionId;\n      }\n      // changing of workflow status from now happens within `cart/mergeCart`\n      return Meteor.call(\"cart/mergeCart\", cart._id, currentSessionId);\n    }\n  });\n}\n"]},"sourceType":"script","hash":"2fbbc46c2a055f8451eb060e8b51c03b2ec5e956"}
