{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$1$2","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"ast":true,"babelrc":false,"sourceFileName":"imports/plugins/included/search-mongo/server/methods/searchcollections.js","filename":"imports/plugins/included/search-mongo/server/methods/searchcollections.js","sourceMaps":true,"envName":"development","cwd":"/Users/estebandev/test-knowledge","passPerPreset":false,"presets":[],"parserOpts":{"sourceType":"module","sourceFileName":"imports/plugins/included/search-mongo/server/methods/searchcollections.js","plugins":["jsx","jsx","flow","flow","objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties"]},"generatorOpts":{"filename":"imports/plugins/included/search-mongo/server/methods/searchcollections.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"imports/plugins/included/search-mongo/server/methods/searchcollections.js"}},"code":"var _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/builtin/objectSpread\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nmodule.export({\n  getSearchParameters: () => getSearchParameters,\n  buildProductSearchRecord: () => buildProductSearchRecord,\n  buildProductSearch: () => buildProductSearch,\n  buildEmptyProductSearch: () => buildEmptyProductSearch,\n  rebuildProductSearchIndex: () => rebuildProductSearchIndex,\n  ensureProductSearchIndex: () => ensureProductSearchIndex,\n  buildOrderSearchRecord: () => buildOrderSearchRecord,\n  buildOrderSearch: () => buildOrderSearch,\n  buildAccountSearchRecord: () => buildAccountSearchRecord,\n  buildAccountSearch: () => buildAccountSearch\n});\nlet Meteor;\nmodule.watch(require(\"meteor/meteor\"), {\n  Meteor(v) {\n    Meteor = v;\n  }\n\n}, 0);\nlet check, Match;\nmodule.watch(require(\"meteor/check\"), {\n  check(v) {\n    check = v;\n  },\n\n  Match(v) {\n    Match = v;\n  }\n\n}, 1);\nlet Reaction, Logger;\nmodule.watch(require(\"../../../../../../server/api\"), {\n  Reaction(v) {\n    Reaction = v;\n  },\n\n  Logger(v) {\n    Logger = v;\n  }\n\n}, 2);\nlet ProductSearch, OrderSearch, AccountSearch, Orders, Products, Accounts, Shops;\nmodule.watch(require(\"../../../../../../lib/collections\"), {\n  ProductSearch(v) {\n    ProductSearch = v;\n  },\n\n  OrderSearch(v) {\n    OrderSearch = v;\n  },\n\n  AccountSearch(v) {\n    AccountSearch = v;\n  },\n\n  Orders(v) {\n    Orders = v;\n  },\n\n  Products(v) {\n    Products = v;\n  },\n\n  Accounts(v) {\n    Accounts = v;\n  },\n\n  Shops(v) {\n    Shops = v;\n  }\n\n}, 3);\nlet utils;\nmodule.watch(require(\"./common\"), {\n  default(v) {\n    utils = v;\n  }\n\n}, 4);\nlet transformations;\nmodule.watch(require(\"./transformations\"), {\n  transformations(v) {\n    transformations = v;\n  }\n\n}, 5);\nlet moment;\n\nfunction lazyLoadMoment() {\n  return Promise.asyncApply(() => {\n    if (moment) return;\n    moment = Promise.await(Promise.resolve().then(() => require(\"moment\")));\n  });\n}\n\nconst requiredFields = {};\nrequiredFields.products = [\"_id\", \"hashtags\", \"shopId\", \"handle\", \"price\", \"isVisible\", \"isSoldOut\", \"isLowQuantity\", \"isBackorder\"];\nrequiredFields.orders = [\"_id\", \"shopId\", \"shippingName\", \"shippingPhone\", \"billingName\", \"userEmails\", \"shippingAddress\", \"billingAddress\", \"shippingStatus\", \"billingStatus\", \"orderTotal\", \"orderDate\"];\nrequiredFields.accounts = [\"_id\", \"shopId\", \"emails\", \"profile\"]; // https://docs.mongodb.com/manual/reference/text-search-languages/#text-search-languages\n// MongoDb supports a subset of languages for analysis of the text data which includes\n// things like stop words and stems. With this language support the quality of the search matches\n// and weighting increases, however without this search will still work and delivery good results.\n// We currently support the languages which are supported by Mongo by default but more languages\n// are available through custom configuration.\n\nconst supportedLanguages = [\"da\", \"nl\", \"en\", \"fi\", \"fr\", \"de\", \"hu\", \"it\", \"nb\", \"pt\", \"ro\", \"ru\", \"es\", \"sv\", \"tr\"];\n\nfunction filterFields(customFields) {\n  const fieldNames = [];\n  const fieldKeys = Object.keys(customFields);\n\n  for (const fieldKey of fieldKeys) {\n    if (customFields[fieldKey]) {\n      fieldNames.push(fieldKey);\n    }\n  }\n\n  return fieldNames;\n} // get the weights for all enabled fields\n\n\nfunction getScores(customFields, settings, collection = \"products\") {\n  const weightObject = {};\n\n  for (const weight of Object.keys(settings[collection].weights)) {\n    if (customFields.includes(weight)) {\n      weightObject[weight] = settings[collection].weights[weight];\n    }\n  }\n\n  return weightObject;\n}\n\nfunction getSearchLanguage() {\n  const shopId = Reaction.getShopId();\n  const shopLanguage = Shops.findOne(shopId).language;\n\n  if (supportedLanguages.includes(shopLanguage)) {\n    return {\n      default_language: shopLanguage\n    };\n  }\n\n  return {\n    default_language: \"en\"\n  };\n}\n/**\n * handleIndexUpdateFailures\n * When using Collection.rawCollection() methods that return a Promise,\n * handle the errors in a catch. However, ignore errors with altering indexes\n * before a collection exists.\n * @param  {Error} error an error object returned from a Promise rejection\n * @return {undefined}   doesn't return anything\n */\n\n\nfunction handleIndexUpdateFailures(error) {\n  // If we get an error from the Mongo driver because something tried to drop a\n  // collection before it existed, log it out as debug info.\n  // Otherwise, log whatever happened as an error.\n  if (error.name === \"MongoError\" && error.message === \"ns not found\") {\n    Logger.debug(error, \"Attempted to set or remove indexes in a Mongo collection that doesn't exist yet\");\n  } else {\n    Logger.error(error);\n  }\n}\n\nfunction getSearchParameters(collection = \"products\") {\n  const settings = utils.getPackageSettings();\n  const customFields = filterFields(settings[collection].includes);\n  const fieldSet = requiredFields[collection].concat(customFields);\n  const weightObject = getScores(customFields, settings);\n  return {\n    fieldSet,\n    weightObject,\n    customFields\n  };\n}\n\nfunction buildProductSearchRecord(productId) {\n  const product = Products.findOne(productId);\n\n  if (product.type === \"simple\") {\n    const {\n      fieldSet\n    } = getSearchParameters();\n    const productRecord = {};\n\n    for (const field of fieldSet) {\n      if (transformations.products[field]) {\n        productRecord[field] = transformations.products[field](product[field]);\n      } else {\n        productRecord[field] = product[field];\n      }\n    }\n\n    const productSearchRecord = ProductSearch.insert(productRecord);\n    ensureProductSearchIndex();\n    return productSearchRecord;\n  }\n\n  return undefined;\n}\n\nfunction buildProductSearch(cb) {\n  check(cb, Match.Optional(Function));\n  Logger.debug(\"Start (re)Building ProductSearch Collection\");\n  ProductSearch.remove({});\n  const {\n    fieldSet,\n    weightObject,\n    customFields\n  } = getSearchParameters();\n  const products = Products.find({\n    type: \"simple\"\n  }).fetch();\n\n  for (const product of products) {\n    const productRecord = {};\n\n    for (const field of fieldSet) {\n      if (transformations.products[field]) {\n        productRecord[field] = transformations.products[field](product[field]);\n      } else {\n        productRecord[field] = product[field];\n      }\n    }\n\n    ProductSearch.insert(productRecord);\n  }\n\n  const indexObject = {};\n\n  for (const field of customFields) {\n    indexObject[field] = \"text\";\n  }\n\n  const rawProductSearchCollection = ProductSearch.rawCollection();\n  rawProductSearchCollection.dropIndexes().catch(handleIndexUpdateFailures);\n  rawProductSearchCollection.createIndex(indexObject, weightObject, getSearchLanguage()).catch(handleIndexUpdateFailures);\n\n  if (cb) {\n    cb();\n  }\n}\n\nfunction buildEmptyProductSearch() {\n  const {\n    weightObject,\n    customFields\n  } = getSearchParameters();\n  const indexObject = {};\n\n  for (const field of customFields) {\n    indexObject[field] = \"text\";\n  }\n\n  const rawProductSearchCollection = ProductSearch.rawCollection();\n  rawProductSearchCollection.dropIndexes().catch(handleIndexUpdateFailures);\n  rawProductSearchCollection.createIndex(indexObject, weightObject, getSearchLanguage()).catch(handleIndexUpdateFailures);\n}\n\nfunction rebuildProductSearchIndex(cb) {\n  check(cb, Match.Optional(Function));\n  const {\n    customFields,\n    weightObject\n  } = getSearchParameters();\n  const indexObject = {};\n\n  for (const field of customFields) {\n    indexObject[field] = \"text\";\n  }\n\n  const rawProductSearchCollection = ProductSearch.rawCollection();\n  rawProductSearchCollection.dropIndexes().catch(handleIndexUpdateFailures);\n  rawProductSearchCollection.createIndex(indexObject, weightObject, getSearchLanguage()).catch(handleIndexUpdateFailures);\n\n  if (cb) {\n    cb();\n  }\n}\n\nfunction ensureProductSearchIndex() {\n  const {\n    customFields,\n    weightObject\n  } = getSearchParameters();\n  const indexObject = {};\n\n  for (const field of customFields) {\n    indexObject[field] = \"text\";\n  }\n\n  const rawProductSearchCollection = ProductSearch.rawCollection();\n  rawProductSearchCollection.createIndex(indexObject, weightObject, getSearchLanguage()).catch(handleIndexUpdateFailures);\n}\n\nfunction buildOrderSearchRecord(orderId) {\n  const order = Orders.findOne(orderId);\n  const user = Meteor.users.findOne(order.userId);\n  const anonymousUserEmail = order.email;\n  const userEmails = [];\n\n  if (user && user.emails.length) {\n    for (const email of user.emails) {\n      userEmails.push(email.address);\n    }\n  } else if (anonymousUserEmail) {\n    userEmails.push(anonymousUserEmail);\n  }\n\n  const orderSearch = {};\n\n  for (const field of requiredFields.orders) {\n    if (transformations.orders[field]) {\n      orderSearch[field] = transformations.orders[field](order[field]);\n    } else {\n      orderSearch[field] = order[field];\n    }\n  } // get the billing object for the current shop on the order (and not hardcoded [0])\n\n\n  const shopBilling = order.billing && order.billing.find(billing => billing && billing.shopId === Reaction.getShopId()) || {}; // get the shipping object for the current shop on the order (and not hardcoded [0])\n\n  const shopShipping = order.shipping.find(shipping => shipping.shopId === Reaction.getShopId()) || {};\n  Promise.await(lazyLoadMoment());\n  orderSearch.billingName = shopBilling.address && shopBilling.address.fullName;\n  orderSearch.billingPhone = shopBilling.address && shopBilling.address.phone.replace(/\\D/g, \"\");\n  orderSearch.shippingName = shopShipping.address && shopShipping.address.fullName;\n\n  if (shopShipping.address && shopShipping.address.phone) {\n    orderSearch.shippingPhone = shopShipping.address && shopShipping.address.phone.replace(/\\D/g, \"\");\n  }\n\n  orderSearch.billingAddress = {\n    address: shopBilling.address && shopBilling.address.address1,\n    postal: shopBilling.address && shopBilling.address.postal,\n    city: shopBilling.address && shopBilling.address.city,\n    region: shopBilling.address && shopBilling.address.region,\n    country: shopBilling.address && shopBilling.address.country\n  };\n  orderSearch.shippingAddress = {\n    address: shopShipping.address && shopShipping.address.address1,\n    postal: shopShipping.address && shopShipping.address.postal,\n    city: shopShipping.address && shopShipping.address.city,\n    region: shopShipping.address && shopShipping.address.region,\n    country: shopShipping.address && shopShipping.address.country\n  };\n  orderSearch.userEmails = userEmails;\n  orderSearch.orderTotal = shopBilling.invoice && shopBilling.invoice.total;\n  orderSearch.orderDate = moment && moment(order.createdAt).format(\"YYYY/MM/DD\");\n  orderSearch.billingStatus = shopBilling.paymentMethod && shopBilling.paymentMethod.status;\n  orderSearch.billingCard = shopBilling.paymentMethod && shopBilling.paymentMethod.storedCard;\n  orderSearch.currentWorkflowStatus = order.workflow.status;\n\n  if (shopShipping.shipped) {\n    orderSearch.shippingStatus = \"Shipped\";\n  } else if (shopShipping.packed) {\n    orderSearch.shippingStatus = \"Packed\";\n  } else {\n    orderSearch.shippingStatus = \"New\";\n  }\n\n  orderSearch.product = {};\n  orderSearch.variants = {};\n  orderSearch.product.title = order.items.map(item => item.product && item.product.title);\n  orderSearch.variants.title = order.items.map(item => item.variants && item.variants.title);\n  orderSearch.variants.optionTitle = order.items.map(item => item.variants && item.variants.optionTitle);\n\n  try {\n    OrderSearch.upsert(orderId, {\n      $set: (0, _objectSpread2.default)({}, orderSearch)\n    });\n  } catch (error) {\n    Logger.error(error, \"Failed to add order to the OrderSearch collection\");\n  }\n}\n\nfunction buildOrderSearch(cb) {\n  check(cb, Match.Optional(Function));\n  const orders = Orders.find({}).fetch();\n\n  for (const order of orders) {\n    buildOrderSearchRecord(order._id);\n  }\n\n  const rawOrderSearchCollection = OrderSearch.rawCollection();\n  rawOrderSearchCollection.dropIndexes().catch(handleIndexUpdateFailures);\n  rawOrderSearchCollection.createIndex({\n    shopId: 1,\n    shippingName: 1,\n    billingName: 1,\n    userEmails: 1\n  }).catch(handleIndexUpdateFailures);\n\n  if (cb) {\n    cb();\n  }\n}\n\nfunction buildAccountSearchRecord(accountId, updatedFields) {\n  Logger.debug(\"building account search record\");\n  check(accountId, String);\n  check(updatedFields, Array);\n  const account = Accounts.findOne(accountId); // let's ignore anonymous accounts\n\n  if (account && account.emails && account.emails.length) {\n    const accountSearch = {}; // Not all required fields are used in search\n    // We need to filter through fields that are used,\n    // and only update the search index if one of those fields were updated\n    // forceIndex is included to forceIndexing on startup, or when manually added\n\n    const searchableFields = [\"forceIndex\", \"shopId\", \"emails\", \"firstName\", \"lastName\", \"phone\"];\n    const shouldRunIndex = updatedFields && updatedFields.some(field => searchableFields.includes(field)); // If updatedFields contains one of the searchableFields, run the indexing\n\n    if (shouldRunIndex) {\n      AccountSearch.remove(accountId);\n\n      for (const field of requiredFields.accounts) {\n        if (transformations.accounts[field]) {\n          accountSearch[field] = transformations.accounts[field](account[field]);\n        } else {\n          accountSearch[field] = account[field];\n        }\n      }\n\n      AccountSearch.insert(accountSearch);\n    }\n  }\n}\n\nfunction buildAccountSearch(cb) {\n  check(cb, Match.Optional(Function));\n  AccountSearch.remove({});\n  const accounts = Accounts.find({}).fetch();\n\n  for (const account of accounts) {\n    // Passing forceIndex will run account search index even if\n    // updated fields don't match a searchable field\n    buildAccountSearchRecord(account._id, [\"forceIndex\"]);\n  }\n\n  const rawAccountSearchCollection = AccountSearch.rawCollection();\n  rawAccountSearchCollection.dropIndexes().catch(handleIndexUpdateFailures);\n  rawAccountSearchCollection.createIndex({\n    shopId: 1,\n    emails: 1\n  }).catch(handleIndexUpdateFailures);\n\n  if (cb) {\n    cb();\n  }\n}","map":{"version":3,"sources":["imports/plugins/included/search-mongo/server/methods/searchcollections.js"],"names":["module","export","getSearchParameters","buildProductSearchRecord","buildProductSearch","buildEmptyProductSearch","rebuildProductSearchIndex","ensureProductSearchIndex","buildOrderSearchRecord","buildOrderSearch","buildAccountSearchRecord","buildAccountSearch","Meteor","watch","require","v","check","Match","Reaction","Logger","ProductSearch","OrderSearch","AccountSearch","Orders","Products","Accounts","Shops","utils","default","transformations","moment","lazyLoadMoment","requiredFields","products","orders","accounts","supportedLanguages","filterFields","customFields","fieldNames","fieldKeys","Object","keys","fieldKey","push","getScores","settings","collection","weightObject","weight","weights","includes","getSearchLanguage","shopId","getShopId","shopLanguage","findOne","language","default_language","handleIndexUpdateFailures","error","name","message","debug","getPackageSettings","fieldSet","concat","productId","product","type","productRecord","field","productSearchRecord","insert","undefined","cb","Optional","Function","remove","find","fetch","indexObject","rawProductSearchCollection","rawCollection","dropIndexes","catch","createIndex","orderId","order","user","users","userId","anonymousUserEmail","email","userEmails","emails","length","address","orderSearch","shopBilling","billing","shopShipping","shipping","Promise","await","billingName","fullName","billingPhone","phone","replace","shippingName","shippingPhone","billingAddress","address1","postal","city","region","country","shippingAddress","orderTotal","invoice","total","orderDate","createdAt","format","billingStatus","paymentMethod","status","billingCard","storedCard","currentWorkflowStatus","workflow","shipped","shippingStatus","packed","variants","title","items","map","item","optionTitle","upsert","$set","_id","rawOrderSearchCollection","accountId","updatedFields","String","Array","account","accountSearch","searchableFields","shouldRunIndex","some","rawAccountSearchCollection"],"mappings":"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","sourcesContent":["/* eslint camelcase: 0 */\nimport { Meteor } from \"meteor/meteor\";\nimport { check, Match } from \"meteor/check\";\nimport { Reaction, Logger } from \"/server/api\";\nimport { ProductSearch, OrderSearch, AccountSearch, Orders, Products, Accounts, Shops } from \"/lib/collections\";\nimport utils from \"./common\";\nimport { transformations } from \"./transformations\";\n\nlet moment;\nasync function lazyLoadMoment() {\n  if (moment) return;\n  moment = await import(\"moment\");\n}\n\nconst requiredFields = {};\nrequiredFields.products = [\"_id\", \"hashtags\", \"shopId\", \"handle\", \"price\", \"isVisible\", \"isSoldOut\", \"isLowQuantity\", \"isBackorder\"];\nrequiredFields.orders = [\"_id\", \"shopId\", \"shippingName\", \"shippingPhone\", \"billingName\", \"userEmails\",\n  \"shippingAddress\", \"billingAddress\", \"shippingStatus\", \"billingStatus\", \"orderTotal\", \"orderDate\"];\nrequiredFields.accounts = [\"_id\", \"shopId\", \"emails\", \"profile\"];\n\n// https://docs.mongodb.com/manual/reference/text-search-languages/#text-search-languages\n// MongoDb supports a subset of languages for analysis of the text data which includes\n// things like stop words and stems. With this language support the quality of the search matches\n// and weighting increases, however without this search will still work and delivery good results.\n// We currently support the languages which are supported by Mongo by default but more languages\n// are available through custom configuration.\nconst supportedLanguages = [\"da\", \"nl\", \"en\", \"fi\", \"fr\", \"de\", \"hu\", \"it\", \"nb\", \"pt\", \"ro\", \"ru\", \"es\", \"sv\", \"tr\"];\n\n\nfunction filterFields(customFields) {\n  const fieldNames = [];\n  const fieldKeys = Object.keys(customFields);\n  for (const fieldKey of fieldKeys) {\n    if (customFields[fieldKey]) {\n      fieldNames.push(fieldKey);\n    }\n  }\n  return fieldNames;\n}\n\n// get the weights for all enabled fields\nfunction getScores(customFields, settings, collection = \"products\") {\n  const weightObject = {};\n  for (const weight of Object.keys(settings[collection].weights)) {\n    if (customFields.includes(weight)) {\n      weightObject[weight] = settings[collection].weights[weight];\n    }\n  }\n  return weightObject;\n}\n\nfunction getSearchLanguage() {\n  const shopId = Reaction.getShopId();\n  const shopLanguage = Shops.findOne(shopId).language;\n  if (supportedLanguages.includes(shopLanguage)) {\n    return { default_language: shopLanguage };\n  }\n  return { default_language: \"en\" };\n}\n\n/**\n * handleIndexUpdateFailures\n * When using Collection.rawCollection() methods that return a Promise,\n * handle the errors in a catch. However, ignore errors with altering indexes\n * before a collection exists.\n * @param  {Error} error an error object returned from a Promise rejection\n * @return {undefined}   doesn't return anything\n */\nfunction handleIndexUpdateFailures(error) {\n  // If we get an error from the Mongo driver because something tried to drop a\n  // collection before it existed, log it out as debug info.\n  // Otherwise, log whatever happened as an error.\n  if (error.name === \"MongoError\" && error.message === \"ns not found\") {\n    Logger.debug(error, \"Attempted to set or remove indexes in a Mongo collection that doesn't exist yet\");\n  } else {\n    Logger.error(error);\n  }\n}\n\nexport function getSearchParameters(collection = \"products\") {\n  const settings = utils.getPackageSettings();\n  const customFields = filterFields(settings[collection].includes);\n  const fieldSet = requiredFields[collection].concat(customFields);\n  const weightObject = getScores(customFields, settings);\n  return { fieldSet, weightObject, customFields };\n}\n\nexport function buildProductSearchRecord(productId) {\n  const product = Products.findOne(productId);\n  if (product.type === \"simple\") {\n    const { fieldSet } = getSearchParameters();\n    const productRecord = {};\n    for (const field of fieldSet) {\n      if (transformations.products[field]) {\n        productRecord[field] = transformations.products[field](product[field]);\n      } else {\n        productRecord[field] = product[field];\n      }\n    }\n    const productSearchRecord = ProductSearch.insert(productRecord);\n    ensureProductSearchIndex();\n    return productSearchRecord;\n  }\n  return undefined;\n}\n\nexport function buildProductSearch(cb) {\n  check(cb, Match.Optional(Function));\n  Logger.debug(\"Start (re)Building ProductSearch Collection\");\n  ProductSearch.remove({});\n  const { fieldSet, weightObject, customFields } = getSearchParameters();\n  const products = Products.find({ type: \"simple\" }).fetch();\n  for (const product of products) {\n    const productRecord = {};\n    for (const field of fieldSet) {\n      if (transformations.products[field]) {\n        productRecord[field] = transformations.products[field](product[field]);\n      } else {\n        productRecord[field] = product[field];\n      }\n    }\n    ProductSearch.insert(productRecord);\n  }\n  const indexObject = {};\n  for (const field of customFields) {\n    indexObject[field] = \"text\";\n  }\n\n  const rawProductSearchCollection = ProductSearch.rawCollection();\n  rawProductSearchCollection.dropIndexes().catch(handleIndexUpdateFailures);\n  rawProductSearchCollection.createIndex(indexObject, weightObject, getSearchLanguage()).catch(handleIndexUpdateFailures);\n  if (cb) {\n    cb();\n  }\n}\n\n// we build this immediately on startup so that search will not throw an error\nexport function buildEmptyProductSearch() {\n  const { weightObject, customFields } = getSearchParameters();\n  const indexObject = {};\n  for (const field of customFields) {\n    indexObject[field] = \"text\";\n  }\n  const rawProductSearchCollection = ProductSearch.rawCollection();\n  rawProductSearchCollection.dropIndexes().catch(handleIndexUpdateFailures);\n  rawProductSearchCollection.createIndex(indexObject, weightObject, getSearchLanguage()).catch(handleIndexUpdateFailures);\n}\n\nexport function rebuildProductSearchIndex(cb) {\n  check(cb, Match.Optional(Function));\n  const { customFields, weightObject } = getSearchParameters();\n  const indexObject = {};\n  for (const field of customFields) {\n    indexObject[field] = \"text\";\n  }\n  const rawProductSearchCollection = ProductSearch.rawCollection();\n  rawProductSearchCollection.dropIndexes().catch(handleIndexUpdateFailures);\n  rawProductSearchCollection.createIndex(indexObject, weightObject, getSearchLanguage()).catch(handleIndexUpdateFailures);\n  if (cb) {\n    cb();\n  }\n}\n\n// this only creates the index if it doesn't already exist, `ensureIndex` is deprecated\nexport function ensureProductSearchIndex() {\n  const { customFields, weightObject } = getSearchParameters();\n  const indexObject = {};\n  for (const field of customFields) {\n    indexObject[field] = \"text\";\n  }\n  const rawProductSearchCollection = ProductSearch.rawCollection();\n  rawProductSearchCollection.createIndex(indexObject, weightObject, getSearchLanguage()).catch(handleIndexUpdateFailures);\n}\n\nexport function buildOrderSearchRecord(orderId) {\n  const order = Orders.findOne(orderId);\n  const user = Meteor.users.findOne(order.userId);\n  const anonymousUserEmail = order.email;\n\n  const userEmails = [];\n  if (user && user.emails.length) {\n    for (const email of user.emails) {\n      userEmails.push(email.address);\n    }\n  } else if (anonymousUserEmail) {\n    userEmails.push(anonymousUserEmail);\n  }\n  const orderSearch = {};\n  for (const field of requiredFields.orders) {\n    if (transformations.orders[field]) {\n      orderSearch[field] = transformations.orders[field](order[field]);\n    } else {\n      orderSearch[field] = order[field];\n    }\n  }\n\n  // get the billing object for the current shop on the order (and not hardcoded [0])\n  const shopBilling = (order.billing && order.billing.find((billing) => billing && billing.shopId === Reaction.getShopId())) || {};\n\n  // get the shipping object for the current shop on the order (and not hardcoded [0])\n  const shopShipping = order.shipping.find((shipping) => shipping.shopId === Reaction.getShopId()) || {};\n\n  Promise.await(lazyLoadMoment());\n\n  orderSearch.billingName = shopBilling.address && shopBilling.address.fullName;\n  orderSearch.billingPhone = shopBilling.address && shopBilling.address.phone.replace(/\\D/g, \"\");\n  orderSearch.shippingName = shopShipping.address && shopShipping.address.fullName;\n  if (shopShipping.address && shopShipping.address.phone) {\n    orderSearch.shippingPhone = shopShipping.address && shopShipping.address.phone.replace(/\\D/g, \"\");\n  }\n\n  orderSearch.billingAddress = {\n    address: shopBilling.address && shopBilling.address.address1,\n    postal: shopBilling.address && shopBilling.address.postal,\n    city: shopBilling.address && shopBilling.address.city,\n    region: shopBilling.address && shopBilling.address.region,\n    country: shopBilling.address && shopBilling.address.country\n  };\n  orderSearch.shippingAddress = {\n    address: shopShipping.address && shopShipping.address.address1,\n    postal: shopShipping.address && shopShipping.address.postal,\n    city: shopShipping.address && shopShipping.address.city,\n    region: shopShipping.address && shopShipping.address.region,\n    country: shopShipping.address && shopShipping.address.country\n  };\n  orderSearch.userEmails = userEmails;\n  orderSearch.orderTotal = shopBilling.invoice && shopBilling.invoice.total;\n  orderSearch.orderDate = moment && moment(order.createdAt).format(\"YYYY/MM/DD\");\n  orderSearch.billingStatus = shopBilling.paymentMethod && shopBilling.paymentMethod.status;\n  orderSearch.billingCard = shopBilling.paymentMethod && shopBilling.paymentMethod.storedCard;\n  orderSearch.currentWorkflowStatus = order.workflow.status;\n  if (shopShipping.shipped) {\n    orderSearch.shippingStatus = \"Shipped\";\n  } else if (shopShipping.packed) {\n    orderSearch.shippingStatus = \"Packed\";\n  } else {\n    orderSearch.shippingStatus = \"New\";\n  }\n  orderSearch.product = {};\n  orderSearch.variants = {};\n  orderSearch.product.title = order.items.map((item) => item.product && item.product.title);\n  orderSearch.variants.title = order.items.map((item) => item.variants && item.variants.title);\n  orderSearch.variants.optionTitle = order.items.map((item) => item.variants && item.variants.optionTitle);\n\n  try {\n    OrderSearch.upsert(orderId, { $set: { ...orderSearch } });\n  } catch (error) {\n    Logger.error(error, \"Failed to add order to the OrderSearch collection\");\n  }\n}\n\nexport function buildOrderSearch(cb) {\n  check(cb, Match.Optional(Function));\n  const orders = Orders.find({}).fetch();\n  for (const order of orders) {\n    buildOrderSearchRecord(order._id);\n  }\n  const rawOrderSearchCollection = OrderSearch.rawCollection();\n  rawOrderSearchCollection.dropIndexes().catch(handleIndexUpdateFailures);\n  rawOrderSearchCollection.createIndex({\n    shopId: 1, shippingName: 1, billingName: 1, userEmails: 1\n  }).catch(handleIndexUpdateFailures);\n  if (cb) {\n    cb();\n  }\n}\n\nexport function buildAccountSearchRecord(accountId, updatedFields) {\n  Logger.debug(\"building account search record\");\n  check(accountId, String);\n  check(updatedFields, Array);\n\n  const account = Accounts.findOne(accountId);\n  // let's ignore anonymous accounts\n  if (account && account.emails && account.emails.length) {\n    const accountSearch = {};\n\n    // Not all required fields are used in search\n    // We need to filter through fields that are used,\n    // and only update the search index if one of those fields were updated\n    // forceIndex is included to forceIndexing on startup, or when manually added\n    const searchableFields = [\"forceIndex\", \"shopId\", \"emails\", \"firstName\", \"lastName\", \"phone\"];\n\n    const shouldRunIndex = updatedFields && updatedFields.some((field) => searchableFields.includes(field));\n\n    // If updatedFields contains one of the searchableFields, run the indexing\n    if (shouldRunIndex) {\n      AccountSearch.remove(accountId);\n      for (const field of requiredFields.accounts) {\n        if (transformations.accounts[field]) {\n          accountSearch[field] = transformations.accounts[field](account[field]);\n        } else {\n          accountSearch[field] = account[field];\n        }\n      }\n      AccountSearch.insert(accountSearch);\n    }\n  }\n}\n\nexport function buildAccountSearch(cb) {\n  check(cb, Match.Optional(Function));\n  AccountSearch.remove({});\n  const accounts = Accounts.find({}).fetch();\n  for (const account of accounts) {\n    // Passing forceIndex will run account search index even if\n    // updated fields don't match a searchable field\n    buildAccountSearchRecord(account._id, [\"forceIndex\"]);\n  }\n  const rawAccountSearchCollection = AccountSearch.rawCollection();\n  rawAccountSearchCollection.dropIndexes().catch(handleIndexUpdateFailures);\n  rawAccountSearchCollection.createIndex({ shopId: 1, emails: 1 }).catch(handleIndexUpdateFailures);\n  if (cb) {\n    cb();\n  }\n}\n"]},"sourceType":"script","hash":"f399ab8b9a8b77195b5bfab7cef4d5a41d453d84"}
