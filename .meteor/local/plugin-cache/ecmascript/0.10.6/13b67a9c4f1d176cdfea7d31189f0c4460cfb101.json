{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$1$2","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"ast":true,"babelrc":false,"sourceFileName":"imports/plugins/core/revisions/server/methods.js","filename":"imports/plugins/core/revisions/server/methods.js","sourceMaps":true,"envName":"development","cwd":"/Users/estebandev/test-knowledge","passPerPreset":false,"presets":[],"parserOpts":{"sourceType":"module","sourceFileName":"imports/plugins/core/revisions/server/methods.js","plugins":["jsx","jsx","flow","flow","objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties"]},"generatorOpts":{"filename":"imports/plugins/core/revisions/server/methods.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"imports/plugins/core/revisions/server/methods.js"}},"code":"var _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/builtin/objectSpread\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nmodule.export({\n  updateSettings: () => updateSettings,\n  discardDrafts: () => discardDrafts\n});\nlet Meteor;\nmodule.watch(require(\"meteor/meteor\"), {\n  Meteor(v) {\n    Meteor = v;\n  }\n\n}, 0);\nlet check, Match;\nmodule.watch(require(\"meteor/check\"), {\n  check(v) {\n    check = v;\n  },\n\n  Match(v) {\n    Match = v;\n  }\n\n}, 1);\nlet Products, MediaRecords, Revisions, Packages;\nmodule.watch(require(\"../../../../../lib/collections\"), {\n  Products(v) {\n    Products = v;\n  },\n\n  MediaRecords(v) {\n    MediaRecords = v;\n  },\n\n  Revisions(v) {\n    Revisions = v;\n  },\n\n  Packages(v) {\n    Packages = v;\n  }\n\n}, 2);\nlet Hooks, Logger;\nmodule.watch(require(\"../../../../../server/api\"), {\n  Hooks(v) {\n    Hooks = v;\n  },\n\n  Logger(v) {\n    Logger = v;\n  }\n\n}, 3);\n\nfunction handleImageRevision(revision) {\n  let result = 0;\n\n  if (revision.changeType === \"insert\") {\n    result = MediaRecords.update({\n      _id: revision.documentId\n    }, {\n      $set: {\n        metadata: (0, _objectSpread2.default)({}, revision.documentData, {\n          workflow: \"published\"\n        })\n      }\n    });\n  } else if (revision.changeType === \"remove\") {\n    result = MediaRecords.update({\n      _id: revision.documentId\n    }, {\n      $set: {\n        \"metadata.workflow\": \"archived\"\n      }\n    });\n  } else if (revision.changeType === \"update\") {\n    result = MediaRecords.update({\n      _id: revision.documentId\n    }, {\n      $set: {\n        metadata: (0, _objectSpread2.default)({}, revision.documentData, {\n          workflow: \"published\"\n        })\n      }\n    });\n    Logger.debug(`setting metadata for ${revision.documentId} to ${JSON.stringify(revision.documentData, null, 4)}`);\n  } // mark revision published whether we are publishing the image or not\n\n\n  Revisions.update({\n    _id: revision._id\n  }, {\n    $set: {\n      \"workflow.status\": \"revision/published\"\n    }\n  });\n  return result;\n}\n\nfunction updateSettings(settings) {\n  check(settings, Object);\n  Packages.update({\n    name: \"reaction-revisions\"\n  }, {\n    $set: {\n      settings\n    }\n  });\n}\n\n/**\n * @function\n * @name publishCatalogProduct\n * @description Updates revision and publishes a product.\n *\n * @param {String} userId - currently logged in user\n * @param {Object} selector - selector for product to update\n * @param {Object} modifier - Object describing what parts of the document to update.\n * @param {Object} validation - simple schema validation\n * @return {String} _id of updated document\n */\nfunction publishCatalogProduct(userId, selector, modifier, validation) {\n  const product = Products.findOne(selector);\n  const options = {\n    userId,\n    modifier,\n    validation,\n    publish: true\n  };\n  Hooks.Events.run(\"beforeUpdateCatalogProduct\", product, options);\n  const result = Products.update(selector, modifier, validation);\n  Hooks.Events.run(\"afterUpdateCatalogProduct\", product, options); // Records are not remove from the Products collection, they are only flagged as deleted.\n  // Run Hook to remove search record, if a product is being published as deleted\n  // Which is the equivalent to removing a product.\n\n  if (modifier.$set.isDeleted === true) {\n    Hooks.Events.run(\"afterRemoveProduct\", product);\n  }\n\n  return result;\n}\n\nfunction discardDrafts(documentIds) {\n  check(documentIds, Match.OneOf(String, Array));\n  let documentIdArray;\n\n  if (Array.isArray(documentIds)) {\n    documentIdArray = documentIds;\n  } else {\n    documentIdArray = [documentIds];\n  }\n\n  const selector = {\n    \"workflow.status\": {\n      $nin: [\"revision/published\"]\n    },\n    \"$or\": [{\n      documentId: {\n        $in: documentIdArray\n      }\n    }, {\n      \"documentData.ancestors\": {\n        $in: documentIdArray\n      }\n    }, {\n      parentDocument: {\n        $in: documentIds\n      }\n    }]\n  };\n  const result = Revisions.remove(selector);\n  return result > 0;\n}\n\nMeteor.methods({\n  \"revisions/settings/update\": updateSettings,\n  \"revisions/discard\": discardDrafts,\n\n  \"revisions/publish\"(documentIds) {\n    check(documentIds, Match.OneOf(String, Array)); // Also publish variants if they have a draft\n\n    let revisions;\n\n    if (Array.isArray(documentIds)) {\n      revisions = Revisions.find({\n        \"workflow.status\": {\n          $nin: [\"revision/published\"]\n        },\n        \"$or\": [{\n          documentId: {\n            $in: documentIds\n          }\n        }, {\n          \"documentData.ancestors\": {\n            $in: documentIds\n          }\n        }, {\n          parentDocument: {\n            $in: documentIds\n          }\n        }]\n      }).fetch();\n    } else {\n      revisions = Revisions.find({\n        \"workflow.status\": {\n          $nin: [\"revision/published\"]\n        },\n        \"$or\": [{\n          documentId: documentIds\n        }, {\n          \"documentData.ancestors\": {\n            $in: [documentIds]\n          }\n        }]\n      }).fetch();\n    }\n\n    let updatedDocuments = 0;\n\n    if (revisions) {\n      for (const revision of revisions) {\n        if (!revision.documentType || revision.documentType === \"product\") {\n          const res = publishCatalogProduct(this.userId, {\n            _id: revision.documentId\n          }, {\n            $set: revision.documentData\n          });\n          updatedDocuments += res;\n        } else if (revision.documentType === \"image\") {\n          updatedDocuments += handleImageRevision(revision);\n        }\n      }\n    }\n\n    if (updatedDocuments > 0) {\n      return {\n        status: \"success\"\n      };\n    }\n\n    return false;\n  }\n\n});","map":{"version":3,"sources":["imports/plugins/core/revisions/server/methods.js"],"names":["module","export","updateSettings","discardDrafts","Meteor","watch","require","v","check","Match","Products","MediaRecords","Revisions","Packages","Hooks","Logger","handleImageRevision","revision","result","changeType","update","_id","documentId","$set","metadata","documentData","workflow","debug","JSON","stringify","settings","Object","name","publishCatalogProduct","userId","selector","modifier","validation","product","findOne","options","publish","Events","run","isDeleted","documentIds","OneOf","String","Array","documentIdArray","isArray","$nin","$in","parentDocument","remove","methods","revisions","find","fetch","updatedDocuments","documentType","res","status"],"mappings":"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","sourcesContent":["import { Meteor } from \"meteor/meteor\";\nimport { check, Match } from \"meteor/check\";\nimport { Products, MediaRecords, Revisions, Packages } from \"/lib/collections\";\nimport { Hooks, Logger } from \"/server/api\";\n\nfunction handleImageRevision(revision) {\n  let result = 0;\n  if (revision.changeType === \"insert\") {\n    result = MediaRecords.update({\n      _id: revision.documentId\n    }, {\n      $set: {\n        metadata: { ...revision.documentData, workflow: \"published\" }\n      }\n    });\n  } else if (revision.changeType === \"remove\") {\n    result = MediaRecords.update({\n      _id: revision.documentId\n    }, {\n      $set: {\n        \"metadata.workflow\": \"archived\"\n      }\n    });\n  } else if (revision.changeType === \"update\") {\n    result = MediaRecords.update({\n      _id: revision.documentId\n    }, {\n      $set: {\n        metadata: { ...revision.documentData, workflow: \"published\" }\n      }\n    });\n    Logger.debug(`setting metadata for ${revision.documentId} to ${JSON.stringify(revision.documentData, null, 4)}`);\n  }\n  // mark revision published whether we are publishing the image or not\n  Revisions.update({\n    _id: revision._id\n  }, {\n    $set: {\n      \"workflow.status\": \"revision/published\"\n    }\n  });\n\n  return result;\n}\n\nexport function updateSettings(settings) {\n  check(settings, Object);\n\n  Packages.update({\n    name: \"reaction-revisions\"\n  }, {\n    $set: {\n      settings\n    }\n  });\n}\n\n/**\n * @function\n * @name publishCatalogProduct\n * @description Updates revision and publishes a product.\n *\n * @param {String} userId - currently logged in user\n * @param {Object} selector - selector for product to update\n * @param {Object} modifier - Object describing what parts of the document to update.\n * @param {Object} validation - simple schema validation\n * @return {String} _id of updated document\n */\nfunction publishCatalogProduct(userId, selector, modifier, validation) {\n  const product = Products.findOne(selector);\n  const options = {\n    userId,\n    modifier,\n    validation,\n    publish: true\n  };\n\n  Hooks.Events.run(\"beforeUpdateCatalogProduct\", product, options);\n\n  const result = Products.update(selector, modifier, validation);\n\n  Hooks.Events.run(\"afterUpdateCatalogProduct\", product, options);\n\n  // Records are not remove from the Products collection, they are only flagged as deleted.\n  // Run Hook to remove search record, if a product is being published as deleted\n  // Which is the equivalent to removing a product.\n  if (modifier.$set.isDeleted === true) {\n    Hooks.Events.run(\"afterRemoveProduct\", product);\n  }\n\n  return result;\n}\n\nexport function discardDrafts(documentIds) {\n  check(documentIds, Match.OneOf(String, Array));\n\n  let documentIdArray;\n\n  if (Array.isArray(documentIds)) {\n    documentIdArray = documentIds;\n  } else {\n    documentIdArray = [documentIds];\n  }\n\n  const selector = {\n    \"workflow.status\": {\n      $nin: [\n        \"revision/published\"\n      ]\n    },\n    \"$or\": [\n      {\n        documentId: {\n          $in: documentIdArray\n        }\n      },\n      {\n        \"documentData.ancestors\": {\n          $in: documentIdArray\n        }\n      },\n      {\n        parentDocument: {\n          $in: documentIds\n        }\n      }\n    ]\n  };\n\n  const result = Revisions.remove(selector);\n\n  return result > 0;\n}\n\nMeteor.methods({\n  \"revisions/settings/update\": updateSettings,\n  \"revisions/discard\": discardDrafts,\n  \"revisions/publish\"(documentIds) {\n    check(documentIds, Match.OneOf(String, Array));\n\n    // Also publish variants if they have a draft\n    let revisions;\n\n    if (Array.isArray(documentIds)) {\n      revisions = Revisions.find({\n        \"workflow.status\": {\n          $nin: [\n            \"revision/published\"\n          ]\n        },\n        \"$or\": [\n          {\n            documentId: {\n              $in: documentIds\n            }\n          },\n          {\n            \"documentData.ancestors\": {\n              $in: documentIds\n            }\n          },\n          {\n            parentDocument: {\n              $in: documentIds\n            }\n          }\n        ]\n      }).fetch();\n    } else {\n      revisions = Revisions.find({\n        \"workflow.status\": {\n          $nin: [\n            \"revision/published\"\n          ]\n        },\n        \"$or\": [\n          { documentId: documentIds },\n          {\n            \"documentData.ancestors\": {\n              $in: [documentIds]\n            }\n          }\n        ]\n      }).fetch();\n    }\n\n    let updatedDocuments = 0;\n    if (revisions) {\n      for (const revision of revisions) {\n        if (!revision.documentType || revision.documentType === \"product\") {\n          const res = publishCatalogProduct(\n            this.userId,\n            {\n              _id: revision.documentId\n            },\n            {\n              $set: revision.documentData\n            }\n          );\n          updatedDocuments += res;\n        } else if (revision.documentType === \"image\") {\n          updatedDocuments += handleImageRevision(revision);\n        }\n      }\n    }\n\n    if (updatedDocuments > 0) {\n      return {\n        status: \"success\"\n      };\n    }\n\n    return false;\n  }\n});\n"]},"sourceType":"script","hash":"13b67a9c4f1d176cdfea7d31189f0c4460cfb101"}
