{"metadata":{},"options":{"plugins":[{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$2","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":false}},{"key":"base$0$3","visitor":{"_exploded":{},"_verified":{},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}},{"key":"base$0$4","visitor":{"FunctionExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"ForInStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$6","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$0$1$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$1$2","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$2","visitor":{"ArrowFunctionExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$3","visitor":{"BlockStatement":{"enter":[null]},"SwitchCase":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$4","visitor":{"VariableDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"_exploded":true,"BlockStatement":{"enter":[null]},"SwitchStatement":{"enter":[null]},"Program":{"enter":[null]},"_verified":true,"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"base$0$0$5","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"base$0$0$6","visitor":{"ObjectExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"base$0$0$7","visitor":{"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"VariableDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"base$0$0$8","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"base$0$0$9","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$10","visitor":{"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$11","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]}},"options":{}},{"key":"base$0$0$12","visitor":{"ObjectMethod":{"enter":[null]},"ObjectProperty":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$13","visitor":{"ArrayExpression":{"enter":[null]},"CallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$14","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$15","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"base$0$0$16","visitor":{"UnaryExpression":{"enter":[null]},"_exploded":true,"_verified":true,"BlockStatement":{"enter":[null]},"CatchClause":{"enter":[null]},"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"Program":{"enter":[null]},"ObjectMethod":{"enter":[null]},"SwitchStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"ForOfStatement":{"enter":[null]},"ClassMethod":{"enter":[null]}},"options":{}},{"key":"base$0$0$17","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$18","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$19","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"base$0$0$20","visitor":{"ObjectProperty":{"exit":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$21","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$0$22","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$23","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"regenerator-transform","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{}}],"presets":[],"compact":false,"ast":true,"babelrc":false,"sourceFileName":"imports/plugins/core/orders/client/containers/orderTableContainer.js","filename":"imports/plugins/core/orders/client/containers/orderTableContainer.js","sourceMaps":true,"envName":"development","cwd":"/Users/estebandev/test-knowledge","passPerPreset":false,"parserOpts":{"sourceType":"module","sourceFileName":"imports/plugins/core/orders/client/containers/orderTableContainer.js","plugins":["dynamicImport","classProperties","jsx","jsx","flow","asyncGenerators","objectRestSpread","objectRestSpread","flow","asyncGenerators"]},"generatorOpts":{"filename":"imports/plugins/core/orders/client/containers/orderTableContainer.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"imports/plugins/core/orders/client/containers/orderTableContainer.js"}},"code":"var _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _objectSpread5 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread\"));\n\nvar _inheritsLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inheritsLoose\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _compose;\n\nmodule.watch(require(\"recompose/compose\"), {\n  \"default\": function (v) {\n    _compose = v;\n  }\n}, 0);\nvar React, Component;\nmodule.watch(require(\"react\"), {\n  \"default\": function (v) {\n    React = v;\n  },\n  Component: function (v) {\n    Component = v;\n  }\n}, 1);\nvar Meteor;\nmodule.watch(require(\"meteor/meteor\"), {\n  Meteor: function (v) {\n    Meteor = v;\n  }\n}, 2);\nvar Reaction, i18next;\nmodule.watch(require(\"../../../../../../client/api\"), {\n  Reaction: function (v) {\n    Reaction = v;\n  },\n  i18next: function (v) {\n    i18next = v;\n  }\n}, 3);\nvar getPrimaryMediaForOrderItem;\nmodule.watch(require(\"../../../../../../lib/api\"), {\n  getPrimaryMediaForOrderItem: function (v) {\n    getPrimaryMediaForOrderItem = v;\n  }\n}, 4);\nvar registerComponent;\nmodule.watch(require(\"../../../components/lib\"), {\n  registerComponent: function (v) {\n    registerComponent = v;\n  }\n}, 5);\nvar getShippingInfo;\nmodule.watch(require(\"../helpers\"), {\n  getShippingInfo: function (v) {\n    getShippingInfo = v;\n  }\n}, 6);\nvar PACKAGE_NAME, ORDER_LIST_FILTERS_PREFERENCE_NAME, ORDER_LIST_SELECTED_ORDER_PREFERENCE_NAME, shippingStates;\nmodule.watch(require(\"../../lib/constants\"), {\n  PACKAGE_NAME: function (v) {\n    PACKAGE_NAME = v;\n  },\n  ORDER_LIST_FILTERS_PREFERENCE_NAME: function (v) {\n    ORDER_LIST_FILTERS_PREFERENCE_NAME = v;\n  },\n  ORDER_LIST_SELECTED_ORDER_PREFERENCE_NAME: function (v) {\n    ORDER_LIST_SELECTED_ORDER_PREFERENCE_NAME = v;\n  },\n  shippingStates: function (v) {\n    shippingStates = v;\n  }\n}, 7);\nvar OrderTable;\nmodule.watch(require(\"../components/orderTable\"), {\n  \"default\": function (v) {\n    OrderTable = v;\n  }\n}, 8);\nvar shippingStrings = [\"picked\", \"packed\", \"labeled\", \"shipped\"];\n\nvar wrapComponent = function (Comp) {\n  return (\n    /*#__PURE__*/\n    function (_Component) {\n      (0, _inheritsLoose2.default)(OrderTableContainer, _Component);\n\n      function OrderTableContainer(props) {\n        var _this;\n\n        _this = _Component.call(this, props) || this;\n\n        _this.toggleShippingFlowList = function () {\n          _this.setState({\n            renderFlowList: !_this.state.renderFlowList\n          });\n\n          _this.setListItemsToDefault();\n        };\n\n        _this.handleSelect = function (event, isInputChecked, name) {\n          _this.setState({\n            multipleSelect: false,\n            renderFlowList: false\n          });\n\n          shippingStrings.forEach(function (value) {\n            var _shipping;\n\n            _this.setState({\n              shipping: (_shipping = {}, _shipping[value] = false, _shipping)\n            });\n          });\n          var selectedItemsArray = _this.state.selectedItems;\n\n          if (!selectedItemsArray.includes(name)) {\n            selectedItemsArray.push(name);\n\n            _this.setState({\n              selectedItems: selectedItemsArray\n            });\n          } else {\n            var updatedSelectedArray = selectedItemsArray.filter(function (id) {\n              return id !== name;\n            });\n\n            _this.setState({\n              selectedItems: updatedSelectedArray\n            });\n          }\n        };\n\n        _this.selectAllOrders = function (orders, areAllSelected) {\n          _this.setState({\n            renderFlowList: false\n          });\n\n          shippingStrings.forEach(function (string) {\n            var _shipping2;\n\n            _this.setState({\n              shipping: (_shipping2 = {}, _shipping2[string] = false, _shipping2)\n            });\n          });\n\n          if (areAllSelected) {\n            // if all orders are selected, clear the selectedItems array\n            // and set multipleSelect to false\n            _this.setState({\n              selectedItems: [],\n              multipleSelect: false\n            });\n          } else {\n            // if there are no selected orders, or if there are some orders that have been\n            // selected but not all of them, loop through the orders array and return a\n            // new array with order ids only, then set the selectedItems array with the orderIds\n            var orderIds = orders.map(function (order) {\n              return order._id;\n            });\n\n            _this.setState({\n              selectedItems: orderIds,\n              multipleSelect: true\n            });\n          }\n        };\n\n        _this.handleClick = function (order) {\n          var startWorkflow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n          Reaction.setActionViewDetail({\n            label: \"Order Details\",\n            i18nKeyLabel: \"orderWorkflow.orderDetails\",\n            data: {\n              order: order\n            },\n            props: {\n              size: \"large\"\n            },\n            template: \"coreOrderWorkflow\"\n          });\n\n          if (startWorkflow === true) {\n            Meteor.call(\"workflow/pushOrderWorkflow\", \"coreOrderWorkflow\", \"processing\", order);\n            Reaction.setUserPreferences(PACKAGE_NAME, ORDER_LIST_FILTERS_PREFERENCE_NAME, \"processing\");\n          }\n          /* TODO:\n          a) What other routes have a query parameter of _id=XXXXXXX ?\n          b) What exactly are we using the order dashboard for? If it's search,\n           well, clicking a search result doesn't CURRENTLY do anything. What's\n           more, there's some debate as to whether that SHOULD link to anywhere.\n           And if it should, why not the existing, modal orders panel?\n          */\n\n\n          Reaction.setUserPreferences(PACKAGE_NAME, ORDER_LIST_SELECTED_ORDER_PREFERENCE_NAME, order._id);\n        };\n\n        _this.updateBulkStatusHelper = function (status) {\n          var statusIndex = shippingStrings.indexOf(status);\n          return shippingStrings.reduce(function (shipping, state) {\n            var _objectSpread2;\n\n            return (0, _objectSpread5.default)({}, shipping, (_objectSpread2 = {}, _objectSpread2[state] = shippingStrings.indexOf(state) <= statusIndex, _objectSpread2));\n          }, {});\n        };\n\n        _this.updateBulkLoadingHelper = function (status) {\n          var statusIndex = shippingStrings.indexOf(status);\n          var prevStatusIndex = Object.keys(_this.state.shipping).reduce(function (maxIndex, state) {\n            if (_this.state.shipping[state]) {\n              return Math.max(shippingStrings.indexOf(state), maxIndex);\n            }\n\n            return maxIndex;\n          }, -1);\n          return shippingStrings.reduce(function (shipping, state) {\n            var _objectSpread4;\n\n            if (prevStatusIndex < statusIndex) {\n              var _objectSpread3;\n\n              return (0, _objectSpread5.default)({}, shipping, (_objectSpread3 = {}, _objectSpread3[state] = shippingStrings.indexOf(state) <= statusIndex && shippingStrings.indexOf(state) > prevStatusIndex, _objectSpread3));\n            }\n\n            return (0, _objectSpread5.default)({}, shipping, (_objectSpread4 = {}, _objectSpread4[state] = shippingStrings.indexOf(state) >= statusIndex && shippingStrings.indexOf(state) <= prevStatusIndex, _objectSpread4));\n          }, {});\n        };\n\n        _this.shippingStatusUpdateCall = function (selectedOrders, status) {\n          var filteredSelectedOrders = selectedOrders.filter(function (order) {\n            return order.shipping && Object.keys(getShippingInfo(order)).length;\n          });\n\n          _this.setState({\n            isLoading: _this.updateBulkLoadingHelper(status)\n          });\n\n          var orderText = \"order\";\n\n          if (filteredSelectedOrders.length > 1) {\n            orderText = \"orders\";\n          } // capitalize the first letter of the shipping status passed in\n          // e.g. 'shipped' becomes 'Shipped'.\n          // status[0].toUpperCase() capitalizes the first letter of the string\n          // status.substr(1).toLowerCase() converts every other letter to lower case\n\n\n          var capitalizeStatus = status[0].toUpperCase() + status.substr(1).toLowerCase();\n          var orderCount = 0; // TODO: send these orders in batch as an array. This would entail re-writing the Meteor calls to update the\n          // different shipping statuses to receive an array of objects(orders) as a param\n          // TODO: rethink this type of flow for updating shipping statuses\n\n          filteredSelectedOrders.forEach(function (order) {\n            var shippingRecord = getShippingInfo(order);\n            Meteor.call(\"orders/shipment\" + capitalizeStatus, order, shippingRecord, function (error) {\n              if (error) {\n                Alerts.toast(\"An error occured while setting the status: \" + error, \"error\");\n              } else {\n                Meteor.call(\"orders/updateHistory\", order._id, \"Shipping state set by bulk operation\", status);\n              }\n\n              orderCount += 1;\n\n              if (orderCount === filteredSelectedOrders.length) {\n                var _isLoading;\n\n                _this.setState({\n                  shipping: _this.updateBulkStatusHelper(status),\n                  isLoading: (_isLoading = {}, _isLoading[status] = false, _isLoading)\n                });\n\n                Alerts.alert({\n                  text: i18next.t(\"order.orderSetToState\", {\n                    orderNumber: filteredSelectedOrders.length,\n                    orderText: orderText,\n                    status: status\n                  }),\n                  type: \"success\",\n                  allowOutsideClick: false\n                });\n              }\n            });\n          });\n        };\n\n        _this.displayAlert = function (selectedOrders, status, options) {\n          // capitalize the first letter of the shipping status passed in\n          // e.g. 'shipped' becomes 'Shipped'.\n          // status[0].toUpperCase() capitalizes the first letter of the string\n          // status.substr(1).toLowerCase() converts every other letter to lower case\n          var capitalizeStatus = status[0].toUpperCase() + status.substr(1).toLowerCase();\n          var alertOptions = options || {};\n          var orderText = \"order\";\n          var skippedOrdersText = \"is\";\n          var orderAlreadyInStateText = \"Order has\";\n\n          if (selectedOrders.length > 1) {\n            orderText = \"orders\";\n            orderAlreadyInStateText = \"Orders have\";\n          }\n\n          if (alertOptions.falsePreviousStatuses > 1) {\n            skippedOrdersText = \"are\";\n          } // if the order(s) want to skip the previous states, display alert\n\n\n          if (alertOptions.falsePreviousStatuses) {\n            Alerts.alert({\n              text: i18next.t(\"order.skippedBulkOrdersAlert\", {\n                selectedOrders: selectedOrders.length,\n                orderText: orderText,\n                status: capitalizeStatus,\n                numberOfSkippedOrders: alertOptions.falsePreviousStatuses,\n                skippedOrdersText: skippedOrdersText,\n                skippedState: alertOptions.whichFalseState\n              }),\n              type: \"warning\",\n              showCancelButton: true,\n              showCloseButton: true,\n              allowOutsideClick: false,\n              confirmButtonText: i18next.t(\"order.approveBulkOrderAction\"),\n              cancelButtonText: i18next.t(\"order.cancelBulkOrderAction\")\n            }, function (setSelected) {\n              if (setSelected) {\n                // set status of order(s) if this action is confirmed\n                _this.shippingStatusUpdateCall(selectedOrders, status);\n              }\n            }); // if the order(s) are following proper flow, set the status\n          } else if (!alertOptions.falsePreviousStatuses && alertOptions.falseCurrentState) {\n            _this.shippingStatusUpdateCall(selectedOrders, status); // display alert if order(s) are already in this state\n\n          } else if (!alertOptions.falsePreviousStatuses && !alertOptions.falseCurrentState && alertOptions.trueCurrentState) {\n            Alerts.alert({\n              text: i18next.t(\"order.orderAlreadyInState\", {\n                orderText: orderAlreadyInStateText,\n                status: status\n              })\n            });\n          }\n        };\n\n        _this.displayRegressionAlert = function (selectedOrders, ordersToRegress, status, options) {\n          // capitalize the first letter of the shipping status passed in\n          // e.g. 'shipped' becomes 'Shipped'.\n          // status[0].toUpperCase() capitalizes the first letter of the string\n          // status.substr(1).toLowerCase() converts every other letter to lower case\n          var capitalizeStatus = status[0].toUpperCase() + status.substr(1).toLowerCase();\n          var alertOptions = options || {};\n          var orderText = \"order\";\n\n          if (ordersToRegress > 1) {\n            orderText = \"orders\";\n          }\n\n          Alerts.alert({\n            text: i18next.t(\"order.bulkOrdersRegressionAlert\", {\n              ordersToRegress: ordersToRegress,\n              orderText: orderText,\n              status: capitalizeStatus\n            }),\n            type: \"warning\",\n            showCancelButton: true,\n            showCloseButton: true,\n            allowOutsideClick: false,\n            confirmButtonText: i18next.t(\"order.approveBulkOrderActionRegression\"),\n            cancelButtonText: i18next.t(\"order.cancelBulkOrderAction\")\n          }, function (regress) {\n            if (regress) {\n              // if some of the order(s) want to skip the previous state, display warning alert for skipping states\n              if (alertOptions.falsePreviousStatuses) {\n                _this.displayAlert(selectedOrders, status, {\n                  whichFalseState: alertOptions.whichFalseState,\n                  falsePreviousStatuses: alertOptions.falsePreviousStatuses,\n                  falseCurrentState: alertOptions.falseCurrentState,\n                  trueCurrentState: alertOptions.trueCurrentState\n                });\n              } else {\n                // set status of order(s) if this action is confirmed\n                _this.shippingStatusUpdateCall(selectedOrders, status);\n              }\n            }\n          });\n        };\n\n        _this.pickedShippingStatus = function (selectedOrders, status) {\n          // counters to keep track of how many orders are not picked,\n          // are already picked, and how many are being regressed\n          var isNotPicked = 0;\n          var isPicked = 0;\n          var ordersToRegress = 0; // loop through selected orders array to determine the current shipping workflow\n          // status of each order in regard to the other statuses\n          // TODO: optimise this process to avoid having this similar repetitive block of code across 4 methods\n\n          selectedOrders.forEach(function (order) {\n            var orderWorkflow = getShippingInfo(order).workflow; // check if the order(s) are in this state already or in the previous state\n            // TODO: model this with the assumption that there may be different workflows\n            // depending on the type of shop or product that a shop is selling.\n\n            if (orderWorkflow) {\n              if (orderWorkflow.status === \"new\") {\n                isNotPicked += 1;\n              } else if (orderWorkflow.status === \"coreOrderWorkflow/picked\") {\n                isPicked += 1;\n              } else if (orderWorkflow.workflow.includes(\"coreOrderWorkflow/picked\")) {\n                ordersToRegress += 1;\n              } else if (!orderWorkflow.workflow.includes(\"coreOrderWorkflow/picked\") && (orderWorkflow.status === \"coreOrderWorkflow/packed\" || orderWorkflow.status === \"coreOrderWorkflow/labeled\" || orderWorkflow.status === \"coreOrderWorkflow/shipped\")) {\n                ordersToRegress += 1;\n              }\n            }\n          }); // display regression alert if order(s) are being regressed\n\n          if (ordersToRegress) {\n            _this.displayRegressionAlert(selectedOrders, ordersToRegress, status); // set status to 'picked' if order(s) are in the previous state OR\n            // display alert if order(s) are already in this state\n\n          } else {\n            _this.displayAlert(selectedOrders, status, {\n              falseCurrentState: isNotPicked,\n              trueCurrentState: isPicked\n            });\n          }\n        };\n\n        _this.packedShippingStatus = function (selectedOrders, status) {\n          // if an order state wants to skip to packed, this is the state being skipped\n          var whichFalseState = shippingStates.picked; // counters to keep track of how many orders are not picked/packed,\n          // are already packed, and how many are being regressed\n\n          var isNotPicked = 0;\n          var isNotPacked = 0;\n          var isPacked = 0;\n          var ordersToRegress = 0; // loop through selected orders array to determine the current shipping workflow\n          // status of each order in regard to the other statuses\n          // TODO: optimise this process to avoid having this similar repetitive block of code across 4 methods\n\n          selectedOrders.forEach(function (order) {\n            var orderWorkflow = getShippingInfo(order).workflow; // check if the order(s) are in this state already or in one of the previous states\n            // TODO: model this with the assumption that there may be different workflows\n            // depending on the type of shop or product that a shop is selling.\n\n            if (orderWorkflow) {\n              if (orderWorkflow.status === \"new\") {\n                isNotPicked += 1;\n              } else if (orderWorkflow.status === \"coreOrderWorkflow/picked\") {\n                isNotPacked += 1;\n              } else if (orderWorkflow.status === \"coreOrderWorkflow/packed\") {\n                isPacked += 1;\n              } else if (orderWorkflow.workflow.includes(\"coreOrderWorkflow/packed\")) {\n                // check if the selected order(s) are being regressed back to this state\n                ordersToRegress += 1;\n              } else if (!orderWorkflow.workflow.includes(\"coreOrderWorkflow/packed\") && (orderWorkflow.status === \"coreOrderWorkflow/labeled\" || orderWorkflow.status === \"coreOrderWorkflow/shipped\")) {\n                ordersToRegress += 1;\n              }\n            }\n          }); // display regression alert if order(s) are being regressed\n\n          if (ordersToRegress) {\n            _this.displayRegressionAlert(selectedOrders, ordersToRegress, status, {\n              whichFalseState: whichFalseState,\n              falsePreviousStatuses: isNotPicked,\n              falseCurrentState: isNotPacked,\n              trueCurrentState: isPacked\n            }); // display proper alert if the order(s) are in this state already or want to skip the previous states\n\n          } else {\n            _this.displayAlert(selectedOrders, status, {\n              whichFalseState: whichFalseState,\n              falsePreviousStatuses: isNotPicked,\n              falseCurrentState: isNotPacked,\n              trueCurrentState: isPacked\n            });\n          }\n        };\n\n        _this.labeledShippingStatus = function (selectedOrders, status) {\n          // string that will hold the state being skipped\n          var whichFalseState = \"\"; // counters to keep track of how many orders are not picked/packed/labeled,\n          // are already labeled, and how many are being regressed\n\n          var isNotPacked = 0;\n          var isNotLabeled = 0;\n          var isLabeled = 0;\n          var ordersToRegress = 0; // loop through selected orders array to determine the current shipping workflow\n          // status of each order in regard to the other statuses\n          // TODO: optimise this process to avoid having this similar repetitive block of code across 4 methods\n\n          selectedOrders.forEach(function (order) {\n            var orderWorkflow = getShippingInfo(order).workflow; // check if the order(s) are in this state already or in one of the previous states\n            // TODO: model this with the assumption that there may be different workflows\n            // depending on the type of shop or product that a shop is selling.\n\n            if (orderWorkflow) {\n              if (orderWorkflow.status === \"new\") {\n                isNotPacked += 1;\n                whichFalseState = shippingStates.picked;\n              } else if (orderWorkflow.status === \"coreOrderWorkflow/picked\") {\n                isNotPacked += 1;\n                whichFalseState = shippingStates.packed;\n              } else if (orderWorkflow.status === \"coreOrderWorkflow/packed\") {\n                isNotLabeled += 1;\n              } else if (orderWorkflow.status === \"coreOrderWorkflow/labeled\") {\n                isLabeled += 1;\n              } else if (orderWorkflow.workflow.includes(\"coreOrderWorkflow/labeled\") || orderWorkflow.status === \"coreOrderWorkflow/shipped\") {\n                // check if the selected order(s) are being regressed back to this state\n                ordersToRegress += 1;\n              }\n            }\n          }); // display regression alert if order(s) are being regressed\n\n          if (ordersToRegress) {\n            _this.displayRegressionAlert(selectedOrders, ordersToRegress, status, {\n              whichFalseState: whichFalseState,\n              falsePreviousStatuses: isNotPacked,\n              falseCurrentState: isNotLabeled,\n              trueCurrentState: isLabeled\n            }); // display proper alert if the order(s) are in this state already or want to skip the previous states\n\n          } else {\n            _this.displayAlert(selectedOrders, status, {\n              whichFalseState: whichFalseState,\n              falsePreviousStatuses: isNotPacked,\n              falseCurrentState: isNotLabeled,\n              trueCurrentState: isLabeled\n            });\n          }\n        };\n\n        _this.shippedShippingStatus = function (selectedOrders, status) {\n          // string that will hold the state being skipped\n          var whichFalseState = \"\"; // counters to keep track of how many orders are not picked/packed/labeled/shipped,\n          // are already shipped, and how many are being regressed\n\n          var isNotLabeled = 0;\n          var isNotShipped = 0;\n          var isShipped = 0; // loop through selected orders array to determine the current shipping workflow\n          // status of each order in regard to the other statuses\n          // TODO: optimise this process to avoid having this similar repetitive block of code across 4 methods\n\n          selectedOrders.forEach(function (order) {\n            var orderWorkflow = getShippingInfo(order).workflow; // check if the order(s) are in this state already or in one of the previous states\n            // TODO: model this with the assumption that there may be different workflows\n            // depending on the type of shop or product that a shop is selling.\n\n            if (orderWorkflow) {\n              var orderWorkflowStatus = orderWorkflow.status;\n\n              if (orderWorkflowStatus === \"new\") {\n                isNotLabeled += 1;\n                whichFalseState = shippingStates.picked;\n              } else if (orderWorkflowStatus === \"coreOrderWorkflow/picked\") {\n                isNotLabeled += 1;\n                whichFalseState = shippingStates.packed;\n              } else if (orderWorkflowStatus === \"coreOrderWorkflow/packed\") {\n                isNotLabeled += 1;\n                whichFalseState = shippingStates.labeled;\n              } else if (orderWorkflowStatus === \"coreOrderWorkflow/labeled\") {\n                isNotShipped += 1;\n              } else if (orderWorkflowStatus === \"coreOrderWorkflow/shipped\") {\n                isShipped += 1;\n              }\n            }\n          }); // display proper alert if the order(s) are in this state already or want to skip the previous states\n\n          _this.displayAlert(selectedOrders, status, {\n            whichFalseState: whichFalseState,\n            falsePreviousStatuses: isNotLabeled,\n            falseCurrentState: isNotShipped,\n            trueCurrentState: isShipped\n          });\n        };\n\n        _this.setShippingStatus = function (status, selectedOrdersIds, orders) {\n          _this.setState({\n            renderFlowList: true\n          });\n\n          var selectedOrders = orders.filter(function (order) {\n            return selectedOrdersIds.includes(order._id);\n          });\n\n          if (status === \"picked\") {\n            _this.pickedShippingStatus(selectedOrders, status);\n          }\n\n          if (status === \"packed\") {\n            _this.packedShippingStatus(selectedOrders, status);\n          }\n\n          if (status === \"labeled\") {\n            _this.labeledShippingStatus(selectedOrders, status);\n          }\n\n          if (status === \"shipped\") {\n            _this.shippedShippingStatus(selectedOrders, status);\n          }\n        };\n\n        _this.handleBulkPaymentCapture = function (selectedOrdersIds, orders) {\n          _this.setState({\n            isLoading: {\n              capturePayment: true\n            }\n          });\n\n          var selectedOrders = orders.filter(function (order) {\n            return selectedOrdersIds.includes(order._id);\n          });\n          var orderCount = 0;\n\n          var done = function () {\n            orderCount += 1;\n\n            if (orderCount === selectedOrders.length) {\n              _this.setState({\n                isLoading: {\n                  capturePayment: false\n                }\n              });\n\n              Alerts.alert({\n                text: i18next.t(\"order.paymentCaptureSuccess\"),\n                type: \"success\",\n                allowOutsideClick: false\n              });\n            }\n          }; // TODO: send these orders in batch as an array. This would entail re-writing the\n          // \"orders/approvePayment\" method to receive an array of orders as a param.\n\n\n          selectedOrders.forEach(function (order) {\n            // Only capture orders which are not captured yet (but possibly are already approved)\n            var billingRecord = _this.orderCreditMethod(order);\n\n            if (billingRecord.paymentMethod.mode === \"capture\" && billingRecord.paymentMethod.status === \"completed\") {\n              done();\n              return;\n            }\n\n            Meteor.call(\"orders/approvePayment\", order, function (approvePaymentError) {\n              if (approvePaymentError) {\n                _this.setState({\n                  isLoading: {\n                    capturePayment: false\n                  }\n                });\n\n                Alerts.toast(\"An error occured while approving the payment: \" + approvePaymentError, \"error\");\n              } else {\n                // TODO: send these orders in batch as an array. This would entail re-writing the\n                // \"orders/capturePayments\" method to receive an array of orders as a param.\n                Meteor.call(\"orders/capturePayments\", order._id, function (capturePaymentError) {\n                  if (capturePaymentError) {\n                    _this.setState({\n                      isLoading: {\n                        capturePayment: false\n                      }\n                    });\n\n                    Alerts.toast(\"An error occured while capturing the payment: \" + capturePaymentError, \"error\");\n                  }\n\n                  done();\n                });\n              }\n            });\n          });\n        };\n\n        _this.state = {\n          selectedItems: [],\n          multipleSelect: false,\n          // TODO: model this with the assumption that there may be different stages to workflows\n          shipping: {\n            picked: false,\n            packed: false,\n            labeled: false,\n            shipped: false\n          },\n          renderFlowList: false,\n          // TODO: model this with the assumption that there may be different stages to workflows\n          isLoading: {\n            picked: false,\n            packed: false,\n            labeled: false,\n            shipped: false,\n            capturePayment: false\n          },\n          ready: false\n        };\n        return _this;\n      }\n\n      var _proto = OrderTableContainer.prototype;\n\n      _proto.setListItemsToDefault = function () {\n        function setListItemsToDefault() {\n          var _this2 = this;\n\n          if (this.state.renderFlowList === false) {\n            shippingStrings.forEach(function (value) {\n              var _shipping3;\n\n              _this2.setState({\n                shipping: (_shipping3 = {}, _shipping3[value] = false, _shipping3)\n              });\n            });\n          }\n        }\n\n        return setListItemsToDefault;\n      }();\n\n      /**\n       * orderCreditMethod: Finds the credit record in order.billing for the active shop\n       * @param order: The order where to find the billing record in.\n       * @return: The billing record with paymentMethod.method === credit of currently active shop\n       */\n      _proto.orderCreditMethod = function () {\n        function orderCreditMethod(order) {\n          var creditBillingRecords = order.billing.filter(function (value) {\n            return value.paymentMethod.method === \"credit\";\n          });\n          var billingRecord = creditBillingRecords.find(function (billing) {\n            return billing.shopId === Reaction.getShopId();\n          });\n          return billingRecord;\n        }\n\n        return orderCreditMethod;\n      }();\n\n      _proto.render = function () {\n        function render() {\n          return React.createElement(Comp, (0, _extends2.default)({}, this.props, {\n            handleSelect: this.handleSelect,\n            handleClick: this.handleClick,\n            displayMedia: getPrimaryMediaForOrderItem,\n            selectedItems: this.state.selectedItems,\n            selectAllOrders: this.selectAllOrders,\n            multipleSelect: this.state.multipleSelect,\n            setShippingStatus: this.setShippingStatus,\n            shipping: this.state.shipping,\n            isLoading: this.state.isLoading,\n            renderFlowList: this.state.renderFlowList,\n            toggleShippingFlowList: this.toggleShippingFlowList,\n            handleBulkPaymentCapture: this.handleBulkPaymentCapture\n          }));\n        }\n\n        return render;\n      }();\n\n      return OrderTableContainer;\n    }(Component)\n  );\n};\n\nregisterComponent(\"OrderTable\", OrderTable, [wrapComponent]);\nmodule.exportDefault(_compose(wrapComponent)(OrderTable));","map":{"version":3,"sources":["imports/plugins/core/orders/client/containers/orderTableContainer.js"],"names":["_compose","module","watch","require","v","React","Component","Meteor","Reaction","i18next","getPrimaryMediaForOrderItem","registerComponent","getShippingInfo","PACKAGE_NAME","ORDER_LIST_FILTERS_PREFERENCE_NAME","ORDER_LIST_SELECTED_ORDER_PREFERENCE_NAME","shippingStates","OrderTable","shippingStrings","wrapComponent","Comp","props","toggleShippingFlowList","setState","renderFlowList","state","setListItemsToDefault","handleSelect","event","isInputChecked","name","multipleSelect","forEach","value","shipping","selectedItemsArray","selectedItems","includes","push","updatedSelectedArray","filter","id","selectAllOrders","orders","areAllSelected","string","orderIds","map","order","_id","handleClick","startWorkflow","setActionViewDetail","label","i18nKeyLabel","data","size","template","call","setUserPreferences","updateBulkStatusHelper","status","statusIndex","indexOf","reduce","updateBulkLoadingHelper","prevStatusIndex","Object","keys","maxIndex","Math","max","shippingStatusUpdateCall","selectedOrders","filteredSelectedOrders","length","isLoading","orderText","capitalizeStatus","toUpperCase","substr","toLowerCase","orderCount","shippingRecord","error","Alerts","toast","alert","text","t","orderNumber","type","allowOutsideClick","displayAlert","options","alertOptions","skippedOrdersText","orderAlreadyInStateText","falsePreviousStatuses","numberOfSkippedOrders","skippedState","whichFalseState","showCancelButton","showCloseButton","confirmButtonText","cancelButtonText","setSelected","falseCurrentState","trueCurrentState","displayRegressionAlert","ordersToRegress","regress","pickedShippingStatus","isNotPicked","isPicked","orderWorkflow","workflow","packedShippingStatus","picked","isNotPacked","isPacked","labeledShippingStatus","isNotLabeled","isLabeled","packed","shippedShippingStatus","isNotShipped","isShipped","orderWorkflowStatus","labeled","setShippingStatus","selectedOrdersIds","handleBulkPaymentCapture","capturePayment","done","billingRecord","orderCreditMethod","paymentMethod","mode","approvePaymentError","capturePaymentError","shipped","ready","creditBillingRecords","billing","method","find","shopId","getShopId","render","exportDefault"],"mappings":";;;;;;;;AAAA,IAAIA,QAAJ;;AAAaC,OAAOC,KAAP,CAAaC,QAAQ,mBAAR,CAAb,EAA0C;AAAA,uBAASC,CAAT,EAAW;AAACJ,eAASI,CAAT;AAAW;AAAvB,CAA1C,EAAmE,CAAnE;AAAsE,IAAIC,KAAJ,EAAUC,SAAV;AAAoBL,OAAOC,KAAP,CAAaC,QAAQ,OAAR,CAAb,EAA8B;AAAA,uBAASC,CAAT,EAAW;AAACC,YAAMD,CAAN;AAAQ,GAApB;AAAqBE,WAArB,YAA+BF,CAA/B,EAAiC;AAACE,gBAAUF,CAAV;AAAY;AAA9C,CAA9B,EAA8E,CAA9E;AAAiF,IAAIG,MAAJ;AAAWN,OAAOC,KAAP,CAAaC,QAAQ,eAAR,CAAb,EAAsC;AAACI,QAAD,YAAQH,CAAR,EAAU;AAACG,aAAOH,CAAP;AAAS;AAApB,CAAtC,EAA4D,CAA5D;AAA+D,IAAII,QAAJ,EAAaC,OAAb;AAAqBR,OAAOC,KAAP,CAAaC,QAAQ,8BAAR,CAAb,EAAqD;AAACK,UAAD,YAAUJ,CAAV,EAAY;AAACI,eAASJ,CAAT;AAAW,GAAxB;AAAyBK,SAAzB,YAAiCL,CAAjC,EAAmC;AAACK,cAAQL,CAAR;AAAU;AAA9C,CAArD,EAAqG,CAArG;AAAwG,IAAIM,2BAAJ;AAAgCT,OAAOC,KAAP,CAAaC,QAAQ,2BAAR,CAAb,EAAkD;AAACO,6BAAD,YAA6BN,CAA7B,EAA+B;AAACM,kCAA4BN,CAA5B;AAA8B;AAA9D,CAAlD,EAAkH,CAAlH;AAAqH,IAAIO,iBAAJ;AAAsBV,OAAOC,KAAP,CAAaC,QAAQ,yBAAR,CAAb,EAAgD;AAACQ,mBAAD,YAAmBP,CAAnB,EAAqB;AAACO,wBAAkBP,CAAlB;AAAoB;AAA1C,CAAhD,EAA4F,CAA5F;AAA+F,IAAIQ,eAAJ;AAAoBX,OAAOC,KAAP,CAAaC,QAAQ,YAAR,CAAb,EAAmC;AAACS,iBAAD,YAAiBR,CAAjB,EAAmB;AAACQ,sBAAgBR,CAAhB;AAAkB;AAAtC,CAAnC,EAA2E,CAA3E;AAA8E,IAAIS,YAAJ,EAAiBC,kCAAjB,EAAoDC,yCAApD,EAA8FC,cAA9F;AAA6Gf,OAAOC,KAAP,CAAaC,QAAQ,qBAAR,CAAb,EAA4C;AAACU,cAAD,YAAcT,CAAd,EAAgB;AAACS,mBAAaT,CAAb;AAAe,GAAhC;AAAiCU,oCAAjC,YAAoEV,CAApE,EAAsE;AAACU,yCAAmCV,CAAnC;AAAqC,GAA5G;AAA6GW,2CAA7G,YAAuJX,CAAvJ,EAAyJ;AAACW,gDAA0CX,CAA1C;AAA4C,GAAtM;AAAuMY,gBAAvM,YAAsNZ,CAAtN,EAAwN;AAACY,qBAAeZ,CAAf;AAAiB;AAA1O,CAA5C,EAAwR,CAAxR;AAA2R,IAAIa,UAAJ;AAAehB,OAAOC,KAAP,CAAaC,QAAQ,0BAAR,CAAb,EAAiD;AAAA,uBAASC,CAAT,EAAW;AAACa,iBAAWb,CAAX;AAAa;AAAzB,CAAjD,EAA4E,CAA5E;AAeloC,IAAMc,kBAAkB,CAAC,QAAD,EAAW,QAAX,EAAqB,SAArB,EAAgC,SAAhC,CAAxB;;AAEA,IAAMC,gBAAgB,UAACC,IAAD;AAAA;AAAA;AAAA;AAAA;;AAElB,mCAAYC,KAAZ,EAAmB;AAAA;;AACjB,sCAAMA,KAAN;;AADiB,cAwBnBC,sBAxBmB,GAwBM,YAAM;AAC7B,gBAAKC,QAAL,CAAc;AACZC,4BAAgB,CAAC,MAAKC,KAAL,CAAWD;AADhB,WAAd;;AAGA,gBAAKE,qBAAL;AACD,SA7BkB;;AAAA,cA2CnBC,YA3CmB,GA2CJ,UAACC,KAAD,EAAQC,cAAR,EAAwBC,IAAxB,EAAiC;AAC9C,gBAAKP,QAAL,CAAc;AACZQ,4BAAgB,KADJ;AAEZP,4BAAgB;AAFJ,WAAd;;AAIAN,0BAAgBc,OAAhB,CAAwB,UAACC,KAAD,EAAW;AAAA;;AACjC,kBAAKV,QAAL,CAAc;AACZW,mDACGD,KADH,IACW,KADX;AADY,aAAd;AAKD,WAND;AAOA,cAAME,qBAAqB,MAAKV,KAAL,CAAWW,aAAtC;;AAEA,cAAI,CAACD,mBAAmBE,QAAnB,CAA4BP,IAA5B,CAAL,EAAwC;AACtCK,+BAAmBG,IAAnB,CAAwBR,IAAxB;;AACA,kBAAKP,QAAL,CAAc;AACZa,6BAAeD;AADH,aAAd;AAGD,WALD,MAKO;AACL,gBAAMI,uBAAuBJ,mBAAmBK,MAAnB,CAA0B,UAACC,EAAD;AAAA,qBAAQA,OAAOX,IAAf;AAAA,aAA1B,CAA7B;;AACA,kBAAKP,QAAL,CAAc;AACZa,6BAAeG;AADH,aAAd;AAGD;AACF,SApEkB;;AAAA,cAsEnBG,eAtEmB,GAsED,UAACC,MAAD,EAASC,cAAT,EAA4B;AAC5C,gBAAKrB,QAAL,CAAc;AACZC,4BAAgB;AADJ,WAAd;;AAGAN,0BAAgBc,OAAhB,CAAwB,UAACa,MAAD,EAAY;AAAA;;AAClC,kBAAKtB,QAAL,CAAc;AACZW,qDACGW,MADH,IACY,KADZ;AADY,aAAd;AAKD,WAND;;AAOA,cAAID,cAAJ,EAAoB;AAClB;AACA;AACA,kBAAKrB,QAAL,CAAc;AACZa,6BAAe,EADH;AAEZL,8BAAgB;AAFJ,aAAd;AAID,WAPD,MAOO;AACL;AACA;AACA;AACA,gBAAMe,WAAWH,OAAOI,GAAP,CAAW,UAACC,KAAD;AAAA,qBAAWA,MAAMC,GAAjB;AAAA,aAAX,CAAjB;;AACA,kBAAK1B,QAAL,CAAc;AACZa,6BAAeU,QADH;AAEZf,8BAAgB;AAFJ,aAAd;AAID;AACF,SAlGkB;;AAAA,cAoGnBmB,WApGmB,GAoGL,UAACF,KAAD,EAAkC;AAAA,cAA1BG,aAA0B,uEAAV,KAAU;AAC9C3C,mBAAS4C,mBAAT,CAA6B;AAC3BC,mBAAO,eADoB;AAE3BC,0BAAc,4BAFa;AAG3BC,kBAAM;AACJP;AADI,aAHqB;AAM3B3B,mBAAO;AACLmC,oBAAM;AADD,aANoB;AAS3BC,sBAAU;AATiB,WAA7B;;AAYA,cAAIN,kBAAkB,IAAtB,EAA4B;AAC1B5C,mBAAOmD,IAAP,CAAY,4BAAZ,EAA0C,mBAA1C,EAA+D,YAA/D,EAA6EV,KAA7E;AACAxC,qBAASmD,kBAAT,CAA4B9C,YAA5B,EAA0CC,kCAA1C,EAA8E,YAA9E;AACD;AAED;;;;;;;;;AAOAN,mBAASmD,kBAAT,CAA4B9C,YAA5B,EAA0CE,yCAA1C,EAAqFiC,MAAMC,GAA3F;AACD,SA9HkB;;AAAA,cAuInBW,sBAvImB,GAuIM,UAACC,MAAD,EAAY;AACnC,cAAMC,cAAc5C,gBAAgB6C,OAAhB,CAAwBF,MAAxB,CAApB;AACA,iBAAO3C,gBAAgB8C,MAAhB,CAAuB,UAAC9B,QAAD,EAAWT,KAAX;AAAA;;AAAA,mDACzBS,QADyB,uCAE3BT,KAF2B,IAEnBP,gBAAgB6C,OAAhB,CAAwBtC,KAAxB,KAAkCqC,WAFf;AAAA,WAAvB,EAGH,EAHG,CAAP;AAID,SA7IkB;;AAAA,cAsJnBG,uBAtJmB,GAsJO,UAACJ,MAAD,EAAY;AACpC,cAAMC,cAAc5C,gBAAgB6C,OAAhB,CAAwBF,MAAxB,CAApB;AACA,cAAMK,kBAAkBC,OAAOC,IAAP,CAAY,MAAK3C,KAAL,CAAWS,QAAvB,EAAiC8B,MAAjC,CAAwC,UAACK,QAAD,EAAW5C,KAAX,EAAqB;AACnF,gBAAI,MAAKA,KAAL,CAAWS,QAAX,CAAoBT,KAApB,CAAJ,EAAgC;AAC9B,qBAAO6C,KAAKC,GAAL,CAASrD,gBAAgB6C,OAAhB,CAAwBtC,KAAxB,CAAT,EAAyC4C,QAAzC,CAAP;AACD;;AACD,mBAAOA,QAAP;AACD,WALuB,EAKrB,CAAC,CALoB,CAAxB;AAMA,iBAAOnD,gBAAgB8C,MAAhB,CAAuB,UAAC9B,QAAD,EAAWT,KAAX,EAAqB;AAAA;;AACjD,gBAAIyC,kBAAkBJ,WAAtB,EAAmC;AAAA;;AACjC,qDACK5B,QADL,uCAEGT,KAFH,IAEWP,gBAAgB6C,OAAhB,CAAwBtC,KAAxB,KAAkCqC,WAAlC,IAAiD5C,gBAAgB6C,OAAhB,CAAwBtC,KAAxB,IAAiCyC,eAF7F;AAID;;AACD,mDACKhC,QADL,uCAEGT,KAFH,IAEWP,gBAAgB6C,OAAhB,CAAwBtC,KAAxB,KAAkCqC,WAAlC,IAAiD5C,gBAAgB6C,OAAhB,CAAwBtC,KAAxB,KAAkCyC,eAF9F;AAID,WAXM,EAWJ,EAXI,CAAP;AAYD,SA1KkB;;AAAA,cAoLnBM,wBApLmB,GAoLQ,UAACC,cAAD,EAAiBZ,MAAjB,EAA4B;AACrD,cAAMa,yBAAyBD,eAAejC,MAAf,CAAsB,UAACQ,KAAD;AAAA,mBAAWA,MAAMd,QAAN,IAAkBiC,OAAOC,IAAP,CAAYxD,gBAAgBoC,KAAhB,CAAZ,EAAoC2B,MAAjE;AAAA,WAAtB,CAA/B;;AACA,gBAAKpD,QAAL,CAAc;AACZqD,uBAAW,MAAKX,uBAAL,CAA6BJ,MAA7B;AADC,WAAd;;AAGA,cAAIgB,YAAY,OAAhB;;AAEA,cAAIH,uBAAuBC,MAAvB,GAAgC,CAApC,EAAuC;AACrCE,wBAAY,QAAZ;AACD,WAToD,CAWrD;AACA;AACA;AACA;;;AACA,cAAMC,mBAAmBjB,OAAO,CAAP,EAAUkB,WAAV,KAA0BlB,OAAOmB,MAAP,CAAc,CAAd,EAAiBC,WAAjB,EAAnD;AACA,cAAIC,aAAa,CAAjB,CAhBqD,CAkBrD;AACA;AAEA;;AACAR,iCAAuB1C,OAAvB,CAA+B,UAACgB,KAAD,EAAW;AACxC,gBAAMmC,iBAAiBvE,gBAAgBoC,KAAhB,CAAvB;AAEAzC,mBAAOmD,IAAP,qBAA8BoB,gBAA9B,EAAkD9B,KAAlD,EAAyDmC,cAAzD,EAAyE,UAACC,KAAD,EAAW;AAClF,kBAAIA,KAAJ,EAAW;AACTC,uBAAOC,KAAP,iDAA2DF,KAA3D,EAAoE,OAApE;AACD,eAFD,MAEO;AACL7E,uBAAOmD,IAAP,CAAY,sBAAZ,EAAoCV,MAAMC,GAA1C,EAA+C,sCAA/C,EAAuFY,MAAvF;AACD;;AACDqB,4BAAc,CAAd;;AACA,kBAAIA,eAAeR,uBAAuBC,MAA1C,EAAkD;AAAA;;AAChD,sBAAKpD,QAAL,CAAc;AACZW,4BAAU,MAAK0B,sBAAL,CAA4BC,MAA5B,CADE;AAEZe,0DACGf,MADH,IACY,KADZ;AAFY,iBAAd;;AAMAwB,uBAAOE,KAAP,CAAa;AACXC,wBAAM/E,QAAQgF,CAAR,CAAU,uBAAV,EAAmC;AACvCC,iCAAahB,uBAAuBC,MADG;AAEvCE,wCAFuC;AAGvChB;AAHuC,mBAAnC,CADK;AAMX8B,wBAAM,SANK;AAOXC,qCAAmB;AAPR,iBAAb;AASD;AACF,aAxBD;AAyBD,WA5BD;AA6BD,SAvOkB;;AAAA,cAyOnBC,YAzOmB,GAyOJ,UAACpB,cAAD,EAAiBZ,MAAjB,EAAyBiC,OAAzB,EAAqC;AAClD;AACA;AACA;AACA;AACA,cAAMhB,mBAAmBjB,OAAO,CAAP,EAAUkB,WAAV,KAA0BlB,OAAOmB,MAAP,CAAc,CAAd,EAAiBC,WAAjB,EAAnD;AACA,cAAMc,eAAeD,WAAW,EAAhC;AACA,cAAIjB,YAAY,OAAhB;AACA,cAAImB,oBAAoB,IAAxB;AACA,cAAIC,0BAA0B,WAA9B;;AAEA,cAAIxB,eAAeE,MAAf,GAAwB,CAA5B,EAA+B;AAC7BE,wBAAY,QAAZ;AACAoB,sCAA0B,aAA1B;AACD;;AAED,cAAIF,aAAaG,qBAAb,GAAqC,CAAzC,EAA4C;AAC1CF,gCAAoB,KAApB;AACD,WAlBiD,CAoBlD;;;AACA,cAAID,aAAaG,qBAAjB,EAAwC;AACtCb,mBAAOE,KAAP,CAAa;AACXC,oBAAM/E,QAAQgF,CAAR,CAAU,8BAAV,EAA0C;AAC9ChB,gCAAgBA,eAAeE,MADe;AAE9CE,oCAF8C;AAG9ChB,wBAAQiB,gBAHsC;AAI9CqB,uCAAuBJ,aAAaG,qBAJU;AAK9CF,oDAL8C;AAM9CI,8BAAcL,aAAaM;AANmB,eAA1C,CADK;AASXV,oBAAM,SATK;AAUXW,gCAAkB,IAVP;AAWXC,+BAAiB,IAXN;AAYXX,iCAAmB,KAZR;AAaXY,iCAAmB/F,QAAQgF,CAAR,CAAU,8BAAV,CAbR;AAcXgB,gCAAkBhG,QAAQgF,CAAR,CAAU,6BAAV;AAdP,aAAb,EAeG,UAACiB,WAAD,EAAiB;AAClB,kBAAIA,WAAJ,EAAiB;AACf;AACA,sBAAKlC,wBAAL,CAA8BC,cAA9B,EAA8CZ,MAA9C;AACD;AACF,aApBD,EADsC,CAuBtC;AACD,WAxBD,MAwBO,IAAI,CAACkC,aAAaG,qBAAd,IAAuCH,aAAaY,iBAAxD,EAA2E;AAChF,kBAAKnC,wBAAL,CAA8BC,cAA9B,EAA8CZ,MAA9C,EADgF,CAEhF;;AACD,WAHM,MAGA,IAAI,CAACkC,aAAaG,qBAAd,IAAuC,CAACH,aAAaY,iBAArD,IACTZ,aAAaa,gBADR,EAC0B;AAC/BvB,mBAAOE,KAAP,CAAa;AACXC,oBAAM/E,QAAQgF,CAAR,CAAU,2BAAV,EAAuC;AAC3CZ,2BAAWoB,uBADgC;AAE3CpC;AAF2C,eAAvC;AADK,aAAb;AAMD;AACF,SAlSkB;;AAAA,cAoSnBgD,sBApSmB,GAoSM,UAACpC,cAAD,EAAiBqC,eAAjB,EAAkCjD,MAAlC,EAA0CiC,OAA1C,EAAsD;AAC7E;AACA;AACA;AACA;AACA,cAAMhB,mBAAmBjB,OAAO,CAAP,EAAUkB,WAAV,KAA0BlB,OAAOmB,MAAP,CAAc,CAAd,EAAiBC,WAAjB,EAAnD;AACA,cAAMc,eAAeD,WAAW,EAAhC;AACA,cAAIjB,YAAY,OAAhB;;AAEA,cAAIiC,kBAAkB,CAAtB,EAAyB;AACvBjC,wBAAY,QAAZ;AACD;;AAEDQ,iBAAOE,KAAP,CAAa;AACXC,kBAAM/E,QAAQgF,CAAR,CAAU,iCAAV,EAA6C;AACjDqB,8CADiD;AAChCjC,kCADgC;AACrBhB,sBAAQiB;AADa,aAA7C,CADK;AAIXa,kBAAM,SAJK;AAKXW,8BAAkB,IALP;AAMXC,6BAAiB,IANN;AAOXX,+BAAmB,KAPR;AAQXY,+BAAmB/F,QAAQgF,CAAR,CAAU,wCAAV,CARR;AASXgB,8BAAkBhG,QAAQgF,CAAR,CAAU,6BAAV;AATP,WAAb,EAUG,UAACsB,OAAD,EAAa;AACd,gBAAIA,OAAJ,EAAa;AACX;AACA,kBAAIhB,aAAaG,qBAAjB,EAAwC;AACtC,sBAAKL,YAAL,CACEpB,cADF,EACkBZ,MADlB,EAEE;AACEwC,mCAAiBN,aAAaM,eADhC;AAEEH,yCAAuBH,aAAaG,qBAFtC;AAGES,qCAAmBZ,aAAaY,iBAHlC;AAIEC,oCAAkBb,aAAaa;AAJjC,iBAFF;AASD,eAVD,MAUO;AACL;AACA,sBAAKpC,wBAAL,CAA8BC,cAA9B,EAA8CZ,MAA9C;AACD;AACF;AACF,WA5BD;AA6BD,SA9UkB;;AAAA,cAgVnBmD,oBAhVmB,GAgVI,UAACvC,cAAD,EAAiBZ,MAAjB,EAA4B;AACjD;AACA;AACA,cAAIoD,cAAc,CAAlB;AACA,cAAIC,WAAW,CAAf;AACA,cAAIJ,kBAAkB,CAAtB,CALiD,CAOjD;AACA;AACA;;AACArC,yBAAezC,OAAf,CAAuB,UAACgB,KAAD,EAAW;AAChC,gBAAMmE,gBAAgBvG,gBAAgBoC,KAAhB,EAAuBoE,QAA7C,CADgC,CAEhC;AAEA;AACA;;AACA,gBAAID,aAAJ,EAAmB;AACjB,kBAAIA,cAActD,MAAd,KAAyB,KAA7B,EAAoC;AAClCoD,+BAAe,CAAf;AACD,eAFD,MAEO,IAAIE,cAActD,MAAd,KAAyB,0BAA7B,EAAyD;AAC9DqD,4BAAY,CAAZ;AACD,eAFM,MAEA,IAAIC,cAAcC,QAAd,CAAuB/E,QAAvB,CAAgC,0BAAhC,CAAJ,EAAiE;AACtEyE,mCAAmB,CAAnB;AACD,eAFM,MAEA,IAAI,CAACK,cAAcC,QAAd,CAAuB/E,QAAvB,CAAgC,0BAAhC,CAAD,KACC8E,cAActD,MAAd,KAAyB,0BAAzB,IACAsD,cAActD,MAAd,KAAyB,2BADzB,IAEAsD,cAActD,MAAd,KAAyB,2BAH1B,CAAJ,EAG4D;AACjEiD,mCAAmB,CAAnB;AACD;AACF;AACF,WApBD,EAViD,CAgCjD;;AACA,cAAIA,eAAJ,EAAqB;AACnB,kBAAKD,sBAAL,CAA4BpC,cAA5B,EAA4CqC,eAA5C,EAA6DjD,MAA7D,EADmB,CAGnB;AACA;;AACD,WALD,MAKO;AACL,kBAAKgC,YAAL,CACEpB,cADF,EACkBZ,MADlB,EAEE;AACE8C,iCAAmBM,WADrB;AAEEL,gCAAkBM;AAFpB,aAFF;AAOD;AACF,SA/XkB;;AAAA,cAiYnBG,oBAjYmB,GAiYI,UAAC5C,cAAD,EAAiBZ,MAAjB,EAA4B;AACjD;AACA,cAAMwC,kBAAkBrF,eAAesG,MAAvC,CAFiD,CAGjD;AACA;;AACA,cAAIL,cAAc,CAAlB;AACA,cAAIM,cAAc,CAAlB;AACA,cAAIC,WAAW,CAAf;AACA,cAAIV,kBAAkB,CAAtB,CARiD,CAUjD;AACA;AACA;;AACArC,yBAAezC,OAAf,CAAuB,UAACgB,KAAD,EAAW;AAChC,gBAAMmE,gBAAgBvG,gBAAgBoC,KAAhB,EAAuBoE,QAA7C,CADgC,CAGhC;AAEA;AACA;;AACA,gBAAID,aAAJ,EAAmB;AACjB,kBAAIA,cAActD,MAAd,KAAyB,KAA7B,EAAoC;AAClCoD,+BAAe,CAAf;AACD,eAFD,MAEO,IAAIE,cAActD,MAAd,KAAyB,0BAA7B,EAAyD;AAC9D0D,+BAAe,CAAf;AACD,eAFM,MAEA,IAAIJ,cAActD,MAAd,KAAyB,0BAA7B,EAAyD;AAC9D2D,4BAAY,CAAZ;AACD,eAFM,MAEA,IAAIL,cAAcC,QAAd,CAAuB/E,QAAvB,CAAgC,0BAAhC,CAAJ,EAAiE;AAAE;AACxEyE,mCAAmB,CAAnB;AACD,eAFM,MAEA,IAAI,CAACK,cAAcC,QAAd,CAAuB/E,QAAvB,CAAgC,0BAAhC,CAAD,KACC8E,cAActD,MAAd,KAAyB,2BAAzB,IACAsD,cAActD,MAAd,KAAyB,2BAF1B,CAAJ,EAE4D;AACjEiD,mCAAmB,CAAnB;AACD;AACF;AACF,WAtBD,EAbiD,CAqCjD;;AACA,cAAIA,eAAJ,EAAqB;AACnB,kBAAKD,sBAAL,CACEpC,cADF,EACkBqC,eADlB,EACmCjD,MADnC,EAEE;AACEwC,8CADF;AAEEH,qCAAuBe,WAFzB;AAGEN,iCAAmBY,WAHrB;AAIEX,gCAAkBY;AAJpB,aAFF,EADmB,CAWnB;;AACD,WAZD,MAYO;AACL,kBAAK3B,YAAL,CACEpB,cADF,EACkBZ,MADlB,EAEE;AACEwC,8CADF;AAEEH,qCAAuBe,WAFzB;AAGEN,iCAAmBY,WAHrB;AAIEX,gCAAkBY;AAJpB,aAFF;AASD;AACF,SA9bkB;;AAAA,cAgcnBC,qBAhcmB,GAgcK,UAAChD,cAAD,EAAiBZ,MAAjB,EAA4B;AAClD;AACA,cAAIwC,kBAAkB,EAAtB,CAFkD,CAGlD;AACA;;AACA,cAAIkB,cAAc,CAAlB;AACA,cAAIG,eAAe,CAAnB;AACA,cAAIC,YAAY,CAAhB;AACA,cAAIb,kBAAkB,CAAtB,CARkD,CAUlD;AACA;AACA;;AACArC,yBAAezC,OAAf,CAAuB,UAACgB,KAAD,EAAW;AAChC,gBAAMmE,gBAAgBvG,gBAAgBoC,KAAhB,EAAuBoE,QAA7C,CADgC,CAEhC;AAEA;AACA;;AACA,gBAAID,aAAJ,EAAmB;AACjB,kBAAIA,cAActD,MAAd,KAAyB,KAA7B,EAAoC;AAClC0D,+BAAe,CAAf;AACAlB,kCAAkBrF,eAAesG,MAAjC;AACD,eAHD,MAGO,IAAIH,cAActD,MAAd,KAAyB,0BAA7B,EAAyD;AAC9D0D,+BAAe,CAAf;AACAlB,kCAAkBrF,eAAe4G,MAAjC;AACD,eAHM,MAGA,IAAIT,cAActD,MAAd,KAAyB,0BAA7B,EAAyD;AAC9D6D,gCAAgB,CAAhB;AACD,eAFM,MAEA,IAAIP,cAActD,MAAd,KAAyB,2BAA7B,EAA0D;AAC/D8D,6BAAa,CAAb;AACD,eAFM,MAEA,IAAIR,cAAcC,QAAd,CAAuB/E,QAAvB,CAAgC,2BAAhC,KACA8E,cAActD,MAAd,KAAyB,2BAD7B,EAC0D;AAAE;AACjEiD,mCAAmB,CAAnB;AACD;AACF;AACF,WAtBD,EAbkD,CAqClD;;AACA,cAAIA,eAAJ,EAAqB;AACnB,kBAAKD,sBAAL,CACEpC,cADF,EACkBqC,eADlB,EACmCjD,MADnC,EAEE;AACEwC,8CADF;AAEEH,qCAAuBqB,WAFzB;AAGEZ,iCAAmBe,YAHrB;AAIEd,gCAAkBe;AAJpB,aAFF,EADmB,CAWnB;;AACD,WAZD,MAYO;AACL,kBAAK9B,YAAL,CACEpB,cADF,EACkBZ,MADlB,EAEE;AACEwC,8CADF;AAEEH,qCAAuBqB,WAFzB;AAGEZ,iCAAmBe,YAHrB;AAIEd,gCAAkBe;AAJpB,aAFF;AASD;AACF,SA7fkB;;AAAA,cAggBnBE,qBAhgBmB,GAggBK,UAACpD,cAAD,EAAiBZ,MAAjB,EAA4B;AAClD;AACA,cAAIwC,kBAAkB,EAAtB,CAFkD,CAGlD;AACA;;AACA,cAAIqB,eAAe,CAAnB;AACA,cAAII,eAAe,CAAnB;AACA,cAAIC,YAAY,CAAhB,CAPkD,CASlD;AACA;AACA;;AACAtD,yBAAezC,OAAf,CAAuB,UAACgB,KAAD,EAAW;AAChC,gBAAMmE,gBAAgBvG,gBAAgBoC,KAAhB,EAAuBoE,QAA7C,CADgC,CAEhC;AAEA;AACA;;AACA,gBAAID,aAAJ,EAAmB;AACjB,kBAAMa,sBAAsBb,cAActD,MAA1C;;AACA,kBAAImE,wBAAwB,KAA5B,EAAmC;AACjCN,gCAAgB,CAAhB;AACArB,kCAAkBrF,eAAesG,MAAjC;AACD,eAHD,MAGO,IAAIU,wBAAwB,0BAA5B,EAAwD;AAC7DN,gCAAgB,CAAhB;AACArB,kCAAkBrF,eAAe4G,MAAjC;AACD,eAHM,MAGA,IAAII,wBAAwB,0BAA5B,EAAwD;AAC7DN,gCAAgB,CAAhB;AACArB,kCAAkBrF,eAAeiH,OAAjC;AACD,eAHM,MAGA,IAAID,wBAAwB,2BAA5B,EAAyD;AAC9DF,gCAAgB,CAAhB;AACD,eAFM,MAEA,IAAIE,wBAAwB,2BAA5B,EAAyD;AAC9DD,6BAAa,CAAb;AACD;AACF;AACF,WAvBD,EAZkD,CAqClD;;AACA,gBAAKlC,YAAL,CACEpB,cADF,EACkBZ,MADlB,EAEE;AACEwC,4CADF;AAEEH,mCAAuBwB,YAFzB;AAGEf,+BAAmBmB,YAHrB;AAIElB,8BAAkBmB;AAJpB,WAFF;AASD,SA/iBkB;;AAAA,cA0jBnBG,iBA1jBmB,GA0jBC,UAACrE,MAAD,EAASsE,iBAAT,EAA4BxF,MAA5B,EAAuC;AACzD,gBAAKpB,QAAL,CAAc;AACZC,4BAAgB;AADJ,WAAd;;AAGA,cAAMiD,iBAAiB9B,OAAOH,MAAP,CAAc,UAACQ,KAAD;AAAA,mBAAWmF,kBAAkB9F,QAAlB,CAA2BW,MAAMC,GAAjC,CAAX;AAAA,WAAd,CAAvB;;AAEA,cAAIY,WAAW,QAAf,EAAyB;AACvB,kBAAKmD,oBAAL,CAA0BvC,cAA1B,EAA0CZ,MAA1C;AACD;;AAED,cAAIA,WAAW,QAAf,EAAyB;AACvB,kBAAKwD,oBAAL,CAA0B5C,cAA1B,EAA0CZ,MAA1C;AACD;;AAED,cAAIA,WAAW,SAAf,EAA0B;AACxB,kBAAK4D,qBAAL,CAA2BhD,cAA3B,EAA2CZ,MAA3C;AACD;;AAED,cAAIA,WAAW,SAAf,EAA0B;AACxB,kBAAKgE,qBAAL,CAA2BpD,cAA3B,EAA2CZ,MAA3C;AACD;AACF,SA/kBkB;;AAAA,cA4lBnBuE,wBA5lBmB,GA4lBQ,UAACD,iBAAD,EAAoBxF,MAApB,EAA+B;AACxD,gBAAKpB,QAAL,CAAc;AACZqD,uBAAW;AACTyD,8BAAgB;AADP;AADC,WAAd;;AAKA,cAAM5D,iBAAiB9B,OAAOH,MAAP,CAAc,UAACQ,KAAD;AAAA,mBAAWmF,kBAAkB9F,QAAlB,CAA2BW,MAAMC,GAAjC,CAAX;AAAA,WAAd,CAAvB;AAEA,cAAIiC,aAAa,CAAjB;;AACA,cAAMoD,OAAO,YAAM;AACjBpD,0BAAc,CAAd;;AACA,gBAAIA,eAAeT,eAAeE,MAAlC,EAA0C;AACxC,oBAAKpD,QAAL,CAAc;AACZqD,2BAAW;AACTyD,kCAAgB;AADP;AADC,eAAd;;AAKAhD,qBAAOE,KAAP,CAAa;AACXC,sBAAM/E,QAAQgF,CAAR,CAAU,6BAAV,CADK;AAEXE,sBAAM,SAFK;AAGXC,mCAAmB;AAHR,eAAb;AAKD;AACF,WAdD,CATwD,CAyBxD;AACA;;;AACAnB,yBAAezC,OAAf,CAAuB,UAACgB,KAAD,EAAW;AAChC;AACA,gBAAMuF,gBAAgB,MAAKC,iBAAL,CAAuBxF,KAAvB,CAAtB;;AACA,gBAAIuF,cAAcE,aAAd,CAA4BC,IAA5B,KAAqC,SAArC,IAAkDH,cAAcE,aAAd,CAA4B5E,MAA5B,KAAuC,WAA7F,EAA0G;AACxGyE;AACA;AACD;;AACD/H,mBAAOmD,IAAP,CAAY,uBAAZ,EAAqCV,KAArC,EAA4C,UAAC2F,mBAAD,EAAyB;AACnE,kBAAIA,mBAAJ,EAAyB;AACvB,sBAAKpH,QAAL,CAAc;AACZqD,6BAAW;AACTyD,oCAAgB;AADP;AADC,iBAAd;;AAKAhD,uBAAOC,KAAP,oDAA8DqD,mBAA9D,EAAqF,OAArF;AACD,eAPD,MAOO;AACL;AACA;AACApI,uBAAOmD,IAAP,CAAY,wBAAZ,EAAsCV,MAAMC,GAA5C,EAAiD,UAAC2F,mBAAD,EAAyB;AACxE,sBAAIA,mBAAJ,EAAyB;AACvB,0BAAKrH,QAAL,CAAc;AACZqD,iCAAW;AACTyD,wCAAgB;AADP;AADC,qBAAd;;AAKAhD,2BAAOC,KAAP,oDAA8DsD,mBAA9D,EAAqF,OAArF;AACD;;AACDN;AACD,iBAVD;AAWD;AACF,aAvBD;AAwBD,WA/BD;AAgCD,SAvpBkB;;AAEjB,cAAK7G,KAAL,GAAa;AACXW,yBAAe,EADJ;AAEXL,0BAAgB,KAFL;AAGX;AACAG,oBAAU;AACRoF,oBAAQ,KADA;AAERM,oBAAQ,KAFA;AAGRK,qBAAS,KAHD;AAIRY,qBAAS;AAJD,WAJC;AAUXrH,0BAAgB,KAVL;AAWX;AACAoD,qBAAW;AACT0C,oBAAQ,KADC;AAETM,oBAAQ,KAFC;AAGTK,qBAAS,KAHA;AAITY,qBAAS,KAJA;AAKTR,4BAAgB;AALP,WAZA;AAmBXS,iBAAO;AAnBI,SAAb;AAFiB;AAuBlB;;AAzBiB;;AAAA,aAiClBpH,qBAjCkB;AAAA,yCAiCM;AAAA;;AACtB,cAAI,KAAKD,KAAL,CAAWD,cAAX,KAA8B,KAAlC,EAAyC;AACvCN,4BAAgBc,OAAhB,CAAwB,UAACC,KAAD,EAAW;AAAA;;AACjC,qBAAKV,QAAL,CAAc;AACZW,uDACGD,KADH,IACW,KADX;AADY,eAAd;AAKD,aAND;AAOD;AACF;;AA3CiB;AAAA;;AAmlBlB;;;;;AAnlBkB,aAwlBlBuG,iBAxlBkB;AAAA,mCAwlBAxF,KAxlBA,EAwlBO;AACvB,cAAM+F,uBAAuB/F,MAAMgG,OAAN,CAAcxG,MAAd,CAAqB,UAACP,KAAD;AAAA,mBAAWA,MAAMwG,aAAN,CAAoBQ,MAApB,KAA+B,QAA1C;AAAA,WAArB,CAA7B;AACA,cAAMV,gBAAgBQ,qBAAqBG,IAArB,CAA0B,UAACF,OAAD;AAAA,mBAAaA,QAAQG,MAAR,KAAmB3I,SAAS4I,SAAT,EAAhC;AAAA,WAA1B,CAAtB;AACA,iBAAOb,aAAP;AACD;;AA5lBiB;AAAA;;AAAA,aA2pBlBc,MA3pBkB;AAAA,0BA2pBT;AACP,iBACE,oBAAC,IAAD,6BACM,KAAKhI,KADX;AAEE,0BAAc,KAAKM,YAFrB;AAGE,yBAAa,KAAKuB,WAHpB;AAIE,0BAAcxC,2BAJhB;AAKE,2BAAe,KAAKe,KAAL,CAAWW,aAL5B;AAME,6BAAiB,KAAKM,eANxB;AAOE,4BAAgB,KAAKjB,KAAL,CAAWM,cAP7B;AAQE,+BAAmB,KAAKmG,iBAR1B;AASE,sBAAU,KAAKzG,KAAL,CAAWS,QATvB;AAUE,uBAAW,KAAKT,KAAL,CAAWmD,SAVxB;AAWE,4BAAgB,KAAKnD,KAAL,CAAWD,cAX7B;AAYE,oCAAwB,KAAKF,sBAZ/B;AAaE,sCAA0B,KAAK8G;AAbjC,aADF;AAiBD;;AA7qBiB;AAAA;;AAAA;AAAA,MACc9H,SADd;AAAA;AAAA,CAAtB;;AAirBAK,kBAAkB,YAAlB,EAAgCM,UAAhC,EAA4C,CAACE,aAAD,CAA5C;AAlsBAlB,OAAOqJ,aAAP,CAosBe,SAAQnI,aAAR,EAAuBF,UAAvB,CApsBf","sourcesContent":["import React, { Component } from \"react\";\nimport { compose } from \"recompose\";\nimport { Meteor } from \"meteor/meteor\";\nimport { Reaction, i18next } from \"/client/api\";\nimport { getPrimaryMediaForOrderItem } from \"/lib/api\";\nimport { registerComponent } from \"@reactioncommerce/reaction-components\";\nimport { getShippingInfo } from \"../helpers\";\nimport {\n  PACKAGE_NAME,\n  ORDER_LIST_FILTERS_PREFERENCE_NAME,\n  ORDER_LIST_SELECTED_ORDER_PREFERENCE_NAME,\n  shippingStates\n} from \"../../lib/constants\";\nimport OrderTable from \"../components/orderTable\";\n\nconst shippingStrings = [\"picked\", \"packed\", \"labeled\", \"shipped\"];\n\nconst wrapComponent = (Comp) => (\n  class OrderTableContainer extends Component {\n    constructor(props) {\n      super(props);\n      this.state = {\n        selectedItems: [],\n        multipleSelect: false,\n        // TODO: model this with the assumption that there may be different stages to workflows\n        shipping: {\n          picked: false,\n          packed: false,\n          labeled: false,\n          shipped: false\n        },\n        renderFlowList: false,\n        // TODO: model this with the assumption that there may be different stages to workflows\n        isLoading: {\n          picked: false,\n          packed: false,\n          labeled: false,\n          shipped: false,\n          capturePayment: false\n        },\n        ready: false\n      };\n    }\n    toggleShippingFlowList = () => {\n      this.setState({\n        renderFlowList: !this.state.renderFlowList\n      });\n      this.setListItemsToDefault();\n    }\n\n    setListItemsToDefault() {\n      if (this.state.renderFlowList === false) {\n        shippingStrings.forEach((value) => {\n          this.setState({\n            shipping: {\n              [value]: false\n            }\n          });\n        });\n      }\n    }\n\n    handleSelect = (event, isInputChecked, name) => {\n      this.setState({\n        multipleSelect: false,\n        renderFlowList: false\n      });\n      shippingStrings.forEach((value) => {\n        this.setState({\n          shipping: {\n            [value]: false\n          }\n        });\n      });\n      const selectedItemsArray = this.state.selectedItems;\n\n      if (!selectedItemsArray.includes(name)) {\n        selectedItemsArray.push(name);\n        this.setState({\n          selectedItems: selectedItemsArray\n        });\n      } else {\n        const updatedSelectedArray = selectedItemsArray.filter((id) => id !== name);\n        this.setState({\n          selectedItems: updatedSelectedArray\n        });\n      }\n    }\n\n    selectAllOrders = (orders, areAllSelected) => {\n      this.setState({\n        renderFlowList: false\n      });\n      shippingStrings.forEach((string) => {\n        this.setState({\n          shipping: {\n            [string]: false\n          }\n        });\n      });\n      if (areAllSelected) {\n        // if all orders are selected, clear the selectedItems array\n        // and set multipleSelect to false\n        this.setState({\n          selectedItems: [],\n          multipleSelect: false\n        });\n      } else {\n        // if there are no selected orders, or if there are some orders that have been\n        // selected but not all of them, loop through the orders array and return a\n        // new array with order ids only, then set the selectedItems array with the orderIds\n        const orderIds = orders.map((order) => order._id);\n        this.setState({\n          selectedItems: orderIds,\n          multipleSelect: true\n        });\n      }\n    }\n\n    handleClick = (order, startWorkflow = false) => {\n      Reaction.setActionViewDetail({\n        label: \"Order Details\",\n        i18nKeyLabel: \"orderWorkflow.orderDetails\",\n        data: {\n          order\n        },\n        props: {\n          size: \"large\"\n        },\n        template: \"coreOrderWorkflow\"\n      });\n\n      if (startWorkflow === true) {\n        Meteor.call(\"workflow/pushOrderWorkflow\", \"coreOrderWorkflow\", \"processing\", order);\n        Reaction.setUserPreferences(PACKAGE_NAME, ORDER_LIST_FILTERS_PREFERENCE_NAME, \"processing\");\n      }\n\n      /* TODO:\n      a) What other routes have a query parameter of _id=XXXXXXX ?\n      b) What exactly are we using the order dashboard for? If it's search,\n       well, clicking a search result doesn't CURRENTLY do anything. What's\n       more, there's some debate as to whether that SHOULD link to anywhere.\n       And if it should, why not the existing, modal orders panel?\n      */\n      Reaction.setUserPreferences(PACKAGE_NAME, ORDER_LIST_SELECTED_ORDER_PREFERENCE_NAME, order._id);\n    }\n\n    /**\n     * updateBulkStatusHelper\n     *\n     * @summary return formatted shipping object to update state\n     * @param {String} status - the shipping status to be set\n     * @return {Object} the formatted shipping object\n     */\n    updateBulkStatusHelper = (status) => {\n      const statusIndex = shippingStrings.indexOf(status);\n      return shippingStrings.reduce((shipping, state) => ({\n        ...shipping,\n        [state]: shippingStrings.indexOf(state) <= statusIndex\n      }), {});\n    }\n\n    /**\n     * updateBulkLoadingHelper\n     *\n     * @summary return formatted isLoading object to update state\n     * @param {String} status - the shipping status to be set\n     * @return {Object} the formatted isLoading object\n     */\n    updateBulkLoadingHelper = (status) => {\n      const statusIndex = shippingStrings.indexOf(status);\n      const prevStatusIndex = Object.keys(this.state.shipping).reduce((maxIndex, state) => {\n        if (this.state.shipping[state]) {\n          return Math.max(shippingStrings.indexOf(state), maxIndex);\n        }\n        return maxIndex;\n      }, -1);\n      return shippingStrings.reduce((shipping, state) => {\n        if (prevStatusIndex < statusIndex) {\n          return {\n            ...shipping,\n            [state]: shippingStrings.indexOf(state) <= statusIndex && shippingStrings.indexOf(state) > prevStatusIndex\n          };\n        }\n        return {\n          ...shipping,\n          [state]: shippingStrings.indexOf(state) >= statusIndex && shippingStrings.indexOf(state) <= prevStatusIndex\n        };\n      }, {});\n    }\n\n    /**\n     * shippingStatusUpdateCall\n     *\n     * @summary set selected order(s) to the provided shipping state\n     * @param {Array} selectedOrders - array of selected orders\n     * @param {String} status - the shipping status to be set\n     * @return {null} no return value\n     */\n    shippingStatusUpdateCall = (selectedOrders, status) => {\n      const filteredSelectedOrders = selectedOrders.filter((order) => order.shipping && Object.keys(getShippingInfo(order)).length);\n      this.setState({\n        isLoading: this.updateBulkLoadingHelper(status)\n      });\n      let orderText = \"order\";\n\n      if (filteredSelectedOrders.length > 1) {\n        orderText = \"orders\";\n      }\n\n      // capitalize the first letter of the shipping status passed in\n      // e.g. 'shipped' becomes 'Shipped'.\n      // status[0].toUpperCase() capitalizes the first letter of the string\n      // status.substr(1).toLowerCase() converts every other letter to lower case\n      const capitalizeStatus = status[0].toUpperCase() + status.substr(1).toLowerCase();\n      let orderCount = 0;\n\n      // TODO: send these orders in batch as an array. This would entail re-writing the Meteor calls to update the\n      // different shipping statuses to receive an array of objects(orders) as a param\n\n      // TODO: rethink this type of flow for updating shipping statuses\n      filteredSelectedOrders.forEach((order) => {\n        const shippingRecord = getShippingInfo(order);\n\n        Meteor.call(`orders/shipment${capitalizeStatus}`, order, shippingRecord, (error) => {\n          if (error) {\n            Alerts.toast(`An error occured while setting the status: ${error}`, \"error\");\n          } else {\n            Meteor.call(\"orders/updateHistory\", order._id, \"Shipping state set by bulk operation\", status);\n          }\n          orderCount += 1;\n          if (orderCount === filteredSelectedOrders.length) {\n            this.setState({\n              shipping: this.updateBulkStatusHelper(status),\n              isLoading: {\n                [status]: false\n              }\n            });\n            Alerts.alert({\n              text: i18next.t(\"order.orderSetToState\", {\n                orderNumber: filteredSelectedOrders.length,\n                orderText,\n                status\n              }),\n              type: \"success\",\n              allowOutsideClick: false\n            });\n          }\n        });\n      });\n    }\n\n    displayAlert = (selectedOrders, status, options) => {\n      // capitalize the first letter of the shipping status passed in\n      // e.g. 'shipped' becomes 'Shipped'.\n      // status[0].toUpperCase() capitalizes the first letter of the string\n      // status.substr(1).toLowerCase() converts every other letter to lower case\n      const capitalizeStatus = status[0].toUpperCase() + status.substr(1).toLowerCase();\n      const alertOptions = options || {};\n      let orderText = \"order\";\n      let skippedOrdersText = \"is\";\n      let orderAlreadyInStateText = \"Order has\";\n\n      if (selectedOrders.length > 1) {\n        orderText = \"orders\";\n        orderAlreadyInStateText = \"Orders have\";\n      }\n\n      if (alertOptions.falsePreviousStatuses > 1) {\n        skippedOrdersText = \"are\";\n      }\n\n      // if the order(s) want to skip the previous states, display alert\n      if (alertOptions.falsePreviousStatuses) {\n        Alerts.alert({\n          text: i18next.t(\"order.skippedBulkOrdersAlert\", {\n            selectedOrders: selectedOrders.length,\n            orderText,\n            status: capitalizeStatus,\n            numberOfSkippedOrders: alertOptions.falsePreviousStatuses,\n            skippedOrdersText,\n            skippedState: alertOptions.whichFalseState\n          }),\n          type: \"warning\",\n          showCancelButton: true,\n          showCloseButton: true,\n          allowOutsideClick: false,\n          confirmButtonText: i18next.t(\"order.approveBulkOrderAction\"),\n          cancelButtonText: i18next.t(\"order.cancelBulkOrderAction\")\n        }, (setSelected) => {\n          if (setSelected) {\n            // set status of order(s) if this action is confirmed\n            this.shippingStatusUpdateCall(selectedOrders, status);\n          }\n        });\n\n        // if the order(s) are following proper flow, set the status\n      } else if (!alertOptions.falsePreviousStatuses && alertOptions.falseCurrentState) {\n        this.shippingStatusUpdateCall(selectedOrders, status);\n        // display alert if order(s) are already in this state\n      } else if (!alertOptions.falsePreviousStatuses && !alertOptions.falseCurrentState &&\n        alertOptions.trueCurrentState) {\n        Alerts.alert({\n          text: i18next.t(\"order.orderAlreadyInState\", {\n            orderText: orderAlreadyInStateText,\n            status\n          })\n        });\n      }\n    }\n\n    displayRegressionAlert = (selectedOrders, ordersToRegress, status, options) => {\n      // capitalize the first letter of the shipping status passed in\n      // e.g. 'shipped' becomes 'Shipped'.\n      // status[0].toUpperCase() capitalizes the first letter of the string\n      // status.substr(1).toLowerCase() converts every other letter to lower case\n      const capitalizeStatus = status[0].toUpperCase() + status.substr(1).toLowerCase();\n      const alertOptions = options || {};\n      let orderText = \"order\";\n\n      if (ordersToRegress > 1) {\n        orderText = \"orders\";\n      }\n\n      Alerts.alert({\n        text: i18next.t(\"order.bulkOrdersRegressionAlert\", {\n          ordersToRegress, orderText, status: capitalizeStatus\n        }),\n        type: \"warning\",\n        showCancelButton: true,\n        showCloseButton: true,\n        allowOutsideClick: false,\n        confirmButtonText: i18next.t(\"order.approveBulkOrderActionRegression\"),\n        cancelButtonText: i18next.t(\"order.cancelBulkOrderAction\")\n      }, (regress) => {\n        if (regress) {\n          // if some of the order(s) want to skip the previous state, display warning alert for skipping states\n          if (alertOptions.falsePreviousStatuses) {\n            this.displayAlert(\n              selectedOrders, status,\n              {\n                whichFalseState: alertOptions.whichFalseState,\n                falsePreviousStatuses: alertOptions.falsePreviousStatuses,\n                falseCurrentState: alertOptions.falseCurrentState,\n                trueCurrentState: alertOptions.trueCurrentState\n              }\n            );\n          } else {\n            // set status of order(s) if this action is confirmed\n            this.shippingStatusUpdateCall(selectedOrders, status);\n          }\n        }\n      });\n    }\n\n    pickedShippingStatus = (selectedOrders, status) => {\n      // counters to keep track of how many orders are not picked,\n      // are already picked, and how many are being regressed\n      let isNotPicked = 0;\n      let isPicked = 0;\n      let ordersToRegress = 0;\n\n      // loop through selected orders array to determine the current shipping workflow\n      // status of each order in regard to the other statuses\n      // TODO: optimise this process to avoid having this similar repetitive block of code across 4 methods\n      selectedOrders.forEach((order) => {\n        const orderWorkflow = getShippingInfo(order).workflow;\n        // check if the order(s) are in this state already or in the previous state\n\n        // TODO: model this with the assumption that there may be different workflows\n        // depending on the type of shop or product that a shop is selling.\n        if (orderWorkflow) {\n          if (orderWorkflow.status === \"new\") {\n            isNotPicked += 1;\n          } else if (orderWorkflow.status === \"coreOrderWorkflow/picked\") {\n            isPicked += 1;\n          } else if (orderWorkflow.workflow.includes(\"coreOrderWorkflow/picked\")) {\n            ordersToRegress += 1;\n          } else if (!orderWorkflow.workflow.includes(\"coreOrderWorkflow/picked\") &&\n                     (orderWorkflow.status === \"coreOrderWorkflow/packed\" ||\n                      orderWorkflow.status === \"coreOrderWorkflow/labeled\" ||\n                      orderWorkflow.status === \"coreOrderWorkflow/shipped\")) {\n            ordersToRegress += 1;\n          }\n        }\n      });\n\n      // display regression alert if order(s) are being regressed\n      if (ordersToRegress) {\n        this.displayRegressionAlert(selectedOrders, ordersToRegress, status);\n\n        // set status to 'picked' if order(s) are in the previous state OR\n        // display alert if order(s) are already in this state\n      } else {\n        this.displayAlert(\n          selectedOrders, status,\n          {\n            falseCurrentState: isNotPicked,\n            trueCurrentState: isPicked\n          }\n        );\n      }\n    }\n\n    packedShippingStatus = (selectedOrders, status) => {\n      // if an order state wants to skip to packed, this is the state being skipped\n      const whichFalseState = shippingStates.picked;\n      // counters to keep track of how many orders are not picked/packed,\n      // are already packed, and how many are being regressed\n      let isNotPicked = 0;\n      let isNotPacked = 0;\n      let isPacked = 0;\n      let ordersToRegress = 0;\n\n      // loop through selected orders array to determine the current shipping workflow\n      // status of each order in regard to the other statuses\n      // TODO: optimise this process to avoid having this similar repetitive block of code across 4 methods\n      selectedOrders.forEach((order) => {\n        const orderWorkflow = getShippingInfo(order).workflow;\n\n        // check if the order(s) are in this state already or in one of the previous states\n\n        // TODO: model this with the assumption that there may be different workflows\n        // depending on the type of shop or product that a shop is selling.\n        if (orderWorkflow) {\n          if (orderWorkflow.status === \"new\") {\n            isNotPicked += 1;\n          } else if (orderWorkflow.status === \"coreOrderWorkflow/picked\") {\n            isNotPacked += 1;\n          } else if (orderWorkflow.status === \"coreOrderWorkflow/packed\") {\n            isPacked += 1;\n          } else if (orderWorkflow.workflow.includes(\"coreOrderWorkflow/packed\")) { // check if the selected order(s) are being regressed back to this state\n            ordersToRegress += 1;\n          } else if (!orderWorkflow.workflow.includes(\"coreOrderWorkflow/packed\") &&\n                     (orderWorkflow.status === \"coreOrderWorkflow/labeled\" ||\n                      orderWorkflow.status === \"coreOrderWorkflow/shipped\")) {\n            ordersToRegress += 1;\n          }\n        }\n      });\n\n      // display regression alert if order(s) are being regressed\n      if (ordersToRegress) {\n        this.displayRegressionAlert(\n          selectedOrders, ordersToRegress, status,\n          {\n            whichFalseState,\n            falsePreviousStatuses: isNotPicked,\n            falseCurrentState: isNotPacked,\n            trueCurrentState: isPacked\n          }\n        );\n\n        // display proper alert if the order(s) are in this state already or want to skip the previous states\n      } else {\n        this.displayAlert(\n          selectedOrders, status,\n          {\n            whichFalseState,\n            falsePreviousStatuses: isNotPicked,\n            falseCurrentState: isNotPacked,\n            trueCurrentState: isPacked\n          }\n        );\n      }\n    }\n\n    labeledShippingStatus = (selectedOrders, status) => {\n      // string that will hold the state being skipped\n      let whichFalseState = \"\";\n      // counters to keep track of how many orders are not picked/packed/labeled,\n      // are already labeled, and how many are being regressed\n      let isNotPacked = 0;\n      let isNotLabeled = 0;\n      let isLabeled = 0;\n      let ordersToRegress = 0;\n\n      // loop through selected orders array to determine the current shipping workflow\n      // status of each order in regard to the other statuses\n      // TODO: optimise this process to avoid having this similar repetitive block of code across 4 methods\n      selectedOrders.forEach((order) => {\n        const orderWorkflow = getShippingInfo(order).workflow;\n        // check if the order(s) are in this state already or in one of the previous states\n\n        // TODO: model this with the assumption that there may be different workflows\n        // depending on the type of shop or product that a shop is selling.\n        if (orderWorkflow) {\n          if (orderWorkflow.status === \"new\") {\n            isNotPacked += 1;\n            whichFalseState = shippingStates.picked;\n          } else if (orderWorkflow.status === \"coreOrderWorkflow/picked\") {\n            isNotPacked += 1;\n            whichFalseState = shippingStates.packed;\n          } else if (orderWorkflow.status === \"coreOrderWorkflow/packed\") {\n            isNotLabeled += 1;\n          } else if (orderWorkflow.status === \"coreOrderWorkflow/labeled\") {\n            isLabeled += 1;\n          } else if (orderWorkflow.workflow.includes(\"coreOrderWorkflow/labeled\") ||\n                     orderWorkflow.status === \"coreOrderWorkflow/shipped\") { // check if the selected order(s) are being regressed back to this state\n            ordersToRegress += 1;\n          }\n        }\n      });\n\n      // display regression alert if order(s) are being regressed\n      if (ordersToRegress) {\n        this.displayRegressionAlert(\n          selectedOrders, ordersToRegress, status,\n          {\n            whichFalseState,\n            falsePreviousStatuses: isNotPacked,\n            falseCurrentState: isNotLabeled,\n            trueCurrentState: isLabeled\n          }\n        );\n\n        // display proper alert if the order(s) are in this state already or want to skip the previous states\n      } else {\n        this.displayAlert(\n          selectedOrders, status,\n          {\n            whichFalseState,\n            falsePreviousStatuses: isNotPacked,\n            falseCurrentState: isNotLabeled,\n            trueCurrentState: isLabeled\n          }\n        );\n      }\n    }\n\n\n    shippedShippingStatus = (selectedOrders, status) => {\n      // string that will hold the state being skipped\n      let whichFalseState = \"\";\n      // counters to keep track of how many orders are not picked/packed/labeled/shipped,\n      // are already shipped, and how many are being regressed\n      let isNotLabeled = 0;\n      let isNotShipped = 0;\n      let isShipped = 0;\n\n      // loop through selected orders array to determine the current shipping workflow\n      // status of each order in regard to the other statuses\n      // TODO: optimise this process to avoid having this similar repetitive block of code across 4 methods\n      selectedOrders.forEach((order) => {\n        const orderWorkflow = getShippingInfo(order).workflow;\n        // check if the order(s) are in this state already or in one of the previous states\n\n        // TODO: model this with the assumption that there may be different workflows\n        // depending on the type of shop or product that a shop is selling.\n        if (orderWorkflow) {\n          const orderWorkflowStatus = orderWorkflow.status;\n          if (orderWorkflowStatus === \"new\") {\n            isNotLabeled += 1;\n            whichFalseState = shippingStates.picked;\n          } else if (orderWorkflowStatus === \"coreOrderWorkflow/picked\") {\n            isNotLabeled += 1;\n            whichFalseState = shippingStates.packed;\n          } else if (orderWorkflowStatus === \"coreOrderWorkflow/packed\") {\n            isNotLabeled += 1;\n            whichFalseState = shippingStates.labeled;\n          } else if (orderWorkflowStatus === \"coreOrderWorkflow/labeled\") {\n            isNotShipped += 1;\n          } else if (orderWorkflowStatus === \"coreOrderWorkflow/shipped\") {\n            isShipped += 1;\n          }\n        }\n      });\n\n      // display proper alert if the order(s) are in this state already or want to skip the previous states\n      this.displayAlert(\n        selectedOrders, status,\n        {\n          whichFalseState,\n          falsePreviousStatuses: isNotLabeled,\n          falseCurrentState: isNotShipped,\n          trueCurrentState: isShipped\n        }\n      );\n    }\n\n    /**\n     * setShippingStatus\n     *\n     * @summary call the relevant method based on the provided shipping status\n     * @param {String} status - the selected shipping status to be set\n     * @param {Array} selectedOrdersIds - array of ids of the selected orders\n     * @param {Array} orders - array of orders\n     * @return {null} no return value\n     */\n    setShippingStatus = (status, selectedOrdersIds, orders) => {\n      this.setState({\n        renderFlowList: true\n      });\n      const selectedOrders = orders.filter((order) => selectedOrdersIds.includes(order._id));\n\n      if (status === \"picked\") {\n        this.pickedShippingStatus(selectedOrders, status);\n      }\n\n      if (status === \"packed\") {\n        this.packedShippingStatus(selectedOrders, status);\n      }\n\n      if (status === \"labeled\") {\n        this.labeledShippingStatus(selectedOrders, status);\n      }\n\n      if (status === \"shipped\") {\n        this.shippedShippingStatus(selectedOrders, status);\n      }\n    }\n\n    /**\n     * orderCreditMethod: Finds the credit record in order.billing for the active shop\n     * @param order: The order where to find the billing record in.\n     * @return: The billing record with paymentMethod.method === credit of currently active shop\n     */\n    orderCreditMethod(order) {\n      const creditBillingRecords = order.billing.filter((value) => value.paymentMethod.method === \"credit\");\n      const billingRecord = creditBillingRecords.find((billing) => billing.shopId === Reaction.getShopId());\n      return billingRecord;\n    }\n\n    handleBulkPaymentCapture = (selectedOrdersIds, orders) => {\n      this.setState({\n        isLoading: {\n          capturePayment: true\n        }\n      });\n      const selectedOrders = orders.filter((order) => selectedOrdersIds.includes(order._id));\n\n      let orderCount = 0;\n      const done = () => {\n        orderCount += 1;\n        if (orderCount === selectedOrders.length) {\n          this.setState({\n            isLoading: {\n              capturePayment: false\n            }\n          });\n          Alerts.alert({\n            text: i18next.t(\"order.paymentCaptureSuccess\"),\n            type: \"success\",\n            allowOutsideClick: false\n          });\n        }\n      };\n\n      // TODO: send these orders in batch as an array. This would entail re-writing the\n      // \"orders/approvePayment\" method to receive an array of orders as a param.\n      selectedOrders.forEach((order) => {\n        // Only capture orders which are not captured yet (but possibly are already approved)\n        const billingRecord = this.orderCreditMethod(order);\n        if (billingRecord.paymentMethod.mode === \"capture\" && billingRecord.paymentMethod.status === \"completed\") {\n          done();\n          return;\n        }\n        Meteor.call(\"orders/approvePayment\", order, (approvePaymentError) => {\n          if (approvePaymentError) {\n            this.setState({\n              isLoading: {\n                capturePayment: false\n              }\n            });\n            Alerts.toast(`An error occured while approving the payment: ${approvePaymentError}`, \"error\");\n          } else {\n            // TODO: send these orders in batch as an array. This would entail re-writing the\n            // \"orders/capturePayments\" method to receive an array of orders as a param.\n            Meteor.call(\"orders/capturePayments\", order._id, (capturePaymentError) => {\n              if (capturePaymentError) {\n                this.setState({\n                  isLoading: {\n                    capturePayment: false\n                  }\n                });\n                Alerts.toast(`An error occured while capturing the payment: ${capturePaymentError}`, \"error\");\n              }\n              done();\n            });\n          }\n        });\n      });\n    }\n\n    render() {\n      return (\n        <Comp\n          {...this.props}\n          handleSelect={this.handleSelect}\n          handleClick={this.handleClick}\n          displayMedia={getPrimaryMediaForOrderItem}\n          selectedItems={this.state.selectedItems}\n          selectAllOrders={this.selectAllOrders}\n          multipleSelect={this.state.multipleSelect}\n          setShippingStatus={this.setShippingStatus}\n          shipping={this.state.shipping}\n          isLoading={this.state.isLoading}\n          renderFlowList={this.state.renderFlowList}\n          toggleShippingFlowList={this.toggleShippingFlowList}\n          handleBulkPaymentCapture={this.handleBulkPaymentCapture}\n        />\n      );\n    }\n  }\n);\n\nregisterComponent(\"OrderTable\", OrderTable, [wrapComponent]);\n\nexport default compose(wrapComponent)(OrderTable);\n"]},"sourceType":"script","hash":"38619b176bd2334574e84110018ce581e59a8a52"}
