{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$1$2","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"ast":true,"babelrc":false,"sourceFileName":"server/api/core/addDefaultRoles.js","filename":"server/api/core/addDefaultRoles.js","sourceMaps":true,"envName":"development","cwd":"/Users/estebandev/test-knowledge","passPerPreset":false,"presets":[],"parserOpts":{"sourceType":"module","sourceFileName":"server/api/core/addDefaultRoles.js","plugins":["jsx","jsx","flow","flow","objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties"]},"generatorOpts":{"filename":"server/api/core/addDefaultRoles.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"server/api/core/addDefaultRoles.js"}},"code":"var _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/builtin/objectSpread\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nmodule.export({\n  addRolesToGroups: () => addRolesToGroups\n});\nlet Meteor;\nmodule.watch(require(\"meteor/meteor\"), {\n  Meteor(v) {\n    Meteor = v;\n  }\n\n}, 0);\nlet check, Match;\nmodule.watch(require(\"meteor/check\"), {\n  check(v) {\n    check = v;\n  },\n\n  Match(v) {\n    Match = v;\n  }\n\n}, 1);\nlet Accounts, Groups, Shops;\nmodule.watch(require(\"../../../lib/collections\"), {\n  Accounts(v) {\n    Accounts = v;\n  },\n\n  Groups(v) {\n    Groups = v;\n  },\n\n  Shops(v) {\n    Shops = v;\n  }\n\n}, 2);\nlet Logger;\nmodule.watch(require(\"./..\"), {\n  Logger(v) {\n    Logger = v;\n  }\n\n}, 3);\n\n/**\n * Private method which should only be called by addRolesToGroups to keep users in sync with updated groups\n * @private\n * @method addRolesToUsersInGroups\n * @param  {object} options object that contains the query selector for groups and roles to add to users\n * @returns {void}\n */\nfunction addRolesToUsersInGroups(options) {\n  const {\n    query,\n    roles\n  } = (0, _objectSpread2.default)({}, options);\n\n  if (!query.shopId) {\n    const shops = Shops.find({}).fetch();\n    const shopIds = shops.map(shop => shop._id);\n    query.shopId = {\n      $in: shopIds\n    };\n  }\n\n  const groupsToUpdate = Groups.find(query, {\n    fields: {\n      _id: 1,\n      shopId: 1\n    }\n  }).fetch(); // We need a list of groups => shops to determine which users get which updates\n\n  const groupAndShopIds = groupsToUpdate.map(group => ({\n    id: group._id,\n    shopId: group.shopId\n  })); // We perform one update for each groupId and return a count of the number of updates performed\n\n  groupAndShopIds.forEach(group => {\n    // Find all accounts with this group\n    const accounts = Accounts.find({\n      groups: group.id\n    }, {\n      fields: {\n        _id: 1\n      }\n    }).fetch(); // Get a list of all userIds in those accounts\n\n    const userIds = accounts.map(account => account._id); // We're going to update all users with an _id that matched\n\n    const selector = {\n      _id: {\n        $in: userIds\n      }\n    }; // Build our update operation - add new roles to set for the shop associated with this group.\n\n    const operation = {\n      $addToSet: {\n        [`roles.${group.shopId}`]: {\n          $each: roles\n        }\n      }\n    }; // Update users\n\n    Meteor.users.update(selector, operation, {\n      multi: true\n    });\n  });\n}\n/**\n * @name addRolesToGroups\n * @method\n * @memberof Core\n * @summary Add roles to the default groups for shops and updates any users that are in\n * those permission groups\n * Options:\n * allShops: add supplied roles to all shops, defaults to false\n * roles: Array of roles to add to default roles set\n * shops: Array of shopIds that should be added to set\n * groups: Groups to add roles to, Options: [\"guest\", \"customer\", \"owner\"]\n * @param {Object} options - See above for details\n * @returns {Number} result of Groups.update method (number of documents updated)\n */\n\n\nfunction addRolesToGroups(options = {\n  allShops: false,\n  roles: [],\n  shops: [],\n  groups: [\"guest\"]\n}) {\n  check(options.roles, [String]);\n  check(options.allShops, Match.Maybe(Boolean));\n  check(options.shops, Match.Maybe([String]));\n  check(options.groups, Match.Maybe([String]));\n  const {\n    allShops,\n    roles,\n    shops,\n    groups\n  } = options;\n  const query = {\n    slug: {\n      $in: groups\n    }\n  };\n  const multi = {\n    multi: true\n  };\n\n  if (!allShops) {\n    // if we're not updating for all shops, we should only update for the shops passed in.\n    query.shopId = {\n      $in: shops || []\n    };\n    Logger.debug(`Adding Roles: ${roles} to Groups: ${groups} for shops: ${shops}`);\n  } else {\n    Logger.debug(`Adding Roles: ${roles} to Groups: ${groups} for all shops`);\n  }\n\n  addRolesToUsersInGroups({\n    query,\n    roles\n  });\n  return Groups.update(query, {\n    $addToSet: {\n      permissions: {\n        $each: roles\n      }\n    }\n  }, multi);\n}","map":{"version":3,"sources":["server/api/core/addDefaultRoles.js"],"names":["module","export","addRolesToGroups","Meteor","watch","require","v","check","Match","Accounts","Groups","Shops","Logger","addRolesToUsersInGroups","options","query","roles","shopId","shops","find","fetch","shopIds","map","shop","_id","$in","groupsToUpdate","fields","groupAndShopIds","group","id","forEach","accounts","groups","userIds","account","selector","operation","$addToSet","$each","users","update","multi","allShops","String","Maybe","Boolean","slug","debug","permissions"],"mappings":"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","sourcesContent":["import { Meteor } from \"meteor/meteor\";\nimport { check, Match } from \"meteor/check\";\nimport { Accounts, Groups, Shops } from \"/lib/collections\";\nimport { Logger } from \"/server/api\";\n\n/**\n * Private method which should only be called by addRolesToGroups to keep users in sync with updated groups\n * @private\n * @method addRolesToUsersInGroups\n * @param  {object} options object that contains the query selector for groups and roles to add to users\n * @returns {void}\n */\nfunction addRolesToUsersInGroups(options) {\n  const { query, roles } = { ...options };\n\n  if (!query.shopId) {\n    const shops = Shops.find({}).fetch();\n    const shopIds = shops.map((shop) => shop._id);\n    query.shopId = {\n      $in: shopIds\n    };\n  }\n\n  const groupsToUpdate = Groups.find(query, { fields: { _id: 1, shopId: 1 } }).fetch();\n  // We need a list of groups => shops to determine which users get which updates\n  const groupAndShopIds = groupsToUpdate.map((group) => ({\n    id: group._id,\n    shopId: group.shopId\n  }));\n\n  // We perform one update for each groupId and return a count of the number of updates performed\n  groupAndShopIds.forEach((group) => {\n    // Find all accounts with this group\n    const accounts = Accounts.find({ groups: group.id }, { fields: { _id: 1 } }).fetch();\n    // Get a list of all userIds in those accounts\n    const userIds = accounts.map((account) => account._id);\n    // We're going to update all users with an _id that matched\n    const selector = { _id: { $in: userIds } };\n\n    // Build our update operation - add new roles to set for the shop associated with this group.\n    const operation = {\n      $addToSet: {\n        [`roles.${group.shopId}`]: {\n          $each: roles\n        }\n      }\n    };\n\n    // Update users\n    Meteor.users.update(selector, operation, { multi: true });\n  });\n}\n\n/**\n * @name addRolesToGroups\n * @method\n * @memberof Core\n * @summary Add roles to the default groups for shops and updates any users that are in\n * those permission groups\n * Options:\n * allShops: add supplied roles to all shops, defaults to false\n * roles: Array of roles to add to default roles set\n * shops: Array of shopIds that should be added to set\n * groups: Groups to add roles to, Options: [\"guest\", \"customer\", \"owner\"]\n * @param {Object} options - See above for details\n * @returns {Number} result of Groups.update method (number of documents updated)\n */\nexport function addRolesToGroups(options = { allShops: false, roles: [], shops: [], groups: [\"guest\"] }) {\n  check(options.roles, [String]);\n  check(options.allShops, Match.Maybe(Boolean));\n  check(options.shops, Match.Maybe([String]));\n  check(options.groups, Match.Maybe([String]));\n\n  const { allShops, roles, shops, groups } = options;\n  const query = {\n    slug: {\n      $in: groups\n    }\n  };\n  const multi = { multi: true };\n\n  if (!allShops) {\n    // if we're not updating for all shops, we should only update for the shops passed in.\n    query.shopId = { $in: shops || [] };\n    Logger.debug(`Adding Roles: ${roles} to Groups: ${groups} for shops: ${shops}`);\n  } else {\n    Logger.debug(`Adding Roles: ${roles} to Groups: ${groups} for all shops`);\n  }\n\n  addRolesToUsersInGroups({ query, roles });\n\n  return Groups.update(query, { $addToSet: { permissions: { $each: roles } } }, multi);\n}\n"]},"sourceType":"script","hash":"56b2ef2c6c6b6858034268ce1c7ef31194888703"}
