{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$1$2","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"ast":true,"babelrc":false,"sourceFileName":"server/api/core/core.js","filename":"server/api/core/core.js","sourceMaps":true,"envName":"development","cwd":"/Users/estebandev/test-knowledge","passPerPreset":false,"presets":[],"parserOpts":{"sourceType":"module","sourceFileName":"server/api/core/core.js","plugins":["jsx","jsx","flow","flow","objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties"]},"generatorOpts":{"filename":"server/api/core/core.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"server/api/core/core.js"}},"code":"let _has;\n\nmodule.watch(require(\"lodash/has\"), {\n  default(v) {\n    _has = v;\n  }\n\n}, 0);\n\nlet _each;\n\nmodule.watch(require(\"lodash/each\"), {\n  default(v) {\n    _each = v;\n  }\n\n}, 1);\n\nlet _isEqual;\n\nmodule.watch(require(\"lodash/isEqual\"), {\n  default(v) {\n    _isEqual = v;\n  }\n\n}, 2);\n\nlet _uniq;\n\nmodule.watch(require(\"lodash/uniq\"), {\n  default(v) {\n    _uniq = v;\n  }\n\n}, 3);\n\nlet _difference;\n\nmodule.watch(require(\"lodash/difference\"), {\n  default(v) {\n    _difference = v;\n  }\n\n}, 4);\n\nlet _uniqWith;\n\nmodule.watch(require(\"lodash/uniqWith\"), {\n  default(v) {\n    _uniqWith = v;\n  }\n\n}, 5);\n\nlet _merge;\n\nmodule.watch(require(\"lodash/merge\"), {\n  default(v) {\n    _merge = v;\n  }\n\n}, 6);\nlet url;\nmodule.watch(require(\"url\"), {\n  default(v) {\n    url = v;\n  }\n\n}, 7);\nlet packageJson;\nmodule.watch(require(\"../../../package.json\"), {\n  default(v) {\n    packageJson = v;\n  }\n\n}, 8);\nlet Meteor;\nmodule.watch(require(\"meteor/meteor\"), {\n  Meteor(v) {\n    Meteor = v;\n  }\n\n}, 9);\nlet check;\nmodule.watch(require(\"meteor/check\"), {\n  check(v) {\n    check = v;\n  }\n\n}, 10);\nlet Random;\nmodule.watch(require(\"meteor/random\"), {\n  Random(v) {\n    Random = v;\n  }\n\n}, 11);\nlet Accounts;\nmodule.watch(require(\"meteor/accounts-base\"), {\n  Accounts(v) {\n    Accounts = v;\n  }\n\n}, 12);\nlet Roles;\nmodule.watch(require(\"meteor/alanning:roles\"), {\n  Roles(v) {\n    Roles = v;\n  }\n\n}, 13);\nlet EJSON;\nmodule.watch(require(\"meteor/ejson\"), {\n  EJSON(v) {\n    EJSON = v;\n  }\n\n}, 14);\nlet Collections;\nmodule.watch(require(\"../../../lib/collections\"), {\n  \"*\"(v) {\n    Collections = v;\n  }\n\n}, 15);\nlet Hooks, Logger;\nmodule.watch(require(\"./..\"), {\n  Hooks(v) {\n    Hooks = v;\n  },\n\n  Logger(v) {\n    Logger = v;\n  }\n\n}, 16);\nlet ProcessJobs;\nmodule.watch(require(\"../../jobs\"), {\n  default(v) {\n    ProcessJobs = v;\n  }\n\n}, 17);\nlet registerTemplate;\nmodule.watch(require(\"./templates\"), {\n  registerTemplate(v) {\n    registerTemplate = v;\n  }\n\n}, 18);\nlet sendVerificationEmail;\nmodule.watch(require(\"./accounts\"), {\n  sendVerificationEmail(v) {\n    sendVerificationEmail = v;\n  }\n\n}, 19);\nlet getMailUrl;\nmodule.watch(require(\"./email/config\"), {\n  getMailUrl(v) {\n    getMailUrl = v;\n  }\n\n}, 20);\nlet createGroups;\nmodule.watch(require(\"./groups\"), {\n  createGroups(v) {\n    createGroups = v;\n  }\n\n}, 21);\nlet ConnectionDataStore;\nmodule.watch(require(\"./connectionDataStore\"), {\n  default(v) {\n    ConnectionDataStore = v;\n  }\n\n}, 22);\n\n/**\n * @file Server core methods\n *\n * @namespace Core\n */\n// Unpack the named Collections we use.\nconst {\n  Jobs,\n  Packages,\n  Shops,\n  Accounts: AccountsCollection\n} = Collections;\nmodule.exportDefault({\n  init() {\n    // run beforeCoreInit hooks\n    Hooks.Events.run(\"beforeCoreInit\"); // make sure the default shop has been created before going further\n\n    while (!this.getShopId()) {\n      Logger.warn(\"No shopId, waiting one second...\");\n\n      Meteor._sleepForMs(1000);\n    } // run onCoreInit hooks\n\n\n    Hooks.Events.run(\"onCoreInit\"); // start job server\n\n    Jobs.startJobServer(() => {\n      Logger.info(\"JobServer started\");\n      ProcessJobs();\n      Hooks.Events.run(\"onJobServerStart\");\n    });\n\n    if (process.env.VERBOSE_JOBS) {\n      Jobs.setLogStream(process.stdout);\n    }\n\n    this.loadPackages(); // process imports from packages and any hooked imports\n\n    this.Importer.flush();\n    this.createGroups(); // timing is important, packages are rqd for initial permissions configuration.\n\n    if (!Meteor.isAppTest) {\n      this.createDefaultAdminUser();\n    }\n\n    this.setAppVersion(); // hook after init finished\n\n    Hooks.Events.run(\"afterCoreInit\");\n    Logger.debug(\"Reaction.init() has run\");\n    return true;\n  },\n\n  Packages: {},\n\n  registerPackage(packageInfo) {\n    this.Packages[packageInfo.name] = packageInfo;\n    const registeredPackage = this.Packages[packageInfo.name];\n    return registeredPackage;\n  },\n\n  defaultCustomerRoles: [\"guest\", \"account/profile\", \"product\", \"tag\", \"index\", \"cart/checkout\", \"cart/completed\"],\n  defaultVisitorRoles: [\"anonymous\", \"guest\", \"product\", \"tag\", \"index\", \"cart/checkout\", \"cart/completed\"],\n  createGroups,\n\n  /**\n   * @name canInviteToGroup\n   * @method\n   * @memberof Core\n   * @summary checks if the user making the request is allowed to make invitation to that group\n   * @param {Object} options -\n   * @param {Object} options.group - group to invite to\n   * @param {Object} options.user - user object  making the invite (Meteor.user())\n   * @return {Boolean} -\n   */\n  canInviteToGroup(options) {\n    const {\n      group\n    } = options;\n    let {\n      user\n    } = options;\n\n    if (!user) {\n      user = Meteor.user();\n    }\n\n    const userPermissions = user.roles[group.shopId];\n    const groupPermissions = group.permissions; // granting invitation right for user with `owner` role in a shop\n\n    if (this.hasPermission([\"owner\"], Meteor.userId(), group.shopId)) {\n      return true;\n    } // checks that userPermissions includes all elements from groupPermissions\n    // we are not using Reaction.hasPermission here because it returns true if the user has at least one\n\n\n    return _difference(groupPermissions, userPermissions).length === 0;\n  },\n\n  /**\n   * @name registerTemplate\n   * @method\n   * @memberof Core\n   * @summary Registers Templates into the Templates Collection\n   * @return {function} Registers template\n   */\n  registerTemplate,\n\n  /**\n   * @name hasPermission\n   * @method\n   * @memberof Core\n   * @summary server permissions checks hasPermission exists on both the server and the client.\n   * @param {String | Array} checkPermissions -String or Array of permissions if empty, defaults to \"admin, owner\"\n   * @param {String} userId - userId, defaults to Meteor.userId()\n   * @param {String} checkGroup group - default to shopId\n   * @return {Boolean} Boolean - true if has permission\n   */\n  hasPermission(checkPermissions, userId = Meteor.userId(), checkGroup = this.getShopId()) {\n    // check(checkPermissions, Match.OneOf(String, Array)); check(userId, String); check(checkGroup,\n    // Match.Optional(String));\n    let permissions; // default group to the shop or global if shop isn't defined for some reason.\n\n    let group;\n\n    if (checkGroup !== undefined && typeof checkGroup === \"string\") {\n      group = checkGroup;\n    } else {\n      group = this.getShopId() || Roles.GLOBAL_GROUP;\n    } // permissions can be either a string or an array we'll force it into an array and use that\n\n\n    if (checkPermissions === undefined) {\n      permissions = [\"owner\"];\n    } else if (typeof checkPermissions === \"string\") {\n      permissions = [checkPermissions];\n    } else {\n      permissions = checkPermissions;\n    } // if the user has admin, owner permissions we'll always check if those roles are enough\n\n\n    permissions.push(\"owner\");\n    permissions = _uniq(permissions); // return if user has permissions in the group\n\n    return Roles.userIsInRole(userId, permissions, group);\n  },\n\n  /**\n   * @name hasOwnerAccess\n   * @method\n   * @memberof Core\n   * @return {Boolean} Boolean - true if has permission\n   */\n  hasOwnerAccess() {\n    return this.hasPermission([\"owner\"]);\n  },\n\n  /**\n   * @name hasAdminAccess\n   * @method\n   * @memberof Core\n   * @return {Boolean} Boolean - true if has permission\n   */\n  hasAdminAccess() {\n    return this.hasPermission([\"owner\", \"admin\"]);\n  },\n\n  /**\n   * @name hasDashboardAccess\n   * @method\n   * @memberof Core\n   * @return {Boolean} Boolean - true if has permission\n   */\n  hasDashboardAccess() {\n    return this.hasPermission([\"owner\", \"admin\", \"dashboard\"]);\n  },\n\n  /**\n   * @summary Finds all shops that a user has a given set of roles for\n   * @name getShopsWithRoles\n   * @method\n   * @memberof Core\n   * @param  {array} roles an array of roles to check. Will return a shopId if the user has _any_ of the roles\n   * @param  {string} [userId=Meteor.userId()] Optional userId, defaults to Meteor.userId()\n   *                                           Must pass this.userId from publications to avoid error!\n   * @return {array} Array of shopIds that the user has at least one of the given set of roles for\n   */\n  getShopsWithRoles(roles, userId = Meteor.userId()) {\n    // Owner permission for a shop superceeds grantable permissions, so we always check for owner permissions as well\n    roles.push(\"owner\"); // Reducer that returns a unique list of shopIds that results from calling getGroupsForUser for each role\n\n    return roles.reduce((shopIds, role) => {\n      // getGroupsForUser will return a list of shops for which this user has the supplied role for\n      const shopIdsUserHasRoleFor = Roles.getGroupsForUser(userId, role); // If we have new shopIds found, add them to the list\n\n      if (Array.isArray(shopIdsUserHasRoleFor) && shopIdsUserHasRoleFor.length > 0) {\n        // Create unique array from existing shopIds array and the shops\n        return [...new Set([...shopIds, ...shopIdsUserHasRoleFor])];\n      } // IF we don't have any shopIds returned, keep our existing list\n\n\n      return shopIds;\n    }, []);\n  },\n\n  /**\n   * @name getSellerShopId\n   * @method\n   * @memberof Core\n   * @return {String} Shop ID\n   */\n  getSellerShopId() {\n    return Roles.getGroupsForUser(this.userId, \"admin\");\n  },\n\n  /**\n   * @name configureMailUrl\n   * @method\n   * @memberof Core\n   * @summary Reaction.configureMailUrl() is deprecated. Please use Reaction.Email.getMailUrl() instead\n   * @return {String} URL\n   * @deprecated\n   */\n  configureMailUrl() {\n    // maintained for legacy support\n    Logger.warn(\"Reaction.configureMailUrl() is deprecated. Please use Reaction.Email.getMailUrl() instead\");\n    return getMailUrl();\n  },\n\n  /**\n   * @name getPrimaryShop\n   * @summary Get the first created shop. In marketplace, the Primary Shop is the shop that controls the marketplace\n   * and can see all other shops\n   * @method\n   * @memberof Core\n   * @return {Object} Shop\n   */\n  getPrimaryShop() {\n    const primaryShop = Shops.findOne({\n      shopType: \"primary\"\n    });\n    return primaryShop;\n  },\n\n  /**\n   * @name getPrimaryShopId\n   * @summary Get the first created shop ID. In marketplace, the Primary Shop is the shop that controls the marketplace\n   * and can see all other shops\n   * @method\n   * @memberof Core\n   * @return {String} ID\n   */\n  getPrimaryShopId() {\n    const primaryShop = this.getPrimaryShop();\n\n    if (primaryShop) {\n      return primaryShop._id;\n    }\n  },\n\n  /**\n   * @name getPrimaryShopName\n   * @method\n   * @summary Get primary shop name or empty string\n   * @memberof Core\n   * @return {String} Return shop name or empty string\n   */\n  getPrimaryShopName() {\n    const primaryShop = this.getPrimaryShop();\n\n    if (primaryShop) {\n      return primaryShop.name;\n    }\n\n    return \"\";\n  },\n\n  /**\n   * @name getPrimaryShopPrefix\n   * @summary Get primary shop prefix for URL\n   * @memberof Core\n   * @method\n   * @todo Primary Shop should probably not have a prefix (or should it be /shop?)\n   * @return {String} Prefix in the format of \"/<slug>\"\n   */\n  getPrimaryShopPrefix() {\n    return `/${this.getSlug(this.getPrimaryShopName().toLowerCase())}`;\n  },\n\n  /**\n   * @name getPrimaryShopSettings\n   * @method\n   * @memberof Core\n   * @summary Get primary shop settings object\n   * @return {Object} Get settings object or empty object\n   */\n  getPrimaryShopSettings() {\n    const settings = Packages.findOne({\n      name: \"core\",\n      shopId: this.getPrimaryShopId()\n    }) || {};\n    return settings.settings || {};\n  },\n\n  /**\n   * @name getPrimaryShopCurrency\n   * @method\n   * @memberof Core\n   * @summary Get primary shop currency string\n   * @return {String} Get shop currency or \"USD\"\n   */\n  getPrimaryShopCurrency() {\n    const primaryShop = this.getPrimaryShop();\n\n    if (primaryShop && primaryShop.currency) {\n      return primaryShop.currency;\n    }\n\n    return \"USD\";\n  },\n\n  /**\n   * @summary **DEPRECATED** This method has been deprecated in favor of using getShopId\n   * and getPrimaryShopId. To be removed.\n   * @deprecated\n   * @memberof Core\n   * @method getCurrentShopCursor\n   * @return {Cursor} cursor of shops that match the current domain\n   */\n  getCurrentShopCursor() {\n    const domain = this.getDomain();\n    const cursor = Shops.find({\n      domains: domain\n    });\n\n    if (!cursor.count()) {\n      Logger.debug(domain, \"Add a domain entry to shops for \");\n    }\n\n    return cursor;\n  },\n\n  /**\n   * @summary **DEPRECATED** This method has been deprecated in favor of using getShopId\n   * and getPrimaryShopId. To be removed.\n   * @deprecated\n   * @memberof Core\n   * @method getCurrentShop\n   * @return {Object} returns the first shop object from the shop cursor\n   */\n  getCurrentShop() {\n    const currentShopCursor = this.getCurrentShopCursor(); // also, we could check in such a way: `currentShopCursor instanceof Object` but not instanceof something.Cursor\n\n    if (typeof currentShopCursor === \"object\") {\n      return currentShopCursor.fetch()[0];\n    }\n\n    return null;\n  },\n\n  /**\n   * @name getShopId\n   * @method\n   * @memberof Core\n   * @summary Get shop ID, first by checking the current user's preferences\n   * then by getting the shop by the current domain.\n   * @todo should we return the Primary Shop if none found?\n   * @return {String} active shop ID\n   */\n  getShopId() {\n    // is there a stored value?\n    let shopId = ConnectionDataStore.get(\"shopId\"); // if so, return it\n\n    if (shopId) {\n      return shopId;\n    }\n\n    try {\n      // otherwise, find the shop by user settings\n      shopId = this.getUserShopId(Meteor.userId());\n    } catch (e) {} // `Meteor.userId` will raise an error when invoked outside of a method\n    // call or publication, i.e., at startup. That's ok here.\n    // if still not found, look up the shop by domain\n\n\n    if (!shopId) {\n      shopId = this.getShopIdByDomain();\n    } // store the value for faster responses\n\n\n    ConnectionDataStore.set(\"shopId\", shopId);\n    return shopId;\n  },\n\n  /**\n   * @name clearCache\n   * @method\n   * @memberof Core\n   * @summary allows the client to trigger an uncached lookup of the shopId.\n   *          this is useful when a user switches shops.\n   */\n  resetShopId() {\n    ConnectionDataStore.clear(\"shopId\");\n  },\n\n  /**\n   * @name getShopIdByDomain\n   * @method\n   * @memberof Core\n   * @summary returns the shop which should be used given the current domain\n   */\n  getShopIdByDomain() {\n    const domain = this.getDomain();\n    const shop = Shops.find({\n      domains: domain\n    }, {\n      limit: 1,\n      fields: {\n        _id: 1\n      }\n    }).fetch()[0];\n    return shop && shop._id;\n  },\n\n  /**\n   * @name getUserShopId\n   * @method\n   * @memberof Core\n   * @summary Get a user's shop ID, as stored in preferences\n   * @todo This should intelligently find the correct default shop Probably whatever the main shop is or marketplace\n   * @return {StringId}        active shop ID\n   */\n  getUserShopId(userId) {\n    check(userId, String);\n    return this.getUserPreferences({\n      userId,\n      packageName: \"reaction\",\n      preference: \"activeShopId\"\n    });\n  },\n\n  /**\n   * @name getDomain\n   * @method\n   * @memberof Core\n   * @summary Get shop domain for URL\n   * @return {String} Shop domain\n   */\n  getDomain() {\n    return url.parse(Meteor.absoluteUrl()).hostname;\n  },\n\n  /**\n   * @name getShopName\n   * @method\n   * @memberof Core\n   * @summary If we can't find the shop or shop name return an empty string\n   * @return {String} Shop name or empty string \"\"\n   */\n  getShopName() {\n    const shopId = this.getShopId();\n    let shop;\n\n    if (shopId) {\n      shop = Shops.findOne({\n        _id: shopId\n      }, {\n        fields: {\n          name: 1\n        }\n      });\n    } else {\n      const domain = this.getDomain();\n      shop = Shops.findOne({\n        domains: domain\n      }, {\n        fields: {\n          name: 1\n        }\n      });\n    }\n\n    if (shop && shop.name) {\n      return shop.name;\n    }\n\n    return \"\";\n  },\n\n  /**\n   * @name getShopPrefix\n   * @method\n   * @memberof Core\n   * @summary Get shop prefix for URL\n   * @return {String} String in the format of \"/shop/slug\"\n   */\n  getShopPrefix() {\n    const shopName = this.getShopName();\n    const lowerCaseShopName = shopName.toLowerCase();\n    const slug = this.getSlug(lowerCaseShopName);\n    const marketplace = Packages.findOne({\n      name: \"reaction-marketplace\",\n      shopId: this.getPrimaryShopId()\n    });\n\n    if (marketplace && marketplace.settings && marketplace.settings.public) {\n      return `${marketplace.settings.public.shopPrefix}/${slug}`;\n    }\n\n    return `/${slug}`;\n  },\n\n  /**\n   * @name getShopEmail\n   * @method\n   * @memberof Core\n   * @summary Get shop email\n   * @return {String} String with the first store email\n   */\n  getShopEmail() {\n    const shop = Shops.find({\n      _id: this.getShopId()\n    }, {\n      limit: 1,\n      fields: {\n        emails: 1\n      }\n    }).fetch()[0];\n    return shop && shop.emails && shop.emails[0].address;\n  },\n\n  /**\n   * @name getShopSettings\n   * @method\n   * @memberof Core\n   * @summary Get shop settings object\n   * @param  {String} [name=\"core\"] Package name\n   * @return {Object}               Shop settings object or empty object\n   */\n  getShopSettings(name = \"core\") {\n    const settings = Packages.findOne({\n      name,\n      shopId: this.getShopId()\n    }) || {};\n    return settings.settings || {};\n  },\n\n  /**\n   * @name getShopCurrency\n   * @method\n   * @memberof Core\n   * @summary Get shop currency\n   * @return {String} Shop currency or \"USD\"\n   */\n  getShopCurrency() {\n    const shop = Shops.findOne({\n      _id: this.getShopId()\n    });\n    return shop && shop.currency || \"USD\";\n  },\n\n  /**\n   * @name getShopCurrencies\n   * @method\n   * @memberof Core\n   * @summary Get all currencies available to a shop\n   * @return {Object} Shop currency or \"USD\"\n   */\n  getShopCurrencies() {\n    const shop = Shops.findOne({\n      _id: this.getShopId()\n    });\n    return shop && shop.currencies;\n  },\n\n  /**\n   * @name getShopLanguage\n   * @method\n   * @memberof Core\n   * @todo TODO: Marketplace - should each shop set their own default language or\n   * should the Marketplace set a language that's picked up by all shops?\n   * @return {String} language\n   */\n  getShopLanguage() {\n    const {\n      language\n    } = Shops.findOne({\n      _id: this.getShopId()\n    }, {\n      fields: {\n        language: 1\n      }\n    });\n    return language;\n  },\n\n  /**\n   * @name getPackageSettings\n   * @method\n   * @memberof Core\n   * @summary Get package settings\n   * @param  {String} name Package name\n   * @return {Object|null}      Package setting object or null\n   */\n  getPackageSettings(name) {\n    return Packages.findOne({\n      name,\n      shopId: this.getShopId()\n    }) || null;\n  },\n\n  /**\n   * @summary Takes options in the form of a query object. Returns a package that matches.\n   * @method\n   * @memberof Core\n   * @name getPackageSettingsWithOptions\n   * @param  {object} options Options object, forms the query for Packages.findOne\n   * @return {object} Returns the first package found with the provided options\n   */\n  getPackageSettingsWithOptions(options) {\n    const query = options;\n    return Packages.findOne(query);\n  },\n\n  /**\n   * @name getMarketplaceSettings\n   * @method\n   * @memberof Core\n   * @summary finds the enabled `reaction-marketplace` package for\n   * the primary shop and returns the settings\n   * @return {Object} The marketplace settings from the primary shop or undefined\n   */\n  getMarketplaceSettings() {\n    const marketplace = Packages.findOne({\n      name: \"reaction-marketplace\",\n      shopId: this.getPrimaryShopId(),\n      enabled: true\n    });\n\n    if (marketplace && marketplace.settings) {\n      return marketplace.settings;\n    }\n\n    return {};\n  },\n\n  /**\n   * @name getUserPreferences\n   * @method\n   * @memberof Core\n   * @param  {Object} options {packageName, preference, defaultValue}\n   * @return {String|undefined} User's package preference or undefined\n   */\n  getUserPreferences(options) {\n    const {\n      userId,\n      packageName,\n      preference,\n      defaultValue\n    } = options;\n\n    if (!userId) {\n      return undefined;\n    }\n\n    const user = AccountsCollection.findOne({\n      _id: userId\n    });\n\n    if (user) {\n      const {\n        profile\n      } = user;\n\n      if (profile && profile.preferences && profile.preferences[packageName] && profile.preferences[packageName][preference]) {\n        return profile.preferences[packageName][preference];\n      }\n    }\n\n    return defaultValue || undefined;\n  },\n\n  /**\n   * @name setUserPreferences\n   * @method\n   * @summary save user preferences in the Accounts collection\n   * @param {String} packageName\n   * @param {String} preference\n   * @param {String} value\n   * @param {String} userId\n   * @return {Number} setPreferenceResult\n   */\n  setUserPreferences(packageName, preference, value, userId) {\n    const setPreferenceResult = AccountsCollection.update(userId, {\n      $set: {\n        [`profile.preferences.${packageName}.${preference}`]: value\n      }\n    });\n    return setPreferenceResult;\n  },\n\n  /**\n   *  @name insertPackagesForShop\n   *  @method\n   *  @memberof Core\n   *  @summary insert Reaction packages into Packages collection registry for a new shop\n   *  Assigns owner roles for new packages\n   *  Imports layouts from packages\n   *  @param {String} shopId - the shopId to create packages for\n   *  @return {String} returns insert result\n   */\n  insertPackagesForShop(shopId) {\n    const layouts = [];\n\n    if (!shopId) {\n      return [];\n    } // Check to see what packages should be enabled\n\n\n    const shop = Shops.findOne({\n      _id: shopId\n    });\n    const marketplaceSettings = this.getMarketplaceSettings();\n    let enabledPackages; // Unless we have marketplace settings and an enabledPackagesByShopTypes Array\n    // we will skip this\n\n    if (marketplaceSettings && marketplaceSettings.shops && Array.isArray(marketplaceSettings.shops.enabledPackagesByShopTypes)) {\n      // Find the correct packages list for this shopType\n      const matchingShopType = marketplaceSettings.shops.enabledPackagesByShopTypes.find(EnabledPackagesByShopType => EnabledPackagesByShopType.shopType === shop.shopType); // eslint-disable-line max-len\n\n      if (matchingShopType) {\n        ({\n          enabledPackages\n        } = matchingShopType);\n      }\n    }\n\n    const packages = this.Packages; // for each shop, we're loading packages in a unique registry\n    // Object.keys(pkgConfigs).forEach((pkgName) => {\n\n    for (const packageName in packages) {\n      // Guard to prvent unexpected `for in` behavior\n      if ({}.hasOwnProperty.call(packages, packageName)) {\n        const config = packages[packageName];\n        this.assignOwnerRoles(shopId, packageName, config.registry);\n        const pkg = Object.assign({}, config, {\n          shopId\n        }); // populate array of layouts that don't already exist (?!)\n\n        if (pkg.layout) {\n          // filter out layout templates\n          for (const template of pkg.layout) {\n            if (template && template.layout) {\n              layouts.push(template);\n            }\n          }\n        }\n\n        if (enabledPackages && Array.isArray(enabledPackages)) {\n          if (enabledPackages.indexOf(pkg.name) === -1) {\n            pkg.enabled = false;\n          } else if (pkg.settings && pkg.settings[packageName]) {\n            // Enable \"soft switch\" for package.\n            pkg.settings[packageName].enabled = true;\n          }\n        }\n\n        Packages.insert(pkg);\n        Logger.debug(`Initializing ${shopId} ${packageName}`);\n      }\n    } // helper for removing layout duplicates\n\n\n    const uniqLayouts = _uniqWith(layouts, _isEqual);\n\n    Shops.update({\n      _id: shopId\n    }, {\n      $set: {\n        layout: uniqLayouts\n      }\n    });\n  },\n\n  /**\n   * @name getAppVersion\n   * @method\n   * @memberof Core\n   * @return {String} App version\n   */\n  getAppVersion() {\n    return Shops.findOne().appVersion;\n  },\n\n  /**\n   * @name createDefaultAdminUser\n   * @method\n   * @memberof Core\n   * @summary Method that creates default admin user\n   * Settings load precendence:\n   *  1. environment variables\n   *  2. settings in meteor.settings\n   * @returns {String} return userId\n   */\n  createDefaultAdminUser() {\n    const shopId = this.getPrimaryShopId();\n\n    if (!shopId) {\n      throw new Error(`createDefaultAdminUser: getPrimaryShopId returned ${shopId}`);\n    } // if an admin user has already been created, we'll exit\n\n\n    if (Roles.getUsersInRole(\"owner\", shopId).count() !== 0) {\n      Logger.debug(\"Not creating default admin user, already exists\");\n      return \"\"; // this default admin has already been created for this shop.\n    } // run hooks on options object before creating user (the options object must be returned from all callbacks)\n\n\n    let options = {};\n    options = Hooks.Events.run(\"beforeCreateDefaultAdminUser\", options); // If $REACTION_SECURE_DEFAULT_ADMIN is set to \"true\" on first run,\n    // a random email/password will be generated instead of using the\n    // default email and password (email: admin@localhost pw: r3@cti0n)\n    // and the new admin user will need to verify their email to log in.\n    // If a random email and password are generated, the console will be\n    // the only place to retrieve them.\n    // If the admin email/password is provided via environment or Meteor settings,\n    // the $REACTION_SECURE_DEFAULT_ADMIN will only enforce the email validation part.\n\n    const isSecureSetup = process.env.REACTION_SECURE_DEFAULT_ADMIN === \"true\"; // generate default values to use if none are supplied\n\n    const defaultEmail = isSecureSetup ? `${Random.id(8).toLowerCase()}@localhost` : \"admin@localhost\";\n    const defaultPassword = isSecureSetup ? Random.secret(8) : \"r3@cti0n\";\n    const defaultUsername = \"admin\";\n    const defaultName = \"Admin\"; // Process environment variables and Meteor settings for initial user config.\n    // If ENV variables are set, they always override Meteor settings (settings.json).\n    // This is to allow for testing environments where we don't want to use users configured in a settings file.\n\n    const {\n      env\n    } = process;\n    let configureEnv = false;\n\n    if (env.REACTION_EMAIL && env.REACTION_AUTH) {\n      configureEnv = true;\n      Logger.info(\"Using environment variables to create admin user\");\n    } // defaults use either env or generated values\n\n\n    options.email = env.REACTION_EMAIL || defaultEmail;\n    options.password = env.REACTION_AUTH || defaultPassword;\n    options.username = env.REACTION_USER_NAME || defaultUsername;\n    options.name = env.REACTION_USER || defaultName; // or use `meteor --settings`\n\n    if (Meteor.settings && !configureEnv) {\n      if (Meteor.settings.reaction) {\n        options.email = Meteor.settings.reaction.REACTION_EMAIL || defaultEmail;\n        options.password = Meteor.settings.reaction.REACTION_AUTH || defaultPassword;\n        options.username = Meteor.settings.reaction.REACTION_USER || defaultUsername;\n        options.name = Meteor.settings.reaction.REACTION_USER_NAME || defaultName;\n        Logger.info(\"Using meteor --settings to create admin user\");\n      }\n    } // set the default shop email to the default admin email\n\n\n    Shops.update(shopId, {\n      $addToSet: {\n        emails: {\n          address: options.email,\n          verified: true\n        }\n      }\n    }); // get the current shop\n\n    const shop = Shops.findOne(shopId); // add the current domain to the shop if it doesn't already exist\n\n    if (!shop.domains.includes(this.getDomain())) {\n      // set the default shop email to the default admin email\n      Shops.update(shopId, {\n        $addToSet: {\n          domains: this.getDomain()\n        }\n      });\n    } //\n    // create the new admin user\n    //\n\n\n    let accountId; // we're checking again to see if this user was created but not specifically for this shop.\n\n    if (Meteor.users.find({\n      \"emails.address\": options.email\n    }).count() === 0) {\n      accountId = Accounts.createUser(options);\n    } else {\n      // this should only occur when existing admin creates a new shop\n      accountId = Meteor.users.findOne({\n        \"emails.address\": options.email\n      })._id;\n    } // update the user's name if it was provided\n    // (since Accounts.createUser() doesn't allow that field and strips it out)\n\n\n    Meteor.users.update(accountId, {\n      $set: {\n        name: options.name\n      }\n    }); // unless strict security is enabled, mark the admin's email as validated\n\n    if (!isSecureSetup) {\n      Meteor.users.update({\n        \"_id\": accountId,\n        \"emails.address\": options.email\n      }, {\n        $set: {\n          \"emails.$.verified\": true\n        }\n      });\n      Collections.Accounts.update({\n        \"_id\": accountId,\n        \"emails.address\": options.email\n      }, {\n        $set: {\n          \"emails.$.verified\": true\n        }\n      });\n    } else {\n      // send verification email to admin\n      sendVerificationEmail(accountId);\n    } // Set default owner roles\n\n\n    const defaultAdminRoles = [\"owner\", \"admin\", \"guest\", \"account/profile\"]; // Join other roles with defaultAdminRoles for owner.\n    // this is needed as owner should not just have \"owner\" but all other defined roles\n\n    let ownerRoles = defaultAdminRoles.concat(this.defaultCustomerRoles);\n    ownerRoles = _uniq(ownerRoles); // we don't use accounts/addUserPermissions here because we may not yet have permissions\n\n    Roles.setUserRoles(accountId, ownerRoles, shopId); // // the reaction owner has permissions to all sites by default\n\n    Roles.setUserRoles(accountId, ownerRoles, Roles.GLOBAL_GROUP); // initialize package permissions we don't need to do any further permission configuration it is taken care of in the\n    // assignOwnerRoles\n\n    const packages = Packages.find().fetch();\n\n    for (const pkg of packages) {\n      this.assignOwnerRoles(shopId, pkg.name, pkg.registry);\n    } // notify user that the default admin was created by\n    // printing the account info to the console\n\n\n    Logger.warn(`\\n *********************************\n        \\n  IMPORTANT! DEFAULT ADMIN INFO\n        \\n  EMAIL/LOGIN: ${options.email}\n        \\n  PASSWORD: ${options.password}\n        \\n ********************************* \\n\\n`); // run hooks on new user object\n\n    const user = Meteor.users.findOne(accountId);\n    Hooks.Events.run(\"afterCreateDefaultAdminUser\", user);\n    return accountId;\n  },\n\n  /**\n   *  @name loadPackages\n   *  @method\n   *  @memberof Core\n   *  @summary Insert Reaction packages into registry\n   *  we check to see if the number of packages have changed against current data\n   *  if there is a change, we'll either insert or upsert package registry\n   *  into the Packages collection\n   *  import is processed on hook in init()\n   *  @return {String} returns insert result\n   */\n  loadPackages() {\n    const packages = Packages.find().fetch();\n    let registryFixtureData;\n\n    if (process.env.REACTION_REGISTRY) {\n      // check the environment for the registry fixture data first\n      registryFixtureData = process.env.REACTION_REGISTRY;\n      Logger.info(\"Loaded REACTION_REGISTRY environment variable for registry fixture import\");\n    } else {\n      // or attempt to load reaction.json fixture data\n      try {\n        registryFixtureData = Assets.getText(\"settings/reaction.json\");\n        Logger.info(\"Loaded \\\"/private/settings/reaction.json\\\" for registry fixture import\");\n      } catch (error) {\n        Logger.warn(\"Skipped loading settings from reaction.json.\");\n        Logger.debug(error, \"loadSettings reaction.json not loaded.\");\n      }\n    }\n\n    if (registryFixtureData) {\n      const validatedJson = EJSON.parse(registryFixtureData);\n\n      if (!Array.isArray(validatedJson[0])) {\n        Logger.warn(\"Registry fixture data is not an array. Failed to load.\");\n      } else {\n        registryFixtureData = validatedJson;\n      }\n    }\n\n    const layouts = []; // for each shop, we're loading packages in a unique registry\n\n    _each(this.Packages, (config, pkgName) => Shops.find().forEach(shop => {\n      const shopId = shop._id;\n      if (!shopId) return []; // existing registry will be upserted with changes, perhaps we should add:\n\n      this.assignOwnerRoles(shopId, pkgName, config.registry); // Settings from the package registry.js\n\n      const settingsFromPackage = {\n        name: pkgName,\n        icon: config.icon,\n        enabled: !!config.autoEnable,\n        settings: config.settings,\n        registry: config.registry,\n        layout: config.layout\n      }; // Setting from a fixture file, most likely reaction.json\n\n      let settingsFromFixture;\n\n      if (registryFixtureData) {\n        settingsFromFixture = registryFixtureData[0].find(packageSetting => config.name === packageSetting.name);\n      } // Setting already imported into the packages collection\n\n\n      const settingsFromDB = packages.find(ps => config.name === ps.name && shopId === ps.shopId);\n\n      const combinedSettings = _merge({}, settingsFromPackage, settingsFromFixture || {}, settingsFromDB || {});\n\n      if (combinedSettings.registry) {\n        combinedSettings.registry = combinedSettings.registry.map(entry => {\n          if (entry.provides && !Array.isArray(entry.provides)) {\n            entry.provides = [entry.provides];\n            Logger.warn(`Plugin ${combinedSettings.name} is using a deprecated version of the provides property for` + ` the ${entry.name || entry.route} registry entry. Since v1.5.0 registry provides accepts` + \" an array of strings.\");\n          }\n\n          return entry;\n        });\n      } // populate array of layouts that don't already exist in Shops\n\n\n      if (combinedSettings.layout) {\n        // filter out layout Templates\n        for (const pkg of combinedSettings.layout) {\n          if (pkg.layout) {\n            layouts.push(pkg);\n          }\n        }\n      } // Import package data\n\n\n      this.Importer.package(combinedSettings, shopId);\n      return Logger.debug(`Initializing ${shop.name} ${pkgName}`);\n    })); // helper for removing layout duplicates\n\n\n    const uniqLayouts = _uniqWith(layouts, _isEqual); // import layouts into Shops\n\n\n    Shops.find().forEach(shop => {\n      this.Importer.layout(uniqLayouts, shop._id);\n    }); //\n    // package cleanup\n    //\n\n    Shops.find().forEach(shop => Packages.find().forEach(pkg => {\n      // delete registry entries for packages that have been removed\n      if (!_has(this.Packages, pkg.name)) {\n        Logger.debug(`Removing ${pkg.name}`);\n        return Packages.remove({\n          shopId: shop._id,\n          name: pkg.name\n        });\n      }\n\n      return false;\n    }));\n  },\n\n  /**\n   * @name setAppVersion\n   * @method\n   * @memberof Core\n   * @return {undefined} no return value\n   */\n  setAppVersion() {\n    const {\n      version\n    } = packageJson;\n    Logger.info(`Reaction Version: ${version}`);\n    Shops.update({}, {\n      $set: {\n        appVersion: version\n      }\n    }, {\n      multi: true\n    });\n  },\n\n  /**\n   * @summary Method for getting all schemas attached to a given collection\n   * @deprecated by simpl-schema\n   * @private\n   * @name collectionSchema\n   * @param  {string} collection The mongo collection to get schemas for\n   * @param  {Object} [selector] Optional selector for multi schema collections\n   * @return {Object} Returns a simpleSchema that is a combination of all schemas\n   *                  that have been attached to the collection or false if\n   *                  the collection or schema could not be found\n   */\n  collectionSchema(collection, selector) {\n    Logger.warn(\"Reaction.collectionSchema is deprecated and will be removed\" + \" in a future release. Use collection.simpleSchema(selector).\");\n    const selectorErrMsg = selector ? `and selector ${selector}` : \"\";\n    const errMsg = `Reaction.collectionSchema could not find schemas for ${collection} collection ${selectorErrMsg}`;\n    const col = Collections[collection];\n\n    if (!col) {\n      Logger.warn(errMsg); // Return false so we don't pass a check that uses a non-existant schema\n\n      return false;\n    }\n\n    const schema = col.simpleSchema(selector);\n\n    if (!schema) {\n      Logger.warn(errMsg); // Return false so we don't pass a check that uses a non-existant schema\n\n      return false;\n    }\n\n    return schema;\n  }\n\n});","map":{"version":3,"sources":["server/api/core/core.js"],"names":["_has","module","watch","require","default","v","_each","_isEqual","_uniq","_difference","_uniqWith","_merge","url","packageJson","Meteor","check","Random","Accounts","Roles","EJSON","Collections","Hooks","Logger","ProcessJobs","registerTemplate","sendVerificationEmail","getMailUrl","createGroups","ConnectionDataStore","Jobs","Packages","Shops","AccountsCollection","exportDefault","init","Events","run","getShopId","warn","_sleepForMs","startJobServer","info","process","env","VERBOSE_JOBS","setLogStream","stdout","loadPackages","Importer","flush","isAppTest","createDefaultAdminUser","setAppVersion","debug","registerPackage","packageInfo","name","registeredPackage","defaultCustomerRoles","defaultVisitorRoles","canInviteToGroup","options","group","user","userPermissions","roles","shopId","groupPermissions","permissions","hasPermission","userId","length","checkPermissions","checkGroup","undefined","GLOBAL_GROUP","push","userIsInRole","hasOwnerAccess","hasAdminAccess","hasDashboardAccess","getShopsWithRoles","reduce","shopIds","role","shopIdsUserHasRoleFor","getGroupsForUser","Array","isArray","Set","getSellerShopId","configureMailUrl","getPrimaryShop","primaryShop","findOne","shopType","getPrimaryShopId","_id","getPrimaryShopName","getPrimaryShopPrefix","getSlug","toLowerCase","getPrimaryShopSettings","settings","getPrimaryShopCurrency","currency","getCurrentShopCursor","domain","getDomain","cursor","find","domains","count","getCurrentShop","currentShopCursor","fetch","get","getUserShopId","e","getShopIdByDomain","set","resetShopId","clear","shop","limit","fields","String","getUserPreferences","packageName","preference","parse","absoluteUrl","hostname","getShopName","getShopPrefix","shopName","lowerCaseShopName","slug","marketplace","public","shopPrefix","getShopEmail","emails","address","getShopSettings","getShopCurrency","getShopCurrencies","currencies","getShopLanguage","language","getPackageSettings","getPackageSettingsWithOptions","query","getMarketplaceSettings","enabled","defaultValue","profile","preferences","setUserPreferences","value","setPreferenceResult","update","$set","insertPackagesForShop","layouts","marketplaceSettings","enabledPackages","shops","enabledPackagesByShopTypes","matchingShopType","EnabledPackagesByShopType","packages","hasOwnProperty","call","config","assignOwnerRoles","registry","pkg","Object","assign","layout","template","indexOf","insert","uniqLayouts","getAppVersion","appVersion","Error","getUsersInRole","isSecureSetup","REACTION_SECURE_DEFAULT_ADMIN","defaultEmail","id","defaultPassword","secret","defaultUsername","defaultName","configureEnv","REACTION_EMAIL","REACTION_AUTH","email","password","username","REACTION_USER_NAME","REACTION_USER","reaction","$addToSet","verified","includes","accountId","users","createUser","defaultAdminRoles","ownerRoles","concat","setUserRoles","registryFixtureData","REACTION_REGISTRY","Assets","getText","error","validatedJson","pkgName","forEach","settingsFromPackage","icon","autoEnable","settingsFromFixture","packageSetting","settingsFromDB","ps","combinedSettings","map","entry","provides","route","package","remove","version","multi","collectionSchema","collection","selector","selectorErrMsg","errMsg","col","schema","simpleSchema"],"mappings":"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","sourcesContent":["import url from \"url\";\nimport packageJson from \"/package.json\";\nimport _, { merge, uniqWith } from \"lodash\";\nimport { Meteor } from \"meteor/meteor\";\nimport { check } from \"meteor/check\";\nimport { Random } from \"meteor/random\";\nimport { Accounts } from \"meteor/accounts-base\";\nimport { Roles } from \"meteor/alanning:roles\";\nimport { EJSON } from \"meteor/ejson\";\nimport * as Collections from \"/lib/collections\";\nimport { Hooks, Logger } from \"/server/api\";\nimport ProcessJobs from \"/server/jobs\";\nimport { registerTemplate } from \"./templates\";\nimport { sendVerificationEmail } from \"./accounts\";\nimport { getMailUrl } from \"./email/config\";\nimport { createGroups } from \"./groups\";\nimport ConnectionDataStore from \"./connectionDataStore\";\n\n/**\n * @file Server core methods\n *\n * @namespace Core\n */\n\n// Unpack the named Collections we use.\nconst { Jobs, Packages, Shops, Accounts: AccountsCollection } = Collections;\n\nexport default {\n  init() {\n    // run beforeCoreInit hooks\n    Hooks.Events.run(\"beforeCoreInit\");\n\n    // make sure the default shop has been created before going further\n    while (!this.getShopId()) {\n      Logger.warn(\"No shopId, waiting one second...\");\n      Meteor._sleepForMs(1000);\n    }\n\n    // run onCoreInit hooks\n    Hooks.Events.run(\"onCoreInit\");\n\n    // start job server\n    Jobs.startJobServer(() => {\n      Logger.info(\"JobServer started\");\n      ProcessJobs();\n      Hooks.Events.run(\"onJobServerStart\");\n    });\n    if (process.env.VERBOSE_JOBS) {\n      Jobs.setLogStream(process.stdout);\n    }\n\n    this.loadPackages();\n    // process imports from packages and any hooked imports\n    this.Importer.flush();\n    this.createGroups();\n    // timing is important, packages are rqd for initial permissions configuration.\n    if (!Meteor.isAppTest) {\n      this.createDefaultAdminUser();\n    }\n    this.setAppVersion();\n    // hook after init finished\n    Hooks.Events.run(\"afterCoreInit\");\n\n    Logger.debug(\"Reaction.init() has run\");\n\n    return true;\n  },\n\n  Packages: {},\n\n  registerPackage(packageInfo) {\n    this.Packages[packageInfo.name] = packageInfo;\n    const registeredPackage = this.Packages[packageInfo.name];\n    return registeredPackage;\n  },\n  defaultCustomerRoles: [\"guest\", \"account/profile\", \"product\", \"tag\", \"index\", \"cart/checkout\", \"cart/completed\"],\n  defaultVisitorRoles: [\"anonymous\", \"guest\", \"product\", \"tag\", \"index\", \"cart/checkout\", \"cart/completed\"],\n  createGroups,\n\n  /**\n   * @name canInviteToGroup\n   * @method\n   * @memberof Core\n   * @summary checks if the user making the request is allowed to make invitation to that group\n   * @param {Object} options -\n   * @param {Object} options.group - group to invite to\n   * @param {Object} options.user - user object  making the invite (Meteor.user())\n   * @return {Boolean} -\n   */\n  canInviteToGroup(options) {\n    const { group } = options;\n    let { user } = options;\n    if (!user) {\n      user = Meteor.user();\n    }\n    const userPermissions = user.roles[group.shopId];\n    const groupPermissions = group.permissions;\n\n    // granting invitation right for user with `owner` role in a shop\n    if (this.hasPermission([\"owner\"], Meteor.userId(), group.shopId)) {\n      return true;\n    }\n\n    // checks that userPermissions includes all elements from groupPermissions\n    // we are not using Reaction.hasPermission here because it returns true if the user has at least one\n    return _.difference(groupPermissions, userPermissions).length === 0;\n  },\n\n  /**\n   * @name registerTemplate\n   * @method\n   * @memberof Core\n   * @summary Registers Templates into the Templates Collection\n   * @return {function} Registers template\n   */\n  registerTemplate,\n\n  /**\n   * @name hasPermission\n   * @method\n   * @memberof Core\n   * @summary server permissions checks hasPermission exists on both the server and the client.\n   * @param {String | Array} checkPermissions -String or Array of permissions if empty, defaults to \"admin, owner\"\n   * @param {String} userId - userId, defaults to Meteor.userId()\n   * @param {String} checkGroup group - default to shopId\n   * @return {Boolean} Boolean - true if has permission\n   */\n  hasPermission(checkPermissions, userId = Meteor.userId(), checkGroup = this.getShopId()) {\n    // check(checkPermissions, Match.OneOf(String, Array)); check(userId, String); check(checkGroup,\n    // Match.Optional(String));\n    let permissions;\n    // default group to the shop or global if shop isn't defined for some reason.\n    let group;\n    if (checkGroup !== undefined && typeof checkGroup === \"string\") {\n      group = checkGroup;\n    } else {\n      group = this.getShopId() || Roles.GLOBAL_GROUP;\n    }\n\n    // permissions can be either a string or an array we'll force it into an array and use that\n    if (checkPermissions === undefined) {\n      permissions = [\"owner\"];\n    } else if (typeof checkPermissions === \"string\") {\n      permissions = [checkPermissions];\n    } else {\n      permissions = checkPermissions;\n    }\n\n    // if the user has admin, owner permissions we'll always check if those roles are enough\n    permissions.push(\"owner\");\n    permissions = _.uniq(permissions);\n\n    // return if user has permissions in the group\n    return Roles.userIsInRole(userId, permissions, group);\n  },\n\n  /**\n   * @name hasOwnerAccess\n   * @method\n   * @memberof Core\n   * @return {Boolean} Boolean - true if has permission\n   */\n  hasOwnerAccess() {\n    return this.hasPermission([\"owner\"]);\n  },\n\n  /**\n   * @name hasAdminAccess\n   * @method\n   * @memberof Core\n   * @return {Boolean} Boolean - true if has permission\n   */\n  hasAdminAccess() {\n    return this.hasPermission([\"owner\", \"admin\"]);\n  },\n\n  /**\n   * @name hasDashboardAccess\n   * @method\n   * @memberof Core\n   * @return {Boolean} Boolean - true if has permission\n   */\n  hasDashboardAccess() {\n    return this.hasPermission([\"owner\", \"admin\", \"dashboard\"]);\n  },\n\n  /**\n   * @summary Finds all shops that a user has a given set of roles for\n   * @name getShopsWithRoles\n   * @method\n   * @memberof Core\n   * @param  {array} roles an array of roles to check. Will return a shopId if the user has _any_ of the roles\n   * @param  {string} [userId=Meteor.userId()] Optional userId, defaults to Meteor.userId()\n   *                                           Must pass this.userId from publications to avoid error!\n   * @return {array} Array of shopIds that the user has at least one of the given set of roles for\n   */\n  getShopsWithRoles(roles, userId = Meteor.userId()) {\n    // Owner permission for a shop superceeds grantable permissions, so we always check for owner permissions as well\n    roles.push(\"owner\");\n\n    // Reducer that returns a unique list of shopIds that results from calling getGroupsForUser for each role\n    return roles.reduce((shopIds, role) => {\n      // getGroupsForUser will return a list of shops for which this user has the supplied role for\n      const shopIdsUserHasRoleFor = Roles.getGroupsForUser(userId, role);\n\n      // If we have new shopIds found, add them to the list\n      if (Array.isArray(shopIdsUserHasRoleFor) && shopIdsUserHasRoleFor.length > 0) {\n        // Create unique array from existing shopIds array and the shops\n        return [...new Set([...shopIds, ...shopIdsUserHasRoleFor])];\n      }\n\n      // IF we don't have any shopIds returned, keep our existing list\n      return shopIds;\n    }, []);\n  },\n\n  /**\n   * @name getSellerShopId\n   * @method\n   * @memberof Core\n   * @return {String} Shop ID\n   */\n  getSellerShopId() {\n    return Roles.getGroupsForUser(this.userId, \"admin\");\n  },\n\n  /**\n   * @name configureMailUrl\n   * @method\n   * @memberof Core\n   * @summary Reaction.configureMailUrl() is deprecated. Please use Reaction.Email.getMailUrl() instead\n   * @return {String} URL\n   * @deprecated\n   */\n  configureMailUrl() {\n    // maintained for legacy support\n    Logger.warn(\"Reaction.configureMailUrl() is deprecated. Please use Reaction.Email.getMailUrl() instead\");\n    return getMailUrl();\n  },\n\n  /**\n   * @name getPrimaryShop\n   * @summary Get the first created shop. In marketplace, the Primary Shop is the shop that controls the marketplace\n   * and can see all other shops\n   * @method\n   * @memberof Core\n   * @return {Object} Shop\n   */\n  getPrimaryShop() {\n    const primaryShop = Shops.findOne({\n      shopType: \"primary\"\n    });\n\n    return primaryShop;\n  },\n\n  /**\n   * @name getPrimaryShopId\n   * @summary Get the first created shop ID. In marketplace, the Primary Shop is the shop that controls the marketplace\n   * and can see all other shops\n   * @method\n   * @memberof Core\n   * @return {String} ID\n   */\n  getPrimaryShopId() {\n    const primaryShop = this.getPrimaryShop();\n    if (primaryShop) {\n      return primaryShop._id;\n    }\n  },\n\n  /**\n   * @name getPrimaryShopName\n   * @method\n   * @summary Get primary shop name or empty string\n   * @memberof Core\n   * @return {String} Return shop name or empty string\n   */\n  getPrimaryShopName() {\n    const primaryShop = this.getPrimaryShop();\n    if (primaryShop) {\n      return primaryShop.name;\n    }\n    return \"\";\n  },\n\n  /**\n   * @name getPrimaryShopPrefix\n   * @summary Get primary shop prefix for URL\n   * @memberof Core\n   * @method\n   * @todo Primary Shop should probably not have a prefix (or should it be /shop?)\n   * @return {String} Prefix in the format of \"/<slug>\"\n   */\n  getPrimaryShopPrefix() {\n    return `/${this.getSlug(this.getPrimaryShopName().toLowerCase())}`;\n  },\n\n  /**\n   * @name getPrimaryShopSettings\n   * @method\n   * @memberof Core\n   * @summary Get primary shop settings object\n   * @return {Object} Get settings object or empty object\n   */\n  getPrimaryShopSettings() {\n    const settings = Packages.findOne({\n      name: \"core\",\n      shopId: this.getPrimaryShopId()\n    }) || {};\n    return settings.settings || {};\n  },\n\n  /**\n   * @name getPrimaryShopCurrency\n   * @method\n   * @memberof Core\n   * @summary Get primary shop currency string\n   * @return {String} Get shop currency or \"USD\"\n   */\n  getPrimaryShopCurrency() {\n    const primaryShop = this.getPrimaryShop();\n\n    if (primaryShop && primaryShop.currency) {\n      return primaryShop.currency;\n    }\n\n    return \"USD\";\n  },\n\n  /**\n   * @summary **DEPRECATED** This method has been deprecated in favor of using getShopId\n   * and getPrimaryShopId. To be removed.\n   * @deprecated\n   * @memberof Core\n   * @method getCurrentShopCursor\n   * @return {Cursor} cursor of shops that match the current domain\n   */\n  getCurrentShopCursor() {\n    const domain = this.getDomain();\n    const cursor = Shops.find({\n      domains: domain\n    });\n    if (!cursor.count()) {\n      Logger.debug(domain, \"Add a domain entry to shops for \");\n    }\n    return cursor;\n  },\n\n  /**\n   * @summary **DEPRECATED** This method has been deprecated in favor of using getShopId\n   * and getPrimaryShopId. To be removed.\n   * @deprecated\n   * @memberof Core\n   * @method getCurrentShop\n   * @return {Object} returns the first shop object from the shop cursor\n   */\n  getCurrentShop() {\n    const currentShopCursor = this.getCurrentShopCursor();\n    // also, we could check in such a way: `currentShopCursor instanceof Object` but not instanceof something.Cursor\n    if (typeof currentShopCursor === \"object\") {\n      return currentShopCursor.fetch()[0];\n    }\n    return null;\n  },\n\n  /**\n   * @name getShopId\n   * @method\n   * @memberof Core\n   * @summary Get shop ID, first by checking the current user's preferences\n   * then by getting the shop by the current domain.\n   * @todo should we return the Primary Shop if none found?\n   * @return {String} active shop ID\n   */\n  getShopId() {\n    // is there a stored value?\n    let shopId = ConnectionDataStore.get(\"shopId\");\n\n    // if so, return it\n    if (shopId) {\n      return shopId;\n    }\n\n    try {\n      // otherwise, find the shop by user settings\n      shopId = this.getUserShopId(Meteor.userId());\n    } catch (e) {\n      // `Meteor.userId` will raise an error when invoked outside of a method\n      // call or publication, i.e., at startup. That's ok here.\n    }\n\n    // if still not found, look up the shop by domain\n    if (!shopId) {\n      shopId = this.getShopIdByDomain();\n    }\n\n    // store the value for faster responses\n    ConnectionDataStore.set(\"shopId\", shopId);\n\n    return shopId;\n  },\n\n  /**\n   * @name clearCache\n   * @method\n   * @memberof Core\n   * @summary allows the client to trigger an uncached lookup of the shopId.\n   *          this is useful when a user switches shops.\n   */\n  resetShopId() {\n    ConnectionDataStore.clear(\"shopId\");\n  },\n\n  /**\n   * @name getShopIdByDomain\n   * @method\n   * @memberof Core\n   * @summary returns the shop which should be used given the current domain\n   */\n  getShopIdByDomain() {\n    const domain = this.getDomain();\n    const shop = Shops.find({\n      domains: domain\n    }, {\n      limit: 1,\n      fields: {\n        _id: 1\n      }\n    }).fetch()[0];\n\n    return shop && shop._id;\n  },\n\n  /**\n   * @name getUserShopId\n   * @method\n   * @memberof Core\n   * @summary Get a user's shop ID, as stored in preferences\n   * @todo This should intelligently find the correct default shop Probably whatever the main shop is or marketplace\n   * @return {StringId}        active shop ID\n   */\n  getUserShopId(userId) {\n    check(userId, String);\n\n    return this.getUserPreferences({\n      userId,\n      packageName: \"reaction\",\n      preference: \"activeShopId\"\n    });\n  },\n\n  /**\n   * @name getDomain\n   * @method\n   * @memberof Core\n   * @summary Get shop domain for URL\n   * @return {String} Shop domain\n   */\n  getDomain() {\n    return url.parse(Meteor.absoluteUrl()).hostname;\n  },\n\n  /**\n   * @name getShopName\n   * @method\n   * @memberof Core\n   * @summary If we can't find the shop or shop name return an empty string\n   * @return {String} Shop name or empty string \"\"\n   */\n  getShopName() {\n    const shopId = this.getShopId();\n    let shop;\n    if (shopId) {\n      shop = Shops.findOne({\n        _id: shopId\n      }, {\n        fields: {\n          name: 1\n        }\n      });\n    } else {\n      const domain = this.getDomain();\n      shop = Shops.findOne({\n        domains: domain\n      }, {\n        fields: {\n          name: 1\n        }\n      });\n    }\n    if (shop && shop.name) {\n      return shop.name;\n    }\n    return \"\";\n  },\n\n  /**\n   * @name getShopPrefix\n   * @method\n   * @memberof Core\n   * @summary Get shop prefix for URL\n   * @return {String} String in the format of \"/shop/slug\"\n   */\n  getShopPrefix() {\n    const shopName = this.getShopName();\n    const lowerCaseShopName = shopName.toLowerCase();\n    const slug = this.getSlug(lowerCaseShopName);\n    const marketplace = Packages.findOne({\n      name: \"reaction-marketplace\",\n      shopId: this.getPrimaryShopId()\n    });\n\n    if (marketplace && marketplace.settings && marketplace.settings.public) {\n      return `${marketplace.settings.public.shopPrefix}/${slug}`;\n    }\n    return `/${slug}`;\n  },\n\n  /**\n   * @name getShopEmail\n   * @method\n   * @memberof Core\n   * @summary Get shop email\n   * @return {String} String with the first store email\n   */\n  getShopEmail() {\n    const shop = Shops.find({\n      _id: this.getShopId()\n    }, {\n      limit: 1,\n      fields: {\n        emails: 1\n      }\n    }).fetch()[0];\n    return shop && shop.emails && shop.emails[0].address;\n  },\n\n  /**\n   * @name getShopSettings\n   * @method\n   * @memberof Core\n   * @summary Get shop settings object\n   * @param  {String} [name=\"core\"] Package name\n   * @return {Object}               Shop settings object or empty object\n   */\n  getShopSettings(name = \"core\") {\n    const settings = Packages.findOne({ name, shopId: this.getShopId() }) || {};\n    return settings.settings || {};\n  },\n\n  /**\n   * @name getShopCurrency\n   * @method\n   * @memberof Core\n   * @summary Get shop currency\n   * @return {String} Shop currency or \"USD\"\n   */\n  getShopCurrency() {\n    const shop = Shops.findOne({\n      _id: this.getShopId()\n    });\n\n    return (shop && shop.currency) || \"USD\";\n  },\n\n  /**\n   * @name getShopCurrencies\n   * @method\n   * @memberof Core\n   * @summary Get all currencies available to a shop\n   * @return {Object} Shop currency or \"USD\"\n   */\n  getShopCurrencies() {\n    const shop = Shops.findOne({\n      _id: this.getShopId()\n    });\n\n    return shop && shop.currencies;\n  },\n\n  /**\n   * @name getShopLanguage\n   * @method\n   * @memberof Core\n   * @todo TODO: Marketplace - should each shop set their own default language or\n   * should the Marketplace set a language that's picked up by all shops?\n   * @return {String} language\n   */\n  getShopLanguage() {\n    const { language } = Shops.findOne({\n      _id: this.getShopId()\n    }, {\n      fields: {\n        language: 1\n      }\n    });\n    return language;\n  },\n\n  /**\n   * @name getPackageSettings\n   * @method\n   * @memberof Core\n   * @summary Get package settings\n   * @param  {String} name Package name\n   * @return {Object|null}      Package setting object or null\n   */\n  getPackageSettings(name) {\n    return Packages.findOne({ name, shopId: this.getShopId() }) || null;\n  },\n\n  /**\n   * @summary Takes options in the form of a query object. Returns a package that matches.\n   * @method\n   * @memberof Core\n   * @name getPackageSettingsWithOptions\n   * @param  {object} options Options object, forms the query for Packages.findOne\n   * @return {object} Returns the first package found with the provided options\n   */\n  getPackageSettingsWithOptions(options) {\n    const query = options;\n    return Packages.findOne(query);\n  },\n\n  /**\n   * @name getMarketplaceSettings\n   * @method\n   * @memberof Core\n   * @summary finds the enabled `reaction-marketplace` package for\n   * the primary shop and returns the settings\n   * @return {Object} The marketplace settings from the primary shop or undefined\n   */\n  getMarketplaceSettings() {\n    const marketplace = Packages.findOne({\n      name: \"reaction-marketplace\",\n      shopId: this.getPrimaryShopId(),\n      enabled: true\n    });\n\n    if (marketplace && marketplace.settings) {\n      return marketplace.settings;\n    }\n    return {};\n  },\n\n  /**\n   * @name getUserPreferences\n   * @method\n   * @memberof Core\n   * @param  {Object} options {packageName, preference, defaultValue}\n   * @return {String|undefined} User's package preference or undefined\n   */\n  getUserPreferences(options) {\n    const { userId, packageName, preference, defaultValue } = options;\n\n    if (!userId) {\n      return undefined;\n    }\n\n    const user = AccountsCollection.findOne({ _id: userId });\n\n    if (user) {\n      const { profile } = user;\n      if (profile && profile.preferences && profile.preferences[packageName] && profile.preferences[packageName][preference]) {\n        return profile.preferences[packageName][preference];\n      }\n    }\n    return defaultValue || undefined;\n  },\n\n  /**\n   * @name setUserPreferences\n   * @method\n   * @summary save user preferences in the Accounts collection\n   * @param {String} packageName\n   * @param {String} preference\n   * @param {String} value\n   * @param {String} userId\n   * @return {Number} setPreferenceResult\n   */\n  setUserPreferences(packageName, preference, value, userId) {\n    const setPreferenceResult = AccountsCollection.update(userId, {\n      $set: {\n        [`profile.preferences.${packageName}.${preference}`]: value\n      }\n    });\n    return setPreferenceResult;\n  },\n  /**\n   *  @name insertPackagesForShop\n   *  @method\n   *  @memberof Core\n   *  @summary insert Reaction packages into Packages collection registry for a new shop\n   *  Assigns owner roles for new packages\n   *  Imports layouts from packages\n   *  @param {String} shopId - the shopId to create packages for\n   *  @return {String} returns insert result\n   */\n  insertPackagesForShop(shopId) {\n    const layouts = [];\n    if (!shopId) {\n      return [];\n    }\n\n    // Check to see what packages should be enabled\n    const shop = Shops.findOne({ _id: shopId });\n    const marketplaceSettings = this.getMarketplaceSettings();\n    let enabledPackages;\n\n    // Unless we have marketplace settings and an enabledPackagesByShopTypes Array\n    // we will skip this\n    if (marketplaceSettings &&\n        marketplaceSettings.shops &&\n        Array.isArray(marketplaceSettings.shops.enabledPackagesByShopTypes)) {\n      // Find the correct packages list for this shopType\n      const matchingShopType = marketplaceSettings.shops.enabledPackagesByShopTypes.find((EnabledPackagesByShopType) => EnabledPackagesByShopType.shopType === shop.shopType); // eslint-disable-line max-len\n      if (matchingShopType) {\n        ({ enabledPackages } = matchingShopType);\n      }\n    }\n\n    const packages = this.Packages;\n    // for each shop, we're loading packages in a unique registry\n    // Object.keys(pkgConfigs).forEach((pkgName) => {\n    for (const packageName in packages) {\n      // Guard to prvent unexpected `for in` behavior\n      if ({}.hasOwnProperty.call(packages, packageName)) {\n        const config = packages[packageName];\n        this.assignOwnerRoles(shopId, packageName, config.registry);\n\n        const pkg = Object.assign({}, config, {\n          shopId\n        });\n\n        // populate array of layouts that don't already exist (?!)\n        if (pkg.layout) {\n          // filter out layout templates\n          for (const template of pkg.layout) {\n            if (template && template.layout) {\n              layouts.push(template);\n            }\n          }\n        }\n\n        if (enabledPackages && Array.isArray(enabledPackages)) {\n          if (enabledPackages.indexOf(pkg.name) === -1) {\n            pkg.enabled = false;\n          } else if (pkg.settings && pkg.settings[packageName]) { // Enable \"soft switch\" for package.\n            pkg.settings[packageName].enabled = true;\n          }\n        }\n        Packages.insert(pkg);\n        Logger.debug(`Initializing ${shopId} ${packageName}`);\n      }\n    }\n\n    // helper for removing layout duplicates\n    const uniqLayouts = uniqWith(layouts, _.isEqual);\n    Shops.update({ _id: shopId }, { $set: { layout: uniqLayouts } });\n  },\n\n  /**\n   * @name getAppVersion\n   * @method\n   * @memberof Core\n   * @return {String} App version\n   */\n  getAppVersion() {\n    return Shops.findOne().appVersion;\n  },\n\n  /**\n   * @name createDefaultAdminUser\n   * @method\n   * @memberof Core\n   * @summary Method that creates default admin user\n   * Settings load precendence:\n   *  1. environment variables\n   *  2. settings in meteor.settings\n   * @returns {String} return userId\n   */\n  createDefaultAdminUser() {\n    const shopId = this.getPrimaryShopId();\n    if (!shopId) {\n      throw new Error(`createDefaultAdminUser: getPrimaryShopId returned ${shopId}`);\n    }\n\n    // if an admin user has already been created, we'll exit\n    if (Roles.getUsersInRole(\"owner\", shopId).count() !== 0) {\n      Logger.debug(\"Not creating default admin user, already exists\");\n      return \"\"; // this default admin has already been created for this shop.\n    }\n\n    // run hooks on options object before creating user (the options object must be returned from all callbacks)\n    let options = {};\n    options = Hooks.Events.run(\"beforeCreateDefaultAdminUser\", options);\n\n    // If $REACTION_SECURE_DEFAULT_ADMIN is set to \"true\" on first run,\n    // a random email/password will be generated instead of using the\n    // default email and password (email: admin@localhost pw: r3@cti0n)\n    // and the new admin user will need to verify their email to log in.\n    // If a random email and password are generated, the console will be\n    // the only place to retrieve them.\n    // If the admin email/password is provided via environment or Meteor settings,\n    // the $REACTION_SECURE_DEFAULT_ADMIN will only enforce the email validation part.\n    const isSecureSetup = process.env.REACTION_SECURE_DEFAULT_ADMIN === \"true\";\n\n    // generate default values to use if none are supplied\n    const defaultEmail = isSecureSetup ? `${Random.id(8).toLowerCase()}@localhost` : \"admin@localhost\";\n    const defaultPassword = isSecureSetup ? Random.secret(8) : \"r3@cti0n\";\n    const defaultUsername = \"admin\";\n    const defaultName = \"Admin\";\n\n    // Process environment variables and Meteor settings for initial user config.\n    // If ENV variables are set, they always override Meteor settings (settings.json).\n    // This is to allow for testing environments where we don't want to use users configured in a settings file.\n    const { env } = process;\n    let configureEnv = false;\n\n    if (env.REACTION_EMAIL && env.REACTION_AUTH) {\n      configureEnv = true;\n      Logger.info(\"Using environment variables to create admin user\");\n    }\n\n    // defaults use either env or generated values\n    options.email = env.REACTION_EMAIL || defaultEmail;\n    options.password = env.REACTION_AUTH || defaultPassword;\n    options.username = env.REACTION_USER_NAME || defaultUsername;\n    options.name = env.REACTION_USER || defaultName;\n\n    // or use `meteor --settings`\n    if (Meteor.settings && !configureEnv) {\n      if (Meteor.settings.reaction) {\n        options.email = Meteor.settings.reaction.REACTION_EMAIL || defaultEmail;\n        options.password = Meteor.settings.reaction.REACTION_AUTH || defaultPassword;\n        options.username = Meteor.settings.reaction.REACTION_USER || defaultUsername;\n        options.name = Meteor.settings.reaction.REACTION_USER_NAME || defaultName;\n        Logger.info(\"Using meteor --settings to create admin user\");\n      }\n    }\n\n    // set the default shop email to the default admin email\n    Shops.update(shopId, {\n      $addToSet: {\n        emails: {\n          address: options.email,\n          verified: true\n        }\n      }\n    });\n\n    // get the current shop\n    const shop = Shops.findOne(shopId);\n\n    // add the current domain to the shop if it doesn't already exist\n    if (!shop.domains.includes(this.getDomain())) {\n      // set the default shop email to the default admin email\n      Shops.update(shopId, {\n        $addToSet: {\n          domains: this.getDomain()\n        }\n      });\n    }\n\n    //\n    // create the new admin user\n    //\n    let accountId;\n    // we're checking again to see if this user was created but not specifically for this shop.\n    if (Meteor.users.find({ \"emails.address\": options.email }).count() === 0) {\n      accountId = Accounts.createUser(options);\n    } else {\n      // this should only occur when existing admin creates a new shop\n      accountId = Meteor.users.findOne({ \"emails.address\": options.email })._id;\n    }\n\n    // update the user's name if it was provided\n    // (since Accounts.createUser() doesn't allow that field and strips it out)\n    Meteor.users.update(accountId, {\n      $set: {\n        name: options.name\n      }\n    });\n\n    // unless strict security is enabled, mark the admin's email as validated\n    if (!isSecureSetup) {\n      Meteor.users.update({\n        \"_id\": accountId,\n        \"emails.address\": options.email\n      }, {\n        $set: {\n          \"emails.$.verified\": true\n        }\n      });\n      Collections.Accounts.update({\n        \"_id\": accountId,\n        \"emails.address\": options.email\n      }, {\n        $set: {\n          \"emails.$.verified\": true\n        }\n      });\n    } else {\n      // send verification email to admin\n      sendVerificationEmail(accountId);\n    }\n\n    // Set default owner roles\n    const defaultAdminRoles = [\"owner\", \"admin\", \"guest\", \"account/profile\"];\n    // Join other roles with defaultAdminRoles for owner.\n    // this is needed as owner should not just have \"owner\" but all other defined roles\n    let ownerRoles = defaultAdminRoles.concat(this.defaultCustomerRoles);\n    ownerRoles = _.uniq(ownerRoles);\n\n    // we don't use accounts/addUserPermissions here because we may not yet have permissions\n    Roles.setUserRoles(accountId, ownerRoles, shopId);\n    // // the reaction owner has permissions to all sites by default\n    Roles.setUserRoles(accountId, ownerRoles, Roles.GLOBAL_GROUP);\n    // initialize package permissions we don't need to do any further permission configuration it is taken care of in the\n    // assignOwnerRoles\n    const packages = Packages.find().fetch();\n    for (const pkg of packages) {\n      this.assignOwnerRoles(shopId, pkg.name, pkg.registry);\n    }\n\n    // notify user that the default admin was created by\n    // printing the account info to the console\n    Logger.warn(`\\n *********************************\n        \\n  IMPORTANT! DEFAULT ADMIN INFO\n        \\n  EMAIL/LOGIN: ${options.email}\n        \\n  PASSWORD: ${options.password}\n        \\n ********************************* \\n\\n`);\n\n    // run hooks on new user object\n    const user = Meteor.users.findOne(accountId);\n    Hooks.Events.run(\"afterCreateDefaultAdminUser\", user);\n\n    return accountId;\n  },\n\n  /**\n   *  @name loadPackages\n   *  @method\n   *  @memberof Core\n   *  @summary Insert Reaction packages into registry\n   *  we check to see if the number of packages have changed against current data\n   *  if there is a change, we'll either insert or upsert package registry\n   *  into the Packages collection\n   *  import is processed on hook in init()\n   *  @return {String} returns insert result\n   */\n  loadPackages() {\n    const packages = Packages.find().fetch();\n\n    let registryFixtureData;\n\n    if (process.env.REACTION_REGISTRY) {\n      // check the environment for the registry fixture data first\n      registryFixtureData = process.env.REACTION_REGISTRY;\n      Logger.info(\"Loaded REACTION_REGISTRY environment variable for registry fixture import\");\n    } else {\n      // or attempt to load reaction.json fixture data\n      try {\n        registryFixtureData = Assets.getText(\"settings/reaction.json\");\n        Logger.info(\"Loaded \\\"/private/settings/reaction.json\\\" for registry fixture import\");\n      } catch (error) {\n        Logger.warn(\"Skipped loading settings from reaction.json.\");\n        Logger.debug(error, \"loadSettings reaction.json not loaded.\");\n      }\n    }\n\n    if (registryFixtureData) {\n      const validatedJson = EJSON.parse(registryFixtureData);\n\n      if (!Array.isArray(validatedJson[0])) {\n        Logger.warn(\"Registry fixture data is not an array. Failed to load.\");\n      } else {\n        registryFixtureData = validatedJson;\n      }\n    }\n\n    const layouts = [];\n    // for each shop, we're loading packages in a unique registry\n    _.each(this.Packages, (config, pkgName) =>\n      Shops.find().forEach((shop) => {\n        const shopId = shop._id;\n        if (!shopId) return [];\n\n        // existing registry will be upserted with changes, perhaps we should add:\n        this.assignOwnerRoles(shopId, pkgName, config.registry);\n\n        // Settings from the package registry.js\n        const settingsFromPackage = {\n          name: pkgName,\n          icon: config.icon,\n          enabled: !!config.autoEnable,\n          settings: config.settings,\n          registry: config.registry,\n          layout: config.layout\n        };\n\n        // Setting from a fixture file, most likely reaction.json\n        let settingsFromFixture;\n        if (registryFixtureData) {\n          settingsFromFixture = registryFixtureData[0].find((packageSetting) => config.name === packageSetting.name);\n        }\n\n        // Setting already imported into the packages collection\n        const settingsFromDB = packages.find((ps) => (config.name === ps.name && shopId === ps.shopId));\n\n        const combinedSettings = merge({}, settingsFromPackage, settingsFromFixture || {}, settingsFromDB || {});\n\n        if (combinedSettings.registry) {\n          combinedSettings.registry = combinedSettings.registry.map((entry) => {\n            if (entry.provides && !Array.isArray(entry.provides)) {\n              entry.provides = [entry.provides];\n              Logger.warn(`Plugin ${combinedSettings.name} is using a deprecated version of the provides property for` +\n                          ` the ${entry.name || entry.route} registry entry. Since v1.5.0 registry provides accepts` +\n                          \" an array of strings.\");\n            }\n            return entry;\n          });\n        }\n\n        // populate array of layouts that don't already exist in Shops\n        if (combinedSettings.layout) {\n          // filter out layout Templates\n          for (const pkg of combinedSettings.layout) {\n            if (pkg.layout) {\n              layouts.push(pkg);\n            }\n          }\n        }\n        // Import package data\n        this.Importer.package(combinedSettings, shopId);\n        return Logger.debug(`Initializing ${shop.name} ${pkgName}`);\n      }));\n\n    // helper for removing layout duplicates\n    const uniqLayouts = uniqWith(layouts, _.isEqual);\n    // import layouts into Shops\n    Shops.find().forEach((shop) => {\n      this.Importer.layout(uniqLayouts, shop._id);\n    });\n\n    //\n    // package cleanup\n    //\n    Shops.find().forEach((shop) => Packages.find().forEach((pkg) => {\n      // delete registry entries for packages that have been removed\n      if (!_.has(this.Packages, pkg.name)) {\n        Logger.debug(`Removing ${pkg.name}`);\n        return Packages.remove({ shopId: shop._id, name: pkg.name });\n      }\n      return false;\n    }));\n  },\n\n  /**\n   * @name setAppVersion\n   * @method\n   * @memberof Core\n   * @return {undefined} no return value\n   */\n  setAppVersion() {\n    const { version } = packageJson;\n    Logger.info(`Reaction Version: ${version}`);\n    Shops.update({}, { $set: { appVersion: version } }, { multi: true });\n  },\n\n  /**\n   * @summary Method for getting all schemas attached to a given collection\n   * @deprecated by simpl-schema\n   * @private\n   * @name collectionSchema\n   * @param  {string} collection The mongo collection to get schemas for\n   * @param  {Object} [selector] Optional selector for multi schema collections\n   * @return {Object} Returns a simpleSchema that is a combination of all schemas\n   *                  that have been attached to the collection or false if\n   *                  the collection or schema could not be found\n   */\n  collectionSchema(collection, selector) {\n    Logger.warn(\"Reaction.collectionSchema is deprecated and will be removed\" +\n      \" in a future release. Use collection.simpleSchema(selector).\");\n\n    const selectorErrMsg = selector ? `and selector ${selector}` : \"\";\n    const errMsg = `Reaction.collectionSchema could not find schemas for ${collection} collection ${selectorErrMsg}`;\n\n    const col = Collections[collection];\n    if (!col) {\n      Logger.warn(errMsg);\n      // Return false so we don't pass a check that uses a non-existant schema\n      return false;\n    }\n\n    const schema = col.simpleSchema(selector);\n    if (!schema) {\n      Logger.warn(errMsg);\n      // Return false so we don't pass a check that uses a non-existant schema\n      return false;\n    }\n\n    return schema;\n  }\n};\n"]},"sourceType":"script","hash":"ce35a1d5d921fb0179637cdb26e71209c2f5cdd9"}
