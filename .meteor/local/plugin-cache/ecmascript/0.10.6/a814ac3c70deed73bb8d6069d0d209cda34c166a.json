{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$1$2","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"ast":true,"babelrc":false,"sourceFileName":"server/methods/core/shop.js","filename":"server/methods/core/shop.js","sourceMaps":true,"envName":"development","cwd":"/Users/estebandev/test-knowledge","passPerPreset":false,"presets":[],"parserOpts":{"sourceType":"module","sourceFileName":"server/methods/core/shop.js","plugins":["jsx","jsx","flow","flow","objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties"]},"generatorOpts":{"filename":"server/methods/core/shop.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"server/methods/core/shop.js"}},"code":"module.export({\n  updateShopBrandAssets: () => updateShopBrandAssets\n});\n\nlet _each;\n\nmodule.watch(require(\"lodash/each\"), {\n  default(v) {\n    _each = v;\n  }\n\n}, 0);\nlet Meteor;\nmodule.watch(require(\"meteor/meteor\"), {\n  Meteor(v) {\n    Meteor = v;\n  }\n\n}, 1);\nlet Roles;\nmodule.watch(require(\"meteor/alanning:roles\"), {\n  Roles(v) {\n    Roles = v;\n  }\n\n}, 2);\nlet check, Match;\nmodule.watch(require(\"meteor/check\"), {\n  check(v) {\n    check = v;\n  },\n\n  Match(v) {\n    Match = v;\n  }\n\n}, 3);\nlet HTTP;\nmodule.watch(require(\"meteor/http\"), {\n  HTTP(v) {\n    HTTP = v;\n  }\n\n}, 4);\nlet Job;\nmodule.watch(require(\"../../../imports/plugins/core/job-collection/lib\"), {\n  Job(v) {\n    Job = v;\n  }\n\n}, 5);\nlet GeoCoder, Hooks, Logger;\nmodule.watch(require(\"../../api\"), {\n  GeoCoder(v) {\n    GeoCoder = v;\n  },\n\n  Hooks(v) {\n    Hooks = v;\n  },\n\n  Logger(v) {\n    Logger = v;\n  }\n\n}, 6);\nlet Reaction;\nmodule.watch(require(\"../../../lib/api\"), {\n  Reaction(v) {\n    Reaction = v;\n  }\n\n}, 7);\nlet Collections;\nmodule.watch(require(\"../../../lib/collections\"), {\n  \"*\"(v) {\n    Collections = v;\n  }\n\n}, 8);\nlet Schemas;\nmodule.watch(require(\"../../../lib/collections/schemas\"), {\n  \"*\"(v) {\n    Schemas = v;\n  }\n\n}, 9);\n\n/**\n * @name cloneShop\n * @summary Returns an existing shop object, with some values removed or changed such\n *   that it is suitable for inserting as a new shop.\n * @method\n * @param {Object} shop - the shop to clone\n * @param {Object} partialShopData - any properties you'd like to override\n * @return {Object|null} The cloned shop object or null if a shop with that ID can't be found\n */\nfunction cloneShop(shop, partialShopData = {}) {\n  // if a name is not provided, generate a unique name\n  if (!partialShopData || !partialShopData.name) {\n    const count = Collections.Shops.find().count() || \"\";\n    shop.name += count;\n  } // merge in the partial shop data and some other current user attributes\n\n\n  Object.assign(shop, partialShopData || {});\n  const cleanShop = Schemas.Shop.clean(shop); // Never create a second primary shop\n\n  if (!cleanShop.shopType || cleanShop.shopType === \"primary\") {\n    cleanShop.shopType = \"merchant\";\n  } // Clean up values that get automatically added\n\n\n  delete cleanShop._id;\n  delete cleanShop.createdAt;\n  delete cleanShop.updatedAt;\n  delete cleanShop.slug; // TODO audience permissions need to be consolidated into [object] and not [string]\n  // permissions with [string] on layout ie. orders and checkout, cause the insert to fail\n\n  delete cleanShop.layout; // delete brandAssets object from shop to prevent new shops from carrying over existing shop's\n  // brand image\n\n  delete cleanShop.brandAssets;\n  return cleanShop;\n}\n/**\n * @name updateShopBrandAssets\n * @method\n * @param {Object} asset - brand asset {mediaId: \"\", type, \"\"}\n * @param {String} shopId - the shop id coresponding to the shop for which\n *                 the asset should be applied (defaults to Reaction.getShopId())\n * @param {String} userId - the user id on whose behalf we are performing this\n *                 action (defaults to Meteor.userId())\n * @return {Int} returns update result\n */\n\n\nfunction updateShopBrandAssets(asset, shopId = Reaction.getShopId(), userId = Meteor.userId()) {\n  check(asset, {\n    mediaId: String,\n    type: String\n  });\n  check(shopId, String); // must have core permissions\n\n  if (!Reaction.hasPermission(\"core\", userId, shopId)) {\n    throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n  } // Does our shop contain the brandasset we're tring to add\n\n\n  const shopWithBrandAsset = Collections.Shops.findOne({\n    \"_id\": shopId,\n    \"brandAssets.type\": asset.type\n  }); // If it does, then we update it with the new asset reference\n\n  if (shopWithBrandAsset) {\n    return Collections.Shops.update({\n      \"_id\": shopId,\n      \"brandAssets.type\": asset.type\n    }, {\n      $set: {\n        \"brandAssets.$\": {\n          mediaId: asset.mediaId,\n          type: asset.type\n        }\n      }\n    });\n  } // Otherwise we insert a new brand asset reference\n\n\n  return Collections.Shops.update({\n    _id: shopId\n  }, {\n    $push: {\n      brandAssets: {\n        mediaId: asset.mediaId,\n        type: asset.type\n      }\n    }\n  });\n}\n\n/**\n * @file Meteor methods for Shop\n *\n *\n * @namespace Methods/Shop\n*/\nMeteor.methods({\n  /**\n   * @name shop/resetShopId\n   * @method\n   * @memberof Methods/Shop\n   * @summary a way for the client to notifiy the server that the shop has\n   *          changed. We could has provided #setShopId, however, the server\n   *          has all the information it needs to determine this on its own,\n   *          and allowing the client to set shopId could be a security risk\n   */\n  \"shop/resetShopId\"() {\n    return Reaction.resetShopId();\n  },\n\n  /**\n   * @name shop/createShop\n   * @method\n   * @memberof Methods/Shop\n   * @param {String} shopAdminUserId - optionally create shop for provided userId\n   * @param {Object} partialShopData - optionally provide a subset of shop data\n   *                 which will be merged with properties from the primary shop\n   *                 in order to create a document which meets the Shops schema\n   *                 requirements.\n   * @return {String} return shopId\n   */\n  \"shop/createShop\"(shopAdminUserId, partialShopData) {\n    check(shopAdminUserId, Match.Optional(String)); // It is not necessary to test whether shopData is valid against the Shops\n    // schema here, as shopData can be a subset of data. Later, shopData is\n    // combined with a copy of the Primary Shop to fill in the gaps. It is at\n    // that point that we validate/`check` that the combined object is valid\n    // against the Shops schema.\n\n    check(partialShopData, Match.Maybe(Object)); // Get the current marketplace settings\n\n    const marketplace = Reaction.getMarketplaceSettings(); // check to see if the current user has owner permissions for the primary shop\n\n    const hasPrimaryShopOwnerPermission = Reaction.hasPermission(\"owner\", Meteor.userId(), Reaction.getPrimaryShopId()); // only permit merchant signup if marketplace is enabled and allowMerchantSignup is enabled\n\n    let allowMerchantShopCreation = false;\n\n    if (marketplace && marketplace.enabled && marketplace.public && marketplace.public.allowMerchantSignup) {\n      allowMerchantShopCreation = true;\n    } // must have owner access to create new shops when marketplace is disabled\n\n\n    if (!hasPrimaryShopOwnerPermission && !allowMerchantShopCreation) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    } // Non-admin users may only create shops for themselves\n\n\n    if (!hasPrimaryShopOwnerPermission && shopAdminUserId !== Meteor.userId()) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    } // Anonymous users should never be permitted to create a shop\n\n\n    if (!hasPrimaryShopOwnerPermission && Reaction.hasPermission(\"anonymous\", Meteor.userId(), Reaction.getPrimaryShopId())) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    const currentUser = Meteor.user();\n    const currentAccount = Collections.Accounts.findOne({\n      _id: currentUser._id\n    });\n\n    if (!currentUser) {\n      throw new Meteor.Error(\"server-error\", \"Unable to create shop without a user\");\n    }\n\n    let shopUser = currentUser;\n    let shopAccount = currentAccount; // TODO: Create a grantable permission for creating shops so we can decouple ownership from shop creation\n    // Only marketplace owners can create shops for others\n\n    if (hasPrimaryShopOwnerPermission) {\n      shopUser = Meteor.users.findOne({\n        _id: shopAdminUserId\n      }) || currentUser;\n      shopAccount = Collections.Accounts.findOne({\n        _id: shopAdminUserId\n      }) || currentAccount;\n    }\n\n    const primaryShopId = Reaction.getPrimaryShopId(); // Disallow creation of multiple shops, even for marketplace owners\n\n    if (shopAccount.shopId !== primaryShopId) {\n      throw new Meteor.Error(\"operation-not-permitted\", \"This user already has a shop. Each user may only have one shop.\");\n    }\n\n    const shop = cloneShop(Reaction.getPrimaryShop(), partialShopData);\n    shop.emails = shopUser.emails;\n    shop.addressBook = shopAccount.addressBook;\n    Collections.Shops.simpleSchema(shop).validate(shop);\n    let newShopId;\n\n    try {\n      newShopId = Collections.Shops.insert(shop);\n    } catch (error) {\n      return Logger.error(error, \"Failed to shop/createShop\");\n    }\n\n    const newShop = Collections.Shops.findOne({\n      _id: newShopId\n    }); // we should have created new shop, or errored\n\n    Logger.info(\"Created shop: \", newShopId); // update user\n\n    Reaction.insertPackagesForShop(newShopId);\n    Reaction.createGroups({\n      shopId: newShopId\n    });\n    const ownerGroup = Collections.Groups.findOne({\n      slug: \"owner\",\n      shopId: newShopId\n    });\n    Roles.addUsersToRoles([currentUser, shopUser._id], ownerGroup.permissions, newShopId); // Set the active shopId for this user\n\n    Reaction.setUserPreferences(\"reaction\", \"activeShopId\", newShopId, shopUser._id);\n    Collections.Accounts.update({\n      _id: shopUser._id\n    }, {\n      $set: {\n        shopId: newShopId\n      },\n      $addToSet: {\n        groups: ownerGroup._id\n      }\n    });\n    Hooks.Events.run(\"afterAccountsUpdate\", currentUser._id, {\n      accountId: shopUser._id,\n      updatedFields: [\"groups\"]\n    }); // Add this shop to the merchant\n\n    Collections.Shops.update({\n      _id: primaryShopId\n    }, {\n      $addToSet: {\n        merchantShops: {\n          _id: newShopId,\n          slug: newShop.slug,\n          name: newShop.name\n        }\n      }\n    }); // Set active shop to new shop.\n\n    return {\n      shopId: newShopId\n    };\n  },\n\n  /**\n   * @name shop/getLocale\n   * @method\n   * @memberof Methods/Shop\n   * @summary determine user's countryCode and return locale object\n   * determine local currency and conversion rate from shop currency\n   * @return {Object} returns user location and locale\n   */\n  \"shop/getLocale\"() {\n    this.unblock();\n    let clientAddress;\n    const geo = new GeoCoder();\n    const result = {};\n    let defaultCountryCode = \"US\";\n    let localeCurrency = \"USD\"; // if called from server, ip won't be defined.\n\n    if (this.connection !== null) {\n      ({\n        clientAddress\n      } = this.connection);\n    } else {\n      clientAddress = \"127.0.0.1\";\n    } // get shop locale/currency related data\n\n\n    const shop = Collections.Shops.findOne(Reaction.getShopId(), {\n      fields: {\n        addressBook: 1,\n        locales: 1,\n        currencies: 1,\n        currency: 1\n      }\n    });\n\n    if (!shop) {\n      throw new Meteor.Error(\"not-found\", \"Failed to find shop data. Unable to determine locale.\");\n    } // configure default defaultCountryCode\n    // fallback to shop settings\n\n\n    if (shop.addressBook) {\n      if (shop.addressBook.length >= 1) {\n        if (shop.addressBook[0].country) {\n          defaultCountryCode = shop.addressBook[0].country;\n        }\n      }\n    } // geocode reverse ip lookup\n\n\n    const geoCountryCode = geo.geoip(clientAddress).country_code; // countryCode either from geo or defaults\n\n    const countryCode = (geoCountryCode || defaultCountryCode).toUpperCase(); // get currency rates\n\n    result.currency = {};\n    result.locale = shop.locales.countries[countryCode]; // to return default currency if rates will failed, we need to bring access\n    // to this data\n\n    result.shopCurrency = shop.currencies[shop.currency]; // check if locale has a currency defined\n\n    if (typeof result.locale === \"object\" && typeof result.locale.currency === \"string\") {\n      localeCurrency = result.locale.currency.split(\",\");\n    } // localeCurrency is an array of allowed currencies\n\n\n    _each(localeCurrency, currency => {\n      let exchangeRate;\n\n      if (shop.currencies[currency]) {\n        result.currency = shop.currencies[currency]; // only fetch rates if locale and shop currency are not equal\n        // if shop.currency = locale currency the rate is 1\n\n        if (shop.currency !== currency) {\n          const settings = Reaction.getShopSettings();\n          const exchangeConfig = settings.openexchangerates || {};\n\n          if (exchangeConfig.appId) {\n            exchangeRate = Meteor.call(\"shop/getCurrencyRates\", currency);\n\n            if (typeof exchangeRate === \"number\") {\n              result.currency.exchangeRate = exchangeRate;\n            } else {\n              Logger.warn(\"Failed to get currency exchange rates.\");\n            }\n          }\n        }\n      }\n    }); // adjust user currency\n\n\n    const user = Collections.Accounts.findOne({\n      _id: Meteor.userId()\n    });\n    let profileCurrency = user.profile && user.profile.currency;\n\n    if (!profileCurrency) {\n      [localeCurrency] = localeCurrency;\n\n      if (shop.currencies[localeCurrency] && shop.currencies[localeCurrency].enabled) {\n        profileCurrency = localeCurrency;\n      } else {\n        [profileCurrency] = shop.currency.split(\",\");\n      }\n\n      Meteor.call(\"accounts/setProfileCurrency\", profileCurrency);\n    } // set server side locale\n\n\n    Reaction.Locale = result; // should contain rates, locale, currency\n\n    return result;\n  },\n\n  /**\n   * @name shop/getCurrencyRates\n   * @method\n   * @memberof Methods/Shop\n   * @summary It returns the current exchange rate against the shop currency\n   * usage: Meteor.call(\"shop/getCurrencyRates\",\"USD\")\n   * @param {String} currency code\n   * @return {Number|Object} currency conversion rate\n   */\n  \"shop/getCurrencyRates\"(currency) {\n    check(currency, String);\n    this.unblock();\n    const field = `currencies.${currency}.rate`;\n    const shop = Collections.Shops.findOne(Reaction.getShopId(), {\n      fields: {\n        [field]: 1\n      }\n    });\n    return typeof shop.currencies[currency].rate === \"number\" && shop.currencies[currency].rate;\n  },\n\n  /**\n   * @name shop/fetchCurrencyRate\n   * @method\n   * @memberof Methods/Shop\n   * @summary fetch the latest currency rates from\n   * https://openexchangerates.org\n   * usage: Meteor.call(\"shop/fetchCurrencyRate\")\n   * @fires Collections.Shops#update\n   * @returns {undefined}\n   */\n  \"shop/fetchCurrencyRate\"() {\n    this.unblock();\n    const shopId = Reaction.getShopId();\n    const shop = Collections.Shops.findOne(shopId, {\n      fields: {\n        addressBook: 1,\n        locales: 1,\n        currencies: 1,\n        currency: 1\n      }\n    });\n    const baseCurrency = shop.currency || \"USD\";\n    const shopCurrencies = shop.currencies; // fetch shop settings for api auth credentials\n\n    const shopSettings = Collections.Packages.findOne({\n      shopId,\n      name: \"core\"\n    }, {\n      fields: {\n        settings: 1\n      }\n    }); // update Shops.currencies[currencyKey].rate\n    // with current rates from Open Exchange Rates\n    // warn if we don't have app_id\n\n    if (!shopSettings.settings.openexchangerates) {\n      throw new Meteor.Error(\"not-configured\", \"Open Exchange Rates not configured. Configure for current rates.\");\n    } else if (!shopSettings.settings.openexchangerates.appId) {\n      throw new Meteor.Error(\"not-configured\", \"Open Exchange Rates AppId not configured. Configure for current rates.\");\n    } else {\n      // shop open exchange rates appId\n      const openexchangeratesAppId = shopSettings.settings.openexchangerates.appId; // we'll update all the available rates in Shops.currencies whenever we\n      // get a rate request, using base currency\n\n      const rateUrl = `https://openexchangerates.org/api/latest.json?base=${baseCurrency}&app_id=${openexchangeratesAppId}`;\n      let rateResults; // We can get an error if we try to change the base currency with a simple\n      // account\n\n      try {\n        rateResults = HTTP.get(rateUrl);\n      } catch (error) {\n        if (error.error) {\n          Logger.error(error.message);\n          throw new Meteor.Error(\"server-error\", error.message);\n        } else {\n          // https://openexchangerates.org/documentation#errors\n          throw new Meteor.Error(\"server-error\", error.response.data.description);\n        }\n      }\n\n      const exchangeRates = rateResults.data.rates;\n\n      _each(shopCurrencies, (currencyConfig, currencyKey) => {\n        if (exchangeRates[currencyKey] !== undefined) {\n          const rateUpdate = {\n            // this needed for shop/flushCurrencyRates Method\n            \"currencies.updatedAt\": new Date(rateResults.data.timestamp * 1000)\n          };\n          const collectionKey = `currencies.${currencyKey}.rate`;\n          rateUpdate[collectionKey] = exchangeRates[currencyKey];\n          Collections.Shops.update(shopId, {\n            $set: rateUpdate\n          });\n        }\n      });\n    }\n  },\n\n  /**\n   * @name shop/flushCurrencyRate\n   * @method\n   * @memberof Methods/Shop\n   * @description Method calls by cron job\n   * @summary It removes exchange rates that are too old\n   * usage: Meteor.call(\"shop/flushCurrencyRate\")\n   * @fires Collections.Shops#update\n   * @returns {undefined}\n   */\n  \"shop/flushCurrencyRate\"() {\n    this.unblock();\n    let shopId;\n    const marketplaceSettings = Reaction.getMarketplaceSettings();\n\n    if (marketplaceSettings && marketplaceSettings.public && marketplaceSettings.public.merchantLocale) {\n      shopId = Reaction.getShopId();\n    } else {\n      shopId = Reaction.getPrimaryShopId();\n    }\n\n    const shop = Collections.Shops.findOne(shopId, {\n      fields: {\n        currencies: 1\n      }\n    });\n    const {\n      updatedAt\n    } = shop.currencies; // if updatedAt is not a Date(), then there is no rates yet\n\n    if (typeof updatedAt !== \"object\") {\n      throw new Meteor.Error(\"error-occurred\", \"[flushCurrencyRates worker]: There is nothing to flush.\");\n    }\n\n    updatedAt.setHours(updatedAt.getHours() + 48);\n    const now = new Date();\n\n    if (now < updatedAt) {\n      // todo remove this line. its for tests\n      _each(shop.currencies, (currencyConfig, currencyKey) => {\n        const rate = `currencies.${currencyKey}.rate`;\n\n        if (typeof currencyConfig.rate === \"number\") {\n          Collections.Shops.update(shopId, {\n            $unset: {\n              [rate]: \"\"\n            }\n          });\n        }\n      });\n    }\n  },\n\n  /**\n   * @name shop/updateShopExternalServices\n   * @method\n   * @memberof Methods/Shop\n   * @description On submit OpenExchangeRatesForm handler\n   * @summary we need to rerun fetch exchange rates job on every form submit,\n   * that's why we update autoform type to \"method-update\"\n   * @param {Object} details An object with _id and modifier props\n   * @fires Collections.Packages#update\n   * @todo This method fires Packages collection, so maybe someday it could be moved to another file\n   * @returns {undefined}\n   */\n  \"shop/updateShopExternalServices\"(details) {\n    check(details, {\n      _id: String,\n      modifier: Object // actual schema validation happens below\n\n    });\n    const {\n      _id,\n      modifier\n    } = details;\n    Schemas.CorePackageConfig.validate(modifier, {\n      modifier: true\n    }); // must have core permissions\n\n    if (!Reaction.hasPermission(\"core\")) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    this.unblock(); // we should run new job on every form change, even if not all of them will\n    // change currencyRate job\n\n    const refreshPeriod = modifier.$set[\"settings.openexchangerates.refreshPeriod\"];\n    const fetchCurrencyRatesJob = new Job(Collections.Jobs, \"shop/fetchCurrencyRates\", {}).priority(\"normal\").retry({\n      retries: 5,\n      wait: 60000,\n      backoff: \"exponential\" // delay by twice as long for each subsequent retry\n\n    }).repeat({\n      // wait: refreshPeriod * 60 * 1000\n      schedule: Collections.Jobs.later.parse.text(refreshPeriod)\n    }).save({\n      // Cancel any jobs of the same type,\n      // but only if this job repeats forever.\n      cancelRepeats: true\n    });\n    Collections.Packages.update(_id, modifier);\n    return fetchCurrencyRatesJob;\n  },\n\n  /**\n   * @name shop/locateAddress\n   * @method\n   * @memberof Methods/Shop\n   * @summary determine user's full location for autopopulating addresses\n   * @param {Number} latitude - latitude\n   * @param {Number} longitude - longitude\n   * @return {Object} returns address\n   */\n  \"shop/locateAddress\"(latitude, longitude) {\n    check(latitude, Match.Optional(Number));\n    check(longitude, Match.Optional(Number));\n    let clientAddress;\n    this.unblock(); // if called from server, ip won't be defined.\n\n    if (this.connection !== null) {\n      ({\n        clientAddress\n      } = this.connection);\n    } else {\n      clientAddress = \"127.0.0.1\";\n    } // begin actual address lookups\n\n\n    if (latitude !== null && longitude !== null) {\n      const geo = new GeoCoder();\n      return geo.reverse(latitude, longitude);\n    } // geocode reverse ip lookup\n\n\n    const geo = new GeoCoder();\n    return geo.geoip(clientAddress);\n  },\n\n  /**\n   * @name shop/createTag\n   * @method\n   * @memberof Methods/Shop\n   * @summary creates new tag\n   * @param {String} tagName - new tag name\n   * @param {Boolean} isTopLevel - if true -- new tag will be created on top of\n   * tags tree\n   * @since 0.14.0\n   * @hooks after method\n   * @return {String} with created tag _id\n   */\n  \"shop/createTag\"(tagName, isTopLevel) {\n    check(tagName, String);\n    check(isTopLevel, Boolean); // must have 'core' permissions\n\n    if (!Reaction.hasPermission(\"core\")) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    const tag = {\n      name: tagName,\n      slug: Reaction.getSlug(tagName),\n      isTopLevel,\n      updatedAt: new Date(),\n      createdAt: new Date()\n    };\n    return Collections.Tags.insert(tag);\n  },\n\n  /**\n   * @name shop/updateHeaderTags\n   * @method\n   * @memberof Methods/Shop\n   * @summary method to insert or update tag with hierarchy\n   * @param {String} tagName will insert, tagName + tagId will update existing\n   * @param {String} tagId - tagId to update\n   * @param {String} currentTagId - currentTagId will update related/hierarchy\n   * @return {Boolean} return true/false after insert\n   */\n  \"shop/updateHeaderTags\"(tagName, tagId, currentTagId) {\n    check(tagName, String);\n    check(tagId, Match.OneOf(String, null, undefined));\n    check(currentTagId, Match.OneOf(String, null, undefined));\n    let newTagId = {}; // must have 'core' permissions\n\n    if (!Reaction.hasPermission(\"core\")) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    this.unblock();\n    const newTag = {\n      slug: Reaction.getSlug(tagName),\n      name: tagName\n    };\n    const existingTag = Collections.Tags.findOne({\n      slug: Reaction.getSlug(tagName),\n      name: tagName\n    });\n    let result;\n\n    if (tagId) {\n      result = Collections.Tags.update(tagId, {\n        $set: newTag\n      });\n      Logger.debug(`Changed name of tag ${tagId} to ${tagName}`);\n      return result;\n    }\n\n    if (existingTag) {\n      // if is currentTag\n      if (currentTagId) {\n        result = Collections.Tags.update(currentTagId, {\n          $addToSet: {\n            relatedTagIds: existingTag._id\n          }\n        });\n        Logger.debug(`Added tag ${existingTag.name} to the related tags list for tag ${currentTagId}`);\n        return result;\n      } // update existing tag\n\n\n      result = Collections.Tags.update(existingTag._id, {\n        $set: {\n          isTopLevel: true\n        }\n      });\n      Logger.debug(`Marked tag ${existingTag.name} as a top level tag`);\n      return result;\n    } // create newTags\n\n\n    newTagId = Meteor.call(\"shop/createTag\", tagName, !currentTagId); // if result is an Error object, we return it immediately\n\n    if (typeof newTagId !== \"string\") return newTagId;\n\n    if (currentTagId) {\n      result = Collections.Tags.update(currentTagId, {\n        $addToSet: {\n          relatedTagIds: newTagId\n        }\n      });\n      Logger.debug(`Added tag${newTag.name} to the related tags list for tag ${currentTagId}`);\n      return result;\n    } // TODO: refactor this. unnecessary check\n\n\n    if (typeof newTagId === \"string\" && !currentTagId) return true;\n    throw new Meteor.Error(\"access-denied\", \"Failed to update header tags.\");\n  },\n\n  /**\n   * @name shop/removeHeaderTag\n   * @method\n   * @memberof Methods/Shop\n   * @param {String} tagId - method to remove tag navigation tags\n   * @param {String} currentTagId - currentTagId\n   * @return {String} returns remove result\n   */\n  \"shop/removeHeaderTag\"(tagId, currentTagId) {\n    check(tagId, String);\n    check(currentTagId, String); // must have core permissions\n\n    if (!Reaction.hasPermission(\"core\")) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    this.unblock(); // remove from related tag use\n\n    Collections.Tags.update(currentTagId, {\n      $pull: {\n        relatedTagIds: tagId\n      }\n    }); // check to see if tag is in use.\n\n    const productCount = Collections.Products.find({\n      hashtags: tagId\n    }).count(); // check to see if in use as a related tag\n\n    const relatedTagsCount = Collections.Tags.find({\n      relatedTagIds: tagId\n    }).count(); // not in use anywhere, delete it\n\n    if (productCount === 0 && relatedTagsCount === 0) {\n      return Collections.Tags.remove(tagId);\n    } // unable to delete anything\n\n\n    throw new Meteor.Error(\"access-denied\", \"Unable to delete tags that are in use.\");\n  },\n\n  /**\n   * @name shop/hideHeaderTag\n   * @method\n   * @memberof Methods/Shop\n   * @param {String} tagId - method to remove tag navigation tags\n   * @return {String} returns remove result\n   */\n  \"shop/hideHeaderTag\"(tagId) {\n    check(tagId, String); // must have core permissions\n\n    if (!Reaction.hasPermission(\"core\")) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    this.unblock(); // hide it\n\n    return Collections.Tags.update({\n      _id: tagId\n    }, {\n      $set: {\n        isTopLevel: false\n      }\n    });\n  },\n\n  /**\n   * @name shop/getWorkflow\n   * @method\n   * @memberof Methods/Shop\n   * @summary gets the current shop workflows\n   * @param {String} name - workflow name\n   * @return {Array} returns workflow array\n   */\n  \"shop/getWorkflow\"(name) {\n    check(name, String);\n    const shopWorkflows = Collections.Shops.findOne({\n      defaultWorkflows: {\n        $elemMatch: {\n          provides: name\n        }\n      }\n    }, {\n      fields: {\n        defaultWorkflows: true\n      }\n    });\n    return shopWorkflows;\n  },\n\n  /**\n   * @name shop/updateLanguageConfiguration\n   * @method\n   * @memberof Methods/Shop\n   * @summary enable / disable a language\n   * @param {String} language - language name | \"all\" to bulk enable / disable\n   * @param {Boolean} enabled - true / false\n   * @return {Array} returns workflow array\n   */\n  \"shop/updateLanguageConfiguration\"(language, enabled) {\n    check(language, String);\n    check(enabled, Boolean); // must have core permissions\n\n    if (!Reaction.hasPermission(\"core\")) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    this.unblock();\n    const shop = Collections.Shops.findOne({\n      _id: Reaction.getShopId()\n    });\n    const defaultLanguage = shop.language;\n\n    if (language === \"all\") {\n      const updateObject = {};\n\n      if (Array.isArray(shop.languages)) {\n        shop.languages.forEach((languageData, index) => {\n          if (languageData.i18n === defaultLanguage) {\n            updateObject[`languages.${index}.enabled`] = true;\n          } else {\n            updateObject[`languages.${index}.enabled`] = enabled;\n          }\n        });\n      }\n\n      return Collections.Shops.update({\n        _id: Reaction.getShopId()\n      }, {\n        $set: updateObject\n      });\n    } else if (language === defaultLanguage) {\n      return Collections.Shops.update({\n        \"_id\": Reaction.getShopId(),\n        \"languages.i18n\": language\n      }, {\n        $set: {\n          \"languages.$.enabled\": true\n        }\n      });\n    }\n\n    return Collections.Shops.update({\n      \"_id\": Reaction.getShopId(),\n      \"languages.i18n\": language\n    }, {\n      $set: {\n        \"languages.$.enabled\": enabled\n      }\n    });\n  },\n\n  /**\n   * @name shop/updateCurrencyConfiguration\n   * @method\n   * @memberof Methods/Shop\n   * @summary enable / disable a currency\n   * @param {String} currency - currency name | \"all\" to bulk enable / disable\n   * @param {Boolean} enabled - true / false\n   * @return {Number} returns mongo update result\n   */\n  \"shop/updateCurrencyConfiguration\"(currency, enabled) {\n    check(currency, String);\n    check(enabled, Boolean); // must have core permissions\n\n    if (!Reaction.hasPermission(\"core\")) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    this.unblock();\n    const shop = Collections.Shops.findOne({\n      _id: Reaction.getShopId()\n    });\n    const defaultCurrency = shop.currency;\n\n    if (currency === \"all\") {\n      const updateObject = {};\n\n      for (const currencyName in shop.currencies) {\n        if ({}.hasOwnProperty.call(shop.currencies, currencyName) && currencyName !== \"updatedAt\") {\n          if (currencyName === defaultCurrency) {\n            updateObject[`currencies.${currencyName}.enabled`] = true;\n          } else {\n            updateObject[`currencies.${currencyName}.enabled`] = enabled;\n          }\n        }\n      }\n\n      return Collections.Shops.update({\n        _id: Reaction.getShopId()\n      }, {\n        $set: updateObject\n      });\n    } else if (currency === defaultCurrency) {\n      return Collections.Shops.update({\n        _id: Reaction.getShopId()\n      }, {\n        $set: {\n          [`currencies.${currency}.enabled`]: true\n        }\n      });\n    }\n\n    return Collections.Shops.update({\n      _id: Reaction.getShopId()\n    }, {\n      $set: {\n        [`currencies.${currency}.enabled`]: enabled\n      }\n    });\n  },\n\n  /**\n   * @name shop/updateBrandAsset\n   * @method\n   * @memberof Methods/Shop\n   * @param {Object} asset - brand asset {mediaId: \"\", type, \"\"}\n   * @return {Int} returns update result\n   */\n  \"shop/updateBrandAssets\"(asset) {\n    check(asset, {\n      mediaId: String,\n      type: String\n    });\n    this.unblock();\n    return updateShopBrandAssets(asset);\n  },\n\n  /**\n   * @name shop/togglePackage\n   * @method\n   * @memberof Methods/Shop\n   * @summary enable/disable Reaction package\n   * @param {String} packageId - package _id\n   * @param {Boolean} enabled - current package `enabled` state\n   * @return {Number} mongo update result\n   */\n  \"shop/togglePackage\"(packageId, enabled) {\n    check(packageId, String);\n    check(enabled, Boolean);\n\n    if (!Reaction.hasAdminAccess()) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    return Collections.Packages.update(packageId, {\n      $set: {\n        enabled: !enabled\n      }\n    });\n  },\n\n  /**\n   * @name shop/changeLayout\n   * @method\n   * @memberof Methods/Shop\n   * @summary Change the layout for all workflows so you can use a custom one\n   * @param {String} shopId - the shop's ID\n   * @param {String} newLayout - new layout to use\n   * @return {Number} mongo update result\n   */\n  \"shop/changeLayouts\"(shopId, newLayout) {\n    check(shopId, String);\n    check(newLayout, String);\n    const shop = Collections.Shops.findOne(shopId);\n\n    for (let i = 0; i < shop.layout.length; i += 1) {\n      shop.layout[i].layout = newLayout;\n    }\n\n    return Collections.Shops.update(shopId, {\n      $set: {\n        layout: shop.layout\n      }\n    });\n  },\n\n  /**\n   * @name shop/getBaseLanguage\n   * @method\n   * @memberof Methods/Shop\n   * @summary Return the shop's base language ISO code\n   * @return {String} ISO lang code\n   */\n  \"shop/getBaseLanguage\"() {\n    if (!Reaction.hasPermission()) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    const shopId = Reaction.getShopId();\n    return Collections.Shops.findOne(shopId).language;\n  }\n\n});","map":{"version":3,"sources":["server/methods/core/shop.js"],"names":["module","export","updateShopBrandAssets","_each","watch","require","default","v","Meteor","Roles","check","Match","HTTP","Job","GeoCoder","Hooks","Logger","Reaction","Collections","Schemas","cloneShop","shop","partialShopData","name","count","Shops","find","Object","assign","cleanShop","Shop","clean","shopType","_id","createdAt","updatedAt","slug","layout","brandAssets","asset","shopId","getShopId","userId","mediaId","String","type","hasPermission","Error","shopWithBrandAsset","findOne","update","$set","$push","methods","resetShopId","shopAdminUserId","Optional","Maybe","marketplace","getMarketplaceSettings","hasPrimaryShopOwnerPermission","getPrimaryShopId","allowMerchantShopCreation","enabled","public","allowMerchantSignup","currentUser","user","currentAccount","Accounts","shopUser","shopAccount","users","primaryShopId","getPrimaryShop","emails","addressBook","simpleSchema","validate","newShopId","insert","error","newShop","info","insertPackagesForShop","createGroups","ownerGroup","Groups","addUsersToRoles","permissions","setUserPreferences","$addToSet","groups","Events","run","accountId","updatedFields","merchantShops","unblock","clientAddress","geo","result","defaultCountryCode","localeCurrency","connection","fields","locales","currencies","currency","length","country","geoCountryCode","geoip","country_code","countryCode","toUpperCase","locale","countries","shopCurrency","split","exchangeRate","settings","getShopSettings","exchangeConfig","openexchangerates","appId","call","warn","profileCurrency","profile","Locale","field","rate","baseCurrency","shopCurrencies","shopSettings","Packages","openexchangeratesAppId","rateUrl","rateResults","get","message","response","data","description","exchangeRates","rates","currencyConfig","currencyKey","undefined","rateUpdate","Date","timestamp","collectionKey","marketplaceSettings","merchantLocale","setHours","getHours","now","$unset","details","modifier","CorePackageConfig","refreshPeriod","fetchCurrencyRatesJob","Jobs","priority","retry","retries","wait","backoff","repeat","schedule","later","parse","text","save","cancelRepeats","latitude","longitude","Number","reverse","tagName","isTopLevel","Boolean","tag","getSlug","Tags","tagId","currentTagId","OneOf","newTagId","newTag","existingTag","debug","relatedTagIds","$pull","productCount","Products","hashtags","relatedTagsCount","remove","shopWorkflows","defaultWorkflows","$elemMatch","provides","language","defaultLanguage","updateObject","Array","isArray","languages","forEach","languageData","index","i18n","defaultCurrency","currencyName","hasOwnProperty","packageId","hasAdminAccess","newLayout","i"],"mappings":"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","sourcesContent":["import _ from \"lodash\";\nimport { Meteor } from \"meteor/meteor\";\nimport { Roles } from \"meteor/alanning:roles\";\nimport { check, Match } from \"meteor/check\";\nimport { HTTP } from \"meteor/http\";\nimport { Job } from \"/imports/plugins/core/job-collection/lib\";\nimport { GeoCoder, Hooks, Logger } from \"/server/api\";\nimport { Reaction } from \"/lib/api\";\nimport * as Collections from \"/lib/collections\";\nimport * as Schemas from \"/lib/collections/schemas\";\n\n/**\n * @name cloneShop\n * @summary Returns an existing shop object, with some values removed or changed such\n *   that it is suitable for inserting as a new shop.\n * @method\n * @param {Object} shop - the shop to clone\n * @param {Object} partialShopData - any properties you'd like to override\n * @return {Object|null} The cloned shop object or null if a shop with that ID can't be found\n */\nfunction cloneShop(shop, partialShopData = {}) {\n  // if a name is not provided, generate a unique name\n  if (!partialShopData || !partialShopData.name) {\n    const count = Collections.Shops.find().count() || \"\";\n    shop.name += count;\n  }\n\n  // merge in the partial shop data and some other current user attributes\n  Object.assign(shop, partialShopData || {});\n\n  const cleanShop = Schemas.Shop.clean(shop);\n\n  // Never create a second primary shop\n  if (!cleanShop.shopType || cleanShop.shopType === \"primary\") {\n    cleanShop.shopType = \"merchant\";\n  }\n\n  // Clean up values that get automatically added\n  delete cleanShop._id;\n  delete cleanShop.createdAt;\n  delete cleanShop.updatedAt;\n  delete cleanShop.slug;\n  // TODO audience permissions need to be consolidated into [object] and not [string]\n  // permissions with [string] on layout ie. orders and checkout, cause the insert to fail\n  delete cleanShop.layout;\n  // delete brandAssets object from shop to prevent new shops from carrying over existing shop's\n  // brand image\n  delete cleanShop.brandAssets;\n\n  return cleanShop;\n}\n\n/**\n * @name updateShopBrandAssets\n * @method\n * @param {Object} asset - brand asset {mediaId: \"\", type, \"\"}\n * @param {String} shopId - the shop id coresponding to the shop for which\n *                 the asset should be applied (defaults to Reaction.getShopId())\n * @param {String} userId - the user id on whose behalf we are performing this\n *                 action (defaults to Meteor.userId())\n * @return {Int} returns update result\n */\nexport function updateShopBrandAssets(asset, shopId = Reaction.getShopId(), userId = Meteor.userId()) {\n  check(asset, {\n    mediaId: String,\n    type: String\n  });\n  check(shopId, String);\n\n  // must have core permissions\n  if (!Reaction.hasPermission(\"core\", userId, shopId)) {\n    throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n  }\n\n  // Does our shop contain the brandasset we're tring to add\n  const shopWithBrandAsset = Collections.Shops.findOne({\n    \"_id\": shopId,\n    \"brandAssets.type\": asset.type\n  });\n\n  // If it does, then we update it with the new asset reference\n  if (shopWithBrandAsset) {\n    return Collections.Shops.update({\n      \"_id\": shopId,\n      \"brandAssets.type\": asset.type\n    }, {\n      $set: {\n        \"brandAssets.$\": {\n          mediaId: asset.mediaId,\n          type: asset.type\n        }\n      }\n    });\n  }\n\n  // Otherwise we insert a new brand asset reference\n  return Collections.Shops.update({\n    _id: shopId\n  }, {\n    $push: {\n      brandAssets: {\n        mediaId: asset.mediaId,\n        type: asset.type\n      }\n    }\n  });\n}\n\n/**\n * @file Meteor methods for Shop\n *\n *\n * @namespace Methods/Shop\n*/\nMeteor.methods({\n  /**\n   * @name shop/resetShopId\n   * @method\n   * @memberof Methods/Shop\n   * @summary a way for the client to notifiy the server that the shop has\n   *          changed. We could has provided #setShopId, however, the server\n   *          has all the information it needs to determine this on its own,\n   *          and allowing the client to set shopId could be a security risk\n   */\n  \"shop/resetShopId\"() {\n    return Reaction.resetShopId();\n  },\n\n  /**\n   * @name shop/createShop\n   * @method\n   * @memberof Methods/Shop\n   * @param {String} shopAdminUserId - optionally create shop for provided userId\n   * @param {Object} partialShopData - optionally provide a subset of shop data\n   *                 which will be merged with properties from the primary shop\n   *                 in order to create a document which meets the Shops schema\n   *                 requirements.\n   * @return {String} return shopId\n   */\n  \"shop/createShop\"(shopAdminUserId, partialShopData) {\n    check(shopAdminUserId, Match.Optional(String));\n    // It is not necessary to test whether shopData is valid against the Shops\n    // schema here, as shopData can be a subset of data. Later, shopData is\n    // combined with a copy of the Primary Shop to fill in the gaps. It is at\n    // that point that we validate/`check` that the combined object is valid\n    // against the Shops schema.\n    check(partialShopData, Match.Maybe(Object));\n\n    // Get the current marketplace settings\n    const marketplace = Reaction.getMarketplaceSettings();\n\n    // check to see if the current user has owner permissions for the primary shop\n    const hasPrimaryShopOwnerPermission = Reaction.hasPermission(\"owner\", Meteor.userId(), Reaction.getPrimaryShopId());\n\n    // only permit merchant signup if marketplace is enabled and allowMerchantSignup is enabled\n    let allowMerchantShopCreation = false;\n    if (marketplace && marketplace.enabled && marketplace.public && marketplace.public.allowMerchantSignup) {\n      allowMerchantShopCreation = true;\n    }\n\n    // must have owner access to create new shops when marketplace is disabled\n    if (!hasPrimaryShopOwnerPermission && !allowMerchantShopCreation) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    // Non-admin users may only create shops for themselves\n    if (!hasPrimaryShopOwnerPermission && shopAdminUserId !== Meteor.userId()) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    // Anonymous users should never be permitted to create a shop\n    if (!hasPrimaryShopOwnerPermission &&\n        Reaction.hasPermission(\"anonymous\", Meteor.userId(), Reaction.getPrimaryShopId())) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    const currentUser = Meteor.user();\n    const currentAccount = Collections.Accounts.findOne({ _id: currentUser._id });\n    if (!currentUser) {\n      throw new Meteor.Error(\"server-error\", \"Unable to create shop without a user\");\n    }\n\n    let shopUser = currentUser;\n    let shopAccount = currentAccount;\n    // TODO: Create a grantable permission for creating shops so we can decouple ownership from shop creation\n    // Only marketplace owners can create shops for others\n    if (hasPrimaryShopOwnerPermission) {\n      shopUser = Meteor.users.findOne({ _id: shopAdminUserId }) || currentUser;\n      shopAccount = Collections.Accounts.findOne({ _id: shopAdminUserId }) || currentAccount;\n    }\n\n    const primaryShopId = Reaction.getPrimaryShopId();\n\n    // Disallow creation of multiple shops, even for marketplace owners\n    if (shopAccount.shopId !== primaryShopId) {\n      throw new Meteor.Error(\n        \"operation-not-permitted\",\n        \"This user already has a shop. Each user may only have one shop.\"\n      );\n    }\n\n    const shop = cloneShop(Reaction.getPrimaryShop(), partialShopData);\n\n    shop.emails = shopUser.emails;\n    shop.addressBook = shopAccount.addressBook;\n\n    Collections.Shops.simpleSchema(shop).validate(shop);\n\n    let newShopId;\n\n    try {\n      newShopId = Collections.Shops.insert(shop);\n    } catch (error) {\n      return Logger.error(error, \"Failed to shop/createShop\");\n    }\n\n    const newShop = Collections.Shops.findOne({ _id: newShopId });\n\n    // we should have created new shop, or errored\n    Logger.info(\"Created shop: \", newShopId);\n\n    // update user\n    Reaction.insertPackagesForShop(newShopId);\n    Reaction.createGroups({ shopId: newShopId });\n    const ownerGroup = Collections.Groups.findOne({ slug: \"owner\", shopId: newShopId });\n    Roles.addUsersToRoles([currentUser, shopUser._id], ownerGroup.permissions, newShopId);\n    // Set the active shopId for this user\n    Reaction.setUserPreferences(\"reaction\", \"activeShopId\", newShopId, shopUser._id);\n    Collections.Accounts.update({ _id: shopUser._id }, {\n      $set: {\n        shopId: newShopId\n      },\n      $addToSet: {\n        groups: ownerGroup._id\n      }\n    });\n    Hooks.Events.run(\"afterAccountsUpdate\", currentUser._id, {\n      accountId: shopUser._id,\n      updatedFields: [\"groups\"]\n    });\n    // Add this shop to the merchant\n    Collections.Shops.update({ _id: primaryShopId }, {\n      $addToSet: {\n        merchantShops: {\n          _id: newShopId,\n          slug: newShop.slug,\n          name: newShop.name\n        }\n      }\n    });\n\n    // Set active shop to new shop.\n    return { shopId: newShopId };\n  },\n\n  /**\n   * @name shop/getLocale\n   * @method\n   * @memberof Methods/Shop\n   * @summary determine user's countryCode and return locale object\n   * determine local currency and conversion rate from shop currency\n   * @return {Object} returns user location and locale\n   */\n  \"shop/getLocale\"() {\n    this.unblock();\n    let clientAddress;\n    const geo = new GeoCoder();\n    const result = {};\n    let defaultCountryCode = \"US\";\n    let localeCurrency = \"USD\";\n    // if called from server, ip won't be defined.\n    if (this.connection !== null) {\n      ({ clientAddress } = this.connection);\n    } else {\n      clientAddress = \"127.0.0.1\";\n    }\n\n    // get shop locale/currency related data\n    const shop = Collections.Shops.findOne(Reaction.getShopId(), {\n      fields: {\n        addressBook: 1,\n        locales: 1,\n        currencies: 1,\n        currency: 1\n      }\n    });\n\n    if (!shop) {\n      throw new Meteor.Error(\"not-found\", \"Failed to find shop data. Unable to determine locale.\");\n    }\n    // configure default defaultCountryCode\n    // fallback to shop settings\n    if (shop.addressBook) {\n      if (shop.addressBook.length >= 1) {\n        if (shop.addressBook[0].country) {\n          defaultCountryCode = shop.addressBook[0].country;\n        }\n      }\n    }\n    // geocode reverse ip lookup\n    const geoCountryCode = geo.geoip(clientAddress).country_code;\n\n    // countryCode either from geo or defaults\n    const countryCode = (geoCountryCode || defaultCountryCode).toUpperCase();\n\n    // get currency rates\n    result.currency = {};\n    result.locale = shop.locales.countries[countryCode];\n\n    // to return default currency if rates will failed, we need to bring access\n    // to this data\n    result.shopCurrency = shop.currencies[shop.currency];\n\n    // check if locale has a currency defined\n    if (typeof result.locale === \"object\" &&\n      typeof result.locale.currency === \"string\") {\n      localeCurrency = result.locale.currency.split(\",\");\n    }\n\n    // localeCurrency is an array of allowed currencies\n    _.each(localeCurrency, (currency) => {\n      let exchangeRate;\n      if (shop.currencies[currency]) {\n        result.currency = shop.currencies[currency];\n        // only fetch rates if locale and shop currency are not equal\n        // if shop.currency = locale currency the rate is 1\n        if (shop.currency !== currency) {\n          const settings = Reaction.getShopSettings();\n          const exchangeConfig = settings.openexchangerates || {};\n\n          if (exchangeConfig.appId) {\n            exchangeRate = Meteor.call(\"shop/getCurrencyRates\", currency);\n\n            if (typeof exchangeRate === \"number\") {\n              result.currency.exchangeRate = exchangeRate;\n            } else {\n              Logger.warn(\"Failed to get currency exchange rates.\");\n            }\n          }\n        }\n      }\n    });\n\n    // adjust user currency\n    const user = Collections.Accounts.findOne({\n      _id: Meteor.userId()\n    });\n    let profileCurrency = user.profile && user.profile.currency;\n    if (!profileCurrency) {\n      [localeCurrency] = localeCurrency;\n      if (shop.currencies[localeCurrency] && shop.currencies[localeCurrency].enabled) {\n        profileCurrency = localeCurrency;\n      } else {\n        [profileCurrency] = shop.currency.split(\",\");\n      }\n\n      Meteor.call(\"accounts/setProfileCurrency\", profileCurrency);\n    }\n\n    // set server side locale\n    Reaction.Locale = result;\n\n    // should contain rates, locale, currency\n    return result;\n  },\n\n  /**\n   * @name shop/getCurrencyRates\n   * @method\n   * @memberof Methods/Shop\n   * @summary It returns the current exchange rate against the shop currency\n   * usage: Meteor.call(\"shop/getCurrencyRates\",\"USD\")\n   * @param {String} currency code\n   * @return {Number|Object} currency conversion rate\n   */\n  \"shop/getCurrencyRates\"(currency) {\n    check(currency, String);\n    this.unblock();\n\n    const field = `currencies.${currency}.rate`;\n    const shop = Collections.Shops.findOne(Reaction.getShopId(), {\n      fields: {\n        [field]: 1\n      }\n    });\n\n    return typeof shop.currencies[currency].rate === \"number\" &&\n      shop.currencies[currency].rate;\n  },\n\n  /**\n   * @name shop/fetchCurrencyRate\n   * @method\n   * @memberof Methods/Shop\n   * @summary fetch the latest currency rates from\n   * https://openexchangerates.org\n   * usage: Meteor.call(\"shop/fetchCurrencyRate\")\n   * @fires Collections.Shops#update\n   * @returns {undefined}\n   */\n  \"shop/fetchCurrencyRate\"() {\n    this.unblock();\n\n    const shopId = Reaction.getShopId();\n    const shop = Collections.Shops.findOne(shopId, {\n      fields: {\n        addressBook: 1,\n        locales: 1,\n        currencies: 1,\n        currency: 1\n      }\n    });\n    const baseCurrency = shop.currency || \"USD\";\n    const shopCurrencies = shop.currencies;\n\n    // fetch shop settings for api auth credentials\n    const shopSettings = Collections.Packages.findOne({\n      shopId,\n      name: \"core\"\n    }, {\n      fields: {\n        settings: 1\n      }\n    });\n\n    // update Shops.currencies[currencyKey].rate\n    // with current rates from Open Exchange Rates\n    // warn if we don't have app_id\n    if (!shopSettings.settings.openexchangerates) {\n      throw new Meteor.Error(\n        \"not-configured\",\n        \"Open Exchange Rates not configured. Configure for current rates.\"\n      );\n    } else if (!shopSettings.settings.openexchangerates.appId) {\n      throw new Meteor.Error(\n        \"not-configured\",\n        \"Open Exchange Rates AppId not configured. Configure for current rates.\"\n      );\n    } else {\n      // shop open exchange rates appId\n      const openexchangeratesAppId = shopSettings.settings.openexchangerates.appId;\n\n      // we'll update all the available rates in Shops.currencies whenever we\n      // get a rate request, using base currency\n      const rateUrl =\n              `https://openexchangerates.org/api/latest.json?base=${\n                baseCurrency}&app_id=${openexchangeratesAppId}`;\n      let rateResults;\n\n      // We can get an error if we try to change the base currency with a simple\n      // account\n      try {\n        rateResults = HTTP.get(rateUrl);\n      } catch (error) {\n        if (error.error) {\n          Logger.error(error.message);\n          throw new Meteor.Error(\"server-error\", error.message);\n        } else {\n          // https://openexchangerates.org/documentation#errors\n          throw new Meteor.Error(\"server-error\", error.response.data.description);\n        }\n      }\n\n      const exchangeRates = rateResults.data.rates;\n\n      _.each(shopCurrencies, (currencyConfig, currencyKey) => {\n        if (exchangeRates[currencyKey] !== undefined) {\n          const rateUpdate = {\n            // this needed for shop/flushCurrencyRates Method\n            \"currencies.updatedAt\": new Date(rateResults.data.timestamp * 1000)\n          };\n          const collectionKey = `currencies.${currencyKey}.rate`;\n          rateUpdate[collectionKey] = exchangeRates[currencyKey];\n          Collections.Shops.update(shopId, {\n            $set: rateUpdate\n          });\n        }\n      });\n    }\n  },\n\n  /**\n   * @name shop/flushCurrencyRate\n   * @method\n   * @memberof Methods/Shop\n   * @description Method calls by cron job\n   * @summary It removes exchange rates that are too old\n   * usage: Meteor.call(\"shop/flushCurrencyRate\")\n   * @fires Collections.Shops#update\n   * @returns {undefined}\n   */\n  \"shop/flushCurrencyRate\"() {\n    this.unblock();\n\n    let shopId;\n    const marketplaceSettings = Reaction.getMarketplaceSettings();\n\n    if (marketplaceSettings && marketplaceSettings.public && marketplaceSettings.public.merchantLocale) {\n      shopId = Reaction.getShopId();\n    } else {\n      shopId = Reaction.getPrimaryShopId();\n    }\n\n    const shop = Collections.Shops.findOne(shopId, {\n      fields: {\n        currencies: 1\n      }\n    });\n    const { updatedAt } = shop.currencies;\n\n    // if updatedAt is not a Date(), then there is no rates yet\n    if (typeof updatedAt !== \"object\") {\n      throw new Meteor.Error(\n        \"error-occurred\",\n        \"[flushCurrencyRates worker]: There is nothing to flush.\"\n      );\n    }\n\n    updatedAt.setHours(updatedAt.getHours() + 48);\n    const now = new Date();\n\n    if (now < updatedAt) { // todo remove this line. its for tests\n      _.each(shop.currencies, (currencyConfig, currencyKey) => {\n        const rate = `currencies.${currencyKey}.rate`;\n\n        if (typeof currencyConfig.rate === \"number\") {\n          Collections.Shops.update(shopId, {\n            $unset: {\n              [rate]: \"\"\n            }\n          });\n        }\n      });\n    }\n  },\n\n  /**\n   * @name shop/updateShopExternalServices\n   * @method\n   * @memberof Methods/Shop\n   * @description On submit OpenExchangeRatesForm handler\n   * @summary we need to rerun fetch exchange rates job on every form submit,\n   * that's why we update autoform type to \"method-update\"\n   * @param {Object} details An object with _id and modifier props\n   * @fires Collections.Packages#update\n   * @todo This method fires Packages collection, so maybe someday it could be moved to another file\n   * @returns {undefined}\n   */\n  \"shop/updateShopExternalServices\"(details) {\n    check(details, {\n      _id: String,\n      modifier: Object // actual schema validation happens below\n    });\n\n    const { _id, modifier } = details;\n    Schemas.CorePackageConfig.validate(modifier, { modifier: true });\n\n    // must have core permissions\n    if (!Reaction.hasPermission(\"core\")) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n    this.unblock();\n\n    // we should run new job on every form change, even if not all of them will\n    // change currencyRate job\n    const refreshPeriod = modifier.$set[\"settings.openexchangerates.refreshPeriod\"];\n    const fetchCurrencyRatesJob = new Job(Collections.Jobs, \"shop/fetchCurrencyRates\", {})\n      .priority(\"normal\")\n      .retry({\n        retries: 5,\n        wait: 60000,\n        backoff: \"exponential\" // delay by twice as long for each subsequent retry\n      })\n      .repeat({\n        // wait: refreshPeriod * 60 * 1000\n        schedule: Collections.Jobs.later.parse.text(refreshPeriod)\n      })\n      .save({\n        // Cancel any jobs of the same type,\n        // but only if this job repeats forever.\n        cancelRepeats: true\n      });\n\n    Collections.Packages.update(_id, modifier);\n    return fetchCurrencyRatesJob;\n  },\n\n  /**\n   * @name shop/locateAddress\n   * @method\n   * @memberof Methods/Shop\n   * @summary determine user's full location for autopopulating addresses\n   * @param {Number} latitude - latitude\n   * @param {Number} longitude - longitude\n   * @return {Object} returns address\n   */\n  \"shop/locateAddress\"(latitude, longitude) {\n    check(latitude, Match.Optional(Number));\n    check(longitude, Match.Optional(Number));\n    let clientAddress;\n    this.unblock();\n\n    // if called from server, ip won't be defined.\n    if (this.connection !== null) {\n      ({ clientAddress } = this.connection);\n    } else {\n      clientAddress = \"127.0.0.1\";\n    }\n\n    // begin actual address lookups\n    if (latitude !== null && longitude !== null) {\n      const geo = new GeoCoder();\n      return geo.reverse(latitude, longitude);\n    }\n    // geocode reverse ip lookup\n    const geo = new GeoCoder();\n    return geo.geoip(clientAddress);\n  },\n\n  /**\n   * @name shop/createTag\n   * @method\n   * @memberof Methods/Shop\n   * @summary creates new tag\n   * @param {String} tagName - new tag name\n   * @param {Boolean} isTopLevel - if true -- new tag will be created on top of\n   * tags tree\n   * @since 0.14.0\n   * @hooks after method\n   * @return {String} with created tag _id\n   */\n  \"shop/createTag\"(tagName, isTopLevel) {\n    check(tagName, String);\n    check(isTopLevel, Boolean);\n\n    // must have 'core' permissions\n    if (!Reaction.hasPermission(\"core\")) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    const tag = {\n      name: tagName,\n      slug: Reaction.getSlug(tagName),\n      isTopLevel,\n      updatedAt: new Date(),\n      createdAt: new Date()\n    };\n\n    return Collections.Tags.insert(tag);\n  },\n\n  /**\n   * @name shop/updateHeaderTags\n   * @method\n   * @memberof Methods/Shop\n   * @summary method to insert or update tag with hierarchy\n   * @param {String} tagName will insert, tagName + tagId will update existing\n   * @param {String} tagId - tagId to update\n   * @param {String} currentTagId - currentTagId will update related/hierarchy\n   * @return {Boolean} return true/false after insert\n   */\n  \"shop/updateHeaderTags\"(tagName, tagId, currentTagId) {\n    check(tagName, String);\n    check(tagId, Match.OneOf(String, null, undefined));\n    check(currentTagId, Match.OneOf(String, null, undefined));\n\n    let newTagId = {};\n    // must have 'core' permissions\n    if (!Reaction.hasPermission(\"core\")) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n    this.unblock();\n\n    const newTag = {\n      slug: Reaction.getSlug(tagName),\n      name: tagName\n    };\n\n    const existingTag = Collections.Tags.findOne({\n      slug: Reaction.getSlug(tagName),\n      name: tagName\n    });\n\n    let result;\n\n    if (tagId) {\n      result = Collections.Tags.update(tagId, { $set: newTag });\n      Logger.debug(`Changed name of tag ${tagId} to ${tagName}`);\n      return result;\n    }\n\n    if (existingTag) {\n      // if is currentTag\n      if (currentTagId) {\n        result = Collections.Tags.update(currentTagId, {\n          $addToSet: {\n            relatedTagIds: existingTag._id\n          }\n        });\n        Logger.debug(`Added tag ${existingTag.name} to the related tags list for tag ${currentTagId}`);\n        return result;\n      }\n\n      // update existing tag\n      result = Collections.Tags.update(existingTag._id, {\n        $set: {\n          isTopLevel: true\n        }\n      });\n      Logger.debug(`Marked tag ${existingTag.name} as a top level tag`);\n      return result;\n    }\n\n    // create newTags\n    newTagId = Meteor.call(\"shop/createTag\", tagName, !currentTagId);\n\n    // if result is an Error object, we return it immediately\n    if (typeof newTagId !== \"string\") return newTagId;\n\n    if (currentTagId) {\n      result = Collections.Tags.update(currentTagId, {\n        $addToSet: {\n          relatedTagIds: newTagId\n        }\n      });\n      Logger.debug(`Added tag${newTag.name} to the related tags list for tag ${currentTagId}`);\n      return result;\n    }\n\n    // TODO: refactor this. unnecessary check\n    if (typeof newTagId === \"string\" && !currentTagId) return true;\n\n    throw new Meteor.Error(\"access-denied\", \"Failed to update header tags.\");\n  },\n\n  /**\n   * @name shop/removeHeaderTag\n   * @method\n   * @memberof Methods/Shop\n   * @param {String} tagId - method to remove tag navigation tags\n   * @param {String} currentTagId - currentTagId\n   * @return {String} returns remove result\n   */\n  \"shop/removeHeaderTag\"(tagId, currentTagId) {\n    check(tagId, String);\n    check(currentTagId, String);\n    // must have core permissions\n    if (!Reaction.hasPermission(\"core\")) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n    this.unblock();\n    // remove from related tag use\n    Collections.Tags.update(currentTagId, {\n      $pull: {\n        relatedTagIds: tagId\n      }\n    });\n    // check to see if tag is in use.\n    const productCount = Collections.Products.find({\n      hashtags: tagId\n    }).count();\n    // check to see if in use as a related tag\n    const relatedTagsCount = Collections.Tags.find({\n      relatedTagIds: tagId\n    }).count();\n    // not in use anywhere, delete it\n    if (productCount === 0 && relatedTagsCount === 0) {\n      return Collections.Tags.remove(tagId);\n    }\n    // unable to delete anything\n    throw new Meteor.Error(\"access-denied\", \"Unable to delete tags that are in use.\");\n  },\n\n  /**\n   * @name shop/hideHeaderTag\n   * @method\n   * @memberof Methods/Shop\n   * @param {String} tagId - method to remove tag navigation tags\n   * @return {String} returns remove result\n   */\n  \"shop/hideHeaderTag\"(tagId) {\n    check(tagId, String);\n    // must have core permissions\n    if (!Reaction.hasPermission(\"core\")) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n    this.unblock();\n    // hide it\n    return Collections.Tags.update({\n      _id: tagId\n    }, {\n      $set: {\n        isTopLevel: false\n      }\n    });\n  },\n\n  /**\n   * @name shop/getWorkflow\n   * @method\n   * @memberof Methods/Shop\n   * @summary gets the current shop workflows\n   * @param {String} name - workflow name\n   * @return {Array} returns workflow array\n   */\n  \"shop/getWorkflow\"(name) {\n    check(name, String);\n\n    const shopWorkflows = Collections.Shops.findOne({\n      defaultWorkflows: {\n        $elemMatch: {\n          provides: name\n        }\n      }\n    }, {\n      fields: {\n        defaultWorkflows: true\n      }\n    });\n    return shopWorkflows;\n  },\n\n  /**\n   * @name shop/updateLanguageConfiguration\n   * @method\n   * @memberof Methods/Shop\n   * @summary enable / disable a language\n   * @param {String} language - language name | \"all\" to bulk enable / disable\n   * @param {Boolean} enabled - true / false\n   * @return {Array} returns workflow array\n   */\n  \"shop/updateLanguageConfiguration\"(language, enabled) {\n    check(language, String);\n    check(enabled, Boolean);\n\n    // must have core permissions\n    if (!Reaction.hasPermission(\"core\")) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n    this.unblock();\n\n    const shop = Collections.Shops.findOne({\n      _id: Reaction.getShopId()\n    });\n\n    const defaultLanguage = shop.language;\n\n    if (language === \"all\") {\n      const updateObject = {};\n\n      if (Array.isArray(shop.languages)) {\n        shop.languages.forEach((languageData, index) => {\n          if (languageData.i18n === defaultLanguage) {\n            updateObject[`languages.${index}.enabled`] = true;\n          } else {\n            updateObject[`languages.${index}.enabled`] = enabled;\n          }\n        });\n      }\n      return Collections.Shops.update({\n        _id: Reaction.getShopId()\n      }, {\n        $set: updateObject\n      });\n    } else if (language === defaultLanguage) {\n      return Collections.Shops.update({\n        \"_id\": Reaction.getShopId(),\n        \"languages.i18n\": language\n      }, {\n        $set: {\n          \"languages.$.enabled\": true\n        }\n      });\n    }\n\n    return Collections.Shops.update({\n      \"_id\": Reaction.getShopId(),\n      \"languages.i18n\": language\n    }, {\n      $set: {\n        \"languages.$.enabled\": enabled\n      }\n    });\n  },\n\n  /**\n   * @name shop/updateCurrencyConfiguration\n   * @method\n   * @memberof Methods/Shop\n   * @summary enable / disable a currency\n   * @param {String} currency - currency name | \"all\" to bulk enable / disable\n   * @param {Boolean} enabled - true / false\n   * @return {Number} returns mongo update result\n   */\n  \"shop/updateCurrencyConfiguration\"(currency, enabled) {\n    check(currency, String);\n    check(enabled, Boolean);\n    // must have core permissions\n    if (!Reaction.hasPermission(\"core\")) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n    this.unblock();\n\n    const shop = Collections.Shops.findOne({\n      _id: Reaction.getShopId()\n    });\n\n    const defaultCurrency = shop.currency;\n\n    if (currency === \"all\") {\n      const updateObject = {};\n      for (const currencyName in shop.currencies) {\n        if ({}.hasOwnProperty.call(shop.currencies, currencyName) && currencyName !== \"updatedAt\") {\n          if (currencyName === defaultCurrency) {\n            updateObject[`currencies.${currencyName}.enabled`] = true;\n          } else {\n            updateObject[`currencies.${currencyName}.enabled`] = enabled;\n          }\n        }\n      }\n\n      return Collections.Shops.update({\n        _id: Reaction.getShopId()\n      }, {\n        $set: updateObject\n      });\n    } else if (currency === defaultCurrency) {\n      return Collections.Shops.update({\n        _id: Reaction.getShopId()\n      }, {\n        $set: {\n          [`currencies.${currency}.enabled`]: true\n        }\n      });\n    }\n\n    return Collections.Shops.update({\n      _id: Reaction.getShopId()\n    }, {\n      $set: {\n        [`currencies.${currency}.enabled`]: enabled\n      }\n    });\n  },\n\n  /**\n   * @name shop/updateBrandAsset\n   * @method\n   * @memberof Methods/Shop\n   * @param {Object} asset - brand asset {mediaId: \"\", type, \"\"}\n   * @return {Int} returns update result\n   */\n  \"shop/updateBrandAssets\"(asset) {\n    check(asset, {\n      mediaId: String,\n      type: String\n    });\n\n    this.unblock();\n\n    return updateShopBrandAssets(asset);\n  },\n\n  /**\n   * @name shop/togglePackage\n   * @method\n   * @memberof Methods/Shop\n   * @summary enable/disable Reaction package\n   * @param {String} packageId - package _id\n   * @param {Boolean} enabled - current package `enabled` state\n   * @return {Number} mongo update result\n   */\n  \"shop/togglePackage\"(packageId, enabled) {\n    check(packageId, String);\n    check(enabled, Boolean);\n    if (!Reaction.hasAdminAccess()) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    return Collections.Packages.update(packageId, {\n      $set: {\n        enabled: !enabled\n      }\n    });\n  },\n\n  /**\n   * @name shop/changeLayout\n   * @method\n   * @memberof Methods/Shop\n   * @summary Change the layout for all workflows so you can use a custom one\n   * @param {String} shopId - the shop's ID\n   * @param {String} newLayout - new layout to use\n   * @return {Number} mongo update result\n   */\n  \"shop/changeLayouts\"(shopId, newLayout) {\n    check(shopId, String);\n    check(newLayout, String);\n    const shop = Collections.Shops.findOne(shopId);\n    for (let i = 0; i < shop.layout.length; i += 1) {\n      shop.layout[i].layout = newLayout;\n    }\n    return Collections.Shops.update(shopId, {\n      $set: { layout: shop.layout }\n    });\n  },\n\n\n  /**\n   * @name shop/getBaseLanguage\n   * @method\n   * @memberof Methods/Shop\n   * @summary Return the shop's base language ISO code\n   * @return {String} ISO lang code\n   */\n  \"shop/getBaseLanguage\"() {\n    if (!Reaction.hasPermission()) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n    const shopId = Reaction.getShopId();\n    return Collections.Shops.findOne(shopId).language;\n  }\n});\n"]},"sourceType":"script","hash":"a814ac3c70deed73bb8d6069d0d209cda34c166a"}
