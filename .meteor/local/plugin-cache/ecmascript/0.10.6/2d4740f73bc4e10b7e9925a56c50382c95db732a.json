{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$1$2","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"ast":true,"babelrc":false,"sourceFileName":"imports/plugins/included/payments-stripe/server/methods/stripe.js","filename":"imports/plugins/included/payments-stripe/server/methods/stripe.js","sourceMaps":true,"envName":"development","cwd":"/Users/estebandev/test-knowledge","passPerPreset":false,"presets":[],"parserOpts":{"sourceType":"module","sourceFileName":"imports/plugins/included/payments-stripe/server/methods/stripe.js","plugins":["jsx","jsx","flow","flow","objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties"]},"generatorOpts":{"filename":"imports/plugins/included/payments-stripe/server/methods/stripe.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"imports/plugins/included/payments-stripe/server/methods/stripe.js"}},"code":"var _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/builtin/objectSpread\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst module1 = module;\nmodule1.export({\n  utils: () => utils,\n  methods: () => methods\n});\nlet accounting;\nmodule1.watch(require(\"accounting-js\"), {\n  default(v) {\n    accounting = v;\n  }\n\n}, 0);\nlet stripeNpm;\nmodule1.watch(require(\"stripe\"), {\n  default(v) {\n    stripeNpm = v;\n  }\n\n}, 1);\nlet Meteor;\nmodule1.watch(require(\"meteor/meteor\"), {\n  Meteor(v) {\n    Meteor = v;\n  }\n\n}, 2);\nlet check;\nmodule1.watch(require(\"meteor/check\"), {\n  check(v) {\n    check = v;\n  }\n\n}, 3);\nlet Random;\nmodule1.watch(require(\"meteor/random\"), {\n  Random(v) {\n    Random = v;\n  }\n\n}, 4);\nlet Reaction, Logger, Hooks;\nmodule1.watch(require(\"../../../../../../server/api\"), {\n  Reaction(v) {\n    Reaction = v;\n  },\n\n  Logger(v) {\n    Logger = v;\n  },\n\n  Hooks(v) {\n    Hooks = v;\n  }\n\n}, 5);\nlet Cart, Shops, Accounts, Packages;\nmodule1.watch(require(\"../../../../../../lib/collections\"), {\n  Cart(v) {\n    Cart = v;\n  },\n\n  Shops(v) {\n    Shops = v;\n  },\n\n  Accounts(v) {\n    Accounts = v;\n  },\n\n  Packages(v) {\n    Packages = v;\n  }\n\n}, 6);\nlet PaymentMethodArgument;\nmodule1.watch(require(\"../../../../../../lib/collections/schemas\"), {\n  PaymentMethodArgument(v) {\n    PaymentMethodArgument = v;\n  }\n\n}, 7);\n\nfunction parseCardData(data) {\n  return {\n    number: data.number,\n    name: data.name,\n    cvc: data.cvv2,\n    exp_month: data.expire_month,\n    // eslint-disable-line camelcase\n    exp_year: data.expire_year // eslint-disable-line camelcase\n\n  };\n} // Stripe uses a \"Decimal-less\" format so 10.00 becomes 1000\n\n\nfunction formatForStripe(amount) {\n  return Math.round(amount * 100);\n}\n\nfunction unformatFromStripe(amount) {\n  return amount / 100;\n}\n\nconst utils = {};\n\nutils.getStripeApi = function (paymentPackageId) {\n  const stripePackage = Packages.findOne(paymentPackageId);\n  const stripeKey = stripePackage.settings.api_key || stripePackage.settings.connectAuth.access_token;\n  return stripeKey;\n};\n/**\n * @summary Capture the results of a previous charge\n * @param {object} paymentMethod - Object containing info about the previous transaction\n * @returns {object} Object indicating the result, saved = true means success\n */\n\n\nfunction stripeCaptureCharge(paymentMethod) {\n  let result;\n  const captureDetails = {\n    amount: formatForStripe(paymentMethod.amount)\n  };\n  const stripeKey = utils.getStripeApi(paymentMethod.paymentPackageId);\n  const stripe = stripeNpm(stripeKey);\n\n  try {\n    const capturePromise = stripe.charges.capture(paymentMethod.transactionId, captureDetails);\n    const captureResult = Promise.await(capturePromise);\n\n    if (captureResult.status === \"succeeded\") {\n      result = {\n        saved: true,\n        response: captureResult\n      };\n    } else {\n      result = {\n        saved: false,\n        response: captureResult\n      };\n    }\n  } catch (error) {\n    Logger.error(error);\n    result = {\n      saved: false,\n      error\n    };\n    return {\n      error,\n      result\n    };\n  }\n\n  return result;\n}\n/**\n * normalizes the status of a transaction\n * @method normalizeStatus\n * @param  {object} transaction - The transaction that we need to normalize\n * @return {string} normalized status string - either failed, settled, or created\n */\n\n\nfunction normalizeStatus(transaction) {\n  if (!transaction) {\n    throw new Meteor.Error(\"invalid-parameter\", \"normalizeStatus requires a transaction\");\n  } // if this transaction failed, mode is \"failed\"\n\n\n  if (transaction.failure_code) {\n    return \"failed\";\n  } // if this transaction was captured, status is \"settled\"\n\n\n  if (transaction.captured) {\n    // Transaction was authorized but not captured\n    return \"settled\";\n  } // Otherwise status is \"created\"\n\n\n  return \"created\";\n}\n/**\n * normalizes the mode of a transaction\n * @method normalizeMode\n * @param  {object} transaction The transaction that we need to normalize\n * @return {string} normalized status string - either failed, capture, or authorize\n */\n\n\nfunction normalizeMode(transaction) {\n  if (!transaction) {\n    throw new Meteor.Error(\"invalid-parameter\", \"normalizeMode requires a transaction\");\n  } // if this transaction failed, mode is \"failed\"\n\n\n  if (transaction.failure_code) {\n    return \"failed\";\n  } // If this transaction was captured, mode is \"capture\"\n\n\n  if (transaction.captured) {\n    return \"capture\";\n  } // Anything else, mode is \"authorize\"\n\n\n  return \"authorize\";\n}\n/**\n * @method normalizeRiskLevel\n * @private\n * @summary Normalizes the risk level response of a transaction to the values defined in paymentMethod schema\n * @param  {object} transaction - The transaction that we need to normalize\n * @return {string} normalized status string - either elevated, high, or normal\n */\n\n\nfunction normalizeRiskLevel(transaction) {\n  if (!transaction) {\n    throw new Meteor.Error(\"invalid-parameter\", \"normalizeRiskLevel requires a transaction\");\n  }\n\n  const outcome = transaction.outcome && transaction.outcome.risk_level;\n\n  if (outcome === \"elevated\") {\n    return \"elevated\";\n  }\n\n  if (outcome === \"highest\") {\n    return \"high\";\n  } // default to normal if no other flagged\n\n\n  return \"normal\";\n}\n\nfunction buildPaymentMethods(options) {\n  const {\n    cardData,\n    cartItemsByShop,\n    transactionsByShopId\n  } = options;\n\n  if (!transactionsByShopId) {\n    throw new Meteor.Error(\"invalid-parameter\", \"Creating a payment method log requries transaction data\");\n  }\n\n  const shopIds = Object.keys(transactionsByShopId);\n  const storedCard = `${cardData.type.charAt(0).toUpperCase() + cardData.type.slice(1)} ${cardData.number.slice(-4)}`;\n  const paymentMethods = [];\n  shopIds.forEach(shopId => {\n    if (transactionsByShopId[shopId]) {\n      const cartItems = cartItemsByShop[shopId].map(item => ({\n        _id: item._id,\n        productId: item.productId,\n        variantId: item.variants._id,\n        shopId,\n        quantity: item.quantity\n      })); // we need to grab this per shop to get the API key\n\n      const packageData = Packages.findOne({\n        name: \"reaction-stripe\",\n        shopId\n      });\n      const paymentMethod = {\n        processor: \"Stripe\",\n        storedCard,\n        method: \"credit\",\n        paymentPackageId: packageData._id,\n        // TODO: REVIEW WITH AARON - why is paymentSettings key important\n        // and why is it just defined on the client?\n        paymentSettingsKey: packageData.name.split(\"/\").splice(-1)[0],\n        transactionId: transactionsByShopId[shopId].id,\n        amount: transactionsByShopId[shopId].amount * 0.01,\n        status: normalizeStatus(transactionsByShopId[shopId]),\n        mode: normalizeMode(transactionsByShopId[shopId]),\n        riskLevel: normalizeRiskLevel(transactionsByShopId[shopId]),\n        createdAt: new Date(transactionsByShopId[shopId].created),\n        transactions: [],\n        items: cartItems,\n        shopId\n      };\n      paymentMethod.transactions.push(transactionsByShopId[shopId]);\n      paymentMethods.push(paymentMethod);\n    }\n  });\n  return paymentMethods;\n}\n\nconst methods = {\n  \"stripe/payment/createCharges\"(transactionType, cardData, cartId) {\n    return Promise.asyncApply(() => {\n      check(transactionType, String);\n      check(cardData, {\n        name: String,\n        number: String,\n        expire_month: String,\n        // eslint-disable-line camelcase\n        expire_year: String,\n        // eslint-disable-line camelcase\n        cvv2: String,\n        type: String\n      });\n      check(cartId, String);\n      const primaryShopId = Reaction.getPrimaryShopId();\n      const stripePkg = Reaction.getPackageSettingsWithOptions({\n        shopId: primaryShopId,\n        name: \"reaction-stripe\"\n      });\n      const card = parseCardData(cardData);\n\n      if (!stripePkg || !stripePkg.settings || !stripePkg.settings.api_key) {\n        // Fail if we can't find a Stripe API key\n        throw new Meteor.Error(\"not-configured\", \"Attempted to create multiple stripe charges, but stripe was not configured properly.\");\n      }\n\n      const capture = transactionType === \"capture\"; // Must have an email\n\n      const cart = Cart.findOne({\n        _id: cartId\n      });\n      const customerAccount = Accounts.findOne({\n        _id: cart.userId\n      });\n      let customerEmail;\n\n      if (!customerAccount || !Array.isArray(customerAccount.emails)) {\n        // TODO: Is it okay to create random email here if anonymous?\n        Logger.Error(\"cart email missing!\");\n        throw new Meteor.Error(\"invalid-parameter\", \"Email is required for marketplace checkouts.\");\n      }\n\n      const defaultEmail = customerAccount.emails.find(email => email.provides === \"default\");\n\n      if (defaultEmail) {\n        customerEmail = defaultEmail.address;\n      } else if (!defaultEmail) {\n        customerEmail = cart.email;\n      } else {\n        throw new Meteor.Error(\"invalid-parameter\", \"Customer does not have default email\");\n      } // Initialize stripe api lib\n\n\n      const stripeApiKey = stripePkg.settings.api_key;\n      const stripe = stripeNpm(stripeApiKey); // get array of shopIds that exist in this cart\n\n      const shopIds = cart.items.reduce((uniqueShopIds, item) => {\n        if (uniqueShopIds.indexOf(item.shopId) === -1) {\n          uniqueShopIds.push(item.shopId);\n        }\n\n        return uniqueShopIds;\n      }, []);\n      const transactionsByShopId = {}; // TODO: If there is only one transactionsByShopId and the shopId is primaryShopId -\n      // Create a standard charge and bypass creating a customer for this charge\n\n      const primaryShop = Shops.findOne({\n        _id: primaryShopId\n      });\n      const {\n        currency\n      } = primaryShop;\n\n      try {\n        // Creates a customer object, adds a source via the card data\n        // and waits for the promise to resolve\n        const customer = Promise.await(stripe.customers.create({\n          email: customerEmail\n        }).then(cust => {\n          const customerCard = stripe.customers.createSource(cust.id, {\n            source: (0, _objectSpread2.default)({}, card, {\n              object: \"card\"\n            })\n          });\n          return customerCard;\n        })); // Get cart totals for each Shop\n\n        const cartTotals = cart.getTotalByShop();\n        const cartSubtotals = cart.getSubtotalByShop(); // Loop through all shopIds represented in cart\n\n        shopIds.forEach(shopId => {\n          // TODO: If shopId is primaryShopId - create a non-connect charge with the\n          // stripe customer object\n          const isPrimaryShop = shopId === primaryShopId;\n          let merchantStripePkg; // Initialize options - this is where idempotency_key\n          // and, if using connect, stripe_account go\n\n          const stripeOptions = {};\n          const stripeCharge = {\n            amount: formatForStripe(cartTotals[shopId]),\n            capture,\n            currency // TODO: add product metadata to stripe charge\n\n          };\n\n          if (isPrimaryShop) {\n            // If this is the primary shop, we can make a direct charge to the\n            // customer object we just created.\n            stripeCharge.customer = customer.customer;\n          } else {\n            // If this is a merchant shop, we need to tokenize the customer\n            // and charge the token with the merchant id\n            merchantStripePkg = Reaction.getPackageSettingsWithOptions({\n              shopId,\n              name: \"reaction-stripe\"\n            }); // If this merchant doesn't have stripe setup, fail.\n            // We should _never_ get to this point, because\n            // this will not roll back the entire transaction\n\n            if (!merchantStripePkg || !merchantStripePkg.settings || !merchantStripePkg.settings.connectAuth || !merchantStripePkg.settings.connectAuth.stripe_user_id) {\n              throw new Meteor.Error(\"server-error\", `Error processing payment for merchant with shopId ${shopId}`);\n            } // get stripe account for this shop\n\n\n            const stripeUserId = merchantStripePkg.settings.connectAuth.stripe_user_id;\n            stripeOptions.stripe_account = stripeUserId; // eslint-disable-line camelcase\n            // Create token from our customer object to use with merchant shop\n\n            const token = Promise.await(stripe.tokens.create({\n              customer: customer.customer\n            }, stripeOptions)); // TODO: Add description to charge in Stripe\n\n            stripeCharge.source = token.id; // Get the set application fee from the dashboard\n\n            const dashboardAppFee = stripePkg.settings.applicationFee || 0;\n            const percentAppFee = dashboardAppFee / 100; // Convert whole number app fee to percentage\n            // Initialize applicationFee - this can be adjusted by the onCalculateStripeApplicationFee event hook\n\n            const coreApplicationFee = formatForStripe(cartSubtotals[shopId] * percentAppFee);\n            /**\n             * Hook for affecting the application fee charged. Any hooks that `add` \"onCalculateStripeApplicationFee\" will\n             * run here\n             * @module hooks/payments/stripe\n             * @method onCalculateStripeApplicationFee\n             * @param {number} applicationFee the exact application fee in cents (must be returned by every hook)\n             * @param {object} options object containing properties passed into the hook\n             * @param {object} options.cart the cart object\n             * @param {object} options.shopId the shopId\n             * @todo Consider abstracting the application fee out of the Stripe implementation, into core payments\n             * @returns {number} the application fee after having been through all hooks (must be returned by ever hook)\n             */\n\n            const applicationFee = Hooks.Events.run(\"onCalculateStripeApplicationFee\", coreApplicationFee, {\n              cart,\n              // The cart\n              shopId // currentShopId\n\n            }); // TODO: Consider discounts when determining application fee\n            // Charge the application fee created by hooks. If it doesn't exist, that means that a hook has fouled up\n            // the application fee. Review hooks and plugins.\n            // Fall back to the application fee that comes from the stripe dashboard when hook based app fee is undefined\n            // eslint-disable-next-line camelcase\n\n            stripeCharge.application_fee = applicationFee || coreApplicationFee;\n          } // We should only do this once per shop per cart\n\n\n          stripeOptions.idempotency_key = `${shopId}${cart._id}${Random.id()}`; // eslint-disable-line camelcase\n          // Create a charge with the options set above\n\n          const charge = Promise.await(stripe.charges.create(stripeCharge, stripeOptions));\n          transactionsByShopId[shopId] = charge;\n        }); // get cartItemsByShop to build paymentMethods\n\n        const cartItemsByShop = cart.getItemsByShop(); // Build paymentMethods from transactions, card data and cart items\n\n        const paymentMethods = buildPaymentMethods({\n          cardData,\n          cartItemsByShop,\n          transactionsByShopId\n        }); // If successful, call cart/submitPayment and return success back to client.\n\n        Meteor.call(\"cart/submitPayment\", paymentMethods);\n        return {\n          success: true,\n          transactions: transactionsByShopId\n        };\n      } catch (error) {\n        // If unsuccessful\n        // return failure back to client if error is a standard stripe card error\n        if (error.rawType === \"card_error\") {\n          return {\n            success: false,\n            error: {\n              message: error.message,\n              code: error.code,\n              type: error.type,\n              rawType: error.rawType,\n              detail: error.detail\n            }\n          };\n        } // If we get an unexpected error, log and return a censored error message\n\n\n        Logger.error(`Received unexpected error type: ${error.rawType}`);\n        Logger.error(error);\n        throw new Meteor.Error(\"server-error\", \"An unexpected error occurred while creating multiple stripe charges\");\n      }\n    });\n  },\n\n  /**\n   * Capture a Stripe charge\n   * @see https://stripe.com/docs/api#capture_charge\n   * @param  {Object} paymentMethod A PaymentMethod object\n   * @return {Object} results from Stripe normalized\n   */\n  \"stripe/payment/capture\"(paymentMethod) {\n    // Call both check and validate because by calling `clean`, the audit pkg\n    // thinks that we haven't checked paymentMethod arg\n    check(paymentMethod, Object);\n    PaymentMethodArgument.validate(PaymentMethodArgument.clean(paymentMethod));\n    const captureDetails = {\n      amount: formatForStripe(paymentMethod.amount)\n    }; // 100% discounts are not valid when using Stripe\n    // If discount is 100%, capture 100% and then refund 100% of transaction\n\n    if (captureDetails.amount === accounting.unformat(0)) {\n      const voidedAmount = unformatFromStripe(paymentMethod.transactions[0].amount);\n      stripeCaptureCharge(paymentMethod);\n      return Meteor.call(\"stripe/refund/create\", paymentMethod, voidedAmount);\n    }\n\n    return stripeCaptureCharge(paymentMethod);\n  },\n\n  /**\n   * Issue a refund against a previously captured transaction\n   * @see https://stripe.com/docs/api#refunds\n   * @param  {Object} paymentMethod object\n   * @param  {Number} amount to be refunded\n   * @param  {String} reason refund was issued (currently unused by client)\n   * @return {Object} result\n   */\n  \"stripe/refund/create\"(paymentMethod, amount, reason = \"requested_by_customer\") {\n    check(amount, Number);\n    check(reason, String); // Call both check and validate because by calling `clean`, the audit pkg\n    // thinks that we haven't checked paymentMethod arg\n\n    check(paymentMethod, Object);\n    PaymentMethodArgument.validate(PaymentMethodArgument.clean(paymentMethod));\n    let result;\n\n    try {\n      const stripeKey = utils.getStripeApi(paymentMethod.paymentPackageId);\n      const stripe = stripeNpm(stripeKey);\n      const refundPromise = stripe.refunds.create({\n        charge: paymentMethod.transactionId,\n        amount: formatForStripe(amount)\n      });\n      const refundResult = Promise.await(refundPromise);\n      Logger.debug(refundResult);\n\n      if (refundResult && refundResult.object === \"refund\") {\n        result = {\n          saved: true,\n          response: refundResult\n        };\n      } else {\n        result = {\n          saved: false,\n          response: refundResult\n        };\n        Logger.warn(\"Stripe call succeeded but refund not issued\");\n      }\n    } catch (error) {\n      Logger.error(error);\n      result = {\n        saved: false,\n        error: `Cannot issue refund: ${error.message}`\n      };\n      Logger.fatal(\"Stripe call failed, refund was not issued\", error.message);\n    }\n\n    return result;\n  },\n\n  /**\n   * List refunds\n   * @param  {Object} paymentMethod object\n   * @return {Object} result\n   */\n  \"stripe/refund/list\"(paymentMethod) {\n    // Call both check and validate because by calling `clean`, the audit pkg\n    // thinks that we haven't checked paymentMethod arg\n    check(paymentMethod, Object);\n    PaymentMethodArgument.validate(PaymentMethodArgument.clean(paymentMethod));\n    const stripeKey = utils.getStripeApi(paymentMethod.paymentPackageId);\n    const stripe = stripeNpm(stripeKey);\n    let refundListResults;\n\n    try {\n      const refundListPromise = stripe.refunds.list({\n        charge: paymentMethod.transactionId\n      });\n      refundListResults = Promise.await(refundListPromise);\n    } catch (error) {\n      Logger.error(\"Encountered an error when trying to list refunds\", error.message);\n    }\n\n    const result = [];\n\n    if (refundListResults && refundListResults.data) {\n      for (const refund of refundListResults.data) {\n        result.push({\n          type: refund.object,\n          amount: refund.amount / 100,\n          created: refund.created * 1000,\n          currency: refund.currency,\n          raw: refund\n        });\n      }\n    }\n\n    return result;\n  }\n\n};\nMeteor.methods(methods);","map":{"version":3,"sources":["imports/plugins/included/payments-stripe/server/methods/stripe.js"],"names":["module1","module","export","utils","methods","accounting","watch","require","default","v","stripeNpm","Meteor","check","Random","Reaction","Logger","Hooks","Cart","Shops","Accounts","Packages","PaymentMethodArgument","parseCardData","data","number","name","cvc","cvv2","exp_month","expire_month","exp_year","expire_year","formatForStripe","amount","Math","round","unformatFromStripe","getStripeApi","paymentPackageId","stripePackage","findOne","stripeKey","settings","api_key","connectAuth","access_token","stripeCaptureCharge","paymentMethod","result","captureDetails","stripe","capturePromise","charges","capture","transactionId","captureResult","Promise","await","status","saved","response","error","normalizeStatus","transaction","Error","failure_code","captured","normalizeMode","normalizeRiskLevel","outcome","risk_level","buildPaymentMethods","options","cardData","cartItemsByShop","transactionsByShopId","shopIds","Object","keys","storedCard","type","charAt","toUpperCase","slice","paymentMethods","forEach","shopId","cartItems","map","item","_id","productId","variantId","variants","quantity","packageData","processor","method","paymentSettingsKey","split","splice","id","mode","riskLevel","createdAt","Date","created","transactions","items","push","transactionType","cartId","String","primaryShopId","getPrimaryShopId","stripePkg","getPackageSettingsWithOptions","card","cart","customerAccount","userId","customerEmail","Array","isArray","emails","defaultEmail","find","email","provides","address","stripeApiKey","reduce","uniqueShopIds","indexOf","primaryShop","currency","customer","customers","create","then","cust","customerCard","createSource","source","object","cartTotals","getTotalByShop","cartSubtotals","getSubtotalByShop","isPrimaryShop","merchantStripePkg","stripeOptions","stripeCharge","stripe_user_id","stripeUserId","stripe_account","token","tokens","dashboardAppFee","applicationFee","percentAppFee","coreApplicationFee","Events","run","application_fee","idempotency_key","charge","getItemsByShop","call","success","rawType","message","code","detail","validate","clean","unformat","voidedAmount","reason","Number","refundPromise","refunds","refundResult","debug","warn","fatal","refundListResults","refundListPromise","list","refund","raw"],"mappings":";;;;AAAA,MAAMA,UAAQC,MAAd;AAAqBD,QAAQE,MAAR,CAAe;AAACC,SAAM,MAAIA,KAAX;AAAiBC,WAAQ,MAAIA;AAA7B,CAAf;AAAsD,IAAIC,UAAJ;AAAeL,QAAQM,KAAR,CAAcC,QAAQ,eAAR,CAAd,EAAuC;AAACC,UAAQC,CAAR,EAAU;AAACJ,iBAAWI,CAAX;AAAa;;AAAzB,CAAvC,EAAkE,CAAlE;AAAqE,IAAIC,SAAJ;AAAcV,QAAQM,KAAR,CAAcC,QAAQ,QAAR,CAAd,EAAgC;AAACC,UAAQC,CAAR,EAAU;AAACC,gBAAUD,CAAV;AAAY;;AAAxB,CAAhC,EAA0D,CAA1D;AAA6D,IAAIE,MAAJ;AAAWX,QAAQM,KAAR,CAAcC,QAAQ,eAAR,CAAd,EAAuC;AAACI,SAAOF,CAAP,EAAS;AAACE,aAAOF,CAAP;AAAS;;AAApB,CAAvC,EAA6D,CAA7D;AAAgE,IAAIG,KAAJ;AAAUZ,QAAQM,KAAR,CAAcC,QAAQ,cAAR,CAAd,EAAsC;AAACK,QAAMH,CAAN,EAAQ;AAACG,YAAMH,CAAN;AAAQ;;AAAlB,CAAtC,EAA0D,CAA1D;AAA6D,IAAII,MAAJ;AAAWb,QAAQM,KAAR,CAAcC,QAAQ,eAAR,CAAd,EAAuC;AAACM,SAAOJ,CAAP,EAAS;AAACI,aAAOJ,CAAP;AAAS;;AAApB,CAAvC,EAA6D,CAA7D;AAAgE,IAAIK,QAAJ,EAAaC,MAAb,EAAoBC,KAApB;AAA0BhB,QAAQM,KAAR,CAAcC,QAAQ,8BAAR,CAAd,EAAsD;AAACO,WAASL,CAAT,EAAW;AAACK,eAASL,CAAT;AAAW,GAAxB;;AAAyBM,SAAON,CAAP,EAAS;AAACM,aAAON,CAAP;AAAS,GAA5C;;AAA6CO,QAAMP,CAAN,EAAQ;AAACO,YAAMP,CAAN;AAAQ;;AAA9D,CAAtD,EAAsH,CAAtH;AAAyH,IAAIQ,IAAJ,EAASC,KAAT,EAAeC,QAAf,EAAwBC,QAAxB;AAAiCpB,QAAQM,KAAR,CAAcC,QAAQ,mCAAR,CAAd,EAA2D;AAACU,OAAKR,CAAL,EAAO;AAACQ,WAAKR,CAAL;AAAO,GAAhB;;AAAiBS,QAAMT,CAAN,EAAQ;AAACS,YAAMT,CAAN;AAAQ,GAAlC;;AAAmCU,WAASV,CAAT,EAAW;AAACU,eAASV,CAAT;AAAW,GAA1D;;AAA2DW,WAASX,CAAT,EAAW;AAACW,eAASX,CAAT;AAAW;;AAAlF,CAA3D,EAA+I,CAA/I;AAAkJ,IAAIY,qBAAJ;AAA0BrB,QAAQM,KAAR,CAAcC,QAAQ,2CAAR,CAAd,EAAmE;AAACc,wBAAsBZ,CAAtB,EAAwB;AAACY,4BAAsBZ,CAAtB;AAAwB;;AAAlD,CAAnE,EAAuH,CAAvH;;AASvyB,SAASa,aAAT,CAAuBC,IAAvB,EAA6B;AAC3B,SAAO;AACLC,YAAQD,KAAKC,MADR;AAELC,UAAMF,KAAKE,IAFN;AAGLC,SAAKH,KAAKI,IAHL;AAILC,eAAWL,KAAKM,YAJX;AAIyB;AAC9BC,cAAUP,KAAKQ,WALV,CAKsB;;AALtB,GAAP;AAOD,C,CAGD;;;AACA,SAASC,eAAT,CAAyBC,MAAzB,EAAiC;AAC/B,SAAOC,KAAKC,KAAL,CAAWF,SAAS,GAApB,CAAP;AACD;;AACD,SAASG,kBAAT,CAA4BH,MAA5B,EAAoC;AAClC,SAAQA,SAAS,GAAjB;AACD;;AAEM,MAAM9B,QAAQ,EAAd;;AAEPA,MAAMkC,YAAN,GAAqB,UAAUC,gBAAV,EAA4B;AAC/C,QAAMC,gBAAgBnB,SAASoB,OAAT,CAAiBF,gBAAjB,CAAtB;AACA,QAAMG,YAAYF,cAAcG,QAAd,CAAuBC,OAAvB,IAAkCJ,cAAcG,QAAd,CAAuBE,WAAvB,CAAmCC,YAAvF;AACA,SAAOJ,SAAP;AACD,CAJD;AAMA;;;;;;;AAKA,SAASK,mBAAT,CAA6BC,aAA7B,EAA4C;AAC1C,MAAIC,MAAJ;AACA,QAAMC,iBAAiB;AACrBhB,YAAQD,gBAAgBe,cAAcd,MAA9B;AADa,GAAvB;AAKA,QAAMQ,YAAYtC,MAAMkC,YAAN,CAAmBU,cAAcT,gBAAjC,CAAlB;AACA,QAAMY,SAASxC,UAAU+B,SAAV,CAAf;;AAEA,MAAI;AACF,UAAMU,iBAAiBD,OAAOE,OAAP,CAAeC,OAAf,CAAuBN,cAAcO,aAArC,EAAoDL,cAApD,CAAvB;AACA,UAAMM,gBAAgBC,QAAQC,KAAR,CAAcN,cAAd,CAAtB;;AAEA,QAAII,cAAcG,MAAd,KAAyB,WAA7B,EAA0C;AACxCV,eAAS;AACPW,eAAO,IADA;AAEPC,kBAAUL;AAFH,OAAT;AAID,KALD,MAKO;AACLP,eAAS;AACPW,eAAO,KADA;AAEPC,kBAAUL;AAFH,OAAT;AAID;AACF,GAfD,CAeE,OAAOM,KAAP,EAAc;AACd9C,WAAO8C,KAAP,CAAaA,KAAb;AACAb,aAAS;AACPW,aAAO,KADA;AAEPE;AAFO,KAAT;AAIA,WAAO;AAAEA,WAAF;AAASb;AAAT,KAAP;AACD;;AACD,SAAOA,MAAP;AACD;AAED;;;;;;;;AAMA,SAASc,eAAT,CAAyBC,WAAzB,EAAsC;AACpC,MAAI,CAACA,WAAL,EAAkB;AAChB,UAAM,IAAIpD,OAAOqD,KAAX,CAAiB,mBAAjB,EAAsC,wCAAtC,CAAN;AACD,GAHmC,CAKpC;;;AACA,MAAID,YAAYE,YAAhB,EAA8B;AAC5B,WAAO,QAAP;AACD,GARmC,CAUpC;;;AACA,MAAIF,YAAYG,QAAhB,EAA0B;AAAE;AAC1B,WAAO,SAAP;AACD,GAbmC,CAepC;;;AACA,SAAO,SAAP;AACD;AAED;;;;;;;;AAMA,SAASC,aAAT,CAAuBJ,WAAvB,EAAoC;AAClC,MAAI,CAACA,WAAL,EAAkB;AAChB,UAAM,IAAIpD,OAAOqD,KAAX,CAAiB,mBAAjB,EAAsC,sCAAtC,CAAN;AACD,GAHiC,CAKlC;;;AACA,MAAID,YAAYE,YAAhB,EAA8B;AAC5B,WAAO,QAAP;AACD,GARiC,CAUlC;;;AACA,MAAIF,YAAYG,QAAhB,EAA0B;AACxB,WAAO,SAAP;AACD,GAbiC,CAelC;;;AACA,SAAO,WAAP;AACD;AAED;;;;;;;;;AAOA,SAASE,kBAAT,CAA4BL,WAA5B,EAAyC;AACvC,MAAI,CAACA,WAAL,EAAkB;AAChB,UAAM,IAAIpD,OAAOqD,KAAX,CAAiB,mBAAjB,EAAsC,2CAAtC,CAAN;AACD;;AAED,QAAMK,UAAUN,YAAYM,OAAZ,IAAuBN,YAAYM,OAAZ,CAAoBC,UAA3D;;AAEA,MAAID,YAAY,UAAhB,EAA4B;AAC1B,WAAO,UAAP;AACD;;AAED,MAAIA,YAAY,SAAhB,EAA2B;AACzB,WAAO,MAAP;AACD,GAbsC,CAevC;;;AACA,SAAO,QAAP;AACD;;AAGD,SAASE,mBAAT,CAA6BC,OAA7B,EAAsC;AACpC,QAAM;AAAEC,YAAF;AAAYC,mBAAZ;AAA6BC;AAA7B,MAAsDH,OAA5D;;AACA,MAAI,CAACG,oBAAL,EAA2B;AACzB,UAAM,IAAIhE,OAAOqD,KAAX,CAAiB,mBAAjB,EAAsC,yDAAtC,CAAN;AACD;;AAED,QAAMY,UAAUC,OAAOC,IAAP,CAAYH,oBAAZ,CAAhB;AACA,QAAMI,aAAc,GAAEN,SAASO,IAAT,CAAcC,MAAd,CAAqB,CAArB,EAAwBC,WAAxB,KAAwCT,SAASO,IAAT,CAAcG,KAAd,CAAoB,CAApB,CAAuB,IAAGV,SAASjD,MAAT,CAAgB2D,KAAhB,CAAsB,CAAC,CAAvB,CAA0B,EAAlH;AACA,QAAMC,iBAAiB,EAAvB;AAGAR,UAAQS,OAAR,CAAiBC,MAAD,IAAY;AAC1B,QAAIX,qBAAqBW,MAArB,CAAJ,EAAkC;AAChC,YAAMC,YAAYb,gBAAgBY,MAAhB,EAAwBE,GAAxB,CAA6BC,IAAD,KAAW;AACvDC,aAAKD,KAAKC,GAD6C;AAEvDC,mBAAWF,KAAKE,SAFuC;AAGvDC,mBAAWH,KAAKI,QAAL,CAAcH,GAH8B;AAIvDJ,cAJuD;AAKvDQ,kBAAUL,KAAKK;AALwC,OAAX,CAA5B,CAAlB,CADgC,CAShC;;AACA,YAAMC,cAAc3E,SAASoB,OAAT,CAAiB;AACnCf,cAAM,iBAD6B;AAEnC6D;AAFmC,OAAjB,CAApB;AAKA,YAAMvC,gBAAgB;AACpBiD,mBAAW,QADS;AAEpBjB,kBAFoB;AAGpBkB,gBAAQ,QAHY;AAIpB3D,0BAAkByD,YAAYL,GAJV;AAKpB;AACA;AACAQ,4BAAoBH,YAAYtE,IAAZ,CAAiB0E,KAAjB,CAAuB,GAAvB,EAA4BC,MAA5B,CAAmC,CAAC,CAApC,EAAuC,CAAvC,CAPA;AAQpB9C,uBAAeqB,qBAAqBW,MAArB,EAA6Be,EARxB;AASpBpE,gBAAQ0C,qBAAqBW,MAArB,EAA6BrD,MAA7B,GAAsC,IAT1B;AAUpByB,gBAAQI,gBAAgBa,qBAAqBW,MAArB,CAAhB,CAVY;AAWpBgB,cAAMnC,cAAcQ,qBAAqBW,MAArB,CAAd,CAXc;AAYpBiB,mBAAWnC,mBAAmBO,qBAAqBW,MAArB,CAAnB,CAZS;AAapBkB,mBAAW,IAAIC,IAAJ,CAAS9B,qBAAqBW,MAArB,EAA6BoB,OAAtC,CAbS;AAcpBC,sBAAc,EAdM;AAepBC,eAAOrB,SAfa;AAgBpBD;AAhBoB,OAAtB;AAkBAvC,oBAAc4D,YAAd,CAA2BE,IAA3B,CAAgClC,qBAAqBW,MAArB,CAAhC;AACAF,qBAAeyB,IAAf,CAAoB9D,aAApB;AACD;AACF,GArCD;AAuCA,SAAOqC,cAAP;AACD;;AAEM,MAAMhF,UAAU;AACf,gCAAN,CAAqC0G,eAArC,EAAsDrC,QAAtD,EAAgEsC,MAAhE;AAAA,oCAAwE;AACtEnG,YAAMkG,eAAN,EAAuBE,MAAvB;AACApG,YAAM6D,QAAN,EAAgB;AACdhD,cAAMuF,MADQ;AAEdxF,gBAAQwF,MAFM;AAGdnF,sBAAcmF,MAHA;AAGQ;AACtBjF,qBAAaiF,MAJC;AAIO;AACrBrF,cAAMqF,MALQ;AAMdhC,cAAMgC;AANQ,OAAhB;AAQApG,YAAMmG,MAAN,EAAcC,MAAd;AAEA,YAAMC,gBAAgBnG,SAASoG,gBAAT,EAAtB;AAEA,YAAMC,YAAYrG,SAASsG,6BAAT,CAAuC;AACvD9B,gBAAQ2B,aAD+C;AAEvDxF,cAAM;AAFiD,OAAvC,CAAlB;AAKA,YAAM4F,OAAO/F,cAAcmD,QAAd,CAAb;;AAEA,UAAI,CAAC0C,SAAD,IAAc,CAACA,UAAUzE,QAAzB,IAAqC,CAACyE,UAAUzE,QAAV,CAAmBC,OAA7D,EAAsE;AACpE;AACA,cAAM,IAAIhC,OAAOqD,KAAX,CAAiB,gBAAjB,EAAmC,sFAAnC,CAAN;AACD;;AAED,YAAMX,UAAUyD,oBAAoB,SAApC,CA1BsE,CA4BtE;;AACA,YAAMQ,OAAOrG,KAAKuB,OAAL,CAAa;AAAEkD,aAAKqB;AAAP,OAAb,CAAb;AACA,YAAMQ,kBAAkBpG,SAASqB,OAAT,CAAiB;AAAEkD,aAAK4B,KAAKE;AAAZ,OAAjB,CAAxB;AACA,UAAIC,aAAJ;;AAEA,UAAI,CAACF,eAAD,IAAoB,CAACG,MAAMC,OAAN,CAAcJ,gBAAgBK,MAA9B,CAAzB,EAAgE;AAC9D;AACA7G,eAAOiD,KAAP,CAAa,qBAAb;AACA,cAAM,IAAIrD,OAAOqD,KAAX,CAAiB,mBAAjB,EAAsC,8CAAtC,CAAN;AACD;;AAED,YAAM6D,eAAeN,gBAAgBK,MAAhB,CAAuBE,IAAvB,CAA6BC,KAAD,IAAWA,MAAMC,QAAN,KAAmB,SAA1D,CAArB;;AACA,UAAIH,YAAJ,EAAkB;AAChBJ,wBAAgBI,aAAaI,OAA7B;AACD,OAFD,MAEO,IAAI,CAACJ,YAAL,EAAmB;AACxBJ,wBAAgBH,KAAKS,KAArB;AACD,OAFM,MAEA;AACL,cAAM,IAAIpH,OAAOqD,KAAX,CAAiB,mBAAjB,EAAsC,sCAAtC,CAAN;AACD,OA9CqE,CAgDtE;;;AACA,YAAMkE,eAAef,UAAUzE,QAAV,CAAmBC,OAAxC;AACA,YAAMO,SAASxC,UAAUwH,YAAV,CAAf,CAlDsE,CAoDtE;;AACA,YAAMtD,UAAU0C,KAAKV,KAAL,CAAWuB,MAAX,CAAkB,CAACC,aAAD,EAAgB3C,IAAhB,KAAyB;AACzD,YAAI2C,cAAcC,OAAd,CAAsB5C,KAAKH,MAA3B,MAAuC,CAAC,CAA5C,EAA+C;AAC7C8C,wBAAcvB,IAAd,CAAmBpB,KAAKH,MAAxB;AACD;;AACD,eAAO8C,aAAP;AACD,OALe,EAKb,EALa,CAAhB;AAOA,YAAMzD,uBAAuB,EAA7B,CA5DsE,CA8DtE;AACA;;AACA,YAAM2D,cAAcpH,MAAMsB,OAAN,CAAc;AAAEkD,aAAKuB;AAAP,OAAd,CAApB;AACA,YAAM;AAAEsB;AAAF,UAAeD,WAArB;;AAEA,UAAI;AACF;AACA;AACA,cAAME,WAAWhF,QAAQC,KAAR,CAAcP,OAAOuF,SAAP,CAAiBC,MAAjB,CAAwB;AACrDX,iBAAON;AAD8C,SAAxB,EAE5BkB,IAF4B,CAEtBC,IAAD,IAAU;AAChB,gBAAMC,eAAe3F,OAAOuF,SAAP,CAAiBK,YAAjB,CAA8BF,KAAKvC,EAAnC,EAAuC;AAAE0C,oDAAa1B,IAAb;AAAmB2B,sBAAQ;AAA3B;AAAF,WAAvC,CAArB;AACA,iBAAOH,YAAP;AACD,SAL8B,CAAd,CAAjB,CAHE,CAUF;;AACA,cAAMI,aAAa3B,KAAK4B,cAAL,EAAnB;AACA,cAAMC,gBAAgB7B,KAAK8B,iBAAL,EAAtB,CAZE,CAcF;;AACAxE,gBAAQS,OAAR,CAAiBC,MAAD,IAAY;AAC1B;AACA;AAEA,gBAAM+D,gBAAgB/D,WAAW2B,aAAjC;AAEA,cAAIqC,iBAAJ,CAN0B,CAO1B;AACA;;AACA,gBAAMC,gBAAgB,EAAtB;AACA,gBAAMC,eAAe;AACnBvH,oBAAQD,gBAAgBiH,WAAW3D,MAAX,CAAhB,CADW;AAEnBjC,mBAFmB;AAGnBkF,oBAHmB,CAInB;;AAJmB,WAArB;;AAOA,cAAIc,aAAJ,EAAmB;AACjB;AACA;AACAG,yBAAahB,QAAb,GAAwBA,SAASA,QAAjC;AACD,WAJD,MAIO;AACL;AACA;AACAc,gCAAoBxI,SAASsG,6BAAT,CAAuC;AACzD9B,oBADyD;AAEzD7D,oBAAM;AAFmD,aAAvC,CAApB,CAHK,CAQL;AACA;AACA;;AACA,gBAAI,CAAC6H,iBAAD,IACF,CAACA,kBAAkB5G,QADjB,IAEF,CAAC4G,kBAAkB5G,QAAlB,CAA2BE,WAF1B,IAGF,CAAC0G,kBAAkB5G,QAAlB,CAA2BE,WAA3B,CAAuC6G,cAH1C,EAG0D;AACxD,oBAAM,IAAI9I,OAAOqD,KAAX,CAAiB,cAAjB,EAAkC,qDAAoDsB,MAAO,EAA7F,CAAN;AACD,aAhBI,CAkBL;;;AACA,kBAAMoE,eAAeJ,kBAAkB5G,QAAlB,CAA2BE,WAA3B,CAAuC6G,cAA5D;AACAF,0BAAcI,cAAd,GAA+BD,YAA/B,CApBK,CAoBwC;AAE7C;;AACA,kBAAME,QAAQpG,QAAQC,KAAR,CAAcP,OAAO2G,MAAP,CAAcnB,MAAd,CAAqB;AAC/CF,wBAAUA,SAASA;AAD4B,aAArB,EAEzBe,aAFyB,CAAd,CAAd,CAvBK,CA2BL;;AACAC,yBAAaT,MAAb,GAAsBa,MAAMvD,EAA5B,CA5BK,CA8BL;;AACA,kBAAMyD,kBAAkB3C,UAAUzE,QAAV,CAAmBqH,cAAnB,IAAqC,CAA7D;AACA,kBAAMC,gBAAgBF,kBAAkB,GAAxC,CAhCK,CAgCwC;AAE7C;;AACA,kBAAMG,qBAAqBjI,gBAAgBmH,cAAc7D,MAAd,IAAwB0E,aAAxC,CAA3B;AAEA;;;;;;;;;;;;;AAYA,kBAAMD,iBAAiB/I,MAAMkJ,MAAN,CAAaC,GAAb,CAAiB,iCAAjB,EAAoDF,kBAApD,EAAwE;AAC7F3C,kBAD6F;AACvF;AACNhC,oBAF6F,CAEtF;;AAFsF,aAAxE,CAAvB,CAjDK,CAsDL;AAEA;AACA;AACA;AACA;;AACAkE,yBAAaY,eAAb,GAA+BL,kBAAkBE,kBAAjD;AACD,WAlFyB,CAoF1B;;;AACAV,wBAAcc,eAAd,GAAiC,GAAE/E,MAAO,GAAEgC,KAAK5B,GAAI,GAAE7E,OAAOwF,EAAP,EAAY,EAAnE,CArF0B,CAqF4C;AAEtE;;AACA,gBAAMiE,SAAS9G,QAAQC,KAAR,CAAcP,OAAOE,OAAP,CAAesF,MAAf,CAAsBc,YAAtB,EAAoCD,aAApC,CAAd,CAAf;AAEA5E,+BAAqBW,MAArB,IAA+BgF,MAA/B;AACD,SA3FD,EAfE,CA6GF;;AACA,cAAM5F,kBAAkB4C,KAAKiD,cAAL,EAAxB,CA9GE,CAgHF;;AACA,cAAMnF,iBAAiBb,oBAAoB;AAAEE,kBAAF;AAAYC,yBAAZ;AAA6BC;AAA7B,SAApB,CAAvB,CAjHE,CAmHF;;AACAhE,eAAO6J,IAAP,CAAY,oBAAZ,EAAkCpF,cAAlC;AACA,eAAO;AAAEqF,mBAAS,IAAX;AAAiB9D,wBAAchC;AAA/B,SAAP;AACD,OAtHD,CAsHE,OAAOd,KAAP,EAAc;AACd;AACA;AACA,YAAIA,MAAM6G,OAAN,KAAkB,YAAtB,EAAoC;AAClC,iBAAO;AACLD,qBAAS,KADJ;AAEL5G,mBAAO;AACL8G,uBAAS9G,MAAM8G,OADV;AAELC,oBAAM/G,MAAM+G,IAFP;AAGL5F,oBAAMnB,MAAMmB,IAHP;AAIL0F,uBAAS7G,MAAM6G,OAJV;AAKLG,sBAAQhH,MAAMgH;AALT;AAFF,WAAP;AAUD,SAda,CAed;;;AACA9J,eAAO8C,KAAP,CAAc,mCAAkCA,MAAM6G,OAAQ,EAA9D;AACA3J,eAAO8C,KAAP,CAAaA,KAAb;AACA,cAAM,IAAIlD,OAAOqD,KAAX,CAAiB,cAAjB,EAAiC,qEAAjC,CAAN;AACD;AACF,KA7MD;AAAA,GADqB;;AA+MrB;;;;;;AAMA,2BAAyBjB,aAAzB,EAAwC;AACtC;AACA;AACAnC,UAAMmC,aAAN,EAAqB8B,MAArB;AACAxD,0BAAsByJ,QAAtB,CAA+BzJ,sBAAsB0J,KAAtB,CAA4BhI,aAA5B,CAA/B;AAEA,UAAME,iBAAiB;AACrBhB,cAAQD,gBAAgBe,cAAcd,MAA9B;AADa,KAAvB,CANsC,CAUtC;AACA;;AACA,QAAIgB,eAAehB,MAAf,KAA0B5B,WAAW2K,QAAX,CAAoB,CAApB,CAA9B,EAAsD;AACpD,YAAMC,eAAe7I,mBAAmBW,cAAc4D,YAAd,CAA2B,CAA3B,EAA8B1E,MAAjD,CAArB;AACAa,0BAAoBC,aAApB;AAEA,aAAOpC,OAAO6J,IAAP,CAAY,sBAAZ,EAAoCzH,aAApC,EAAmDkI,YAAnD,CAAP;AACD;;AACD,WAAOnI,oBAAoBC,aAApB,CAAP;AACD,GAxOoB;;AA0OrB;;;;;;;;AAQA,yBAAuBA,aAAvB,EAAsCd,MAAtC,EAA8CiJ,SAAS,uBAAvD,EAAgF;AAC9EtK,UAAMqB,MAAN,EAAckJ,MAAd;AACAvK,UAAMsK,MAAN,EAAclE,MAAd,EAF8E,CAI9E;AACA;;AACApG,UAAMmC,aAAN,EAAqB8B,MAArB;AACAxD,0BAAsByJ,QAAtB,CAA+BzJ,sBAAsB0J,KAAtB,CAA4BhI,aAA5B,CAA/B;AAEA,QAAIC,MAAJ;;AACA,QAAI;AACF,YAAMP,YAAYtC,MAAMkC,YAAN,CAAmBU,cAAcT,gBAAjC,CAAlB;AACA,YAAMY,SAASxC,UAAU+B,SAAV,CAAf;AACA,YAAM2I,gBAAgBlI,OAAOmI,OAAP,CAAe3C,MAAf,CAAsB;AAAE4B,gBAAQvH,cAAcO,aAAxB;AAAuCrB,gBAAQD,gBAAgBC,MAAhB;AAA/C,OAAtB,CAAtB;AACA,YAAMqJ,eAAe9H,QAAQC,KAAR,CAAc2H,aAAd,CAArB;AACArK,aAAOwK,KAAP,CAAaD,YAAb;;AACA,UAAIA,gBAAgBA,aAAatC,MAAb,KAAwB,QAA5C,EAAsD;AACpDhG,iBAAS;AACPW,iBAAO,IADA;AAEPC,oBAAU0H;AAFH,SAAT;AAID,OALD,MAKO;AACLtI,iBAAS;AACPW,iBAAO,KADA;AAEPC,oBAAU0H;AAFH,SAAT;AAIAvK,eAAOyK,IAAP,CAAY,6CAAZ;AACD;AACF,KAlBD,CAkBE,OAAO3H,KAAP,EAAc;AACd9C,aAAO8C,KAAP,CAAaA,KAAb;AACAb,eAAS;AACPW,eAAO,KADA;AAEPE,eAAQ,wBAAuBA,MAAM8G,OAAQ;AAFtC,OAAT;AAIA5J,aAAO0K,KAAP,CAAa,2CAAb,EAA0D5H,MAAM8G,OAAhE;AACD;;AACD,WAAO3H,MAAP;AACD,GAvRoB;;AAyRrB;;;;;AAKA,uBAAqBD,aAArB,EAAoC;AAClC;AACA;AACAnC,UAAMmC,aAAN,EAAqB8B,MAArB;AACAxD,0BAAsByJ,QAAtB,CAA+BzJ,sBAAsB0J,KAAtB,CAA4BhI,aAA5B,CAA/B;AAEA,UAAMN,YAAYtC,MAAMkC,YAAN,CAAmBU,cAAcT,gBAAjC,CAAlB;AACA,UAAMY,SAASxC,UAAU+B,SAAV,CAAf;AACA,QAAIiJ,iBAAJ;;AACA,QAAI;AACF,YAAMC,oBAAoBzI,OAAOmI,OAAP,CAAeO,IAAf,CAAoB;AAAEtB,gBAAQvH,cAAcO;AAAxB,OAApB,CAA1B;AACAoI,0BAAoBlI,QAAQC,KAAR,CAAckI,iBAAd,CAApB;AACD,KAHD,CAGE,OAAO9H,KAAP,EAAc;AACd9C,aAAO8C,KAAP,CAAa,kDAAb,EAAiEA,MAAM8G,OAAvE;AACD;;AAED,UAAM3H,SAAS,EAAf;;AACA,QAAI0I,qBAAqBA,kBAAkBnK,IAA3C,EAAiD;AAC/C,WAAK,MAAMsK,MAAX,IAAqBH,kBAAkBnK,IAAvC,EAA6C;AAC3CyB,eAAO6D,IAAP,CAAY;AACV7B,gBAAM6G,OAAO7C,MADH;AAEV/G,kBAAQ4J,OAAO5J,MAAP,GAAgB,GAFd;AAGVyE,mBAASmF,OAAOnF,OAAP,GAAiB,IAHhB;AAIV6B,oBAAUsD,OAAOtD,QAJP;AAKVuD,eAAKD;AALK,SAAZ;AAOD;AACF;;AACD,WAAO7I,MAAP;AACD;;AA3ToB,CAAhB;AA8TPrC,OAAOP,OAAP,CAAeA,OAAf","sourcesContent":["import accounting from \"accounting-js\";\nimport stripeNpm from \"stripe\";\nimport { Meteor } from \"meteor/meteor\";\nimport { check } from \"meteor/check\";\nimport { Random } from \"meteor/random\";\nimport { Reaction, Logger, Hooks } from \"/server/api\";\nimport { Cart, Shops, Accounts, Packages } from \"/lib/collections\";\nimport { PaymentMethodArgument } from \"/lib/collections/schemas\";\n\nfunction parseCardData(data) {\n  return {\n    number: data.number,\n    name: data.name,\n    cvc: data.cvv2,\n    exp_month: data.expire_month, // eslint-disable-line camelcase\n    exp_year: data.expire_year // eslint-disable-line camelcase\n  };\n}\n\n\n// Stripe uses a \"Decimal-less\" format so 10.00 becomes 1000\nfunction formatForStripe(amount) {\n  return Math.round(amount * 100);\n}\nfunction unformatFromStripe(amount) {\n  return (amount / 100);\n}\n\nexport const utils = {};\n\nutils.getStripeApi = function (paymentPackageId) {\n  const stripePackage = Packages.findOne(paymentPackageId);\n  const stripeKey = stripePackage.settings.api_key || stripePackage.settings.connectAuth.access_token;\n  return stripeKey;\n};\n\n/**\n * @summary Capture the results of a previous charge\n * @param {object} paymentMethod - Object containing info about the previous transaction\n * @returns {object} Object indicating the result, saved = true means success\n */\nfunction stripeCaptureCharge(paymentMethod) {\n  let result;\n  const captureDetails = {\n    amount: formatForStripe(paymentMethod.amount)\n  };\n\n\n  const stripeKey = utils.getStripeApi(paymentMethod.paymentPackageId);\n  const stripe = stripeNpm(stripeKey);\n\n  try {\n    const capturePromise = stripe.charges.capture(paymentMethod.transactionId, captureDetails);\n    const captureResult = Promise.await(capturePromise);\n\n    if (captureResult.status === \"succeeded\") {\n      result = {\n        saved: true,\n        response: captureResult\n      };\n    } else {\n      result = {\n        saved: false,\n        response: captureResult\n      };\n    }\n  } catch (error) {\n    Logger.error(error);\n    result = {\n      saved: false,\n      error\n    };\n    return { error, result };\n  }\n  return result;\n}\n\n/**\n * normalizes the status of a transaction\n * @method normalizeStatus\n * @param  {object} transaction - The transaction that we need to normalize\n * @return {string} normalized status string - either failed, settled, or created\n */\nfunction normalizeStatus(transaction) {\n  if (!transaction) {\n    throw new Meteor.Error(\"invalid-parameter\", \"normalizeStatus requires a transaction\");\n  }\n\n  // if this transaction failed, mode is \"failed\"\n  if (transaction.failure_code) {\n    return \"failed\";\n  }\n\n  // if this transaction was captured, status is \"settled\"\n  if (transaction.captured) { // Transaction was authorized but not captured\n    return \"settled\";\n  }\n\n  // Otherwise status is \"created\"\n  return \"created\";\n}\n\n/**\n * normalizes the mode of a transaction\n * @method normalizeMode\n * @param  {object} transaction The transaction that we need to normalize\n * @return {string} normalized status string - either failed, capture, or authorize\n */\nfunction normalizeMode(transaction) {\n  if (!transaction) {\n    throw new Meteor.Error(\"invalid-parameter\", \"normalizeMode requires a transaction\");\n  }\n\n  // if this transaction failed, mode is \"failed\"\n  if (transaction.failure_code) {\n    return \"failed\";\n  }\n\n  // If this transaction was captured, mode is \"capture\"\n  if (transaction.captured) {\n    return \"capture\";\n  }\n\n  // Anything else, mode is \"authorize\"\n  return \"authorize\";\n}\n\n/**\n * @method normalizeRiskLevel\n * @private\n * @summary Normalizes the risk level response of a transaction to the values defined in paymentMethod schema\n * @param  {object} transaction - The transaction that we need to normalize\n * @return {string} normalized status string - either elevated, high, or normal\n */\nfunction normalizeRiskLevel(transaction) {\n  if (!transaction) {\n    throw new Meteor.Error(\"invalid-parameter\", \"normalizeRiskLevel requires a transaction\");\n  }\n\n  const outcome = transaction.outcome && transaction.outcome.risk_level;\n\n  if (outcome === \"elevated\") {\n    return \"elevated\";\n  }\n\n  if (outcome === \"highest\") {\n    return \"high\";\n  }\n\n  // default to normal if no other flagged\n  return \"normal\";\n}\n\n\nfunction buildPaymentMethods(options) {\n  const { cardData, cartItemsByShop, transactionsByShopId } = options;\n  if (!transactionsByShopId) {\n    throw new Meteor.Error(\"invalid-parameter\", \"Creating a payment method log requries transaction data\");\n  }\n\n  const shopIds = Object.keys(transactionsByShopId);\n  const storedCard = `${cardData.type.charAt(0).toUpperCase() + cardData.type.slice(1)} ${cardData.number.slice(-4)}`;\n  const paymentMethods = [];\n\n\n  shopIds.forEach((shopId) => {\n    if (transactionsByShopId[shopId]) {\n      const cartItems = cartItemsByShop[shopId].map((item) => ({\n        _id: item._id,\n        productId: item.productId,\n        variantId: item.variants._id,\n        shopId,\n        quantity: item.quantity\n      }));\n\n      // we need to grab this per shop to get the API key\n      const packageData = Packages.findOne({\n        name: \"reaction-stripe\",\n        shopId\n      });\n\n      const paymentMethod = {\n        processor: \"Stripe\",\n        storedCard,\n        method: \"credit\",\n        paymentPackageId: packageData._id,\n        // TODO: REVIEW WITH AARON - why is paymentSettings key important\n        // and why is it just defined on the client?\n        paymentSettingsKey: packageData.name.split(\"/\").splice(-1)[0],\n        transactionId: transactionsByShopId[shopId].id,\n        amount: transactionsByShopId[shopId].amount * 0.01,\n        status: normalizeStatus(transactionsByShopId[shopId]),\n        mode: normalizeMode(transactionsByShopId[shopId]),\n        riskLevel: normalizeRiskLevel(transactionsByShopId[shopId]),\n        createdAt: new Date(transactionsByShopId[shopId].created),\n        transactions: [],\n        items: cartItems,\n        shopId\n      };\n      paymentMethod.transactions.push(transactionsByShopId[shopId]);\n      paymentMethods.push(paymentMethod);\n    }\n  });\n\n  return paymentMethods;\n}\n\nexport const methods = {\n  async \"stripe/payment/createCharges\"(transactionType, cardData, cartId) {\n    check(transactionType, String);\n    check(cardData, {\n      name: String,\n      number: String,\n      expire_month: String, // eslint-disable-line camelcase\n      expire_year: String, // eslint-disable-line camelcase\n      cvv2: String,\n      type: String\n    });\n    check(cartId, String);\n\n    const primaryShopId = Reaction.getPrimaryShopId();\n\n    const stripePkg = Reaction.getPackageSettingsWithOptions({\n      shopId: primaryShopId,\n      name: \"reaction-stripe\"\n    });\n\n    const card = parseCardData(cardData);\n\n    if (!stripePkg || !stripePkg.settings || !stripePkg.settings.api_key) {\n      // Fail if we can't find a Stripe API key\n      throw new Meteor.Error(\"not-configured\", \"Attempted to create multiple stripe charges, but stripe was not configured properly.\");\n    }\n\n    const capture = transactionType === \"capture\";\n\n    // Must have an email\n    const cart = Cart.findOne({ _id: cartId });\n    const customerAccount = Accounts.findOne({ _id: cart.userId });\n    let customerEmail;\n\n    if (!customerAccount || !Array.isArray(customerAccount.emails)) {\n      // TODO: Is it okay to create random email here if anonymous?\n      Logger.Error(\"cart email missing!\");\n      throw new Meteor.Error(\"invalid-parameter\", \"Email is required for marketplace checkouts.\");\n    }\n\n    const defaultEmail = customerAccount.emails.find((email) => email.provides === \"default\");\n    if (defaultEmail) {\n      customerEmail = defaultEmail.address;\n    } else if (!defaultEmail) {\n      customerEmail = cart.email;\n    } else {\n      throw new Meteor.Error(\"invalid-parameter\", \"Customer does not have default email\");\n    }\n\n    // Initialize stripe api lib\n    const stripeApiKey = stripePkg.settings.api_key;\n    const stripe = stripeNpm(stripeApiKey);\n\n    // get array of shopIds that exist in this cart\n    const shopIds = cart.items.reduce((uniqueShopIds, item) => {\n      if (uniqueShopIds.indexOf(item.shopId) === -1) {\n        uniqueShopIds.push(item.shopId);\n      }\n      return uniqueShopIds;\n    }, []);\n\n    const transactionsByShopId = {};\n\n    // TODO: If there is only one transactionsByShopId and the shopId is primaryShopId -\n    // Create a standard charge and bypass creating a customer for this charge\n    const primaryShop = Shops.findOne({ _id: primaryShopId });\n    const { currency } = primaryShop;\n\n    try {\n      // Creates a customer object, adds a source via the card data\n      // and waits for the promise to resolve\n      const customer = Promise.await(stripe.customers.create({\n        email: customerEmail\n      }).then((cust) => {\n        const customerCard = stripe.customers.createSource(cust.id, { source: { ...card, object: \"card\" } });\n        return customerCard;\n      }));\n\n      // Get cart totals for each Shop\n      const cartTotals = cart.getTotalByShop();\n      const cartSubtotals = cart.getSubtotalByShop();\n\n      // Loop through all shopIds represented in cart\n      shopIds.forEach((shopId) => {\n        // TODO: If shopId is primaryShopId - create a non-connect charge with the\n        // stripe customer object\n\n        const isPrimaryShop = shopId === primaryShopId;\n\n        let merchantStripePkg;\n        // Initialize options - this is where idempotency_key\n        // and, if using connect, stripe_account go\n        const stripeOptions = {};\n        const stripeCharge = {\n          amount: formatForStripe(cartTotals[shopId]),\n          capture,\n          currency\n          // TODO: add product metadata to stripe charge\n        };\n\n        if (isPrimaryShop) {\n          // If this is the primary shop, we can make a direct charge to the\n          // customer object we just created.\n          stripeCharge.customer = customer.customer;\n        } else {\n          // If this is a merchant shop, we need to tokenize the customer\n          // and charge the token with the merchant id\n          merchantStripePkg = Reaction.getPackageSettingsWithOptions({\n            shopId,\n            name: \"reaction-stripe\"\n          });\n\n          // If this merchant doesn't have stripe setup, fail.\n          // We should _never_ get to this point, because\n          // this will not roll back the entire transaction\n          if (!merchantStripePkg ||\n            !merchantStripePkg.settings ||\n            !merchantStripePkg.settings.connectAuth ||\n            !merchantStripePkg.settings.connectAuth.stripe_user_id) {\n            throw new Meteor.Error(\"server-error\", `Error processing payment for merchant with shopId ${shopId}`);\n          }\n\n          // get stripe account for this shop\n          const stripeUserId = merchantStripePkg.settings.connectAuth.stripe_user_id;\n          stripeOptions.stripe_account = stripeUserId; // eslint-disable-line camelcase\n\n          // Create token from our customer object to use with merchant shop\n          const token = Promise.await(stripe.tokens.create({\n            customer: customer.customer\n          }, stripeOptions));\n\n          // TODO: Add description to charge in Stripe\n          stripeCharge.source = token.id;\n\n          // Get the set application fee from the dashboard\n          const dashboardAppFee = stripePkg.settings.applicationFee || 0;\n          const percentAppFee = dashboardAppFee / 100; // Convert whole number app fee to percentage\n\n          // Initialize applicationFee - this can be adjusted by the onCalculateStripeApplicationFee event hook\n          const coreApplicationFee = formatForStripe(cartSubtotals[shopId] * percentAppFee);\n\n          /**\n           * Hook for affecting the application fee charged. Any hooks that `add` \"onCalculateStripeApplicationFee\" will\n           * run here\n           * @module hooks/payments/stripe\n           * @method onCalculateStripeApplicationFee\n           * @param {number} applicationFee the exact application fee in cents (must be returned by every hook)\n           * @param {object} options object containing properties passed into the hook\n           * @param {object} options.cart the cart object\n           * @param {object} options.shopId the shopId\n           * @todo Consider abstracting the application fee out of the Stripe implementation, into core payments\n           * @returns {number} the application fee after having been through all hooks (must be returned by ever hook)\n           */\n          const applicationFee = Hooks.Events.run(\"onCalculateStripeApplicationFee\", coreApplicationFee, {\n            cart, // The cart\n            shopId // currentShopId\n          });\n\n          // TODO: Consider discounts when determining application fee\n\n          // Charge the application fee created by hooks. If it doesn't exist, that means that a hook has fouled up\n          // the application fee. Review hooks and plugins.\n          // Fall back to the application fee that comes from the stripe dashboard when hook based app fee is undefined\n          // eslint-disable-next-line camelcase\n          stripeCharge.application_fee = applicationFee || coreApplicationFee;\n        }\n\n        // We should only do this once per shop per cart\n        stripeOptions.idempotency_key = `${shopId}${cart._id}${Random.id()}`; // eslint-disable-line camelcase\n\n        // Create a charge with the options set above\n        const charge = Promise.await(stripe.charges.create(stripeCharge, stripeOptions));\n\n        transactionsByShopId[shopId] = charge;\n      });\n\n\n      // get cartItemsByShop to build paymentMethods\n      const cartItemsByShop = cart.getItemsByShop();\n\n      // Build paymentMethods from transactions, card data and cart items\n      const paymentMethods = buildPaymentMethods({ cardData, cartItemsByShop, transactionsByShopId });\n\n      // If successful, call cart/submitPayment and return success back to client.\n      Meteor.call(\"cart/submitPayment\", paymentMethods);\n      return { success: true, transactions: transactionsByShopId };\n    } catch (error) {\n      // If unsuccessful\n      // return failure back to client if error is a standard stripe card error\n      if (error.rawType === \"card_error\") {\n        return {\n          success: false,\n          error: {\n            message: error.message,\n            code: error.code,\n            type: error.type,\n            rawType: error.rawType,\n            detail: error.detail\n          }\n        };\n      }\n      // If we get an unexpected error, log and return a censored error message\n      Logger.error(`Received unexpected error type: ${error.rawType}`);\n      Logger.error(error);\n      throw new Meteor.Error(\"server-error\", \"An unexpected error occurred while creating multiple stripe charges\");\n    }\n  },\n  /**\n   * Capture a Stripe charge\n   * @see https://stripe.com/docs/api#capture_charge\n   * @param  {Object} paymentMethod A PaymentMethod object\n   * @return {Object} results from Stripe normalized\n   */\n  \"stripe/payment/capture\"(paymentMethod) {\n    // Call both check and validate because by calling `clean`, the audit pkg\n    // thinks that we haven't checked paymentMethod arg\n    check(paymentMethod, Object);\n    PaymentMethodArgument.validate(PaymentMethodArgument.clean(paymentMethod));\n\n    const captureDetails = {\n      amount: formatForStripe(paymentMethod.amount)\n    };\n\n    // 100% discounts are not valid when using Stripe\n    // If discount is 100%, capture 100% and then refund 100% of transaction\n    if (captureDetails.amount === accounting.unformat(0)) {\n      const voidedAmount = unformatFromStripe(paymentMethod.transactions[0].amount);\n      stripeCaptureCharge(paymentMethod);\n\n      return Meteor.call(\"stripe/refund/create\", paymentMethod, voidedAmount);\n    }\n    return stripeCaptureCharge(paymentMethod);\n  },\n\n  /**\n   * Issue a refund against a previously captured transaction\n   * @see https://stripe.com/docs/api#refunds\n   * @param  {Object} paymentMethod object\n   * @param  {Number} amount to be refunded\n   * @param  {String} reason refund was issued (currently unused by client)\n   * @return {Object} result\n   */\n  \"stripe/refund/create\"(paymentMethod, amount, reason = \"requested_by_customer\") {\n    check(amount, Number);\n    check(reason, String);\n\n    // Call both check and validate because by calling `clean`, the audit pkg\n    // thinks that we haven't checked paymentMethod arg\n    check(paymentMethod, Object);\n    PaymentMethodArgument.validate(PaymentMethodArgument.clean(paymentMethod));\n\n    let result;\n    try {\n      const stripeKey = utils.getStripeApi(paymentMethod.paymentPackageId);\n      const stripe = stripeNpm(stripeKey);\n      const refundPromise = stripe.refunds.create({ charge: paymentMethod.transactionId, amount: formatForStripe(amount) });\n      const refundResult = Promise.await(refundPromise);\n      Logger.debug(refundResult);\n      if (refundResult && refundResult.object === \"refund\") {\n        result = {\n          saved: true,\n          response: refundResult\n        };\n      } else {\n        result = {\n          saved: false,\n          response: refundResult\n        };\n        Logger.warn(\"Stripe call succeeded but refund not issued\");\n      }\n    } catch (error) {\n      Logger.error(error);\n      result = {\n        saved: false,\n        error: `Cannot issue refund: ${error.message}`\n      };\n      Logger.fatal(\"Stripe call failed, refund was not issued\", error.message);\n    }\n    return result;\n  },\n\n  /**\n   * List refunds\n   * @param  {Object} paymentMethod object\n   * @return {Object} result\n   */\n  \"stripe/refund/list\"(paymentMethod) {\n    // Call both check and validate because by calling `clean`, the audit pkg\n    // thinks that we haven't checked paymentMethod arg\n    check(paymentMethod, Object);\n    PaymentMethodArgument.validate(PaymentMethodArgument.clean(paymentMethod));\n\n    const stripeKey = utils.getStripeApi(paymentMethod.paymentPackageId);\n    const stripe = stripeNpm(stripeKey);\n    let refundListResults;\n    try {\n      const refundListPromise = stripe.refunds.list({ charge: paymentMethod.transactionId });\n      refundListResults = Promise.await(refundListPromise);\n    } catch (error) {\n      Logger.error(\"Encountered an error when trying to list refunds\", error.message);\n    }\n\n    const result = [];\n    if (refundListResults && refundListResults.data) {\n      for (const refund of refundListResults.data) {\n        result.push({\n          type: refund.object,\n          amount: refund.amount / 100,\n          created: refund.created * 1000,\n          currency: refund.currency,\n          raw: refund\n        });\n      }\n    }\n    return result;\n  }\n};\n\nMeteor.methods(methods);\n"]},"sourceType":"script","hash":"2d4740f73bc4e10b7e9925a56c50382c95db732a"}
