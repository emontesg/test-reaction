{"metadata":{},"options":{"plugins":[{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$2","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":false}},{"key":"base$0$3","visitor":{"_exploded":{},"_verified":{},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}},{"key":"base$0$4","visitor":{"FunctionExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"ForInStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$6","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$0$1$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$1$2","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$2","visitor":{"ArrowFunctionExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$3","visitor":{"BlockStatement":{"enter":[null]},"SwitchCase":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$4","visitor":{"VariableDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"_exploded":true,"BlockStatement":{"enter":[null]},"SwitchStatement":{"enter":[null]},"Program":{"enter":[null]},"_verified":true,"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"base$0$0$5","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"base$0$0$6","visitor":{"ObjectExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"base$0$0$7","visitor":{"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"VariableDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"base$0$0$8","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"base$0$0$9","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$10","visitor":{"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$11","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]}},"options":{}},{"key":"base$0$0$12","visitor":{"ObjectMethod":{"enter":[null]},"ObjectProperty":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$13","visitor":{"ArrayExpression":{"enter":[null]},"CallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$14","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$15","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"base$0$0$16","visitor":{"UnaryExpression":{"enter":[null]},"_exploded":true,"_verified":true,"BlockStatement":{"enter":[null]},"CatchClause":{"enter":[null]},"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"Program":{"enter":[null]},"ObjectMethod":{"enter":[null]},"SwitchStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"ForOfStatement":{"enter":[null]},"ClassMethod":{"enter":[null]}},"options":{}},{"key":"base$0$0$17","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$18","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$19","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"base$0$0$20","visitor":{"ObjectProperty":{"exit":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$21","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$0$22","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$23","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"regenerator-transform","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{}}],"presets":[],"compact":false,"ast":true,"babelrc":false,"sourceFileName":"lib/collections/transform/cartOrder.js","filename":"lib/collections/transform/cartOrder.js","sourceMaps":true,"envName":"development","cwd":"/Users/estebandev/test-knowledge","passPerPreset":false,"parserOpts":{"sourceType":"module","sourceFileName":"lib/collections/transform/cartOrder.js","plugins":["dynamicImport","classProperties","jsx","jsx","flow","asyncGenerators","objectRestSpread","objectRestSpread","flow","asyncGenerators"]},"generatorOpts":{"filename":"lib/collections/transform/cartOrder.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"lib/collections/transform/cartOrder.js"}},"code":"var module1 = module;\nmodule1.export({\n  cartOrderTransform: function () {\n    return cartOrderTransform;\n  }\n});\n\nvar _sortBy;\n\nmodule1.watch(require(\"lodash/sortBy\"), {\n  \"default\": function (v) {\n    _sortBy = v;\n  }\n}, 0);\n\nvar _values;\n\nmodule1.watch(require(\"lodash/values\"), {\n  \"default\": function (v) {\n    _values = v;\n  }\n}, 1);\nvar accounting;\nmodule1.watch(require(\"accounting-js\"), {\n  \"default\": function (v) {\n    accounting = v;\n  }\n}, 2);\nvar Shops;\nmodule1.watch(require(\"./..\"), {\n  Shops: function (v) {\n    Shops = v;\n  }\n}, 3);\n\n/**\n * getSummary\n * @private\n * @summary iterates over cart items with computations\n * @param {Array} items - cart.items array\n * @param {Array} prop - path to item property represented by array\n * @param {Array} [prop2] - path to another item property represented by array\n * @param {String} [shopId] - shopId\n * @return {Number} - computations result\n */\nfunction getSummary(items, prop, prop2, shopId) {\n  try {\n    if (Array.isArray(items)) {\n      return items.reduce(function (sum, item) {\n        if (prop2) {\n          if (shopId) {\n            if (shopId === item.shopId) {\n              // if we're looking for a specific shop's items and this item does match\n              // if prop2 is an empty array\n              if (!prop2.length) {\n                return sum + (prop.length === 1 ? item[prop[0]] : item[prop[0]][prop[1]]);\n              }\n\n              return sum + item[prop[0]] * (prop2.length === 1 ? item[prop2[0]] : item[prop2[0]][prop2[1]]);\n            } // If we're looking for a specific shop's items and this item doesn't match\n\n\n            return sum;\n          } // No shopId param\n          // S + a * b, where b could be b1 or b2\n\n\n          return sum + item[prop[0]] * (prop2.length === 1 ? item[prop2[0]] : item[prop2[0]][prop2[1]]);\n        } // No prop2 param\n        // S + b, where b could be b1 or b2\n\n\n        return sum + (prop.length === 1 ? item[prop[0]] : item[prop[0]][prop[1]]);\n      }, 0);\n    }\n  } catch (e) {\n    // If data not prepared we should send a number to avoid exception with\n    // `toFixed`. This could happens if user stuck on `completed` checkout stage\n    // by some reason.\n    return 0;\n  }\n\n  return 0;\n}\n/**\n * Reaction transform methods on Collections\n * @file Use transform methods to return Cart and Order calculated values: count, subTotal, shipping, taxes, total.\n * Use these methods on Cart and Orders in templates, `{{cart.getCount}}` and in code, `Cart.findOne().getTotal()`.\n * These use Meteor Collection {@link http://docs.meteor.com/api/collections.html#Mongo-Collection transforms}.\n * @module cartOrderTransform\n */\n\n\nvar cartOrderTransform = {\n  /**\n   * @summary Return the total quantity on the order\n   * @method getCount\n   * @example {cart ? cart.getCount() : 0}\n   * @returns {Number}  Total quantity of items on the order\n   */\n  getCount: function () {\n    return getSummary(this.items, [\"quantity\"]);\n  },\n\n  /**\n   * @summary Return the total price of shipping/handling on the order\n   * @method getShippingTotal\n   * @returns {Number} Total price of shipping/handling on the order\n   */\n  getShippingTotal: function () {\n    // loop through the cart.shipping, sum shipments.\n    var rate = getSummary(this.shipping, [\"shipmentMethod\", \"rate\"]);\n    var handling = getSummary(this.shipping, [\"shipmentMethod\", \"handling\"]);\n    var shipping = handling + rate || 0;\n    return accounting.toFixed(shipping, 2);\n  },\n\n  /**\n   * @summary Get the total price of shipping, broken down by shop\n   * @method getShippingTotalByShop\n   * @returns {{Object}} - Total price of shipping, broken down by shop\n   */\n  getShippingTotalByShop: function () {\n    var _this = this;\n\n    return this.shipping.reduce(function (uniqueShopShippingTotals, shippingRec) {\n      if (!uniqueShopShippingTotals[shippingRec.shopId]) {\n        var rate = getSummary(_this.shipping, [\"shipmentMethod\", \"rate\"], [], shippingRec.shopId);\n        var handling = getSummary(_this.shipping, [\"shipmentMethod\", \"handling\"], [], shippingRec.shopId);\n        var shipping = handling + rate || 0;\n        uniqueShopShippingTotals[shippingRec.shopId] = accounting.toFixed(shipping, 2);\n        return uniqueShopShippingTotals;\n      }\n\n      return uniqueShopShippingTotals;\n    }, {});\n  },\n\n  /**\n   * @summary Return the total price of goods on an order\n   * @method getSubTotal\n   * @returns {Number} Total price of goods for the order\n   */\n  getSubTotal: function () {\n    var subTotal = getSummary(this.items, [\"quantity\"], [\"variants\", \"price\"]);\n    return accounting.toFixed(subTotal, 2);\n  },\n\n  /**\n   * @summary Aggregates the subtotals by shopId\n   * @method getSubtotalByShop\n   * @return {object} Object with a key for each shopId in the cart/order where the value is the subtotal for that shop\n   */\n  getSubtotalByShop: function () {\n    var _this2 = this;\n\n    return this.items.reduce(function (uniqueShopSubTotals, item) {\n      if (!uniqueShopSubTotals[item.shopId]) {\n        var subTotal = getSummary(_this2.items, [\"quantity\"], [\"variants\", \"price\"], item.shopId);\n        uniqueShopSubTotals[item.shopId] = accounting.toFixed(subTotal, 2);\n        return uniqueShopSubTotals;\n      }\n\n      return uniqueShopSubTotals;\n    }, {});\n  },\n\n  /**\n   * @summary Total taxes for order\n   * @method getTaxTotal\n   * @returns {Number} Total price of taxes for an order\n   */\n  getTaxTotal: function () {\n    // taxes are calculated in a Cart.after.update hooks\n    // the tax value stored with the cart/order is the effective tax rate\n    // calculated by line items\n    // in the imports/core/taxes plugin\n    var tax = this.tax || 0;\n    var subTotal = parseFloat(this.getSubTotal());\n    var taxTotal = subTotal * tax;\n    return accounting.toFixed(taxTotal, 2);\n  },\n\n  /**\n   * @summary Aggregates the taxes by shopId\n   * @method getTaxesByShop\n   * @return {Object} Object with a key for each shopId in cart/order where the value is the tax total for that shop\n   */\n  getTaxesByShop: function () {\n    var _this3 = this;\n\n    var subtotals = this.getSubtotalByShop();\n    var taxRates = this.taxRatesByShop;\n    return Object.keys(subtotals).reduce(function (shopTaxTotals, shopId) {\n      if (!shopTaxTotals[shopId]) {\n        var shopSubtotal = parseFloat(subtotals[shopId]); // In case of taxAPI's tax rate is stored in tax.\n\n        var shopTaxRate = taxRates && taxRates[shopId] || _this3.tax || 0;\n        var shopTaxTotal = shopSubtotal * shopTaxRate;\n        shopTaxTotals[shopId] = accounting.toFixed(shopTaxTotal, 2);\n      }\n\n      return shopTaxTotals;\n    }, {});\n  },\n\n  /**\n   * @summary Discount for cart/order.\n   * @description Grabs discounts from the invoice records if they exist, otherwise from this.discounts\n   * @example const cartTaxesByShop = cart.getTaxesByShop();\n   * @method getDiscounts\n   * @return {Number} Total value of discounts\n   */\n  getDiscounts: function () {\n    var orderDiscounts = 0;\n    orderDiscounts = this.billing.reduce(function (acc, item) {\n      if (item.invoice) {\n        return acc + parseFloat(item.invoice.discounts);\n      }\n\n      return acc;\n    }, 0);\n    var cartDiscount = parseFloat(this.discount) || 0;\n    var discount = orderDiscounts || cartDiscount || 0;\n    return accounting.toFixed(discount, 2);\n  },\n\n  /**\n   * @summary Discounts by Shop\n   * @method getDiscountsByShop\n   * @returns {object} - An object where the key is a shopId and the value is the discount for that shop\n   */\n  getDiscountsByShop: function () {\n    var discountsByShop = {};\n\n    if (this.billing && this.billing[0].invoice) {\n      // check if we have the invoice object on the billing records\n      for (var _iterator = this.billing, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n        var _ref;\n\n        if (_isArray) {\n          if (_i >= _iterator.length) break;\n          _ref = _iterator[_i++];\n        } else {\n          _i = _iterator.next();\n          if (_i.done) break;\n          _ref = _i.value;\n        }\n\n        var _billingRecord = _ref;\n        discountsByShop[_billingRecord.shopId] = accounting.toFixed(_billingRecord.invoice.discounts);\n      }\n    }\n\n    return discountsByShop;\n  },\n\n  /**\n   * @summary Total for Order\n   * @method getTotal\n   * @return {Number} Total for order\n   */\n  getTotal: function () {\n    var subTotal = parseFloat(this.getSubTotal());\n    var shipping = parseFloat(this.getShippingTotal());\n    var taxes = parseFloat(this.getTaxTotal());\n    var discount = parseFloat(this.getDiscounts());\n    var discountTotal = Math.max(0, subTotal - discount);\n    var total = discountTotal + shipping + taxes;\n    return accounting.toFixed(total, 2);\n  },\n\n  /**\n   * @summary Aggregates the cart/order total by shopId\n   * @method getTotalByShop\n   * @return {object} An object with a key for each shopId in the cart/order where the value is the total for that shop\n   */\n  getTotalByShop: function () {\n    var _this4 = this;\n\n    var subtotals = this.getSubtotalByShop();\n    var taxes = this.getTaxesByShop();\n    var shippingTotalByShop = this.getShippingTotalByShop(); // no discounts right now because that will need to support multi-shop\n    // TODO: Build out shop-by-shop discounts and permit discounts to reduce application fee\n\n    var shopsInCart = Object.keys(subtotals);\n    return Object.keys(subtotals).reduce(function (shopTotals, shopId) {\n      if (!shopTotals[shopId]) {\n        var shopSubtotal = parseFloat(subtotals[shopId]); // pending the implementation of shop-by-shop discounts, we allow discounts to apply only on single shop carts\n\n        if (shopsInCart.length === 1) {\n          var discount = parseFloat(_this4.getDiscounts());\n          shopSubtotal = parseFloat(subtotals[shopId]) - discount;\n        }\n\n        var shopTaxes = parseFloat(taxes[shopId]);\n        var shipping = parseFloat(shippingTotalByShop[shopId]);\n        var shopTotal = shopSubtotal + shopTaxes + shipping;\n        shopTotals[shopId] = accounting.toFixed(shopTotal, 2);\n      }\n\n      return shopTotals;\n    }, {});\n  },\n\n  /**\n   * @summary Cart items organized by shopId\n   * @method getItemsByShop\n   * @example const cartTotals = cart.getTotalByShop();\n   * @return {Object} Dict of shopIds with an array of items from that shop that are present in the cart/order\n   */\n  getItemsByShop: function () {\n    if (this.items) {\n      return this.items.reduce(function (itemsByShop, item) {\n        if (!itemsByShop[item.shopId]) {\n          itemsByShop[item.shopId] = [item];\n        } else {\n          itemsByShop[item.shopId].push(item);\n        }\n\n        return itemsByShop;\n      }, {});\n    }\n\n    return {};\n  },\n\n  /**\n   * @summary Returns an array of payment methods, normalized\n   * @method getPaymentMethods\n   * @returns {Array} Array of Payment Method objects\n   */\n  getPaymentMethods: function () {\n    var billingMethods = this.billing.map(function (method) {\n      return method.paymentMethod;\n    });\n    var methodObjects = billingMethods.map(function (method) {\n      var paymentMethodObject = {\n        storedCard: method.storedCard,\n        processor: method.processor,\n        mode: method.mode,\n        transactionId: method.transactionId,\n        amount: method.amount,\n        method: method.method\n      };\n      return paymentMethodObject;\n    });\n    return methodObjects;\n  },\n\n  /**\n   * @summary Return an array of payment methods for display removing duplicates\n   * @method getUniquePaymentMethods\n   * @returns {object} - An object containing the payment methods used on this order excluding duplicates\n   */\n  getUniquePaymentMethods: function () {\n    var billingMethods = this.billing.map(function (method) {\n      return method.paymentMethod;\n    });\n    var uniqueMethods = {};\n\n    for (var _iterator2 = billingMethods, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n      var _ref2;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref2 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref2 = _i2.value;\n      }\n\n      var _billingMethod = _ref2;\n      var key = \"\" + _billingMethod.storedCard + _billingMethod.processor + _billingMethod.method;\n\n      if (!uniqueMethods[key]) {\n        uniqueMethods[key] = {\n          storedCard: _billingMethod.storedCard,\n          processor: _billingMethod.processor,\n          method: _billingMethod.method,\n          key: key\n        };\n      }\n    }\n\n    var uniqueValueArray = _values(uniqueMethods);\n\n    return uniqueValueArray;\n  },\n\n  /**\n   * @summary Create an object that contains a summary for each shop\n   * @method getShopSummary\n   * @return {Object}  An object with a key for each shopId, and name + summary data for each\n   */\n  getShopSummary: function () {\n    // massage items into an object by Shop\n    var taxesByShop = this.getTaxesByShop();\n    var subTotalsByShop = this.getSubtotalByShop();\n    var shippingByShop = this.getShippingTotalByShop();\n    var shipping = this.shipping;\n    var itemsByShop = this.items.reduce(function (shopItems, item) {\n      if (!shopItems[item.shopId]) {\n        shopItems[item.shopId] = [item];\n      } else {\n        shopItems[item.shopId].push(item);\n      }\n\n      return shopItems;\n    }, {});\n    var shopObjects = Object.keys(itemsByShop).map(function (shop) {\n      var _ref3;\n\n      return _ref3 = {}, _ref3[shop] = {\n        name: Shops.findOne(shop).name,\n        subTotal: subTotalsByShop[shop],\n        taxes: taxesByShop[shop],\n        items: itemsByShop[shop],\n        quantityTotal: itemsByShop[shop].reduce(function (qty, item) {\n          return qty + item.quantity;\n        }, 0),\n        shipping: shippingByShop[shop],\n        shippingMethod: shipping[0].shipmentMethod\n      }, _ref3;\n    }); // TODO we just assume now that every shop uses the same carrier, thus the hard-coded zero index\n    // because shipping records are not stored by shop\n\n    var sortedShopObjects = _sortBy(shopObjects, function (shopObject) {\n      return shopObject.name;\n    });\n\n    return sortedShopObjects;\n  }\n};","map":{"version":3,"sources":["lib/collections/transform/cartOrder.js"],"names":["module1","module","export","cartOrderTransform","_sortBy","watch","require","v","_values","accounting","Shops","getSummary","items","prop","prop2","shopId","Array","isArray","reduce","sum","item","length","e","getCount","getShippingTotal","rate","shipping","handling","toFixed","getShippingTotalByShop","uniqueShopShippingTotals","shippingRec","getSubTotal","subTotal","getSubtotalByShop","uniqueShopSubTotals","getTaxTotal","tax","parseFloat","taxTotal","getTaxesByShop","subtotals","taxRates","taxRatesByShop","Object","keys","shopTaxTotals","shopSubtotal","shopTaxRate","shopTaxTotal","getDiscounts","orderDiscounts","billing","acc","invoice","discounts","cartDiscount","discount","getDiscountsByShop","discountsByShop","billingRecord","getTotal","taxes","discountTotal","Math","max","total","getTotalByShop","shippingTotalByShop","shopsInCart","shopTotals","shopTaxes","shopTotal","getItemsByShop","itemsByShop","push","getPaymentMethods","billingMethods","map","method","paymentMethod","methodObjects","paymentMethodObject","storedCard","processor","mode","transactionId","amount","getUniquePaymentMethods","uniqueMethods","billingMethod","key","uniqueValueArray","getShopSummary","taxesByShop","subTotalsByShop","shippingByShop","shopItems","shopObjects","shop","name","findOne","quantityTotal","qty","quantity","shippingMethod","shipmentMethod","sortedShopObjects","shopObject"],"mappings":"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","sourcesContent":["import accounting from \"accounting-js\";\nimport _ from \"lodash\";\nimport { Shops } from \"/lib/collections\";\n\n/**\n * getSummary\n * @private\n * @summary iterates over cart items with computations\n * @param {Array} items - cart.items array\n * @param {Array} prop - path to item property represented by array\n * @param {Array} [prop2] - path to another item property represented by array\n * @param {String} [shopId] - shopId\n * @return {Number} - computations result\n */\nfunction getSummary(items, prop, prop2, shopId) {\n  try {\n    if (Array.isArray(items)) {\n      return items.reduce((sum, item) => {\n        if (prop2) {\n          if (shopId) {\n            if (shopId === item.shopId) {\n              // if we're looking for a specific shop's items and this item does match\n              // if prop2 is an empty array\n              if (!prop2.length) {\n                return sum + (prop.length === 1 ? item[prop[0]] :\n                  item[prop[0]][prop[1]]);\n              }\n              return sum + item[prop[0]] * (prop2.length === 1 ? item[prop2[0]] :\n                item[prop2[0]][prop2[1]]);\n            }\n            // If we're looking for a specific shop's items and this item doesn't match\n            return sum;\n          }\n          // No shopId param\n          // S + a * b, where b could be b1 or b2\n          return sum + item[prop[0]] * (prop2.length === 1 ? item[prop2[0]] :\n            item[prop2[0]][prop2[1]]);\n        }\n        // No prop2 param\n        // S + b, where b could be b1 or b2\n        return sum + (prop.length === 1 ? item[prop[0]] :\n          item[prop[0]][prop[1]]);\n      }, 0);\n    }\n  } catch (e) {\n    // If data not prepared we should send a number to avoid exception with\n    // `toFixed`. This could happens if user stuck on `completed` checkout stage\n    // by some reason.\n    return 0;\n  }\n  return 0;\n}\n\n/**\n * Reaction transform methods on Collections\n * @file Use transform methods to return Cart and Order calculated values: count, subTotal, shipping, taxes, total.\n * Use these methods on Cart and Orders in templates, `{{cart.getCount}}` and in code, `Cart.findOne().getTotal()`.\n * These use Meteor Collection {@link http://docs.meteor.com/api/collections.html#Mongo-Collection transforms}.\n * @module cartOrderTransform\n */\n\nexport const cartOrderTransform = {\n  /**\n   * @summary Return the total quantity on the order\n   * @method getCount\n   * @example {cart ? cart.getCount() : 0}\n   * @returns {Number}  Total quantity of items on the order\n   */\n  getCount() {\n    return getSummary(this.items, [\"quantity\"]);\n  },\n  /**\n   * @summary Return the total price of shipping/handling on the order\n   * @method getShippingTotal\n   * @returns {Number} Total price of shipping/handling on the order\n   */\n  getShippingTotal() {\n    // loop through the cart.shipping, sum shipments.\n    const rate = getSummary(this.shipping, [\"shipmentMethod\", \"rate\"]);\n    const handling = getSummary(this.shipping, [\"shipmentMethod\", \"handling\"]);\n    const shipping = handling + rate || 0;\n    return accounting.toFixed(shipping, 2);\n  },\n  /**\n   * @summary Get the total price of shipping, broken down by shop\n   * @method getShippingTotalByShop\n   * @returns {{Object}} - Total price of shipping, broken down by shop\n   */\n  getShippingTotalByShop() {\n    return this.shipping.reduce((uniqueShopShippingTotals, shippingRec) => {\n      if (!uniqueShopShippingTotals[shippingRec.shopId]) {\n        const rate = getSummary(this.shipping, [\"shipmentMethod\", \"rate\"], [], shippingRec.shopId);\n        const handling = getSummary(this.shipping, [\"shipmentMethod\", \"handling\"], [], shippingRec.shopId);\n        const shipping = handling + rate || 0;\n        uniqueShopShippingTotals[shippingRec.shopId] = accounting.toFixed(shipping, 2);\n        return uniqueShopShippingTotals;\n      }\n      return uniqueShopShippingTotals;\n    }, {});\n  },\n  /**\n   * @summary Return the total price of goods on an order\n   * @method getSubTotal\n   * @returns {Number} Total price of goods for the order\n   */\n  getSubTotal() {\n    const subTotal = getSummary(this.items, [\"quantity\"], [\"variants\", \"price\"]);\n    return accounting.toFixed(subTotal, 2);\n  },\n  /**\n   * @summary Aggregates the subtotals by shopId\n   * @method getSubtotalByShop\n   * @return {object} Object with a key for each shopId in the cart/order where the value is the subtotal for that shop\n   */\n  getSubtotalByShop() {\n    return this.items.reduce((uniqueShopSubTotals, item) => {\n      if (!uniqueShopSubTotals[item.shopId]) {\n        const subTotal = getSummary(this.items, [\"quantity\"], [\"variants\", \"price\"], item.shopId);\n        uniqueShopSubTotals[item.shopId] = accounting.toFixed(subTotal, 2);\n        return uniqueShopSubTotals;\n      }\n      return uniqueShopSubTotals;\n    }, {});\n  },\n  /**\n   * @summary Total taxes for order\n   * @method getTaxTotal\n   * @returns {Number} Total price of taxes for an order\n   */\n  getTaxTotal() {\n    // taxes are calculated in a Cart.after.update hooks\n    // the tax value stored with the cart/order is the effective tax rate\n    // calculated by line items\n    // in the imports/core/taxes plugin\n    const tax = this.tax || 0;\n    const subTotal = parseFloat(this.getSubTotal());\n    const taxTotal = subTotal * tax;\n    return accounting.toFixed(taxTotal, 2);\n  },\n  /**\n   * @summary Aggregates the taxes by shopId\n   * @method getTaxesByShop\n   * @return {Object} Object with a key for each shopId in cart/order where the value is the tax total for that shop\n   */\n  getTaxesByShop() {\n    const subtotals = this.getSubtotalByShop();\n    const taxRates = this.taxRatesByShop;\n\n    return Object.keys(subtotals).reduce((shopTaxTotals, shopId) => {\n      if (!shopTaxTotals[shopId]) {\n        const shopSubtotal = parseFloat(subtotals[shopId]);\n        // In case of taxAPI's tax rate is stored in tax.\n        const shopTaxRate = (taxRates && taxRates[shopId]) || this.tax || 0;\n        const shopTaxTotal = shopSubtotal * shopTaxRate;\n        shopTaxTotals[shopId] = accounting.toFixed(shopTaxTotal, 2);\n      }\n      return shopTaxTotals;\n    }, {});\n  },\n  /**\n   * @summary Discount for cart/order.\n   * @description Grabs discounts from the invoice records if they exist, otherwise from this.discounts\n   * @example const cartTaxesByShop = cart.getTaxesByShop();\n   * @method getDiscounts\n   * @return {Number} Total value of discounts\n   */\n  getDiscounts() {\n    let orderDiscounts = 0;\n    orderDiscounts = this.billing.reduce((acc, item) => {\n      if (item.invoice) {\n        return acc + parseFloat(item.invoice.discounts);\n      }\n      return acc;\n    }, 0);\n    const cartDiscount = parseFloat(this.discount) || 0;\n    const discount = orderDiscounts || cartDiscount || 0;\n    return accounting.toFixed(discount, 2);\n  },\n  /**\n   * @summary Discounts by Shop\n   * @method getDiscountsByShop\n   * @returns {object} - An object where the key is a shopId and the value is the discount for that shop\n   */\n  getDiscountsByShop() {\n    const discountsByShop = {};\n    if (this.billing && this.billing[0].invoice) { // check if we have the invoice object on the billing records\n      for (const billingRecord of this.billing) {\n        discountsByShop[billingRecord.shopId] = accounting.toFixed(billingRecord.invoice.discounts);\n      }\n    }\n    return discountsByShop;\n  },\n  /**\n   * @summary Total for Order\n   * @method getTotal\n   * @return {Number} Total for order\n   */\n  getTotal() {\n    const subTotal = parseFloat(this.getSubTotal());\n    const shipping = parseFloat(this.getShippingTotal());\n    const taxes = parseFloat(this.getTaxTotal());\n    const discount = parseFloat(this.getDiscounts());\n    const discountTotal = Math.max(0, subTotal - discount);\n    const total = discountTotal + shipping + taxes;\n    return accounting.toFixed(total, 2);\n  },\n  /**\n   * @summary Aggregates the cart/order total by shopId\n   * @method getTotalByShop\n   * @return {object} An object with a key for each shopId in the cart/order where the value is the total for that shop\n   */\n  getTotalByShop() {\n    const subtotals = this.getSubtotalByShop();\n    const taxes = this.getTaxesByShop();\n    const shippingTotalByShop = this.getShippingTotalByShop();\n\n    // no discounts right now because that will need to support multi-shop\n    // TODO: Build out shop-by-shop discounts and permit discounts to reduce application fee\n    const shopsInCart = Object.keys(subtotals);\n    return Object.keys(subtotals).reduce((shopTotals, shopId) => {\n      if (!shopTotals[shopId]) {\n        let shopSubtotal = parseFloat(subtotals[shopId]);\n        // pending the implementation of shop-by-shop discounts, we allow discounts to apply only on single shop carts\n        if (shopsInCart.length === 1) {\n          const discount = parseFloat(this.getDiscounts());\n          shopSubtotal = parseFloat(subtotals[shopId]) - discount;\n        }\n\n        const shopTaxes = parseFloat(taxes[shopId]);\n        const shipping = parseFloat(shippingTotalByShop[shopId]);\n        const shopTotal = shopSubtotal + shopTaxes + shipping;\n        shopTotals[shopId] = accounting.toFixed(shopTotal, 2);\n      }\n      return shopTotals;\n    }, {});\n  },\n  /**\n   * @summary Cart items organized by shopId\n   * @method getItemsByShop\n   * @example const cartTotals = cart.getTotalByShop();\n   * @return {Object} Dict of shopIds with an array of items from that shop that are present in the cart/order\n   */\n  getItemsByShop() {\n    if (this.items) {\n      return this.items.reduce((itemsByShop, item) => {\n        if (!itemsByShop[item.shopId]) {\n          itemsByShop[item.shopId] = [item];\n        } else {\n          itemsByShop[item.shopId].push(item);\n        }\n        return itemsByShop;\n      }, {});\n    }\n    return {};\n  },\n  /**\n   * @summary Returns an array of payment methods, normalized\n   * @method getPaymentMethods\n   * @returns {Array} Array of Payment Method objects\n   */\n  getPaymentMethods() {\n    const billingMethods = this.billing.map((method) => method.paymentMethod);\n    const methodObjects = billingMethods.map((method) => {\n      const paymentMethodObject = {\n        storedCard: method.storedCard,\n        processor: method.processor,\n        mode: method.mode,\n        transactionId: method.transactionId,\n        amount: method.amount,\n        method: method.method\n      };\n      return paymentMethodObject;\n    });\n    return methodObjects;\n  },\n  /**\n   * @summary Return an array of payment methods for display removing duplicates\n   * @method getUniquePaymentMethods\n   * @returns {object} - An object containing the payment methods used on this order excluding duplicates\n   */\n  getUniquePaymentMethods() {\n    const billingMethods = this.billing.map((method) => method.paymentMethod);\n    const uniqueMethods = {};\n    for (const billingMethod of billingMethods) {\n      const key = `${billingMethod.storedCard}${billingMethod.processor}${billingMethod.method}`;\n      if (!uniqueMethods[key]) {\n        uniqueMethods[key] = {\n          storedCard: billingMethod.storedCard,\n          processor: billingMethod.processor,\n          method: billingMethod.method,\n          key\n        };\n      }\n    }\n    const uniqueValueArray = _.values(uniqueMethods);\n    return uniqueValueArray;\n  },\n  /**\n   * @summary Create an object that contains a summary for each shop\n   * @method getShopSummary\n   * @return {Object}  An object with a key for each shopId, and name + summary data for each\n   */\n  getShopSummary() {\n    // massage items into an object by Shop\n    const taxesByShop = this.getTaxesByShop();\n    const subTotalsByShop = this.getSubtotalByShop();\n    const shippingByShop = this.getShippingTotalByShop();\n    const { shipping } = this;\n    const itemsByShop = this.items.reduce((shopItems, item) => {\n      if (!shopItems[item.shopId]) {\n        shopItems[item.shopId] = [item];\n      } else {\n        shopItems[item.shopId].push(item);\n      }\n      return shopItems;\n    }, {});\n\n    const shopObjects = Object.keys(itemsByShop).map((shop) => ({\n      [shop]: {\n        name: Shops.findOne(shop).name,\n        subTotal: subTotalsByShop[shop],\n        taxes: taxesByShop[shop],\n        items: itemsByShop[shop],\n        quantityTotal: itemsByShop[shop].reduce((qty, item) => qty + item.quantity, 0),\n        shipping: shippingByShop[shop],\n        shippingMethod: shipping[0].shipmentMethod\n      }\n    }));\n    // TODO we just assume now that every shop uses the same carrier, thus the hard-coded zero index\n    // because shipping records are not stored by shop\n    const sortedShopObjects = _.sortBy(shopObjects, (shopObject) => shopObject.name);\n    return sortedShopObjects;\n  }\n};\n"]},"sourceType":"script","hash":"823ddf69c3d8ca0647f7c6a67f55d892af36fd61"}
