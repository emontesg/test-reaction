{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$1$2","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"ast":true,"babelrc":false,"sourceFileName":"imports/plugins/included/taxes-avalara/server/methods/taxCalc.js","filename":"imports/plugins/included/taxes-avalara/server/methods/taxCalc.js","sourceMaps":true,"envName":"development","cwd":"/Users/estebandev/test-knowledge","passPerPreset":false,"presets":[],"parserOpts":{"sourceType":"module","sourceFileName":"imports/plugins/included/taxes-avalara/server/methods/taxCalc.js","plugins":["jsx","jsx","flow","flow","objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties"]},"generatorOpts":{"filename":"imports/plugins/included/taxes-avalara/server/methods/taxCalc.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"imports/plugins/included/taxes-avalara/server/methods/taxCalc.js"}},"code":"let _filter;\n\nmodule.watch(require(\"lodash/filter\"), {\n  default(v) {\n    _filter = v;\n  }\n\n}, 0);\n\nlet _includes;\n\nmodule.watch(require(\"lodash/includes\"), {\n  default(v) {\n    _includes = v;\n  }\n\n}, 1);\n\nlet _split;\n\nmodule.watch(require(\"lodash/split\"), {\n  default(v) {\n    _split = v;\n  }\n\n}, 2);\n\nlet _get;\n\nmodule.watch(require(\"lodash/get\"), {\n  default(v) {\n    _get = v;\n  }\n\n}, 3);\nlet os;\nmodule.watch(require(\"os\"), {\n  default(v) {\n    os = v;\n  }\n\n}, 4);\nlet accounting;\nmodule.watch(require(\"accounting-js\"), {\n  default(v) {\n    accounting = v;\n  }\n\n}, 5);\nlet SimpleSchema;\nmodule.watch(require(\"simpl-schema\"), {\n  default(v) {\n    SimpleSchema = v;\n  }\n\n}, 6);\nlet Meteor;\nmodule.watch(require(\"meteor/meteor\"), {\n  Meteor(v) {\n    Meteor = v;\n  }\n\n}, 7);\nlet HTTP;\nmodule.watch(require(\"meteor/http\"), {\n  HTTP(v) {\n    HTTP = v;\n  }\n\n}, 8);\nlet check;\nmodule.watch(require(\"meteor/check\"), {\n  check(v) {\n    check = v;\n  }\n\n}, 9);\nlet Shops, Accounts;\nmodule.watch(require(\"../../../../../../lib/collections\"), {\n  Shops(v) {\n    Shops = v;\n  },\n\n  Accounts(v) {\n    Accounts = v;\n  }\n\n}, 10);\nlet TaxCodes;\nmodule.watch(require(\"../../../../core/taxes/lib/collections\"), {\n  TaxCodes(v) {\n    TaxCodes = v;\n  }\n\n}, 11);\nlet Reaction, Logger;\nmodule.watch(require(\"../../../../../../server/api\"), {\n  Reaction(v) {\n    Reaction = v;\n  },\n\n  Logger(v) {\n    Logger = v;\n  }\n\n}, 12);\nlet Avalogger;\nmodule.watch(require(\"./avalogger\"), {\n  default(v) {\n    Avalogger = v;\n  }\n\n}, 13);\nconst errorDetails = new SimpleSchema({\n  message: {\n    type: String\n  },\n  description: {\n    type: String,\n    optional: true\n  }\n}); // Validate that whenever we return an error we return the same format\n\nconst ErrorObject = new SimpleSchema({\n  \"type\": {\n    type: String\n  },\n  \"errorCode\": {\n    type: Number\n  },\n  \"errorDetails\": {\n    type: Array,\n    optional: true\n  },\n  \"errorDetails.$\": {\n    type: errorDetails,\n    optional: true\n  }\n});\nlet moment;\n\nfunction lazyLoadMoment() {\n  return Promise.asyncApply(() => {\n    if (moment) return;\n    moment = Promise.await(Promise.resolve().then(() => require(\"moment\")));\n  });\n}\n\nconst countriesWithRegions = [\"US\", \"CA\", \"DE\", \"AU\"];\nconst requiredFields = [\"username\", \"password\", \"apiLoginId\", \"companyCode\", \"shippingTaxCode\"];\nconst taxCalc = {};\n\ntaxCalc.getPackageData = function () {\n  const pkgData = Reaction.getPackageSettings(\"taxes-avalara\");\n  return pkgData;\n}; // Private methods\n\n/**\n * @summary Get the root URL for REST calls\n * @returns {String} Base url\n */\n\n\nfunction getUrl() {\n  const packageData = taxCalc.getPackageData();\n  const {\n    mode\n  } = packageData.settings.avalara;\n  let baseUrl;\n\n  if (mode) {\n    baseUrl = \"https://rest.avatax.com/api/v2/\";\n  } else {\n    baseUrl = \"https://sandbox-rest.avatax.com/api/v2/\";\n  }\n\n  return baseUrl;\n}\n/**\n * @summary Verify that we have all required configuration data before attempting to use the API\n * @param {Object} packageData - Package data retrieved from the database\n * @returns {boolean} - isValid Is the current configuration valid\n */\n\n\nfunction checkConfiguration(packageData = taxCalc.getPackageData()) {\n  let isValid = true;\n\n  const settings = _get(packageData, \"settings.avalara\", {});\n\n  for (const field of requiredFields) {\n    if (!settings[field]) {\n      const msg = `The Avalara package cannot function unless ${field} is configured`;\n      Logger.warn(msg);\n      Avalogger.error({\n        error: msg\n      });\n      isValid = false;\n    }\n  }\n\n  if (!isValid) {\n    Logger.error(\"The Avalara package is not configured correctly. Cannot continue\");\n  }\n\n  return isValid;\n}\n/**\n * @summary Get the auth info to authenticate to REST API\n * @param {Object} packageData - Optionally pass in packageData if we already have it\n * @returns {String} Username/Password string\n */\n\n\nfunction getAuthData(packageData = taxCalc.getPackageData()) {\n  if (checkConfiguration(packageData)) {\n    const settings = _get(packageData, \"settings.avalara\", {});\n\n    const {\n      username,\n      password\n    } = settings;\n    const auth = `${username}:${password}`;\n    return auth;\n  }\n}\n/**\n * @summary Get exempt tax settings to pass to REST API\n * @param {String} userId id of user to find settings\n * @returns {Object} containing exemptCode and customerUsageType\n */\n\n\nfunction getTaxSettings(userId) {\n  return _get(Accounts.findOne({\n    _id: userId\n  }), \"taxSettings\");\n}\n/**\n * @summary: Break Avalara error object into consistent format\n * @param {Object} error The error result from Avalara\n * @returns {Object} Error object with code and errorDetails\n */\n\n\nfunction parseError(error) {\n  let errorData; // The Avalara API constantly times out, so handle this special case first\n\n  if (error && (error.code === \"ETIMEDOUT\" || error.code === \"ESOCKETTIMEDOUT\")) {\n    errorData = {\n      errorCode: 503,\n      type: \"apiFailure\",\n      errorDetails: [{\n        message: error.message,\n        description: error.description\n      }]\n    };\n  } else if (error && error.response && error.response.statusCode === 401) {\n    // authentification error\n    errorData = {\n      errorCode: 401,\n      type: \"apiFailure\",\n      errorDetails: {\n        message: error.message,\n        description: error.description\n      }\n    };\n  } else if (error && error.response && error.response.statusCode === 400) {\n    // address validation error\n    if (error.response.data.error.code === \"GetTaxError\") {\n      errorData = {\n        errorCode: 300,\n        type: \"addressError\"\n      };\n      errorData.errorDetails = error.response.data.error.details.map(errorDetail => {\n        // eslint-disable-line\n        return {\n          message: errorDetail.message,\n          description: errorDetail.description\n        };\n      });\n    }\n  } else {\n    Logger.error(error, \"Unknown Error\");\n    Avalogger.error(error, \"Unknown error or error format\");\n  }\n\n  const errorObjectContext = ErrorObject.newContext(); // No Generic errors ever\n\n  errorObjectContext.validate(errorData);\n\n  if (!errorObjectContext.isValid()) {\n    throw new Meteor.Error(\"invalid-return\", \"Returning invalid Error results\");\n  }\n\n  return errorData;\n}\n/**\n * @summary function to get HTTP data and pass in extra Avalara-specific headers\n * @param {String} requestUrl - The URL to make the request to\n * @param {Object} options - An object of other options\n * @param {Boolean} testCredentials - determines skipping of configuration check\n * @returns {Object} Response from call\n */\n\n\nfunction avaGet(requestUrl, options = {}, testCredentials = true) {\n  const logObject = {};\n  const pkgData = taxCalc.getPackageData();\n\n  if (testCredentials) {\n    if (!checkConfiguration(pkgData)) {\n      return undefined;\n    }\n  }\n\n  const appVersion = Reaction.getAppVersion();\n\n  const meteorVersion = _split(Meteor.release, \"@\")[1];\n\n  const machineName = os.hostname();\n  const avaClient = `Reaction; ${appVersion}; Meteor HTTP; ${meteorVersion}; ${machineName}`;\n  const headers = {\n    headers: {\n      \"X-Avalara-Client\": avaClient,\n      \"X-Avalara-UID\": \"a0o33000004K8g3\"\n    }\n  };\n  const auth = options.auth || getAuthData();\n  const timeout = {\n    timeout: options.timeout || pkgData.settings.avalara.requestTimeout\n  };\n  const allOptions = Object.assign({}, options, headers, {\n    auth\n  }, timeout);\n\n  if (pkgData.settings.avalara.enableLogging) {\n    logObject.request = allOptions;\n  }\n\n  let result;\n\n  try {\n    result = HTTP.get(requestUrl, allOptions);\n  } catch (error) {\n    Logger.error(`Encountered error while calling Avalara API endpoint ${requestUrl}`);\n    Logger.error(error);\n    logObject.error = error;\n    Avalogger.error(logObject);\n    const parsedError = parseError(error);\n    result = {\n      error: parsedError\n    };\n  }\n\n  if (pkgData.settings.avalara.enableLogging) {\n    logObject.duration = _get(result, \"headers.serverDuration\");\n    logObject.result = result.data;\n    Avalogger.info(logObject);\n  }\n\n  return result;\n}\n/**\n * @summary to POST HTTP data and pass in extra Avalara-specific headers\n * @param {String} requestUrl - The URL to make the request to\n * @param {Object} options - An object of others options, usually data\n * @returns {Object} Response from call\n */\n\n\nfunction avaPost(requestUrl, options) {\n  const logObject = {};\n  const pkgData = taxCalc.getPackageData(); // If package is not configured don't bother making an API call\n\n  if (!checkConfiguration(pkgData)) {\n    return {\n      error: {\n        errorCode: 400,\n        type: \"apiFailure\",\n        errorDetails: {\n          message: \"API is not configured\"\n        }\n      }\n    };\n  }\n\n  const appVersion = Reaction.getAppVersion();\n  const meteorVersion = Meteor.release.split(\"@\")[1];\n  const machineName = os.hostname();\n  const avaClient = `Reaction; ${appVersion}; Meteor HTTP; ${meteorVersion}; ${machineName}`;\n  const headers = {\n    headers: {\n      \"X-Avalara-Client\": avaClient,\n      \"X-Avalara-UID\": \"a0o33000004K8g3\"\n    }\n  };\n  const auth = {\n    auth: getAuthData()\n  };\n  const timeout = {\n    timeout: pkgData.settings.avalara.requestTimeout\n  };\n  const allOptions = Object.assign({}, options, headers, auth, timeout);\n\n  if (pkgData.settings.avalara.enableLogging) {\n    logObject.request = allOptions;\n  }\n\n  let result;\n\n  try {\n    result = HTTP.post(requestUrl, allOptions);\n  } catch (error) {\n    Logger.error(`Encountered error while calling API at ${requestUrl}`);\n    Logger.error(error);\n    logObject.error = error; // whether logging is enabled or not we log out errors\n\n    Avalogger.error(logObject);\n    const parsedError = parseError(error);\n    result = {\n      error: parsedError\n    };\n  }\n\n  if (pkgData.settings.avalara.enableLogging) {\n    logObject.duration = _get(result, \"headers.serverDuration\");\n    logObject.result = result.data;\n    Avalogger.info(logObject);\n  }\n\n  return result;\n}\n/**\n * @summary Gets the full list of Avalara-supported entity use codes.\n * @returns {Object[]} API response\n */\n\n\ntaxCalc.getEntityCodes = function () {\n  if (checkConfiguration()) {\n    const baseUrl = getUrl();\n    const requestUrl = `${baseUrl}definitions/entityusecodes`;\n    const result = avaGet(requestUrl);\n\n    if (result && result.code === \"ETIMEDOUT\") {\n      throw new Meteor.Error(\"request-timeout\", \"Request timed out while populating entity codes.\");\n    }\n\n    return _get(result, \"data.value\", []);\n  }\n\n  throw new Meteor.Error(\"bad-configuration\", \"Avalara package is enabled, but is not properly configured\");\n}; // API Methods\n\n/**\n * @summary Calculate the taxable subtotal for a cart\n * @param {Cart} cart - Cart to calculate subtotal for\n * @returns {Number} Taxable subtotal\n */\n\n\ntaxCalc.calcTaxable = function (cart) {\n  let subTotal = 0;\n\n  for (const item of cart.items) {\n    if (item.variants.taxable) {\n      subTotal += item.variants.price * item.quantity;\n    }\n  }\n\n  return subTotal;\n};\n/**\n * @summary Validate a particular address\n * @param {Object} address Address to validate\n * @returns {Object} The validated result\n */\n\n\ntaxCalc.validateAddress = function (address) {\n  check(address, Object);\n  const packageData = taxCalc.getPackageData();\n  const {\n    countryList\n  } = packageData.settings.addressValidation;\n\n  if (!_includes(countryList, address.country)) {\n    // if this is a country selected for validation, proceed\n    // else use current address as response\n    return {\n      validatedAddress: address,\n      errors: []\n    };\n  }\n\n  let messages;\n  let validatedAddress = \"\"; // set default as falsy value\n\n  const errors = [];\n  const addressToValidate = {\n    line1: address.address1,\n    city: address.city,\n    postalCode: address.postal,\n    country: address.country\n  };\n\n  if (_includes(countriesWithRegions, address.country)) {\n    // if this is a country with regions, pass in region\n    addressToValidate.region = address.region;\n  }\n\n  if (address.address2) {\n    addressToValidate.line2 = address.address2;\n  }\n\n  const baseUrl = getUrl();\n  const requestUrl = `${baseUrl}addresses/resolve`;\n  const result = avaPost(requestUrl, {\n    data: addressToValidate\n  }); // Handle errors where we don't get back an address\n\n  if (result.error && result.error.type) {\n    if (result.error.type === \"apiError\") {\n      // If we have a problem with the API there's no reason to tell the customer\n      // so let's consider this unvalidated but move along\n      Logger.error(\"API error, ignoring address validation\");\n    }\n\n    if (result.error.type === \"addressError\") {\n      // We received a validation error so we need somehow pass this up to the client\n      Logger.info(\"Address Validation Error\"); // package up errors\n\n      return {\n        validatedAddress: {},\n        errors: [result.error]\n      };\n    }\n  }\n\n  const content = result.data;\n\n  if (content && content.messages) {\n    ({\n      messages\n    } = content);\n  }\n\n  if (messages) {\n    for (const message of messages) {\n      errors.push({\n        summary: message.summary,\n        details: message.details\n      });\n    }\n  }\n\n  if (result && result.data && result.data.validatedAddresses.length !== 0) {\n    const resultAddress = result.data.validatedAddresses[0];\n    validatedAddress = {\n      address1: resultAddress.line1,\n      city: resultAddress.city,\n      region: resultAddress.region,\n      postal: resultAddress.postalCode,\n      country: resultAddress.country\n    };\n\n    if (resultAddress.line2) {\n      validatedAddress.address2 = resultAddress.line2;\n    }\n  }\n\n  return {\n    validatedAddress,\n    errors\n  };\n};\n/**\n * @summary Tests supplied Avalara credentials by calling company endpoint\n * @param {Object} credentials callback Callback function for asynchronous execution\n * @param {Boolean} testCredentials To be set as false so avaGet skips config check\n * @returns {Object} Object containing \"statusCode\" on success, empty response on error\n */\n\n\ntaxCalc.testCredentials = function (credentials, testCredentials = false) {\n  check(credentials, Object);\n  const baseUrl = getUrl();\n  const auth = `${credentials.username}:${credentials.password}`;\n  const requestUrl = `${baseUrl}companies/${credentials.companyCode}/transactions`;\n  const result = avaGet(requestUrl, {\n    auth,\n    timeout: credentials.requestTimeout\n  }, testCredentials);\n\n  if (result && result.code === \"ETIMEDOUT\") {\n    throw new Meteor.Error(\"request-timeout\", \"Request Timed out. Increase your timeout settings\");\n  }\n\n  if (result.statusCode === 200) {\n    if (TaxCodes.find({}).count() === 0) {\n      Meteor.call(\"avalara/getTaxCodes\", (error, res) => {\n        if (error) {\n          if (typeof error === \"object\") {\n            Meteor.call(\"logging/logError\", \"avalara\", error);\n          } else {\n            Meteor.call(\"logging/logError\", \"avalara\", {\n              error\n            });\n          }\n        } else if (res && Array.isArray(res)) {\n          res.forEach(code => {\n            Meteor.call(\"taxes/insertTaxCodes\", Reaction.getShopId(), code, \"taxes-avalara\", err => {\n              if (err) {\n                throw new Meteor.Error(\"error-occurred\", \"Error populating TaxCodes collection\", err);\n              }\n            });\n          });\n        }\n      });\n    }\n  }\n\n  return {\n    statusCode: result.statusCode\n  };\n};\n/**\n * @summary get Avalara Tax Codes\n * @returns {Array} An array of Tax code objects\n */\n\n\ntaxCalc.getTaxCodes = function () {\n  if (checkConfiguration()) {\n    const baseUrl = getUrl();\n    const requestUrl = `${baseUrl}definitions/taxcodes`;\n    const result = avaGet(requestUrl);\n    return _get(result, \"data.value\", []);\n  }\n\n  throw new Meteor.Error(\"bad-configuration\", \"Avalara Tax package is enabled but not properly configured\");\n};\n/**\n * @summary Translate RC cart into format for submission\n * @param {Object} cart RC cart to send for tax estimate\n * @returns {Object} SalesOrder in Avalara format\n */\n\n\nfunction cartToSalesOrder(cart) {\n  const pkgData = taxCalc.getPackageData();\n  const {\n    companyCode,\n    shippingTaxCode\n  } = pkgData.settings.avalara;\n  const company = Shops.findOne(Reaction.getShopId());\n\n  const companyShipping = _filter(company.addressBook, o => o.isShippingDefault)[0];\n\n  const currencyCode = company.currency;\n  const cartShipping = cart.getShippingTotal();\n  Promise.await(lazyLoadMoment());\n  const cartDate = moment(cart.createdAt).format();\n  let lineItems = [];\n\n  if (cart.items) {\n    lineItems = cart.items.reduce((items, item) => {\n      if (item.variants.taxable) {\n        const itemObj = {\n          number: item._id,\n          itemCode: item.productId,\n          quantity: item.quantity,\n          amount: item.variants.price * item.quantity,\n          description: item.taxDescription || item.title,\n          taxCode: item.variants.taxCode\n        };\n        items.push(itemObj);\n      }\n\n      return items;\n    }, []);\n\n    if (cartShipping) {\n      lineItems.push({\n        number: \"shipping\",\n        itemCode: \"shipping\",\n        quantity: 1,\n        amount: cartShipping,\n        description: \"Shipping\",\n        taxCode: shippingTaxCode\n      });\n    }\n  }\n\n  const salesOrder = {\n    companyCode,\n    type: \"SalesOrder\",\n    customerCode: cart.userId,\n    date: cartDate,\n    currencyCode,\n    addresses: {\n      ShipFrom: {\n        line1: companyShipping.address1,\n        line2: companyShipping.address2,\n        city: companyShipping.city,\n        region: companyShipping.region,\n        country: companyShipping.country,\n        postalCode: companyShipping.postal\n      },\n      ShipTo: {\n        line1: cart.shipping[0].address.address1,\n        line2: cart.shipping[0].address.address2 || \"\",\n        city: cart.shipping[0].address.city,\n        region: cart.shipping[0].address.region,\n        country: cart.shipping[0].address.country || \"US\"\n      }\n    },\n    lines: lineItems\n  }; // current \"coupon code\" discount are based at the cart level, and every iten has it's\n  // discounted property set to true.\n\n  if (cart.discount) {\n    salesOrder.discount = accounting.toFixed(cart.discount, 2);\n\n    for (const line of salesOrder.lines) {\n      if (line.itemCode !== \"shipping\") {\n        line.discounted = true;\n      }\n    }\n  }\n\n  return salesOrder;\n}\n/**\n * @summary Submit cart for tax calculation\n * @param {Cart} cart Cart object for estimation\n * @param {Function} callback callback when using async version\n * @returns {Object} result Result of SalesOrder call\n */\n\n\ntaxCalc.estimateCart = function (cart, callback) {\n  Reaction.Schemas.Cart.validate(cart);\n  check(callback, Function);\n\n  if (cart.items && cart.shipping && cart.shipping[0] && cart.shipping[0].address) {\n    const salesOrder = Object.assign({}, cartToSalesOrder(cart), getTaxSettings(cart.userId));\n    const baseUrl = getUrl();\n    const requestUrl = `${baseUrl}transactions/create`;\n    const result = avaPost(requestUrl, {\n      data: salesOrder\n    });\n\n    if (!result.error) {\n      return callback(result.data);\n    }\n\n    return callback(result);\n  }\n\n  return callback({\n    error: {\n      errorCode: 300\n    }\n  });\n};\n/**\n * @summary Translate RC order into format for final submission\n * @param {Object} order RC order to send for tax reporting\n * @returns {Object} SalesOrder in Avalara format\n */\n\n\nfunction orderToSalesInvoice(order) {\n  let documentType;\n  const pkgData = taxCalc.getPackageData();\n  const {\n    companyCode,\n    shippingTaxCode,\n    commitDocuments\n  } = pkgData.settings.avalara;\n\n  if (commitDocuments) {\n    documentType = \"SalesInvoice\";\n  } else {\n    documentType = \"SalesOrder\";\n  }\n\n  const company = Shops.findOne(Reaction.getShopId());\n\n  const companyShipping = _filter(company.addressBook, o => o.isShippingDefault)[0];\n\n  const currencyCode = company.currency;\n  const orderShipping = order.getShippingTotal();\n  Promise.await(lazyLoadMoment());\n  const orderDate = moment(order.createdAt).format();\n  const lineItems = order.items.reduce((items, item) => {\n    if (item.variants.taxable) {\n      const itemObj = {\n        number: item._id,\n        itemCode: item.productId,\n        quantity: item.quantity,\n        amount: item.variants.price * item.quantity,\n        description: item.taxDescription || item.title,\n        taxCode: item.variants.taxCode\n      };\n      items.push(itemObj);\n    }\n\n    return items;\n  }, []);\n\n  if (orderShipping) {\n    lineItems.push({\n      number: \"shipping\",\n      itemCode: \"shipping\",\n      quantity: 1,\n      amount: orderShipping,\n      description: \"Shipping\",\n      taxCode: shippingTaxCode\n    });\n  }\n\n  const salesInvoice = {\n    companyCode,\n    type: documentType,\n    commit: commitDocuments,\n    code: order._id,\n    customerCode: order.userId,\n    date: orderDate,\n    currencyCode,\n    addresses: {\n      ShipFrom: {\n        line1: companyShipping.address1,\n        line2: companyShipping.address2,\n        city: companyShipping.city,\n        region: companyShipping.region,\n        country: companyShipping.country,\n        postalCode: companyShipping.postal\n      },\n      ShipTo: {\n        line1: order.shipping[0].address.address1,\n        line2: order.shipping[0].address.address2 || \"\",\n        city: order.shipping[0].address.city,\n        region: order.shipping[0].address.region,\n        country: order.shipping[0].address.country || \"US\"\n      }\n    },\n    lines: lineItems\n  };\n\n  if (order.discount) {\n    salesInvoice.discount = accounting.toFixed(order.discount, 2);\n\n    for (const line of salesInvoice.lines) {\n      if (line.itemCode !== \"shipping\") {\n        line.discounted = true;\n      }\n    }\n  }\n\n  return salesInvoice;\n}\n/**\n * @summary Submit order for tax reporting\n * @param {Order} order Order object for submission\n * @param {Function} callback callback when using async version\n * @returns {Object} result Result of SalesInvoice call\n */\n\n\ntaxCalc.recordOrder = function (order, callback) {\n  check(callback, Function); // unlike the other functions, we expect this to always be called asynchronously\n\n  if (order && order.shipping && order.shipping[0].address) {\n    const salesOrder = Object.assign({}, orderToSalesInvoice(order), getTaxSettings(order.userId));\n    const baseUrl = getUrl();\n    const requestUrl = `${baseUrl}transactions/create`;\n\n    try {\n      const result = avaPost(requestUrl, {\n        data: salesOrder\n      });\n      return callback(result.data);\n    } catch (error) {\n      Logger.error(\"Encountered error while recording order to Avalara\");\n      Logger.error(error);\n    }\n  }\n};\n/**\n * @summary Report refund to Avalara\n * @param {Order} order - The original order the refund was against\n * @param {Number} refundAmount - Amount to be refunded\n * @param {Function} callback - Callback\n * @returns {Object} Results from transaction call\n */\n\n\ntaxCalc.reportRefund = function (order, refundAmount, callback) {\n  check(refundAmount, Number);\n  check(callback, Function);\n  const pkgData = taxCalc.getPackageData();\n  const {\n    companyCode\n  } = pkgData.settings.avalara;\n  const company = Shops.findOne(Reaction.getShopId());\n\n  const companyShipping = _filter(company.addressBook, o => o.isShippingDefault)[0];\n\n  const currencyCode = company.currency;\n  const baseUrl = getUrl();\n  const requestUrl = `${baseUrl}transactions/create`;\n  const returnAmount = refundAmount * -1;\n  Promise.await(lazyLoadMoment());\n  const orderDate = moment(order.createdAt);\n  const refundDate = moment();\n  const refundReference = `${order.cartId}:${refundDate}`;\n  const lineItems = {\n    number: \"01\",\n    quantity: 1,\n    amount: returnAmount,\n    description: \"refund\"\n  };\n  const returnInvoice = {\n    companyCode,\n    type: \"ReturnInvoice\",\n    code: refundReference,\n    commit: true,\n    customerCode: order._id,\n    date: refundDate,\n    currencyCode,\n    addresses: {\n      ShipFrom: {\n        line1: companyShipping.address1,\n        line2: companyShipping.address2,\n        city: companyShipping.city,\n        region: companyShipping.region,\n        country: companyShipping.country,\n        postalCode: companyShipping.postal\n      },\n      ShipTo: {\n        line1: order.shipping[0].address.address1,\n        line2: order.shipping[0].address.address2 || \"\",\n        city: order.shipping[0].address.city,\n        region: order.shipping[0].address.region,\n        country: order.shipping[0].address.country || \"US\"\n      }\n    },\n    lines: [lineItems]\n  };\n\n  if (orderDate.diff(refundDate, \"days\") !== 0) {\n    returnInvoice.taxOverride = {\n      type: \"TaxDate\",\n      taxDate: orderDate.format(),\n      reason: \"Refunded after order placed\"\n    };\n  }\n\n  const result = avaPost(requestUrl, {\n    data: returnInvoice\n  });\n  return callback(result.data);\n};\n\nmodule.exportDefault(taxCalc);\nMeteor.methods({\n  \"avalara/addressValidation\": taxCalc.validateAddress,\n  \"avalara/getTaxCodes\": taxCalc.getTaxCodes,\n  \"avalara/testCredentials\": taxCalc.testCredentials,\n  \"avalara/getEntityCodes\": taxCalc.getEntityCodes\n});","map":{"version":3,"sources":["imports/plugins/included/taxes-avalara/server/methods/taxCalc.js"],"names":["_filter","module","watch","require","default","v","_includes","_split","_get","os","accounting","SimpleSchema","Meteor","HTTP","check","Shops","Accounts","TaxCodes","Reaction","Logger","Avalogger","errorDetails","message","type","String","description","optional","ErrorObject","Number","Array","moment","lazyLoadMoment","countriesWithRegions","requiredFields","taxCalc","getPackageData","pkgData","getPackageSettings","getUrl","packageData","mode","settings","avalara","baseUrl","checkConfiguration","isValid","field","msg","warn","error","getAuthData","username","password","auth","getTaxSettings","userId","findOne","_id","parseError","errorData","code","errorCode","response","statusCode","data","details","map","errorDetail","errorObjectContext","newContext","validate","Error","avaGet","requestUrl","options","testCredentials","logObject","undefined","appVersion","getAppVersion","meteorVersion","release","machineName","hostname","avaClient","headers","timeout","requestTimeout","allOptions","Object","assign","enableLogging","request","result","get","parsedError","duration","info","avaPost","split","post","getEntityCodes","calcTaxable","cart","subTotal","item","items","variants","taxable","price","quantity","validateAddress","address","countryList","addressValidation","country","validatedAddress","errors","messages","addressToValidate","line1","address1","city","postalCode","postal","region","address2","line2","content","push","summary","validatedAddresses","length","resultAddress","credentials","companyCode","find","count","call","res","isArray","forEach","getShopId","err","getTaxCodes","cartToSalesOrder","shippingTaxCode","company","companyShipping","addressBook","o","isShippingDefault","currencyCode","currency","cartShipping","getShippingTotal","Promise","await","cartDate","createdAt","format","lineItems","reduce","itemObj","number","itemCode","productId","amount","taxDescription","title","taxCode","salesOrder","customerCode","date","addresses","ShipFrom","ShipTo","shipping","lines","discount","toFixed","line","discounted","estimateCart","callback","Schemas","Cart","Function","orderToSalesInvoice","order","documentType","commitDocuments","orderShipping","orderDate","salesInvoice","commit","recordOrder","reportRefund","refundAmount","returnAmount","refundDate","refundReference","cartId","returnInvoice","diff","taxOverride","taxDate","reason","exportDefault","methods"],"mappings":"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","sourcesContent":["import os from \"os\";\nimport _ from \"lodash\";\nimport accounting from \"accounting-js\";\nimport SimpleSchema from \"simpl-schema\";\nimport { Meteor } from \"meteor/meteor\";\nimport { HTTP } from \"meteor/http\";\nimport { check } from \"meteor/check\";\nimport { Shops, Accounts } from \"/lib/collections\";\nimport { TaxCodes } from \"/imports/plugins/core/taxes/lib/collections\";\nimport { Reaction, Logger } from \"/server/api\";\nimport Avalogger from \"./avalogger\";\n\nconst errorDetails = new SimpleSchema({\n  message: {\n    type: String\n  },\n  description: {\n    type: String,\n    optional: true\n  }\n});\n\n  // Validate that whenever we return an error we return the same format\nconst ErrorObject = new SimpleSchema({\n  \"type\": {\n    type: String\n  },\n  \"errorCode\": {\n    type: Number\n  },\n  \"errorDetails\": {\n    type: Array,\n    optional: true\n  },\n  \"errorDetails.$\": {\n    type: errorDetails,\n    optional: true\n  }\n});\n\nlet moment;\nasync function lazyLoadMoment() {\n  if (moment) return;\n  moment = await import(\"moment\");\n}\n\nconst countriesWithRegions = [\"US\", \"CA\", \"DE\", \"AU\"];\nconst requiredFields = [\"username\", \"password\", \"apiLoginId\", \"companyCode\", \"shippingTaxCode\"];\nconst taxCalc = {};\n\ntaxCalc.getPackageData = function () {\n  const pkgData = Reaction.getPackageSettings(\"taxes-avalara\");\n  return pkgData;\n};\n\n// Private methods\n\n/**\n * @summary Get the root URL for REST calls\n * @returns {String} Base url\n */\nfunction getUrl() {\n  const packageData = taxCalc.getPackageData();\n  const { mode } = packageData.settings.avalara;\n  let baseUrl;\n  if (mode) {\n    baseUrl = \"https://rest.avatax.com/api/v2/\";\n  } else {\n    baseUrl = \"https://sandbox-rest.avatax.com/api/v2/\";\n  }\n  return baseUrl;\n}\n\n/**\n * @summary Verify that we have all required configuration data before attempting to use the API\n * @param {Object} packageData - Package data retrieved from the database\n * @returns {boolean} - isValid Is the current configuration valid\n */\nfunction checkConfiguration(packageData = taxCalc.getPackageData()) {\n  let isValid = true;\n  const settings = _.get(packageData, \"settings.avalara\", {});\n  for (const field of requiredFields) {\n    if (!settings[field]) {\n      const msg = `The Avalara package cannot function unless ${field} is configured`;\n      Logger.warn(msg);\n      Avalogger.error({ error: msg });\n      isValid = false;\n    }\n  }\n  if (!isValid) {\n    Logger.error(\"The Avalara package is not configured correctly. Cannot continue\");\n  }\n  return isValid;\n}\n\n/**\n * @summary Get the auth info to authenticate to REST API\n * @param {Object} packageData - Optionally pass in packageData if we already have it\n * @returns {String} Username/Password string\n */\nfunction getAuthData(packageData = taxCalc.getPackageData()) {\n  if (checkConfiguration(packageData)) {\n    const settings = _.get(packageData, \"settings.avalara\", {});\n    const { username, password } = settings;\n    const auth = `${username}:${password}`;\n    return auth;\n  }\n}\n\n/**\n * @summary Get exempt tax settings to pass to REST API\n * @param {String} userId id of user to find settings\n * @returns {Object} containing exemptCode and customerUsageType\n */\nfunction getTaxSettings(userId) {\n  return _.get(Accounts.findOne({ _id: userId }), \"taxSettings\");\n}\n\n/**\n * @summary: Break Avalara error object into consistent format\n * @param {Object} error The error result from Avalara\n * @returns {Object} Error object with code and errorDetails\n */\nfunction parseError(error) {\n  let errorData;\n  // The Avalara API constantly times out, so handle this special case first\n  if (error && (error.code === \"ETIMEDOUT\" || error.code === \"ESOCKETTIMEDOUT\")) {\n    errorData = {\n      errorCode: 503,\n      type: \"apiFailure\",\n      errorDetails: [{ message: error.message, description: error.description }]\n    };\n  } else if (error && error.response && error.response.statusCode === 401) {\n    // authentification error\n    errorData = {\n      errorCode: 401,\n      type: \"apiFailure\",\n      errorDetails: {\n        message: error.message,\n        description: error.description\n      }\n    };\n  } else if (error && error.response && error.response.statusCode === 400) {\n    // address validation error\n    if (error.response.data.error.code === \"GetTaxError\") {\n      errorData = {\n        errorCode: 300,\n        type: \"addressError\"\n      };\n      errorData.errorDetails = error.response.data.error.details.map((errorDetail) => { // eslint-disable-line\n        return ({ message: errorDetail.message, description: errorDetail.description });\n      });\n    }\n  } else {\n    Logger.error(error, \"Unknown Error\");\n    Avalogger.error(error, \"Unknown error or error format\");\n  }\n  const errorObjectContext = ErrorObject.newContext();\n  // No Generic errors ever\n  errorObjectContext.validate(errorData);\n  if (!errorObjectContext.isValid()) {\n    throw new Meteor.Error(\"invalid-return\", \"Returning invalid Error results\");\n  }\n  return errorData;\n}\n\n\n/**\n * @summary function to get HTTP data and pass in extra Avalara-specific headers\n * @param {String} requestUrl - The URL to make the request to\n * @param {Object} options - An object of other options\n * @param {Boolean} testCredentials - determines skipping of configuration check\n * @returns {Object} Response from call\n */\nfunction avaGet(requestUrl, options = {}, testCredentials = true) {\n  const logObject = {};\n  const pkgData = taxCalc.getPackageData();\n\n  if (testCredentials) {\n    if (!checkConfiguration(pkgData)) {\n      return undefined;\n    }\n  }\n\n  const appVersion = Reaction.getAppVersion();\n  const meteorVersion = _.split(Meteor.release, \"@\")[1];\n  const machineName = os.hostname();\n  const avaClient = `Reaction; ${appVersion}; Meteor HTTP; ${meteorVersion}; ${machineName}`;\n  const headers = {\n    headers: {\n      \"X-Avalara-Client\": avaClient,\n      \"X-Avalara-UID\": \"a0o33000004K8g3\"\n    }\n  };\n  const auth = options.auth || getAuthData();\n  const timeout = { timeout: options.timeout || pkgData.settings.avalara.requestTimeout };\n  const allOptions = Object.assign({}, options, headers, { auth }, timeout);\n  if (pkgData.settings.avalara.enableLogging) {\n    logObject.request = allOptions;\n  }\n\n  let result;\n  try {\n    result = HTTP.get(requestUrl, allOptions);\n  } catch (error) {\n    Logger.error(`Encountered error while calling Avalara API endpoint ${requestUrl}`);\n    Logger.error(error);\n    logObject.error = error;\n    Avalogger.error(logObject);\n    const parsedError = parseError(error);\n    result = { error: parsedError };\n  }\n\n  if (pkgData.settings.avalara.enableLogging) {\n    logObject.duration = _.get(result, \"headers.serverDuration\");\n    logObject.result = result.data;\n    Avalogger.info(logObject);\n  }\n\n  return result;\n}\n\n\n/**\n * @summary to POST HTTP data and pass in extra Avalara-specific headers\n * @param {String} requestUrl - The URL to make the request to\n * @param {Object} options - An object of others options, usually data\n * @returns {Object} Response from call\n */\nfunction avaPost(requestUrl, options) {\n  const logObject = {};\n  const pkgData = taxCalc.getPackageData();\n  // If package is not configured don't bother making an API call\n  if (!checkConfiguration(pkgData)) {\n    return {\n      error: {\n        errorCode: 400,\n        type: \"apiFailure\",\n        errorDetails: {\n          message: \"API is not configured\"\n        }\n      }\n    };\n  }\n  const appVersion = Reaction.getAppVersion();\n  const meteorVersion = Meteor.release.split(\"@\")[1];\n  const machineName = os.hostname();\n  const avaClient = `Reaction; ${appVersion}; Meteor HTTP; ${meteorVersion}; ${machineName}`;\n  const headers = {\n    headers: {\n      \"X-Avalara-Client\": avaClient,\n      \"X-Avalara-UID\": \"a0o33000004K8g3\"\n    }\n  };\n  const auth = { auth: getAuthData() };\n  const timeout = { timeout: pkgData.settings.avalara.requestTimeout };\n  const allOptions = Object.assign({}, options, headers, auth, timeout);\n  if (pkgData.settings.avalara.enableLogging) {\n    logObject.request = allOptions;\n  }\n\n  let result;\n  try {\n    result = HTTP.post(requestUrl, allOptions);\n  } catch (error) {\n    Logger.error(`Encountered error while calling API at ${requestUrl}`);\n    Logger.error(error);\n    logObject.error = error;\n    // whether logging is enabled or not we log out errors\n    Avalogger.error(logObject);\n    const parsedError = parseError(error);\n    result = { error: parsedError };\n  }\n\n  if (pkgData.settings.avalara.enableLogging) {\n    logObject.duration = _.get(result, \"headers.serverDuration\");\n    logObject.result = result.data;\n    Avalogger.info(logObject);\n  }\n\n  return result;\n}\n\n/**\n * @summary Gets the full list of Avalara-supported entity use codes.\n * @returns {Object[]} API response\n */\ntaxCalc.getEntityCodes = function () {\n  if (checkConfiguration()) {\n    const baseUrl = getUrl();\n    const requestUrl = `${baseUrl}definitions/entityusecodes`;\n    const result = avaGet(requestUrl);\n\n    if (result && result.code === \"ETIMEDOUT\") {\n      throw new Meteor.Error(\"request-timeout\", \"Request timed out while populating entity codes.\");\n    }\n\n    return _.get(result, \"data.value\", []);\n  }\n  throw new Meteor.Error(\"bad-configuration\", \"Avalara package is enabled, but is not properly configured\");\n};\n\n// API Methods\n\n/**\n * @summary Calculate the taxable subtotal for a cart\n * @param {Cart} cart - Cart to calculate subtotal for\n * @returns {Number} Taxable subtotal\n */\ntaxCalc.calcTaxable = function (cart) {\n  let subTotal = 0;\n  for (const item of cart.items) {\n    if (item.variants.taxable) {\n      subTotal += (item.variants.price * item.quantity);\n    }\n  }\n  return subTotal;\n};\n\n/**\n * @summary Validate a particular address\n * @param {Object} address Address to validate\n * @returns {Object} The validated result\n */\ntaxCalc.validateAddress = function (address) {\n  check(address, Object);\n\n  const packageData = taxCalc.getPackageData();\n  const { countryList } = packageData.settings.addressValidation;\n\n  if (!_.includes(countryList, address.country)) {\n    // if this is a country selected for validation, proceed\n    // else use current address as response\n    return { validatedAddress: address, errors: [] };\n  }\n\n  let messages;\n  let validatedAddress = \"\"; // set default as falsy value\n  const errors = [];\n  const addressToValidate = {\n    line1: address.address1,\n    city: address.city,\n    postalCode: address.postal,\n    country: address.country\n  };\n\n  if (_.includes(countriesWithRegions, address.country)) {\n    // if this is a country with regions, pass in region\n    addressToValidate.region = address.region;\n  }\n  if (address.address2) {\n    addressToValidate.line2 = address.address2;\n  }\n  const baseUrl = getUrl();\n  const requestUrl = `${baseUrl}addresses/resolve`;\n  const result = avaPost(requestUrl, { data: addressToValidate });\n  // Handle errors where we don't get back an address\n  if (result.error && result.error.type) {\n    if (result.error.type === \"apiError\") {\n      // If we have a problem with the API there's no reason to tell the customer\n      // so let's consider this unvalidated but move along\n      Logger.error(\"API error, ignoring address validation\");\n    }\n\n    if (result.error.type === \"addressError\") {\n      // We received a validation error so we need somehow pass this up to the client\n      Logger.info(\"Address Validation Error\");\n      // package up errors\n      return { validatedAddress: {}, errors: [result.error] };\n    }\n  }\n  const content = result.data;\n  if (content && content.messages) {\n    ({ messages } = content);\n  }\n  if (messages) {\n    for (const message of messages) {\n      errors.push({ summary: message.summary, details: message.details });\n    }\n  }\n\n  if (result && result.data && result.data.validatedAddresses.length !== 0) {\n    const resultAddress = result.data.validatedAddresses[0];\n    validatedAddress = {\n      address1: resultAddress.line1,\n      city: resultAddress.city,\n      region: resultAddress.region,\n      postal: resultAddress.postalCode,\n      country: resultAddress.country\n    };\n    if (resultAddress.line2) {\n      validatedAddress.address2 = resultAddress.line2;\n    }\n  }\n  return { validatedAddress, errors };\n};\n\n/**\n * @summary Tests supplied Avalara credentials by calling company endpoint\n * @param {Object} credentials callback Callback function for asynchronous execution\n * @param {Boolean} testCredentials To be set as false so avaGet skips config check\n * @returns {Object} Object containing \"statusCode\" on success, empty response on error\n */\ntaxCalc.testCredentials = function (credentials, testCredentials = false) {\n  check(credentials, Object);\n\n  const baseUrl = getUrl();\n  const auth = `${credentials.username}:${credentials.password}`;\n  const requestUrl = `${baseUrl}companies/${credentials.companyCode}/transactions`;\n  const result = avaGet(requestUrl, { auth, timeout: credentials.requestTimeout }, testCredentials);\n\n  if (result && result.code === \"ETIMEDOUT\") {\n    throw new Meteor.Error(\"request-timeout\", \"Request Timed out. Increase your timeout settings\");\n  }\n\n  if (result.statusCode === 200) {\n    if (TaxCodes.find({}).count() === 0) {\n      Meteor.call(\"avalara/getTaxCodes\", (error, res) => {\n        if (error) {\n          if (typeof error === \"object\") {\n            Meteor.call(\"logging/logError\", \"avalara\", error);\n          } else {\n            Meteor.call(\"logging/logError\", \"avalara\", { error });\n          }\n        } else if (res && Array.isArray(res)) {\n          res.forEach((code) => {\n            Meteor.call(\"taxes/insertTaxCodes\", Reaction.getShopId(), code, \"taxes-avalara\", (err) => {\n              if (err) {\n                throw new Meteor.Error(\"error-occurred\", \"Error populating TaxCodes collection\", err);\n              }\n            });\n          });\n        }\n      });\n    }\n  }\n\n  return { statusCode: result.statusCode };\n};\n\n/**\n * @summary get Avalara Tax Codes\n * @returns {Array} An array of Tax code objects\n */\ntaxCalc.getTaxCodes = function () {\n  if (checkConfiguration()) {\n    const baseUrl = getUrl();\n    const requestUrl = `${baseUrl}definitions/taxcodes`;\n    const result = avaGet(requestUrl);\n    return _.get(result, \"data.value\", []);\n  }\n  throw new Meteor.Error(\"bad-configuration\", \"Avalara Tax package is enabled but not properly configured\");\n};\n\n/**\n * @summary Translate RC cart into format for submission\n * @param {Object} cart RC cart to send for tax estimate\n * @returns {Object} SalesOrder in Avalara format\n */\nfunction cartToSalesOrder(cart) {\n  const pkgData = taxCalc.getPackageData();\n  const { companyCode, shippingTaxCode } = pkgData.settings.avalara;\n  const company = Shops.findOne(Reaction.getShopId());\n  const companyShipping = _.filter(company.addressBook, (o) => o.isShippingDefault)[0];\n  const currencyCode = company.currency;\n  const cartShipping = cart.getShippingTotal();\n  Promise.await(lazyLoadMoment());\n  const cartDate = moment(cart.createdAt).format();\n  let lineItems = [];\n  if (cart.items) {\n    lineItems = cart.items.reduce((items, item) => {\n      if (item.variants.taxable) {\n        const itemObj = {\n          number: item._id,\n          itemCode: item.productId,\n          quantity: item.quantity,\n          amount: item.variants.price * item.quantity,\n          description: item.taxDescription || item.title,\n          taxCode: item.variants.taxCode\n        };\n        items.push(itemObj);\n      }\n      return items;\n    }, []);\n    if (cartShipping) {\n      lineItems.push({\n        number: \"shipping\",\n        itemCode: \"shipping\",\n        quantity: 1,\n        amount: cartShipping,\n        description: \"Shipping\",\n        taxCode: shippingTaxCode\n      });\n    }\n  }\n\n  const salesOrder = {\n    companyCode,\n    type: \"SalesOrder\",\n    customerCode: cart.userId,\n    date: cartDate,\n    currencyCode,\n    addresses: {\n      ShipFrom: {\n        line1: companyShipping.address1,\n        line2: companyShipping.address2,\n        city: companyShipping.city,\n        region: companyShipping.region,\n        country: companyShipping.country,\n        postalCode: companyShipping.postal\n      },\n      ShipTo: {\n        line1: cart.shipping[0].address.address1,\n        line2: cart.shipping[0].address.address2 || \"\",\n        city: cart.shipping[0].address.city,\n        region: cart.shipping[0].address.region,\n        country: cart.shipping[0].address.country || \"US\"\n      }\n    },\n    lines: lineItems\n  };\n\n  // current \"coupon code\" discount are based at the cart level, and every iten has it's\n  // discounted property set to true.\n  if (cart.discount) {\n    salesOrder.discount = accounting.toFixed(cart.discount, 2);\n    for (const line of salesOrder.lines) {\n      if (line.itemCode !== \"shipping\") {\n        line.discounted = true;\n      }\n    }\n  }\n  return salesOrder;\n}\n\n/**\n * @summary Submit cart for tax calculation\n * @param {Cart} cart Cart object for estimation\n * @param {Function} callback callback when using async version\n * @returns {Object} result Result of SalesOrder call\n */\ntaxCalc.estimateCart = function (cart, callback) {\n  Reaction.Schemas.Cart.validate(cart);\n  check(callback, Function);\n\n  if (cart.items && cart.shipping && cart.shipping[0] && cart.shipping[0].address) {\n    const salesOrder = Object.assign({}, cartToSalesOrder(cart), getTaxSettings(cart.userId));\n    const baseUrl = getUrl();\n    const requestUrl = `${baseUrl}transactions/create`;\n    const result = avaPost(requestUrl, { data: salesOrder });\n    if (!result.error) {\n      return callback(result.data);\n    }\n    return callback(result);\n  }\n  return callback({\n    error: {\n      errorCode: 300\n    }\n  });\n};\n\n/**\n * @summary Translate RC order into format for final submission\n * @param {Object} order RC order to send for tax reporting\n * @returns {Object} SalesOrder in Avalara format\n */\nfunction orderToSalesInvoice(order) {\n  let documentType;\n  const pkgData = taxCalc.getPackageData();\n  const { companyCode, shippingTaxCode, commitDocuments } = pkgData.settings.avalara;\n  if (commitDocuments) {\n    documentType = \"SalesInvoice\";\n  } else {\n    documentType = \"SalesOrder\";\n  }\n  const company = Shops.findOne(Reaction.getShopId());\n  const companyShipping = _.filter(company.addressBook, (o) => o.isShippingDefault)[0];\n  const currencyCode = company.currency;\n  const orderShipping = order.getShippingTotal();\n  Promise.await(lazyLoadMoment());\n  const orderDate = moment(order.createdAt).format();\n  const lineItems = order.items.reduce((items, item) => {\n    if (item.variants.taxable) {\n      const itemObj = {\n        number: item._id,\n        itemCode: item.productId,\n        quantity: item.quantity,\n        amount: item.variants.price * item.quantity,\n        description: item.taxDescription || item.title,\n        taxCode: item.variants.taxCode\n      };\n      items.push(itemObj);\n    }\n    return items;\n  }, []);\n\n  if (orderShipping) {\n    lineItems.push({\n      number: \"shipping\",\n      itemCode: \"shipping\",\n      quantity: 1,\n      amount: orderShipping,\n      description: \"Shipping\",\n      taxCode: shippingTaxCode\n    });\n  }\n\n  const salesInvoice = {\n    companyCode,\n    type: documentType,\n    commit: commitDocuments,\n    code: order._id,\n    customerCode: order.userId,\n    date: orderDate,\n    currencyCode,\n    addresses: {\n      ShipFrom: {\n        line1: companyShipping.address1,\n        line2: companyShipping.address2,\n        city: companyShipping.city,\n        region: companyShipping.region,\n        country: companyShipping.country,\n        postalCode: companyShipping.postal\n      },\n      ShipTo: {\n        line1: order.shipping[0].address.address1,\n        line2: order.shipping[0].address.address2 || \"\",\n        city: order.shipping[0].address.city,\n        region: order.shipping[0].address.region,\n        country: order.shipping[0].address.country || \"US\"\n      }\n    },\n    lines: lineItems\n  };\n\n  if (order.discount) {\n    salesInvoice.discount = accounting.toFixed(order.discount, 2);\n    for (const line of salesInvoice.lines) {\n      if (line.itemCode !== \"shipping\") {\n        line.discounted = true;\n      }\n    }\n  }\n  return salesInvoice;\n}\n\n/**\n * @summary Submit order for tax reporting\n * @param {Order} order Order object for submission\n * @param {Function} callback callback when using async version\n * @returns {Object} result Result of SalesInvoice call\n */\ntaxCalc.recordOrder = function (order, callback) {\n  check(callback, Function);\n  // unlike the other functions, we expect this to always be called asynchronously\n  if (order && order.shipping && order.shipping[0].address) {\n    const salesOrder = Object.assign({}, orderToSalesInvoice(order), getTaxSettings(order.userId));\n    const baseUrl = getUrl();\n    const requestUrl = `${baseUrl}transactions/create`;\n    try {\n      const result = avaPost(requestUrl, { data: salesOrder });\n      return callback(result.data);\n    } catch (error) {\n      Logger.error(\"Encountered error while recording order to Avalara\");\n      Logger.error(error);\n    }\n  }\n};\n\n/**\n * @summary Report refund to Avalara\n * @param {Order} order - The original order the refund was against\n * @param {Number} refundAmount - Amount to be refunded\n * @param {Function} callback - Callback\n * @returns {Object} Results from transaction call\n */\ntaxCalc.reportRefund = function (order, refundAmount, callback) {\n  check(refundAmount, Number);\n  check(callback, Function);\n  const pkgData = taxCalc.getPackageData();\n  const { companyCode } = pkgData.settings.avalara;\n  const company = Shops.findOne(Reaction.getShopId());\n  const companyShipping = _.filter(company.addressBook, (o) => o.isShippingDefault)[0];\n  const currencyCode = company.currency;\n  const baseUrl = getUrl();\n  const requestUrl = `${baseUrl}transactions/create`;\n  const returnAmount = refundAmount * -1;\n  Promise.await(lazyLoadMoment());\n  const orderDate = moment(order.createdAt);\n  const refundDate = moment();\n  const refundReference = `${order.cartId}:${refundDate}`;\n  const lineItems = {\n    number: \"01\",\n    quantity: 1,\n    amount: returnAmount,\n    description: \"refund\"\n  };\n  const returnInvoice = {\n    companyCode,\n    type: \"ReturnInvoice\",\n    code: refundReference,\n    commit: true,\n    customerCode: order._id,\n    date: refundDate,\n    currencyCode,\n    addresses: {\n      ShipFrom: {\n        line1: companyShipping.address1,\n        line2: companyShipping.address2,\n        city: companyShipping.city,\n        region: companyShipping.region,\n        country: companyShipping.country,\n        postalCode: companyShipping.postal\n      },\n      ShipTo: {\n        line1: order.shipping[0].address.address1,\n        line2: order.shipping[0].address.address2 || \"\",\n        city: order.shipping[0].address.city,\n        region: order.shipping[0].address.region,\n        country: order.shipping[0].address.country || \"US\"\n      }\n    },\n    lines: [lineItems]\n  };\n\n  if (orderDate.diff(refundDate, \"days\") !== 0) {\n    returnInvoice.taxOverride = {\n      type: \"TaxDate\",\n      taxDate: orderDate.format(),\n      reason: \"Refunded after order placed\"\n    };\n  }\n\n  const result = avaPost(requestUrl, { data: returnInvoice });\n  return callback(result.data);\n};\n\nexport default taxCalc;\n\nMeteor.methods({\n  \"avalara/addressValidation\": taxCalc.validateAddress,\n  \"avalara/getTaxCodes\": taxCalc.getTaxCodes,\n  \"avalara/testCredentials\": taxCalc.testCredentials,\n  \"avalara/getEntityCodes\": taxCalc.getEntityCodes\n});\n"]},"sourceType":"script","hash":"ecc52be49e8920395aee49419613fe55ba71bd98"}
