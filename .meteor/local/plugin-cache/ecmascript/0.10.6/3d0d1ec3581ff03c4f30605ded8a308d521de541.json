{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$1$2","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"ast":true,"babelrc":false,"sourceFileName":"server/api/geocoder.js","filename":"server/api/geocoder.js","sourceMaps":true,"envName":"development","cwd":"/Users/estebandev/test-knowledge","passPerPreset":false,"presets":[],"parserOpts":{"sourceType":"module","sourceFileName":"server/api/geocoder.js","plugins":["jsx","jsx","flow","flow","objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties"]},"generatorOpts":{"filename":"server/api/geocoder.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"server/api/geocoder.js"}},"code":"let _extend;\n\nmodule.watch(require(\"lodash/extend\"), {\n  default(v) {\n    _extend = v;\n  }\n\n}, 0);\nlet HTTP;\nmodule.watch(require(\"meteor/http\"), {\n  HTTP(v) {\n    HTTP = v;\n  }\n\n}, 1);\nlet Meteor;\nmodule.watch(require(\"meteor/meteor\"), {\n  Meteor(v) {\n    Meteor = v;\n  }\n\n}, 2);\nlet Packages;\nmodule.watch(require(\"../../lib/collections\"), {\n  Packages(v) {\n    Packages = v;\n  }\n\n}, 3);\nlet Logger, Reaction;\nmodule.watch(require(\"./index\"), {\n  Logger(v) {\n    Logger = v;\n  },\n\n  Reaction(v) {\n    Reaction = v;\n  }\n\n}, 4);\n\n/**\n * meteor-geocoder\n * modifed for reaction core.\n *\n * https://github.com/aldeed/meteor-geocoder\n * The MIT License (MIT)\n * Copyright (c) 2014 Eric Dobbertin\n */\n//\n// init geocoder\nfunction GeoCoder(options) {\n  let extra;\n  const self = this; // fetch shop settings for api auth credentials\n\n  const shopSettings = Packages.findOne({\n    shopId: Reaction.getShopId(),\n    name: \"core\"\n  }, {\n    fields: {\n      settings: 1\n    }\n  });\n\n  if (shopSettings) {\n    if (shopSettings.settings.google) {\n      extra = {\n        clientId: shopSettings.settings.google.clientId,\n        apiKey: shopSettings.settings.google.apiKey\n      };\n    }\n  }\n\n  self.options = _extend({\n    geocoderProvider: \"google\",\n    httpAdapter: \"https\",\n    extra\n  }, options || {});\n}\n\nfunction gc(address, options, callback) {\n  const g = require(\"node-geocoder\")(options.geocoderProvider, options.httpAdapter, options.extra);\n\n  g.geocode(address, callback);\n}\n\nGeoCoder.prototype.geocode = function geoCoderGeocode(address, callback) {\n  let geoCallback = callback;\n  let geoAddress = address;\n\n  if (geoCallback) {\n    geoCallback = Meteor.bindEnvironment(geoCallback, error => {\n      if (error) throw error;\n    });\n    gc(geoAddress, this.options, geoCallback);\n  } else {\n    geoAddress = Meteor.wrapAsync(gc)(geoAddress, this.options);\n    return geoAddress[0];\n  }\n};\n\nfunction rv(lat, lng, options, callback) {\n  const g = require(\"node-geocoder\")(options.geocoderProvider, options.httpAdapter, options.extra);\n\n  g.reverse({\n    lat,\n    lon: lng\n  }, callback);\n}\n\nGeoCoder.prototype.reverse = function geoCoderReverse(lat, lng, callback) {\n  let geoCallback = callback;\n\n  if (geoCallback) {\n    geoCallback = Meteor.bindEnvironment(geoCallback, error => {\n      if (error) throw error;\n    });\n    rv(lat, lng, this.options, geoCallback);\n  } else {\n    try {\n      const address = Meteor.wrapAsync(rv)(lat, lng, this.options);\n      return address[0];\n    } catch (_error) {\n      return {\n        latitude: null,\n        longitude: null,\n        country: \"United States\",\n        city: null,\n        state: null,\n        stateCode: null,\n        zipcode: null,\n        streetName: null,\n        streetNumber: null,\n        countryCode: \"US\"\n      };\n    }\n  }\n};\n\nfunction gi(address, callback) {\n  let lookupAddress = address; // short term solution to an haproxy ssl cert installation issue\n\n  process.env.NODE_TLS_REJECT_UNAUTHORIZED = 0; // if we're local, let's let freegeoip guess.\n\n  if (lookupAddress === \"127.0.0.1\" || lookupAddress === null) {\n    lookupAddress = \"\";\n  } // calls a private reaction hosted version of freegeoip\n\n\n  HTTP.call(\"GET\", `https://geo.getreaction.io/json/${lookupAddress}`, callback);\n}\n\nGeoCoder.prototype.geoip = function geoCoderGeocode(address, callback) {\n  let geoCallback = callback;\n  let geoAddress = address;\n\n  if (geoCallback) {\n    geoCallback = Meteor.bindEnvironment(geoCallback, error => {\n      if (error) throw error;\n    });\n    gi(geoAddress, this.options, geoCallback);\n  } else {\n    try {\n      geoAddress = Meteor.wrapAsync(gi)(geoAddress);\n      return geoAddress.data;\n    } catch (error) {\n      Logger.warn(\"shop/getLocale geoip lookup failure\", error);\n      return {};\n    }\n  }\n};\n\nmodule.exportDefault(GeoCoder);","map":{"version":3,"sources":["server/api/geocoder.js"],"names":["_extend","module","watch","require","default","v","HTTP","Meteor","Packages","Logger","Reaction","GeoCoder","options","extra","self","shopSettings","findOne","shopId","getShopId","name","fields","settings","google","clientId","apiKey","geocoderProvider","httpAdapter","gc","address","callback","g","geocode","prototype","geoCoderGeocode","geoCallback","geoAddress","bindEnvironment","error","wrapAsync","rv","lat","lng","reverse","lon","geoCoderReverse","_error","latitude","longitude","country","city","state","stateCode","zipcode","streetName","streetNumber","countryCode","gi","lookupAddress","process","env","NODE_TLS_REJECT_UNAUTHORIZED","call","geoip","data","warn","exportDefault"],"mappings":"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","sourcesContent":["import _ from \"lodash\";\nimport { HTTP } from \"meteor/http\";\nimport { Meteor } from \"meteor/meteor\";\nimport { Packages } from \"/lib/collections\";\nimport { Logger, Reaction } from \"/server/api\";\n\n/**\n * meteor-geocoder\n * modifed for reaction core.\n *\n * https://github.com/aldeed/meteor-geocoder\n * The MIT License (MIT)\n * Copyright (c) 2014 Eric Dobbertin\n */\n\n//\n// init geocoder\nfunction GeoCoder(options) {\n  let extra;\n  const self = this;\n  // fetch shop settings for api auth credentials\n  const shopSettings = Packages.findOne({\n    shopId: Reaction.getShopId(),\n    name: \"core\"\n  }, {\n    fields: {\n      settings: 1\n    }\n  });\n\n  if (shopSettings) {\n    if (shopSettings.settings.google) {\n      extra = {\n        clientId: shopSettings.settings.google.clientId,\n        apiKey: shopSettings.settings.google.apiKey\n      };\n    }\n  }\n\n  self.options = _.extend({\n    geocoderProvider: \"google\",\n    httpAdapter: \"https\",\n    extra\n  }, options || {});\n}\n\nfunction gc(address, options, callback) {\n  const g = require(\"node-geocoder\")(\n    options.geocoderProvider, options.httpAdapter,\n    options.extra\n  );\n  g.geocode(address, callback);\n}\n\nGeoCoder.prototype.geocode = function geoCoderGeocode(address, callback) {\n  let geoCallback = callback;\n  let geoAddress = address;\n  if (geoCallback) {\n    geoCallback = Meteor.bindEnvironment(geoCallback, (error) => {\n      if (error) throw error;\n    });\n    gc(geoAddress, this.options, geoCallback);\n  } else {\n    geoAddress = Meteor.wrapAsync(gc)(geoAddress, this.options);\n    return geoAddress[0];\n  }\n};\n\nfunction rv(lat, lng, options, callback) {\n  const g = require(\"node-geocoder\")(\n    options.geocoderProvider, options.httpAdapter,\n    options.extra\n  );\n  g.reverse({\n    lat,\n    lon: lng\n  }, callback);\n}\n\nGeoCoder.prototype.reverse = function geoCoderReverse(lat, lng, callback) {\n  let geoCallback = callback;\n  if (geoCallback) {\n    geoCallback = Meteor.bindEnvironment(geoCallback, (error) => {\n      if (error) throw error;\n    });\n    rv(lat, lng, this.options, geoCallback);\n  } else {\n    try {\n      const address = Meteor.wrapAsync(rv)(lat, lng, this.options);\n      return address[0];\n    } catch (_error) {\n      return {\n        latitude: null,\n        longitude: null,\n        country: \"United States\",\n        city: null,\n        state: null,\n        stateCode: null,\n        zipcode: null,\n        streetName: null,\n        streetNumber: null,\n        countryCode: \"US\"\n      };\n    }\n  }\n};\n\nfunction gi(address, callback) {\n  let lookupAddress = address;\n  // short term solution to an haproxy ssl cert installation issue\n  process.env.NODE_TLS_REJECT_UNAUTHORIZED = 0;\n  // if we're local, let's let freegeoip guess.\n  if (lookupAddress === \"127.0.0.1\" || lookupAddress === null) {\n    lookupAddress = \"\";\n  }\n  // calls a private reaction hosted version of freegeoip\n  HTTP.call(\"GET\", `https://geo.getreaction.io/json/${lookupAddress}`, callback);\n}\n\nGeoCoder.prototype.geoip = function geoCoderGeocode(address, callback) {\n  let geoCallback = callback;\n  let geoAddress = address;\n  if (geoCallback) {\n    geoCallback = Meteor.bindEnvironment(geoCallback, (error) => {\n      if (error) throw error;\n    });\n    gi(geoAddress, this.options, geoCallback);\n  } else {\n    try {\n      geoAddress = Meteor.wrapAsync(gi)(geoAddress);\n      return geoAddress.data;\n    } catch (error) {\n      Logger.warn(\"shop/getLocale geoip lookup failure\", error);\n      return {};\n    }\n  }\n};\n\nexport default GeoCoder;\n"]},"sourceType":"script","hash":"3d0d1ec3581ff03c4f30605ded8a308d521de541"}
