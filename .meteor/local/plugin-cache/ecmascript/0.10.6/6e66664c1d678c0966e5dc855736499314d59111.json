{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$1$2","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"ast":true,"babelrc":false,"sourceFileName":"server/methods/core/shipping.js","filename":"server/methods/core/shipping.js","sourceMaps":true,"envName":"development","cwd":"/Users/estebandev/test-knowledge","passPerPreset":false,"presets":[],"parserOpts":{"sourceType":"module","sourceFileName":"server/methods/core/shipping.js","plugins":["jsx","jsx","flow","flow","objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties"]},"generatorOpts":{"filename":"server/methods/core/shipping.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"server/methods/core/shipping.js"}},"code":"module.export({\n  methods: () => methods\n});\nlet Meteor;\nmodule.watch(require(\"meteor/meteor\"), {\n  Meteor(v) {\n    Meteor = v;\n  }\n\n}, 0);\nlet check;\nmodule.watch(require(\"meteor/check\"), {\n  check(v) {\n    check = v;\n  }\n\n}, 1);\nlet Cart, Accounts;\nmodule.watch(require(\"../../../lib/collections\"), {\n  Cart(v) {\n    Cart = v;\n  },\n\n  Accounts(v) {\n    Accounts = v;\n  }\n\n}, 2);\nlet Logger, Hooks;\nmodule.watch(require(\"../../api\"), {\n  Logger(v) {\n    Logger = v;\n  },\n\n  Hooks(v) {\n    Hooks = v;\n  }\n\n}, 3);\nlet CartSchema;\nmodule.watch(require(\"../../../lib/collections/schemas\"), {\n  Cart(v) {\n    CartSchema = v;\n  }\n\n}, 4);\n\n/**\n * @file Methods for Shipping - methods typically used for checkout (shipping, taxes, etc).\n * Run these methods using `Meteor.call()`.\n *\n *\n * @namespace Methods/Shipping\n*/\n\n/**\n * @name createShipmentQuotes\n * @private\n * @summary Returns object with shipping object with `requestStatus` as `pending`\n * @param  {String} cartId ID\n * @param  {String} shopId ID\n * @param  {Object} rates  Shipping rates\n * @return {Object}        Update object with `shipping` object.\n */\nfunction createShipmentQuotes(cartId, shopId, rates) {\n  let update = {\n    $push: {\n      shipping: {\n        shopId,\n        shipmentQuotes: [],\n        shipmentQuotesQueryStatus: {\n          requestStatus: \"pending\"\n        }\n      }\n    }\n  };\n\n  try {\n    Cart.update({\n      _id: cartId\n    }, update);\n  } catch (error) {\n    Logger.warn(`Error in setting shipping query status to \"pending\" for ${cartId}`, error);\n    throw error;\n  } // Calculate discounts\n\n\n  Hooks.Events.run(\"afterCartUpdateCalculateDiscount\", cartId);\n  Logger.debug(`Success in setting shipping query status to \"pending\" for ${cartId}`, rates);\n\n  if (rates.length === 1 && rates[0].requestStatus === \"error\") {\n    const errorDetails = rates[0];\n    update = {\n      $set: {\n        \"shipping.$.shipmentQuotes\": [],\n        \"shipping.$.shipmentQuotesQueryStatus\": {\n          requestStatus: errorDetails.requestStatus,\n          shippingProvider: errorDetails.shippingProvider,\n          message: errorDetails.message\n        }\n      }\n    };\n  }\n\n  if (rates.length > 0 && rates[0].requestStatus === undefined) {\n    update = {\n      $set: {\n        \"shipping.$.shipmentQuotes\": rates,\n        \"shipping.$.shipmentQuotesQueryStatus\": {\n          requestStatus: \"success\",\n          numOfShippingMethodsFound: rates.length\n        }\n      }\n    };\n  }\n\n  return update;\n}\n/**\n * @name pruneShippingRecordsByShop\n * @private\n * @summary if we have items in the cart, ensure that we only have shipping records\n * for shops currently represented in the cart\n * @param {Object} cart - The cart to operate on\n * @returns {undefined} undefined\n * @private\n */\n\n\nfunction pruneShippingRecordsByShop(cart) {\n  if (cart.items) {\n    const cartId = cart._id;\n    const itemsByShop = cart.getItemsByShop();\n    const shops = Object.keys(itemsByShop);\n\n    if (shops.length > 0 && cart.items.length > 0) {\n      Cart.update({\n        _id: cartId\n      }, {\n        $pull: {\n          shipping: {\n            shopId: {\n              $nin: shops\n            }\n          }\n        }\n      });\n    } else {\n      Cart.update({\n        _id: cartId\n      }, {\n        $unset: {\n          shipping: \"\"\n        }\n      });\n    } // Calculate discounts\n\n\n    Hooks.Events.run(\"afterCartUpdateCalculateDiscount\", cartId);\n  }\n}\n/**\n * @name normalizeAddresses\n * @summary - When adding shipping records, ensure that each record has an address\n * @param {Object} cart - The Cart object we need to operate on\n * @returns {undefined} undefined\n * @private\n */\n\n\nfunction normalizeAddresses(cart) {\n  if (cart.shipping && cart.shipping.length > 0) {\n    const {\n      shipping\n    } = cart;\n    const cartId = cart._id;\n    let address; // we can only have one address so whatever was the last assigned\n\n    shipping.forEach(shippingRecord => {\n      if (shippingRecord.address) {\n        ({\n          address\n        } = shippingRecord);\n      }\n    });\n    const shopIds = Object.keys(cart.getItemsByShop());\n    shopIds.forEach(shopId => {\n      const selector = {\n        \"_id\": cartId,\n        \"shipping.shopId\": shopId\n      };\n      const update = {\n        $set: {\n          \"shipping.$.address\": address\n        }\n      };\n      Cart.update(selector, update); // Calculate discounts\n\n      Hooks.Events.run(\"afterCartUpdateCalculateDiscount\", cartId);\n    });\n  }\n}\n/**\n * @name updateShipmentQuotes\n * @param  {String} cartId   Cart ID\n * @param  {Object} rates    Rate object\n * @param  {Object} selector Selector\n * @return {Object}          Update\n * @private\n */\n\n\nfunction updateShipmentQuotes(cartId, rates, selector) {\n  let update = {\n    $set: {\n      \"shipping.$.shipmentQuotesQueryStatus\": {\n        requestStatus: \"pending\"\n      }\n    }\n  };\n\n  try {\n    Cart.update(selector, update);\n  } catch (error) {\n    Logger.warn(`Error in setting shipping query status to \"pending\" for ${cartId}`, error);\n    throw error;\n  } // Calculate discounts\n\n\n  Hooks.Events.run(\"afterCartUpdateCalculateDiscount\", cartId);\n  Logger.debug(`Success in setting shipping query status to \"pending\" for ${cartId}`, rates);\n\n  if (rates.length === 1 && rates[0].requestStatus === \"error\") {\n    const errorDetails = rates[0];\n    update = {\n      $set: {\n        \"shipping.$.shipmentQuotes\": [],\n        \"shipping.$.shipmentQuotesQueryStatus\": {\n          requestStatus: errorDetails.requestStatus,\n          shippingProvider: errorDetails.shippingProvider,\n          message: errorDetails.message\n        }\n      }\n    };\n  }\n\n  if (rates.length > 0 && rates[0].requestStatus === undefined) {\n    update = {\n      $set: {\n        \"shipping.$.shipmentQuotes\": rates,\n        \"shipping.$.shipmentQuotesQueryStatus\": {\n          requestStatus: \"success\",\n          numOfShippingMethodsFound: rates.length\n        }\n      }\n    };\n  }\n\n  return update;\n}\n/**\n * @name updateShippingRecordByShop\n * @param  {Object} cart  Cart object\n * @param  {Object} rates Rate object\n * @return {null}\n * @private\n */\n\n\nfunction updateShippingRecordByShop(cart, rates) {\n  const cartId = cart._id;\n  const itemsByShop = cart.getItemsByShop();\n  const shops = Object.keys(itemsByShop);\n  shops.forEach(shopId => {\n    const selector = {\n      \"_id\": cartId,\n      \"shipping.shopId\": shopId\n    };\n    const cartForShipping = Cart.findOne(selector); // we may have added a new shop since the last time we did this, if so we need to add a new record\n\n    let update;\n\n    if (cartForShipping) {\n      update = updateShipmentQuotes(cartId, rates, selector);\n    } else {\n      update = createShipmentQuotes(cartId, shopId, rates);\n    }\n\n    try {\n      Cart.update(selector, update);\n    } catch (error) {\n      Logger.warn(`Error updating rates for cart ${cartId}`, error);\n      throw error;\n    } // Calculate discounts\n\n\n    Hooks.Events.run(\"afterCartUpdateCalculateDiscount\", cartId);\n    Logger.debug(`Success updating rates for cart ${cartId}`, rates);\n  });\n  pruneShippingRecordsByShop(cart);\n  normalizeAddresses(cart);\n}\n/**\n * @name getDefaultAddress\n * @param  {Object} cart [description]\n * @return {Object} address\n * @private\n */\n\n\nfunction getDefaultAddress(cart) {\n  const {\n    userId\n  } = cart;\n  const account = Accounts.findOne(userId);\n\n  if (account && account.profile && account.profile.addressBook) {\n    const address = account.profile.addressBook.find(addressEntry => addressEntry.isShippingDefault === true);\n    return address;\n  }\n}\n/**\n * @name addAddresses\n * @summary Add the default address to the cart\n * @param {Object} cart - the cart to modify\n * @returns {undefined}\n * @private\n */\n\n\nfunction addAddresses(cart) {\n  const address = getDefaultAddress(cart);\n\n  if (address) {\n    const shopIds = Object.keys(cart.getItemsByShop());\n    shopIds.forEach(shopId => {\n      Cart.update({\n        _id: cart._id\n      }, {\n        $push: {\n          shipping: {\n            shopId,\n            address\n          }\n        }\n      });\n    });\n  }\n}\n\nconst methods = {\n  /**\n   * @name shipping/updateShipmentQuotes\n   * @method\n   * @memberof Methods/Shipping\n   * @summary Gets shipping rates and updates the users cart methods\n   * @todo Add orderId argument/fallback\n   * @param {String} cartId - cartId\n   * @return {undefined}\n   */\n  \"shipping/updateShipmentQuotes\"(cartId) {\n    check(cartId, String);\n\n    if (!cartId) {\n      return [];\n    }\n\n    this.unblock();\n    let cart = Cart.findOne(cartId);\n    CartSchema.validate(cart);\n\n    if (cart) {\n      if (!cart.shipping || cart.shipping.length === 0) {\n        addAddresses(cart);\n        cart = Cart.findOne(cartId);\n      }\n\n      const rates = Meteor.call(\"shipping/getShippingRates\", cart);\n      updateShippingRecordByShop(cart, rates);\n    }\n  },\n\n  /**\n   * @name shipping/getShippingRates\n   * @method\n   * @memberof Methods/Shipping\n   * @summary Just gets rates, without updating anything\n   * @param {Object} cart - cart object\n   * @return {Array} return updated rates in cart\n   */\n  \"shipping/getShippingRates\"(cart) {\n    CartSchema.validate(cart);\n    const rates = [];\n    const retrialTargets = []; // must have items to calculate shipping\n\n    if (!cart.items || !cart.items.length) {\n      return rates;\n    } // hooks for other shipping rate events\n    // all callbacks should return rates\n\n\n    Hooks.Events.run(\"onGetShippingRates\", [rates, retrialTargets], cart); // Try once more.\n\n    if (retrialTargets.length > 0) {\n      Hooks.Events.run(\"onGetShippingRates\", [rates, retrialTargets], cart);\n\n      if (retrialTargets.length > 0) {\n        Logger.warn(\"Failed to get shipping methods from these packages:\", retrialTargets);\n      }\n    }\n\n    let newRates = rates.filter(({\n      requestStatus\n    }) => requestStatus !== \"error\");\n\n    if (newRates.length === 0) {\n      newRates = [{\n        requestStatus: \"error\",\n        shippingProvider: \"all\",\n        message: \"All requests for shipping methods failed.\"\n      }];\n    }\n\n    Logger.debug(\"getShippingRates returning rates\", rates);\n    return newRates;\n  }\n\n};\nMeteor.methods(methods);","map":{"version":3,"sources":["server/methods/core/shipping.js"],"names":["module","export","methods","Meteor","watch","require","v","check","Cart","Accounts","Logger","Hooks","CartSchema","createShipmentQuotes","cartId","shopId","rates","update","$push","shipping","shipmentQuotes","shipmentQuotesQueryStatus","requestStatus","_id","error","warn","Events","run","debug","length","errorDetails","$set","shippingProvider","message","undefined","numOfShippingMethodsFound","pruneShippingRecordsByShop","cart","items","itemsByShop","getItemsByShop","shops","Object","keys","$pull","$nin","$unset","normalizeAddresses","address","forEach","shippingRecord","shopIds","selector","updateShipmentQuotes","updateShippingRecordByShop","cartForShipping","findOne","getDefaultAddress","userId","account","profile","addressBook","find","addressEntry","isShippingDefault","addAddresses","String","unblock","validate","call","retrialTargets","newRates","filter"],"mappings":"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","sourcesContent":["import { Meteor } from \"meteor/meteor\";\nimport { check } from \"meteor/check\";\nimport { Cart, Accounts } from \"/lib/collections\";\nimport { Logger, Hooks } from \"/server/api\";\nimport { Cart as CartSchema } from \"/lib/collections/schemas\";\n\n/**\n * @file Methods for Shipping - methods typically used for checkout (shipping, taxes, etc).\n * Run these methods using `Meteor.call()`.\n *\n *\n * @namespace Methods/Shipping\n*/\n\n/**\n * @name createShipmentQuotes\n * @private\n * @summary Returns object with shipping object with `requestStatus` as `pending`\n * @param  {String} cartId ID\n * @param  {String} shopId ID\n * @param  {Object} rates  Shipping rates\n * @return {Object}        Update object with `shipping` object.\n */\nfunction createShipmentQuotes(cartId, shopId, rates) {\n  let update = {\n    $push: {\n      shipping: {\n        shopId,\n        shipmentQuotes: [],\n        shipmentQuotesQueryStatus: {\n          requestStatus: \"pending\"\n        }\n      }\n    }\n  };\n\n  try {\n    Cart.update({ _id: cartId }, update);\n  } catch (error) {\n    Logger.warn(`Error in setting shipping query status to \"pending\" for ${cartId}`, error);\n    throw error;\n  }\n\n  // Calculate discounts\n  Hooks.Events.run(\"afterCartUpdateCalculateDiscount\", cartId);\n\n  Logger.debug(`Success in setting shipping query status to \"pending\" for ${cartId}`, rates);\n\n  if (rates.length === 1 && rates[0].requestStatus === \"error\") {\n    const errorDetails = rates[0];\n    update = {\n      $set: {\n        \"shipping.$.shipmentQuotes\": [],\n        \"shipping.$.shipmentQuotesQueryStatus\": {\n          requestStatus: errorDetails.requestStatus,\n          shippingProvider: errorDetails.shippingProvider,\n          message: errorDetails.message\n        }\n      }\n    };\n  }\n\n  if (rates.length > 0 && rates[0].requestStatus === undefined) {\n    update = {\n      $set: {\n        \"shipping.$.shipmentQuotes\": rates,\n        \"shipping.$.shipmentQuotesQueryStatus\": {\n          requestStatus: \"success\",\n          numOfShippingMethodsFound: rates.length\n        }\n      }\n    };\n  }\n\n  return update;\n}\n\n/**\n * @name pruneShippingRecordsByShop\n * @private\n * @summary if we have items in the cart, ensure that we only have shipping records\n * for shops currently represented in the cart\n * @param {Object} cart - The cart to operate on\n * @returns {undefined} undefined\n * @private\n */\nfunction pruneShippingRecordsByShop(cart) {\n  if (cart.items) {\n    const cartId = cart._id;\n    const itemsByShop = cart.getItemsByShop();\n    const shops = Object.keys(itemsByShop);\n    if (shops.length > 0 && cart.items.length > 0) {\n      Cart.update(\n        { _id: cartId },\n        {\n          $pull: {\n            shipping: { shopId: { $nin: shops } }\n          }\n        }\n      );\n    } else {\n      Cart.update(\n        { _id: cartId },\n        {\n          $unset: {\n            shipping: \"\"\n          }\n        }\n      );\n    }\n\n    // Calculate discounts\n    Hooks.Events.run(\"afterCartUpdateCalculateDiscount\", cartId);\n  }\n}\n\n/**\n * @name normalizeAddresses\n * @summary - When adding shipping records, ensure that each record has an address\n * @param {Object} cart - The Cart object we need to operate on\n * @returns {undefined} undefined\n * @private\n */\nfunction normalizeAddresses(cart) {\n  if (cart.shipping && cart.shipping.length > 0) {\n    const { shipping } = cart;\n    const cartId = cart._id;\n    let address; // we can only have one address so whatever was the last assigned\n    shipping.forEach((shippingRecord) => {\n      if (shippingRecord.address) {\n        ({ address } = shippingRecord);\n      }\n    });\n    const shopIds = Object.keys(cart.getItemsByShop());\n    shopIds.forEach((shopId) => {\n      const selector = {\n        \"_id\": cartId,\n        \"shipping.shopId\": shopId\n      };\n\n      const update = {\n        $set: {\n          \"shipping.$.address\": address\n        }\n      };\n      Cart.update(selector, update);\n      // Calculate discounts\n      Hooks.Events.run(\"afterCartUpdateCalculateDiscount\", cartId);\n    });\n  }\n}\n\n/**\n * @name updateShipmentQuotes\n * @param  {String} cartId   Cart ID\n * @param  {Object} rates    Rate object\n * @param  {Object} selector Selector\n * @return {Object}          Update\n * @private\n */\nfunction updateShipmentQuotes(cartId, rates, selector) {\n  let update = {\n    $set: {\n      \"shipping.$.shipmentQuotesQueryStatus\": {\n        requestStatus: \"pending\"\n      }\n    }\n  };\n\n  try {\n    Cart.update(selector, update);\n  } catch (error) {\n    Logger.warn(`Error in setting shipping query status to \"pending\" for ${cartId}`, error);\n    throw error;\n  }\n\n  // Calculate discounts\n  Hooks.Events.run(\"afterCartUpdateCalculateDiscount\", cartId);\n\n  Logger.debug(`Success in setting shipping query status to \"pending\" for ${cartId}`, rates);\n\n  if (rates.length === 1 && rates[0].requestStatus === \"error\") {\n    const errorDetails = rates[0];\n    update = {\n      $set: {\n        \"shipping.$.shipmentQuotes\": [],\n        \"shipping.$.shipmentQuotesQueryStatus\": {\n          requestStatus: errorDetails.requestStatus,\n          shippingProvider: errorDetails.shippingProvider,\n          message: errorDetails.message\n        }\n      }\n    };\n  }\n\n  if (rates.length > 0 && rates[0].requestStatus === undefined) {\n    update = {\n      $set: {\n        \"shipping.$.shipmentQuotes\": rates,\n        \"shipping.$.shipmentQuotesQueryStatus\": {\n          requestStatus: \"success\",\n          numOfShippingMethodsFound: rates.length\n        }\n      }\n    };\n  }\n\n  return update;\n}\n\n/**\n * @name updateShippingRecordByShop\n * @param  {Object} cart  Cart object\n * @param  {Object} rates Rate object\n * @return {null}\n * @private\n */\nfunction updateShippingRecordByShop(cart, rates) {\n  const cartId = cart._id;\n  const itemsByShop = cart.getItemsByShop();\n\n  const shops = Object.keys(itemsByShop);\n  shops.forEach((shopId) => {\n    const selector = {\n      \"_id\": cartId,\n      \"shipping.shopId\": shopId\n    };\n    const cartForShipping = Cart.findOne(selector);\n\n    // we may have added a new shop since the last time we did this, if so we need to add a new record\n    let update;\n    if (cartForShipping) {\n      update = updateShipmentQuotes(cartId, rates, selector);\n    } else {\n      update = createShipmentQuotes(cartId, shopId, rates);\n    }\n\n    try {\n      Cart.update(selector, update);\n    } catch (error) {\n      Logger.warn(`Error updating rates for cart ${cartId}`, error);\n      throw error;\n    }\n\n    // Calculate discounts\n    Hooks.Events.run(\"afterCartUpdateCalculateDiscount\", cartId);\n\n    Logger.debug(`Success updating rates for cart ${cartId}`, rates);\n  });\n\n  pruneShippingRecordsByShop(cart);\n  normalizeAddresses(cart);\n}\n\n/**\n * @name getDefaultAddress\n * @param  {Object} cart [description]\n * @return {Object} address\n * @private\n */\nfunction getDefaultAddress(cart) {\n  const { userId } = cart;\n  const account = Accounts.findOne(userId);\n  if (account && account.profile && account.profile.addressBook) {\n    const address = account.profile.addressBook.find((addressEntry) => addressEntry.isShippingDefault === true);\n    return address;\n  }\n}\n\n/**\n * @name addAddresses\n * @summary Add the default address to the cart\n * @param {Object} cart - the cart to modify\n * @returns {undefined}\n * @private\n */\nfunction addAddresses(cart) {\n  const address = getDefaultAddress(cart);\n  if (address) {\n    const shopIds = Object.keys(cart.getItemsByShop());\n    shopIds.forEach((shopId) => {\n      Cart.update({\n        _id: cart._id\n      }, {\n        $push: {\n          shipping: {\n            shopId,\n            address\n          }\n        }\n      });\n    });\n  }\n}\n\nexport const methods = {\n  /**\n   * @name shipping/updateShipmentQuotes\n   * @method\n   * @memberof Methods/Shipping\n   * @summary Gets shipping rates and updates the users cart methods\n   * @todo Add orderId argument/fallback\n   * @param {String} cartId - cartId\n   * @return {undefined}\n   */\n  \"shipping/updateShipmentQuotes\"(cartId) {\n    check(cartId, String);\n    if (!cartId) {\n      return [];\n    }\n    this.unblock();\n    let cart = Cart.findOne(cartId);\n    CartSchema.validate(cart);\n\n    if (cart) {\n      if (!cart.shipping || cart.shipping.length === 0) {\n        addAddresses(cart);\n        cart = Cart.findOne(cartId);\n      }\n      const rates = Meteor.call(\"shipping/getShippingRates\", cart);\n      updateShippingRecordByShop(cart, rates);\n    }\n  },\n\n  /**\n   * @name shipping/getShippingRates\n   * @method\n   * @memberof Methods/Shipping\n   * @summary Just gets rates, without updating anything\n   * @param {Object} cart - cart object\n   * @return {Array} return updated rates in cart\n   */\n  \"shipping/getShippingRates\"(cart) {\n    CartSchema.validate(cart);\n    const rates = [];\n    const retrialTargets = [];\n    // must have items to calculate shipping\n    if (!cart.items || !cart.items.length) {\n      return rates;\n    }\n    // hooks for other shipping rate events\n    // all callbacks should return rates\n    Hooks.Events.run(\"onGetShippingRates\", [rates, retrialTargets], cart);\n\n    // Try once more.\n    if (retrialTargets.length > 0) {\n      Hooks.Events.run(\"onGetShippingRates\", [rates, retrialTargets], cart);\n\n      if (retrialTargets.length > 0) {\n        Logger.warn(\"Failed to get shipping methods from these packages:\", retrialTargets);\n      }\n    }\n\n    let newRates = rates.filter(({ requestStatus }) => requestStatus !== \"error\");\n    if (newRates.length === 0) {\n      newRates = [{\n        requestStatus: \"error\",\n        shippingProvider: \"all\",\n        message: \"All requests for shipping methods failed.\"\n      }];\n    }\n\n    Logger.debug(\"getShippingRates returning rates\", rates);\n    return newRates;\n  }\n};\n\nMeteor.methods(methods);\n"]},"sourceType":"script","hash":"6e66664c1d678c0966e5dc855736499314d59111"}
