{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$1$2","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"ast":true,"babelrc":false,"sourceFileName":"server/methods/core/cartToOrder.js","filename":"server/methods/core/cartToOrder.js","sourceMaps":true,"envName":"development","cwd":"/Users/estebandev/test-knowledge","passPerPreset":false,"presets":[],"parserOpts":{"sourceType":"module","sourceFileName":"server/methods/core/cartToOrder.js","plugins":["jsx","jsx","flow","flow","objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties"]},"generatorOpts":{"filename":"server/methods/core/cartToOrder.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"server/methods/core/cartToOrder.js"}},"code":"module.export({\n  copyCartToOrder: () => copyCartToOrder\n});\n\nlet _each;\n\nmodule.watch(require(\"lodash/each\"), {\n  default(v) {\n    _each = v;\n  }\n\n}, 0);\nlet Meteor;\nmodule.watch(require(\"meteor/meteor\"), {\n  Meteor(v) {\n    Meteor = v;\n  }\n\n}, 1);\nlet check;\nmodule.watch(require(\"meteor/check\"), {\n  check(v) {\n    check = v;\n  }\n\n}, 2);\nlet Roles;\nmodule.watch(require(\"meteor/alanning:roles\"), {\n  Roles(v) {\n    Roles = v;\n  }\n\n}, 3);\nlet Collections;\nmodule.watch(require(\"../../../lib/collections\"), {\n  \"*\"(v) {\n    Collections = v;\n  }\n\n}, 4);\nlet Hooks, Logger, Reaction;\nmodule.watch(require(\"../../api\"), {\n  Hooks(v) {\n    Hooks = v;\n  },\n\n  Logger(v) {\n    Logger = v;\n  },\n\n  Reaction(v) {\n    Reaction = v;\n  }\n\n}, 5);\n\nfunction copyCartToOrder(cartId) {\n  check(cartId, String);\n  const cart = Collections.Cart.findOne(cartId); // security check - method can only be called on own cart\n\n  if (cart.userId !== Meteor.userId()) {\n    throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n  } // Init new order object from existing cart\n\n\n  const order = Object.assign({}, cart); // get sessionId from cart while cart is fresh\n\n  const {\n    sessionId\n  } = cart; // If there are no order items, throw an error. We won't create an empty order\n\n  if (!order.items || order.items.length === 0) {\n    const msg = \"An error occurred saving the order. Missing cart items.\";\n    Logger.error(msg);\n    throw new Meteor.Error(\"error-occurred\", msg);\n  } // Debug only message to identify the current cartId\n\n\n  Logger.debug(\"cart/copyCartToOrder\", cartId); // Set our new order's cartId to existing cart._id\n  // We'll get a new _id for our order\n\n  order.cartId = cart._id; // This block assigns an existing user's email associated with their account to this order\n  // We copied order from cart, so this userId and email are coming from the existing cart\n\n  if (order.userId && !order.email) {\n    // If we have a userId, but do _not_ have an email associated with this order\n    // we need to go find the account associated with this userId\n    const account = Collections.Accounts.findOne(order.userId); // Check to make sure that the account exists and has an emails field\n\n    if (typeof account === \"object\" && account.emails) {\n      for (const email of account.emails) {\n        // If a user has specified an alternate \"order\" email address, use that\n        if (email.provides === \"orders\") {\n          order.email = email.address; // Otherwise, check to see if the user has a \"default\" email address\n        } else if (email.provides === \"default\") {\n          order.email = email.address;\n        } // If we can't find any relevant email addresses for the user, we'll\n        // let them assign an email address to this order after the checkout\n\n      }\n    }\n  } // The schema will provide default values for these fields in our new order\n  // so we'll delete the values copied from the cart\n\n\n  delete order.createdAt; // autovalues from cart\n\n  delete order.updatedAt;\n  delete order.getCount;\n  delete order.getShippingTotal;\n  delete order.getSubTotal;\n  delete order.getTaxTotal;\n  delete order.getDiscounts;\n  delete order.getTotal;\n  delete order._id; // Create a shipping record for each shop on the order\n\n  if (Array.isArray(order.shipping)) {\n    if (order.shipping.length > 0) {\n      const shippingRecords = [];\n      order.shipping.map(shippingRecord => {\n        const billingRecord = order.billing.find(billing => billing.shopId === shippingRecord.shopId);\n        shippingRecord.paymentId = billingRecord._id;\n        shippingRecord.items = [];\n        shippingRecord.items.packed = false;\n        shippingRecord.items.shipped = false;\n        shippingRecord.items.delivered = false;\n        shippingRecord.workflow = {\n          status: \"new\",\n          workflow: [\"coreOrderWorkflow/notStarted\"]\n        };\n        shippingRecords.push(shippingRecord);\n        return shippingRecords;\n      });\n      order.shipping = shippingRecords;\n    }\n  } else {\n    // if not - create it\n    order.shipping = [];\n  } // Add current exchange rate into order.billing.currency\n  // If user currency === shop currency, exchange rate = 1.0\n\n\n  const currentUser = Meteor.user();\n  let userCurrency = Reaction.getShopCurrency();\n  let exchangeRate = \"1.00\";\n\n  if (currentUser && currentUser.profile && currentUser.profile.currency) {\n    userCurrency = Meteor.user().profile.currency;\n  }\n\n  if (userCurrency !== Reaction.getShopCurrency()) {\n    const userExchangeRate = Meteor.call(\"shop/getCurrencyRates\", userCurrency);\n\n    if (typeof userExchangeRate === \"number\") {\n      exchangeRate = userExchangeRate;\n    } else {\n      Logger.warn(\"Failed to get currency exchange rates. Setting exchange rate to null.\");\n      exchangeRate = null;\n    }\n  }\n\n  if (!order.billing[0].currency) {\n    order.billing[0].currency = {\n      // userCurrency is shopCurrency unless user has selected a different currency than the shop\n      userCurrency\n    };\n  }\n\n  order.items = order.items.map(item => {\n    item.shippingMethod = order.shipping[order.shipping.length - 1];\n    item.workflow = {\n      status: \"new\",\n      workflow: [\"coreOrderWorkflow/created\"]\n    };\n    return item;\n  }); // Assign items to each shipping record based on the shopId of the item\n\n  _each(order.items, item => {\n    const shippingRecord = order.shipping.find(sRecord => sRecord.shopId === item.shopId);\n    const shipmentItem = {\n      _id: item._id,\n      productId: item.productId,\n      quantity: item.quantity,\n      shopId: item.shopId,\n      variantId: item.variants._id\n    }; // If the shipment exists\n\n    if (shippingRecord.items) {\n      shippingRecord.items.push(shipmentItem);\n    } else {\n      shippingRecord.items = [shipmentItem];\n    }\n  });\n\n  order.billing[0].currency.exchangeRate = exchangeRate;\n  order.workflow.status = \"new\";\n  order.workflow.workflow = [\"coreOrderWorkflow/created\"]; // insert new reaction order\n\n  const orderId = Collections.Orders.insert(order);\n  Hooks.Events.run(\"afterOrderInsert\", order);\n\n  if (orderId) {\n    Collections.Cart.remove({\n      _id: order.cartId\n    }); // create a new cart for the user\n    // even though this should be caught by\n    // subscription handler, it's not always working\n\n    const newCartExists = Collections.Cart.find({\n      userId: order.userId\n    });\n\n    if (newCartExists.count() === 0) {\n      Meteor.call(\"cart/createCart\", this.userId, sessionId); // reset the checkout workflow to the beginning for an anonymous user.\n      // Using `Roles.userIsInRole` here because currently `Reaction.hasPermission(\"anonymous\")`\n      // will not return the correct result for actual anonymous users\n\n      if (Roles.userIsInRole(currentUser, \"anonymous\", Reaction.getShopId())) {\n        Meteor.call(\"workflow/pushCartWorkflow\", \"coreCartWorkflow\", \"checkoutLogin\");\n      } else {\n        // after recreate new cart we need to make it looks like previous by\n        // updating `cart/workflow/status` to \"coreCheckoutShipping\"\n        // by calling `workflow/pushCartWorkflow` three times. This is the only\n        // way to do that without refactoring of `workflow/pushCartWorkflow`\n        Meteor.call(\"workflow/pushCartWorkflow\", \"coreCartWorkflow\", \"checkoutLogin\");\n        Meteor.call(\"workflow/pushCartWorkflow\", \"coreCartWorkflow\", \"checkoutAddressBook\");\n        Meteor.call(\"workflow/pushCartWorkflow\", \"coreCartWorkflow\", \"coreCheckoutShipping\");\n      }\n    }\n\n    Logger.info(`Transitioned cart ${cartId} to order ${orderId}`); // catch send notification, we don't want\n    // to block because of notification errors\n\n    if (order.email) {\n      Meteor.call(\"orders/sendNotification\", Collections.Orders.findOne(orderId), err => {\n        if (err) {\n          Logger.error(err, `Error in orders/sendNotification for order ${orderId}`);\n        }\n      });\n    } // order success\n\n\n    return orderId;\n  } // we should not have made it here, throw error\n\n\n  throw new Meteor.Error(\"bad-request\", \"cart/copyCartToOrder: Invalid request\");\n}\n\nMeteor.methods({\n  \"cart/copyCartToOrder\": copyCartToOrder\n});","map":{"version":3,"sources":["server/methods/core/cartToOrder.js"],"names":["module","export","copyCartToOrder","_each","watch","require","default","v","Meteor","check","Roles","Collections","Hooks","Logger","Reaction","cartId","String","cart","Cart","findOne","userId","Error","order","Object","assign","sessionId","items","length","msg","error","debug","_id","email","account","Accounts","emails","provides","address","createdAt","updatedAt","getCount","getShippingTotal","getSubTotal","getTaxTotal","getDiscounts","getTotal","Array","isArray","shipping","shippingRecords","map","shippingRecord","billingRecord","billing","find","shopId","paymentId","packed","shipped","delivered","workflow","status","push","currentUser","user","userCurrency","getShopCurrency","exchangeRate","profile","currency","userExchangeRate","call","warn","item","shippingMethod","sRecord","shipmentItem","productId","quantity","variantId","variants","orderId","Orders","insert","Events","run","remove","newCartExists","count","userIsInRole","getShopId","info","err","methods"],"mappings":"AAAAA,OAAOC,MAAP,CAAc;AAACC,mBAAgB,MAAIA;AAArB,CAAd;;AAAqD,IAAIC,KAAJ;;AAAUH,OAAOI,KAAP,CAAaC,QAAQ,aAAR,CAAb,EAAoC;AAACC,UAAQC,CAAR,EAAU;AAACJ,YAAMI,CAAN;AAAQ;;AAApB,CAApC,EAA0D,CAA1D;AAA6D,IAAIC,MAAJ;AAAWR,OAAOI,KAAP,CAAaC,QAAQ,eAAR,CAAb,EAAsC;AAACG,SAAOD,CAAP,EAAS;AAACC,aAAOD,CAAP;AAAS;;AAApB,CAAtC,EAA4D,CAA5D;AAA+D,IAAIE,KAAJ;AAAUT,OAAOI,KAAP,CAAaC,QAAQ,cAAR,CAAb,EAAqC;AAACI,QAAMF,CAAN,EAAQ;AAACE,YAAMF,CAAN;AAAQ;;AAAlB,CAArC,EAAyD,CAAzD;AAA4D,IAAIG,KAAJ;AAAUV,OAAOI,KAAP,CAAaC,QAAQ,uBAAR,CAAb,EAA8C;AAACK,QAAMH,CAAN,EAAQ;AAACG,YAAMH,CAAN;AAAQ;;AAAlB,CAA9C,EAAkE,CAAlE;AAAqE,IAAII,WAAJ;AAAgBX,OAAOI,KAAP,CAAaC,QAAQ,0BAAR,CAAb,EAAiD;AAAC,MAAIE,CAAJ,EAAM;AAACI,kBAAYJ,CAAZ;AAAc;;AAAtB,CAAjD,EAAyE,CAAzE;AAA4E,IAAIK,KAAJ,EAAUC,MAAV,EAAiBC,QAAjB;AAA0Bd,OAAOI,KAAP,CAAaC,QAAQ,WAAR,CAAb,EAAkC;AAACO,QAAML,CAAN,EAAQ;AAACK,YAAML,CAAN;AAAQ,GAAlB;;AAAmBM,SAAON,CAAP,EAAS;AAACM,aAAON,CAAP;AAAS,GAAtC;;AAAuCO,WAASP,CAAT,EAAW;AAACO,eAASP,CAAT;AAAW;;AAA9D,CAAlC,EAAkG,CAAlG;;AAqB1c,SAASL,eAAT,CAAyBa,MAAzB,EAAiC;AACtCN,QAAMM,MAAN,EAAcC,MAAd;AACA,QAAMC,OAAON,YAAYO,IAAZ,CAAiBC,OAAjB,CAAyBJ,MAAzB,CAAb,CAFsC,CAItC;;AACA,MAAIE,KAAKG,MAAL,KAAgBZ,OAAOY,MAAP,EAApB,EAAqC;AACnC,UAAM,IAAIZ,OAAOa,KAAX,CAAiB,eAAjB,EAAkC,eAAlC,CAAN;AACD,GAPqC,CAStC;;;AACA,QAAMC,QAAQC,OAAOC,MAAP,CAAc,EAAd,EAAkBP,IAAlB,CAAd,CAVsC,CAYtC;;AACA,QAAM;AAAEQ;AAAF,MAAgBR,IAAtB,CAbsC,CAetC;;AACA,MAAI,CAACK,MAAMI,KAAP,IAAgBJ,MAAMI,KAAN,CAAYC,MAAZ,KAAuB,CAA3C,EAA8C;AAC5C,UAAMC,MAAM,yDAAZ;AACAf,WAAOgB,KAAP,CAAaD,GAAb;AACA,UAAM,IAAIpB,OAAOa,KAAX,CAAiB,gBAAjB,EAAmCO,GAAnC,CAAN;AACD,GApBqC,CAsBtC;;;AACAf,SAAOiB,KAAP,CAAa,sBAAb,EAAqCf,MAArC,EAvBsC,CAyBtC;AACA;;AACAO,QAAMP,MAAN,GAAeE,KAAKc,GAApB,CA3BsC,CA6BtC;AACA;;AACA,MAAIT,MAAMF,MAAN,IAAgB,CAACE,MAAMU,KAA3B,EAAkC;AAChC;AACA;AACA,UAAMC,UAAUtB,YAAYuB,QAAZ,CAAqBf,OAArB,CAA6BG,MAAMF,MAAnC,CAAhB,CAHgC,CAKhC;;AACA,QAAI,OAAOa,OAAP,KAAmB,QAAnB,IAA+BA,QAAQE,MAA3C,EAAmD;AACjD,WAAK,MAAMH,KAAX,IAAoBC,QAAQE,MAA5B,EAAoC;AAClC;AACA,YAAIH,MAAMI,QAAN,KAAmB,QAAvB,EAAiC;AAC/Bd,gBAAMU,KAAN,GAAcA,MAAMK,OAApB,CAD+B,CAE/B;AACD,SAHD,MAGO,IAAIL,MAAMI,QAAN,KAAmB,SAAvB,EAAkC;AACvCd,gBAAMU,KAAN,GAAcA,MAAMK,OAApB;AACD,SAPiC,CAQlC;AACA;;AACD;AACF;AACF,GAlDqC,CAoDtC;AACA;;;AACA,SAAOf,MAAMgB,SAAb,CAtDsC,CAsDd;;AACxB,SAAOhB,MAAMiB,SAAb;AACA,SAAOjB,MAAMkB,QAAb;AACA,SAAOlB,MAAMmB,gBAAb;AACA,SAAOnB,MAAMoB,WAAb;AACA,SAAOpB,MAAMqB,WAAb;AACA,SAAOrB,MAAMsB,YAAb;AACA,SAAOtB,MAAMuB,QAAb;AACA,SAAOvB,MAAMS,GAAb,CA9DsC,CAiEtC;;AACA,MAAIe,MAAMC,OAAN,CAAczB,MAAM0B,QAApB,CAAJ,EAAmC;AACjC,QAAI1B,MAAM0B,QAAN,CAAerB,MAAf,GAAwB,CAA5B,EAA+B;AAC7B,YAAMsB,kBAAkB,EAAxB;AACA3B,YAAM0B,QAAN,CAAeE,GAAf,CAAoBC,cAAD,IAAoB;AACrC,cAAMC,gBAAgB9B,MAAM+B,OAAN,CAAcC,IAAd,CAAoBD,OAAD,IAAaA,QAAQE,MAAR,KAAmBJ,eAAeI,MAAlE,CAAtB;AACAJ,uBAAeK,SAAf,GAA2BJ,cAAcrB,GAAzC;AACAoB,uBAAezB,KAAf,GAAuB,EAAvB;AACAyB,uBAAezB,KAAf,CAAqB+B,MAArB,GAA8B,KAA9B;AACAN,uBAAezB,KAAf,CAAqBgC,OAArB,GAA+B,KAA/B;AACAP,uBAAezB,KAAf,CAAqBiC,SAArB,GAAiC,KAAjC;AACAR,uBAAeS,QAAf,GAA0B;AAAEC,kBAAQ,KAAV;AAAiBD,oBAAU,CAAC,8BAAD;AAA3B,SAA1B;AACAX,wBAAgBa,IAAhB,CAAqBX,cAArB;AACA,eAAOF,eAAP;AACD,OAVD;AAWA3B,YAAM0B,QAAN,GAAiBC,eAAjB;AACD;AACF,GAhBD,MAgBO;AAAE;AACP3B,UAAM0B,QAAN,GAAiB,EAAjB;AACD,GApFqC,CAsFtC;AACA;;;AACA,QAAMe,cAAcvD,OAAOwD,IAAP,EAApB;AACA,MAAIC,eAAenD,SAASoD,eAAT,EAAnB;AACA,MAAIC,eAAe,MAAnB;;AAEA,MAAIJ,eAAeA,YAAYK,OAA3B,IAAsCL,YAAYK,OAAZ,CAAoBC,QAA9D,EAAwE;AACtEJ,mBAAezD,OAAOwD,IAAP,GAAcI,OAAd,CAAsBC,QAArC;AACD;;AAED,MAAIJ,iBAAiBnD,SAASoD,eAAT,EAArB,EAAiD;AAC/C,UAAMI,mBAAmB9D,OAAO+D,IAAP,CAAY,uBAAZ,EAAqCN,YAArC,CAAzB;;AAEA,QAAI,OAAOK,gBAAP,KAA4B,QAAhC,EAA0C;AACxCH,qBAAeG,gBAAf;AACD,KAFD,MAEO;AACLzD,aAAO2D,IAAP,CAAY,uEAAZ;AACAL,qBAAe,IAAf;AACD;AACF;;AAED,MAAI,CAAC7C,MAAM+B,OAAN,CAAc,CAAd,EAAiBgB,QAAtB,EAAgC;AAC9B/C,UAAM+B,OAAN,CAAc,CAAd,EAAiBgB,QAAjB,GAA4B;AAC1B;AACAJ;AAF0B,KAA5B;AAID;;AAED3C,QAAMI,KAAN,GAAcJ,MAAMI,KAAN,CAAYwB,GAAZ,CAAiBuB,IAAD,IAAU;AACtCA,SAAKC,cAAL,GAAsBpD,MAAM0B,QAAN,CAAe1B,MAAM0B,QAAN,CAAerB,MAAf,GAAwB,CAAvC,CAAtB;AACA8C,SAAKb,QAAL,GAAgB;AACdC,cAAQ,KADM;AAEdD,gBAAU,CAAC,2BAAD;AAFI,KAAhB;AAKA,WAAOa,IAAP;AACD,GARa,CAAd,CAlHsC,CA4HtC;;AACA,QAAOnD,MAAMI,KAAb,EAAqB+C,IAAD,IAAU;AAC5B,UAAMtB,iBAAiB7B,MAAM0B,QAAN,CAAeM,IAAf,CAAqBqB,OAAD,IAAaA,QAAQpB,MAAR,KAAmBkB,KAAKlB,MAAzD,CAAvB;AACA,UAAMqB,eAAe;AACnB7C,WAAK0C,KAAK1C,GADS;AAEnB8C,iBAAWJ,KAAKI,SAFG;AAGnBC,gBAAUL,KAAKK,QAHI;AAInBvB,cAAQkB,KAAKlB,MAJM;AAKnBwB,iBAAWN,KAAKO,QAAL,CAAcjD;AALN,KAArB,CAF4B,CAS5B;;AACA,QAAIoB,eAAezB,KAAnB,EAA0B;AACxByB,qBAAezB,KAAf,CAAqBoC,IAArB,CAA0Bc,YAA1B;AACD,KAFD,MAEO;AACLzB,qBAAezB,KAAf,GAAuB,CAACkD,YAAD,CAAvB;AACD;AACF,GAfD;;AAiBAtD,QAAM+B,OAAN,CAAc,CAAd,EAAiBgB,QAAjB,CAA0BF,YAA1B,GAAyCA,YAAzC;AACA7C,QAAMsC,QAAN,CAAeC,MAAf,GAAwB,KAAxB;AACAvC,QAAMsC,QAAN,CAAeA,QAAf,GAA0B,CAAC,2BAAD,CAA1B,CAhJsC,CAkJtC;;AACA,QAAMqB,UAAUtE,YAAYuE,MAAZ,CAAmBC,MAAnB,CAA0B7D,KAA1B,CAAhB;AACAV,QAAMwE,MAAN,CAAaC,GAAb,CAAiB,kBAAjB,EAAqC/D,KAArC;;AAEA,MAAI2D,OAAJ,EAAa;AACXtE,gBAAYO,IAAZ,CAAiBoE,MAAjB,CAAwB;AACtBvD,WAAKT,MAAMP;AADW,KAAxB,EADW,CAIX;AACA;AACA;;AACA,UAAMwE,gBAAgB5E,YAAYO,IAAZ,CAAiBoC,IAAjB,CAAsB;AAAElC,cAAQE,MAAMF;AAAhB,KAAtB,CAAtB;;AACA,QAAImE,cAAcC,KAAd,OAA0B,CAA9B,EAAiC;AAC/BhF,aAAO+D,IAAP,CAAY,iBAAZ,EAA+B,KAAKnD,MAApC,EAA4CK,SAA5C,EAD+B,CAG/B;AACA;AACA;;AACA,UAAIf,MAAM+E,YAAN,CAAmB1B,WAAnB,EAAgC,WAAhC,EAA6CjD,SAAS4E,SAAT,EAA7C,CAAJ,EAAwE;AACtElF,eAAO+D,IAAP,CAAY,2BAAZ,EAAyC,kBAAzC,EAA6D,eAA7D;AACD,OAFD,MAEO;AACL;AACA;AACA;AACA;AACA/D,eAAO+D,IAAP,CAAY,2BAAZ,EAAyC,kBAAzC,EAA6D,eAA7D;AACA/D,eAAO+D,IAAP,CAAY,2BAAZ,EAAyC,kBAAzC,EAA6D,qBAA7D;AACA/D,eAAO+D,IAAP,CAAY,2BAAZ,EAAyC,kBAAzC,EAA6D,sBAA7D;AACD;AACF;;AAED1D,WAAO8E,IAAP,CAAa,qBAAoB5E,MAAO,aAAYkE,OAAQ,EAA5D,EA3BW,CA4BX;AACA;;AAEA,QAAI3D,MAAMU,KAAV,EAAiB;AACfxB,aAAO+D,IAAP,CAAY,yBAAZ,EAAuC5D,YAAYuE,MAAZ,CAAmB/D,OAAnB,CAA2B8D,OAA3B,CAAvC,EAA6EW,GAAD,IAAS;AACnF,YAAIA,GAAJ,EAAS;AACP/E,iBAAOgB,KAAP,CAAa+D,GAAb,EAAmB,8CAA6CX,OAAQ,EAAxE;AACD;AACF,OAJD;AAKD,KArCU,CAuCX;;;AACA,WAAOA,OAAP;AACD,GA/LqC,CAgMtC;;;AACA,QAAM,IAAIzE,OAAOa,KAAX,CAAiB,aAAjB,EAAgC,uCAAhC,CAAN;AACD;;AAEDb,OAAOqF,OAAP,CAAe;AACb,0BAAwB3F;AADX,CAAf","sourcesContent":["import _ from \"lodash\";\nimport { Meteor } from \"meteor/meteor\";\nimport { check } from \"meteor/check\";\nimport { Roles } from \"meteor/alanning:roles\";\nimport * as Collections from \"/lib/collections\";\nimport { Hooks, Logger, Reaction } from \"/server/api\";\n\n\n/**\n * @name cart/copyCartToOrder\n * @method\n * @memberof Methods/Cart\n * @summary Transform Cart to Order when a payment is processed.\n * We want to copy the cart over to an order object, and give the user a new empty\n * cart. Reusing the cart schema makes sense, but integrity of the order,\n * we don't want to just make another cart item\n * @todo  Partial order processing, shopId processing\n * @todo  Review Security on this method\n * @param {String} cartId - cartId to transform to order\n * @return {String} returns orderId\n */\nexport function copyCartToOrder(cartId) {\n  check(cartId, String);\n  const cart = Collections.Cart.findOne(cartId);\n\n  // security check - method can only be called on own cart\n  if (cart.userId !== Meteor.userId()) {\n    throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n  }\n\n  // Init new order object from existing cart\n  const order = Object.assign({}, cart);\n\n  // get sessionId from cart while cart is fresh\n  const { sessionId } = cart;\n\n  // If there are no order items, throw an error. We won't create an empty order\n  if (!order.items || order.items.length === 0) {\n    const msg = \"An error occurred saving the order. Missing cart items.\";\n    Logger.error(msg);\n    throw new Meteor.Error(\"error-occurred\", msg);\n  }\n\n  // Debug only message to identify the current cartId\n  Logger.debug(\"cart/copyCartToOrder\", cartId);\n\n  // Set our new order's cartId to existing cart._id\n  // We'll get a new _id for our order\n  order.cartId = cart._id;\n\n  // This block assigns an existing user's email associated with their account to this order\n  // We copied order from cart, so this userId and email are coming from the existing cart\n  if (order.userId && !order.email) {\n    // If we have a userId, but do _not_ have an email associated with this order\n    // we need to go find the account associated with this userId\n    const account = Collections.Accounts.findOne(order.userId);\n\n    // Check to make sure that the account exists and has an emails field\n    if (typeof account === \"object\" && account.emails) {\n      for (const email of account.emails) {\n        // If a user has specified an alternate \"order\" email address, use that\n        if (email.provides === \"orders\") {\n          order.email = email.address;\n          // Otherwise, check to see if the user has a \"default\" email address\n        } else if (email.provides === \"default\") {\n          order.email = email.address;\n        }\n        // If we can't find any relevant email addresses for the user, we'll\n        // let them assign an email address to this order after the checkout\n      }\n    }\n  }\n\n  // The schema will provide default values for these fields in our new order\n  // so we'll delete the values copied from the cart\n  delete order.createdAt; // autovalues from cart\n  delete order.updatedAt;\n  delete order.getCount;\n  delete order.getShippingTotal;\n  delete order.getSubTotal;\n  delete order.getTaxTotal;\n  delete order.getDiscounts;\n  delete order.getTotal;\n  delete order._id;\n\n\n  // Create a shipping record for each shop on the order\n  if (Array.isArray(order.shipping)) {\n    if (order.shipping.length > 0) {\n      const shippingRecords = [];\n      order.shipping.map((shippingRecord) => {\n        const billingRecord = order.billing.find((billing) => billing.shopId === shippingRecord.shopId);\n        shippingRecord.paymentId = billingRecord._id;\n        shippingRecord.items = [];\n        shippingRecord.items.packed = false;\n        shippingRecord.items.shipped = false;\n        shippingRecord.items.delivered = false;\n        shippingRecord.workflow = { status: \"new\", workflow: [\"coreOrderWorkflow/notStarted\"] };\n        shippingRecords.push(shippingRecord);\n        return shippingRecords;\n      });\n      order.shipping = shippingRecords;\n    }\n  } else { // if not - create it\n    order.shipping = [];\n  }\n\n  // Add current exchange rate into order.billing.currency\n  // If user currency === shop currency, exchange rate = 1.0\n  const currentUser = Meteor.user();\n  let userCurrency = Reaction.getShopCurrency();\n  let exchangeRate = \"1.00\";\n\n  if (currentUser && currentUser.profile && currentUser.profile.currency) {\n    userCurrency = Meteor.user().profile.currency;\n  }\n\n  if (userCurrency !== Reaction.getShopCurrency()) {\n    const userExchangeRate = Meteor.call(\"shop/getCurrencyRates\", userCurrency);\n\n    if (typeof userExchangeRate === \"number\") {\n      exchangeRate = userExchangeRate;\n    } else {\n      Logger.warn(\"Failed to get currency exchange rates. Setting exchange rate to null.\");\n      exchangeRate = null;\n    }\n  }\n\n  if (!order.billing[0].currency) {\n    order.billing[0].currency = {\n      // userCurrency is shopCurrency unless user has selected a different currency than the shop\n      userCurrency\n    };\n  }\n\n  order.items = order.items.map((item) => {\n    item.shippingMethod = order.shipping[order.shipping.length - 1];\n    item.workflow = {\n      status: \"new\",\n      workflow: [\"coreOrderWorkflow/created\"]\n    };\n\n    return item;\n  });\n\n  // Assign items to each shipping record based on the shopId of the item\n  _.each(order.items, (item) => {\n    const shippingRecord = order.shipping.find((sRecord) => sRecord.shopId === item.shopId);\n    const shipmentItem = {\n      _id: item._id,\n      productId: item.productId,\n      quantity: item.quantity,\n      shopId: item.shopId,\n      variantId: item.variants._id\n    };\n    // If the shipment exists\n    if (shippingRecord.items) {\n      shippingRecord.items.push(shipmentItem);\n    } else {\n      shippingRecord.items = [shipmentItem];\n    }\n  });\n\n  order.billing[0].currency.exchangeRate = exchangeRate;\n  order.workflow.status = \"new\";\n  order.workflow.workflow = [\"coreOrderWorkflow/created\"];\n\n  // insert new reaction order\n  const orderId = Collections.Orders.insert(order);\n  Hooks.Events.run(\"afterOrderInsert\", order);\n\n  if (orderId) {\n    Collections.Cart.remove({\n      _id: order.cartId\n    });\n    // create a new cart for the user\n    // even though this should be caught by\n    // subscription handler, it's not always working\n    const newCartExists = Collections.Cart.find({ userId: order.userId });\n    if (newCartExists.count() === 0) {\n      Meteor.call(\"cart/createCart\", this.userId, sessionId);\n\n      // reset the checkout workflow to the beginning for an anonymous user.\n      // Using `Roles.userIsInRole` here because currently `Reaction.hasPermission(\"anonymous\")`\n      // will not return the correct result for actual anonymous users\n      if (Roles.userIsInRole(currentUser, \"anonymous\", Reaction.getShopId())) {\n        Meteor.call(\"workflow/pushCartWorkflow\", \"coreCartWorkflow\", \"checkoutLogin\");\n      } else {\n        // after recreate new cart we need to make it looks like previous by\n        // updating `cart/workflow/status` to \"coreCheckoutShipping\"\n        // by calling `workflow/pushCartWorkflow` three times. This is the only\n        // way to do that without refactoring of `workflow/pushCartWorkflow`\n        Meteor.call(\"workflow/pushCartWorkflow\", \"coreCartWorkflow\", \"checkoutLogin\");\n        Meteor.call(\"workflow/pushCartWorkflow\", \"coreCartWorkflow\", \"checkoutAddressBook\");\n        Meteor.call(\"workflow/pushCartWorkflow\", \"coreCartWorkflow\", \"coreCheckoutShipping\");\n      }\n    }\n\n    Logger.info(`Transitioned cart ${cartId} to order ${orderId}`);\n    // catch send notification, we don't want\n    // to block because of notification errors\n\n    if (order.email) {\n      Meteor.call(\"orders/sendNotification\", Collections.Orders.findOne(orderId), (err) => {\n        if (err) {\n          Logger.error(err, `Error in orders/sendNotification for order ${orderId}`);\n        }\n      });\n    }\n\n    // order success\n    return orderId;\n  }\n  // we should not have made it here, throw error\n  throw new Meteor.Error(\"bad-request\", \"cart/copyCartToOrder: Invalid request\");\n}\n\nMeteor.methods({\n  \"cart/copyCartToOrder\": copyCartToOrder\n});\n"]},"sourceType":"script","hash":"ab27090c2cea820ec6c9173a3ceae27319c16c41"}
