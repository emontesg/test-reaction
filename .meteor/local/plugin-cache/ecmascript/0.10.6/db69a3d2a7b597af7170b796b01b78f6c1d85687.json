{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$1$2","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"ast":true,"babelrc":false,"sourceFileName":"packages/mdg:validated-method/validated-method.js","filename":"packages/mdg:validated-method/validated-method.js","sourceMaps":true,"envName":"development","cwd":"/Users/estebandev/test-knowledge","passPerPreset":false,"presets":[],"parserOpts":{"sourceType":"module","sourceFileName":"packages/mdg:validated-method/validated-method.js","plugins":["jsx","jsx","flow","flow","objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties"]},"generatorOpts":{"filename":"packages/mdg:validated-method/validated-method.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/mdg:validated-method/validated-method.js"}},"code":"/* global ValidatedMethod:true */\nValidatedMethod = class ValidatedMethod {\n  constructor(options) {\n    // Default to no mixins\n    options.mixins = options.mixins || [];\n    check(options.mixins, [Function]);\n    check(options.name, String);\n    options = applyMixins(options, options.mixins); // connection argument defaults to Meteor, which is where Methods are defined on client and\n    // server\n\n    options.connection = options.connection || Meteor; // Allow validate: null shorthand for methods that take no arguments\n\n    if (options.validate === null) {\n      options.validate = function () {};\n    } // If this is null/undefined, make it an empty object\n\n\n    options.applyOptions = options.applyOptions || {};\n    check(options, Match.ObjectIncluding({\n      name: String,\n      validate: Function,\n      run: Function,\n      mixins: [Function],\n      connection: Object,\n      applyOptions: Object\n    })); // Default options passed to Meteor.apply, can be overridden with applyOptions\n\n    const defaultApplyOptions = {\n      // Make it possible to get the ID of an inserted item\n      returnStubValue: true,\n      // Don't call the server method if the client stub throws an error, so that we don't end\n      // up doing validations twice\n      throwStubExceptions: true\n    };\n    options.applyOptions = _.extend({}, defaultApplyOptions, options.applyOptions); // Attach all options to the ValidatedMethod instance\n\n    _.extend(this, options);\n\n    const method = this;\n    this.connection.methods({\n      [options.name](args) {\n        // Silence audit-argument-checks since arguments are always checked when using this package\n        check(args, Match.Any);\n        const methodInvocation = this;\n        return method._execute(methodInvocation, args);\n      }\n\n    });\n  }\n\n  call(args, callback) {\n    // Accept calling with just a callback\n    if (_.isFunction(args)) {\n      callback = args;\n      args = {};\n    }\n\n    try {\n      return this.connection.apply(this.name, [args], this.applyOptions, callback);\n    } catch (err) {\n      if (callback) {\n        // Get errors from the stub in the same way as from the server-side method\n        callback(err);\n      } else {\n        // No callback passed, throw instead of silently failing; this is what\n        // \"normal\" Methods do if you don't pass a callback.\n        throw err;\n      }\n    }\n  }\n\n  _execute(methodInvocation, args) {\n    methodInvocation = methodInvocation || {}; // Add `this.name` to reference the Method name\n\n    methodInvocation.name = this.name;\n    const validateResult = this.validate.bind(methodInvocation)(args);\n\n    if (typeof validateResult !== 'undefined') {\n      throw new Error(`Returning from validate doesn't do anything; \\\nperhaps you meant to throw an error?`);\n    }\n\n    return this.run.bind(methodInvocation)(args);\n  }\n\n}; // Mixins get a chance to transform the arguments before they are passed to the actual Method\n\nfunction applyMixins(args, mixins) {\n  // You can pass nested arrays so that people can ship mixin packs\n  const flatMixins = _.flatten(mixins); // Save name of the method here, so we can attach it to potential error messages\n\n\n  const {\n    name\n  } = args;\n  flatMixins.forEach(mixin => {\n    args = mixin(args);\n\n    if (!Match.test(args, Object)) {\n      const functionName = mixin.toString().match(/function\\s(\\w+)/);\n      let msg = 'One of the mixins';\n\n      if (functionName) {\n        msg = `The function '${functionName[1]}'`;\n      }\n\n      throw new Error(`Error in ${name} method: ${msg} didn't return the options object.`);\n    }\n  });\n  return args;\n}","map":{"version":3,"sources":["packages/mdg:validated-method/validated-method.js"],"names":["ValidatedMethod","constructor","options","mixins","check","Function","name","String","applyMixins","connection","Meteor","validate","applyOptions","Match","ObjectIncluding","run","Object","defaultApplyOptions","returnStubValue","throwStubExceptions","_","extend","method","methods","args","Any","methodInvocation","_execute","call","callback","isFunction","apply","err","validateResult","bind","Error","flatMixins","flatten","forEach","mixin","test","functionName","toString","match","msg"],"mappings":"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","sourcesContent":["/* global ValidatedMethod:true */\n\nValidatedMethod = class ValidatedMethod {\n  constructor(options) {\n    // Default to no mixins\n    options.mixins = options.mixins || [];\n    check(options.mixins, [Function]);\n    check(options.name, String);\n    options = applyMixins(options, options.mixins);\n\n    // connection argument defaults to Meteor, which is where Methods are defined on client and\n    // server\n    options.connection = options.connection || Meteor;\n\n    // Allow validate: null shorthand for methods that take no arguments\n    if (options.validate === null) {\n      options.validate = function () {};\n    }\n\n    // If this is null/undefined, make it an empty object\n    options.applyOptions = options.applyOptions || {};\n\n    check(options, Match.ObjectIncluding({\n      name: String,\n      validate: Function,\n      run: Function,\n      mixins: [Function],\n      connection: Object,\n      applyOptions: Object,\n    }));\n\n    // Default options passed to Meteor.apply, can be overridden with applyOptions\n    const defaultApplyOptions = {\n      // Make it possible to get the ID of an inserted item\n      returnStubValue: true,\n\n      // Don't call the server method if the client stub throws an error, so that we don't end\n      // up doing validations twice\n      throwStubExceptions: true,\n    };\n\n    options.applyOptions = _.extend({}, defaultApplyOptions, options.applyOptions);\n\n    // Attach all options to the ValidatedMethod instance\n    _.extend(this, options);\n\n    const method = this;\n    this.connection.methods({\n      [options.name](args) {\n        // Silence audit-argument-checks since arguments are always checked when using this package\n        check(args, Match.Any);\n        const methodInvocation = this;\n\n        return method._execute(methodInvocation, args);\n      }\n    });\n  }\n\n  call(args, callback) {\n    // Accept calling with just a callback\n    if (_.isFunction(args)) {\n      callback = args;\n      args = {};\n    }\n\n    try {\n      return this.connection.apply(this.name, [args], this.applyOptions, callback);\n    } catch (err) {\n      if (callback) {\n        // Get errors from the stub in the same way as from the server-side method\n        callback(err);\n      } else {\n        // No callback passed, throw instead of silently failing; this is what\n        // \"normal\" Methods do if you don't pass a callback.\n        throw err;\n      }\n    }\n  }\n\n  _execute(methodInvocation, args) {\n    methodInvocation = methodInvocation || {};\n\n    // Add `this.name` to reference the Method name\n    methodInvocation.name = this.name;\n\n    const validateResult = this.validate.bind(methodInvocation)(args);\n\n    if (typeof validateResult !== 'undefined') {\n      throw new Error(`Returning from validate doesn't do anything; \\\nperhaps you meant to throw an error?`);\n    }\n\n    return this.run.bind(methodInvocation)(args);\n  }\n};\n\n// Mixins get a chance to transform the arguments before they are passed to the actual Method\nfunction applyMixins(args, mixins) {\n  // You can pass nested arrays so that people can ship mixin packs\n  const flatMixins = _.flatten(mixins);\n  // Save name of the method here, so we can attach it to potential error messages\n  const {name} = args;\n\n  flatMixins.forEach((mixin) => {\n    args = mixin(args);\n\n    if(!Match.test(args, Object)) {\n      const functionName = mixin.toString().match(/function\\s(\\w+)/);\n      let msg = 'One of the mixins';\n\n      if(functionName) {\n        msg = `The function '${functionName[1]}'`;\n      }\n\n      throw new Error(`Error in ${name} method: ${msg} didn't return the options object.`);\n    }\n  });\n\n  return args;\n}\n"]},"sourceType":"script","hash":"db69a3d2a7b597af7170b796b01b78f6c1d85687"}
