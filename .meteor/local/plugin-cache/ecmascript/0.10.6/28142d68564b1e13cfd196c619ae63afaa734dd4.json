{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$1$2","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"ast":true,"babelrc":false,"sourceFileName":"server/methods/core/cart.js","filename":"server/methods/core/cart.js","sourceMaps":true,"envName":"development","cwd":"/Users/estebandev/test-knowledge","passPerPreset":false,"presets":[],"parserOpts":{"sourceType":"module","sourceFileName":"server/methods/core/cart.js","plugins":["jsx","jsx","flow","flow","objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties"]},"generatorOpts":{"filename":"server/methods/core/cart.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"server/methods/core/cart.js"}},"code":"var _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/builtin/objectSpread\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nlet _find;\n\nmodule.watch(require(\"lodash/find\"), {\n  default(v) {\n    _find = v;\n  }\n\n}, 0);\nlet Meteor;\nmodule.watch(require(\"meteor/meteor\"), {\n  Meteor(v) {\n    Meteor = v;\n  }\n\n}, 1);\nlet check, Match;\nmodule.watch(require(\"meteor/check\"), {\n  check(v) {\n    check = v;\n  },\n\n  Match(v) {\n    Match = v;\n  }\n\n}, 2);\nlet Roles;\nmodule.watch(require(\"meteor/alanning:roles\"), {\n  Roles(v) {\n    Roles = v;\n  }\n\n}, 3);\nlet Random;\nmodule.watch(require(\"meteor/random\"), {\n  Random(v) {\n    Random = v;\n  }\n\n}, 4);\nlet Collections;\nmodule.watch(require(\"../../../lib/collections\"), {\n  \"*\"(v) {\n    Collections = v;\n  }\n\n}, 5);\nlet Hooks, Logger, Reaction;\nmodule.watch(require(\"../../api\"), {\n  Hooks(v) {\n    Hooks = v;\n  },\n\n  Logger(v) {\n    Logger = v;\n  },\n\n  Reaction(v) {\n    Reaction = v;\n  }\n\n}, 6);\nlet PaymentMethodArgument;\nmodule.watch(require(\"../../../lib/collections/schemas\"), {\n  PaymentMethodArgument(v) {\n    PaymentMethodArgument = v;\n  }\n\n}, 7);\n\n/**\n * @method quantityProcessing\n * @private\n * @summary Perform calculations admissibility of adding product to cart\n * @param {Object} product - product to add to Cart\n * @param {Object} variant - product variant\n * @param {Number} itemQty - qty to add to cart, defaults to 1, deducts\n *  from inventory\n * @since 1.10.1\n * @return {Number} quantity - revised quantity to be added to cart\n */\nfunction quantityProcessing(product, variant, itemQty = 1) {\n  let quantity = itemQty;\n  const MIN = variant.minOrderQuantity || 1;\n  const MAX = variant.inventoryQuantity || Infinity;\n\n  if (variant.inventoryPolicy && MIN > MAX) {\n    Logger.debug(`productId: ${product._id}, variantId ${variant._id}: inventoryQuantity lower then minimum order`);\n    throw new Meteor.Error(\"invalid-parameter\", `productId: ${product._id}, variantId ${variant._id}: inventoryQuantity lower then minimum order`);\n  } // TODO: think about #152 implementation here\n\n\n  switch (product.type) {\n    case \"not-in-stock\":\n      break;\n\n    default:\n      // type: `simple` // todo: maybe it should be \"variant\"\n      if (quantity < MIN) {\n        quantity = MIN;\n      } else if (variant.inventoryPolicy && quantity > MAX) {\n        quantity = MAX;\n      }\n\n  }\n\n  return quantity;\n}\n/**\n * @method getSessionCarts\n * @private\n * @summary Get Cart cursor with all session carts\n * @param {String} userId - current user _id\n * @param {String} sessionId - current user session id\n * @param {String} shopId - shop id\n * @since 0.10.2\n * @return {Mongo.Cursor} with array of session carts\n */\n\n\nfunction getSessionCarts(userId, sessionId, shopId) {\n  const carts = Collections.Cart.find({\n    $and: [{\n      userId: {\n        $ne: userId\n      }\n    }, {\n      sessionId: {\n        $eq: sessionId\n      }\n    }, {\n      shopId: {\n        $eq: shopId\n      }\n    }]\n  }); // we can't use Array.map here, because we need to reduce the number of array\n  // elements if element belongs to registered user, we should throw it.\n\n  const allowedCarts = []; // only anonymous user carts allowed\n\n  carts.forEach(cart => {\n    if (Roles.userIsInRole(cart.userId, \"anonymous\", shopId)) {\n      allowedCarts.push(cart);\n    }\n  });\n  return allowedCarts;\n}\n/**\n * @method removeShippingAddresses\n * @private\n * @summary Remove shipping address from cart\n * @param {String} cart - current cart\n * @return null\n */\n\n\nfunction removeShippingAddresses(cart) {\n  const cartShipping = cart.shipping;\n  cartShipping.map(sRecord => delete sRecord.address);\n  Collections.Cart.update({\n    _id: cart._id\n  }, {\n    $set: {\n      shipping: cartShipping\n    }\n  }); // Calculate discounts\n\n  Hooks.Events.run(\"afterCartUpdateCalculateDiscount\", cart._id); // Calculate taxes\n\n  Hooks.Events.run(\"afterCartUpdateCalculateTaxes\", cart._id);\n}\n/**\n * @file Methods for Cart - Use these methods by running `Meteor.call()`\n * @example Meteor.call(\"cart/createCart\", this.userId, sessionId)\n * @namespace Methods/Cart\n */\n\n\nMeteor.methods({\n  /**\n   * @method cart/mergeCart\n   * @summary Merge matching sessionId cart into specified userId cart\n   * There should be one cart for each independent, non-logged-in user session.\n   * When a user logs in that cart now belongs to that user and we use the a single user cart.\n   * If they are logged in on more than one devices, regardless of session,the user cart will be used\n   * If they had more than one cart, on more than one device,logged in at separate times then merge the carts\n   * @memberof Methods/Cart\n   * @param {String} cartId - cartId of the cart to merge matching session carts into.\n   * @param {String} [currentSessionId] - current client session id\n   * @todo I think this method should be moved out from methods to a Function Declaration to keep it more secure\n   * @return {Object|Boolean} cartId - cartId on success or false\n   */\n  \"cart/mergeCart\"(cartId, currentSessionId) {\n    check(cartId, String); // TODO: Review this. currentSessionId sometimes come in as false. e.g from Accounts.onLogin\n\n    check(currentSessionId, Match.Optional(String)); // we don't process current cart, but merge into it.\n\n    const currentCart = Collections.Cart.findOne(cartId);\n\n    if (!currentCart) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    } // just used to filter out the current cart\n    // we do additional check of cart exists here and if it not exist, next\n    // check supposed to throw 403 error\n\n\n    const userId = currentCart && currentCart.userId; // user should have an access to operate with only one - his - cart\n\n    if (this.userId !== null && userId !== this.userId) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    } // persistent sessions, see: publications/sessions.js\n    // this is the last place where we still need `Reaction.sessionId`.\n    // The use case is: on user log in. I don't know how pass `sessionId` down\n    // at that moment.\n\n\n    const sessionId = currentSessionId || Reaction.sessionId;\n    const shopId = Reaction.getShopId(); // no need to merge anonymous carts\n\n    if (Roles.userIsInRole(userId, \"anonymous\", shopId)) {\n      return false;\n    }\n\n    Logger.debug(\"merge cart: matching sessionId\");\n    Logger.debug(\"current userId:\", userId);\n    Logger.debug(\"sessionId:\", sessionId); // get session carts without current user cart cursor\n\n    const sessionCarts = getSessionCarts(userId, sessionId, shopId);\n    Logger.debug(`merge cart: begin merge processing of session ${sessionId} into: ${currentCart._id}`); // loop through session carts and merge into user cart\n\n    sessionCarts.forEach(sessionCart => {\n      Logger.debug(`merge cart: merge user userId: ${userId}, sessionCart.userId: ${sessionCart.userId}, sessionCart id: ${sessionCart._id}`); // really if we have no items, there's nothing to merge\n\n      if (sessionCart.items) {\n        // if currentCart already have a cartWorkflow, we don't need to clean it\n        // up completely, just to `coreCheckoutShipping` stage. Also, we will\n        // need to recalculate shipping rates\n        if (typeof currentCart.workflow === \"object\" && typeof currentCart.workflow.workflow === \"object\") {\n          if (currentCart.workflow.workflow.length > 2) {\n            Meteor.call(\"workflow/revertCartWorkflow\", \"coreCheckoutShipping\"); // refresh shipping quotes\n\n            Meteor.call(\"shipping/updateShipmentQuotes\", cartId);\n          }\n        } else {\n          // if user logged in he doesn't need to show `checkoutLogin` step\n          Meteor.call(\"workflow/revertCartWorkflow\", \"checkoutAddressBook\");\n        }\n\n        const cartSum = sessionCart.items.concat(currentCart.items);\n        const mergedItems = cartSum.reduce((newItems, item) => {\n          if (item) {\n            const existingItem = newItems.find(cartItem => cartItem.variants._id === item.variants._id);\n\n            if (existingItem) {\n              existingItem.quantity += item.quantity;\n            } else {\n              newItems.push(item);\n            }\n          }\n\n          return newItems;\n        }, []);\n        Collections.Cart.update(currentCart._id, {\n          $push: {\n            items: {\n              $each: mergedItems,\n              $slice: -mergedItems.length\n            }\n          }\n        }); // Calculate discounts\n\n        Hooks.Events.run(\"afterCartUpdateCalculateDiscount\", currentCart._id);\n      } // cleanup session Carts after merge.\n\n\n      if (sessionCart.userId !== this.userId) {\n        // clear the cart that was used for a session\n        // and we're also going to do some garbage Collection\n        Collections.Cart.remove(sessionCart._id); // cleanup user/accounts\n\n        Collections.Accounts.remove({\n          userId: sessionCart.userId\n        });\n        Hooks.Events.run(\"afterAccountsRemove\", this.userId, sessionCart.userId);\n        Meteor.users.remove(sessionCart.userId);\n        Logger.debug(`merge cart: delete cart ${sessionCart._id} and user: ${sessionCart.userId}`);\n      }\n\n      Logger.debug(`merge cart: processed merge for cartId ${sessionCart._id}`);\n    }); // `checkoutLogin` should be used for anonymous only. Registered users\n    // no need see this.\n\n    if (currentCart.workflow && currentCart.workflow.status === \"new\") {\n      // to call `workflow/pushCartWorkflow` two times is the only way to move\n      // from status \"new\" to \"checkoutAddressBook\" which I found without\n      // refactoring of `workflow/pushCartWorkflow`\n      // We send `cartId` as arguments because this method could be called from\n      // publication method and in half cases it could be so, that\n      // Meteor.userId() will be null.\n      Meteor.call(\"workflow/pushCartWorkflow\", \"coreCartWorkflow\", \"checkoutLogin\", cartId);\n      Meteor.call(\"workflow/pushCartWorkflow\", \"coreCartWorkflow\", \"checkoutAddressBook\", cartId);\n    }\n\n    return currentCart._id;\n  },\n\n  /**\n   * @method cart/createCart\n   * @summary create new cart for user,\n   * but all checks for current cart's existence should go before this method will be called, to keep it clean\n   * @memberof Methods/Cart\n   * @param {String} userId - userId to create cart for\n   * @param {String} sessionId - current client session id\n   * @todo I think this method should be moved out from methods to a Function Declaration to keep it more secure\n   * @returns {String} cartId - users cartId\n   */\n  \"cart/createCart\"(userId, sessionId) {\n    check(userId, String);\n    check(sessionId, String);\n    const marketplaceSettings = Reaction.getMarketplaceSettings();\n    let shopId;\n\n    if (marketplaceSettings && marketplaceSettings.public && marketplaceSettings.public.merchantCart) {\n      shopId = Reaction.getShopId();\n    } else {\n      shopId = Reaction.getPrimaryShopId();\n    } // check if user has `anonymous` role.( this is a visitor)\n\n\n    const anonymousUser = Roles.userIsInRole(userId, \"anonymous\", shopId);\n    const sessionCartCount = getSessionCarts(userId, sessionId, shopId).length;\n    Logger.debug(\"create cart: shopId\", shopId);\n    Logger.debug(\"create cart: userId\", userId);\n    Logger.debug(\"create cart: sessionId\", sessionId);\n    Logger.debug(\"create cart: sessionCarts.count\", sessionCartCount);\n    Logger.debug(\"create cart: anonymousUser\", anonymousUser); // we need to create a user cart for the new authenticated user or\n    // anonymous.\n\n    const currentCartId = Collections.Cart.insert({\n      sessionId,\n      userId\n    });\n    Logger.debug(`create cart: into new user cart. created: ${currentCartId} for user ${userId}`); // merge session carts into the current cart\n\n    if (sessionCartCount > 0 && !anonymousUser) {\n      Logger.debug(`create cart: found existing cart. merge into ${currentCartId} for user ${userId}`);\n      Meteor.call(\"cart/mergeCart\", currentCartId, sessionId);\n    } // we should check for an default billing/shipping address in user account.\n    // this needed after submitting order, when user receives new cart\n\n\n    const account = Collections.Accounts.findOne(userId);\n\n    if (account && account.profile && account.profile.addressBook) {\n      account.profile.addressBook.forEach(address => {\n        if (address.isBillingDefault) {\n          Meteor.call(\"cart/setPaymentAddress\", currentCartId, address);\n        }\n\n        if (address.isShippingDefault) {\n          Meteor.call(\"cart/setShipmentAddress\", currentCartId, address);\n        }\n      });\n    } // attach current user currency to cart\n\n\n    const currentUser = Meteor.user();\n    let userCurrency = Reaction.getShopCurrency(); // Check to see if the user has a custom currency saved to their profile\n    // Use it if they do\n\n    if (currentUser && currentUser.profile && currentUser.profile.currency) {\n      userCurrency = currentUser.profile.currency;\n    }\n\n    Meteor.call(\"cart/setUserCurrency\", currentCartId, userCurrency);\n    return currentCartId;\n  },\n\n  /**\n   *  @method cart/addToCart\n   *  @summary Add items to a user cart. When we add an item to the cart,\n   *  we want to break all relationships with the existing item.\n   *  We want to fix price, qty, etc into history.\n   *  However, we could check reactively for price /qty etc, adjustments on the original and notify them.\n   *  @memberof Methods/Cart\n   *  @param {String} productId - productId to add to Cart\n   *  @param {String} variantId - product variant _id\n   *  @param {Number} [itemQty] - qty to add to cart\n   *  @param {Object} [additionalOptions] - object containing additional options and fields for cart item\n   *  @return {Number|Object} Mongo insert response\n   */\n  \"cart/addToCart\"(productId, variantId, itemQty, additionalOptions) {\n    check(productId, String);\n    check(variantId, String);\n    check(itemQty, Match.Optional(Number));\n    check(additionalOptions, Match.Optional(Object)); // Copy additionalOptions into an options object to use througout the method\n\n    const options = (0, _objectSpread2.default)({\n      overwriteExistingMetafields: false,\n      // Allows updating of metafields on quantity change\n      metafields: undefined\n    }, additionalOptions || {});\n    const cart = Collections.Cart.findOne({\n      userId: this.userId\n    });\n\n    if (!cart) {\n      Logger.error(`Cart not found for user: ${this.userId}`);\n      throw new Meteor.Error(\"invalid-parameter\", \"Cart not found for user with such id\");\n    } // With the flattened model we no longer need to work directly with the\n    // products. But product still could be necessary for a `quantityProcessing`\n    // TODO: need to understand: do we really need product inside\n    // `quantityProcessing`?\n\n\n    let product;\n    let variant;\n    Collections.Products.find({\n      _id: {\n        $in: [productId, variantId]\n      }\n    }).forEach(doc => {\n      if (doc.type === \"simple\") {\n        product = doc;\n      } else {\n        variant = doc;\n      }\n    }); // TODO: this lines still needed. We could uncomment them in future if\n    // decide to not completely remove product data from this method\n    // const product = Collections.Products.findOne(productId);\n    // const variant = Collections.Products.findOne(variantId);\n\n    if (!product) {\n      Logger.warn(`Product: ${productId} was not found in database`);\n      throw new Meteor.Error(\"not-found\", \"Product with such id was not found\");\n    }\n\n    if (!variant) {\n      Logger.warn(`Product variant: ${variantId} was not found in database`);\n      throw new Meteor.Error(\"not-found\", \"ProductVariant with such id was not found\");\n    } // performs calculations admissibility of adding product to cart\n\n\n    const quantity = quantityProcessing(product, variant, itemQty); // performs search of variant inside cart\n\n    const cartVariantExists = cart.items && cart.items.some(item => item.variants._id === variantId);\n\n    if (cartVariantExists) {\n      let modifier = {}; // Allows for updating metafields on an existing item when the quantity also changes\n\n      if (options.overwriteExistingMetafields) {\n        modifier = {\n          $set: {\n            \"items.$.metafields\": options.metafields\n          }\n        };\n      }\n\n      let updateResult;\n\n      try {\n        updateResult = Collections.Cart.update({\n          \"_id\": cart._id,\n          \"items.product._id\": productId,\n          \"items.variants._id\": variantId\n        }, (0, _objectSpread2.default)({\n          $inc: {\n            \"items.$.quantity\": quantity\n          }\n        }, modifier));\n      } catch (error) {\n        Logger.error(\"Error adding to cart.\", error);\n        Logger.error(\"Error adding to cart. Invalid keys:\", Collections.Cart.simpleSchema().namedContext().validationErrors());\n        throw error;\n      } // Update inventory\n\n\n      Hooks.Events.run(\"afterModifyQuantityInCart\", cart._id, {\n        productId,\n        variantId\n      }); // Calculate discounts\n\n      Hooks.Events.run(\"afterCartUpdateCalculateDiscount\", cart._id); // refresh shipping quotes\n\n      Meteor.call(\"shipping/updateShipmentQuotes\", cart._id); // revert workflow to checkout shipping step.\n\n      Meteor.call(\"workflow/revertCartWorkflow\", \"coreCheckoutShipping\"); // reset selected shipment method\n\n      Meteor.call(\"cart/resetShipmentMethod\", cart._id); // Calculate taxes\n\n      Hooks.Events.run(\"afterCartUpdateCalculateTaxes\", cart._id);\n      Logger.debug(`cart: increment variant ${variantId} quantity by ${quantity}`);\n      return updateResult;\n    } // TODO: Handle more than 2 levels of variant hierarchy for determining parcel dimensions\n    // we need to get the parent of the option to check if parcel info is stored there\n\n\n    const immediateAncestors = variant.ancestors.filter(ancestor => ancestor !== product._id);\n    const immediateAncestor = Collections.Products.findOne({\n      _id: immediateAncestors[0]\n    });\n    let parcel = null;\n\n    if (immediateAncestor) {\n      if (immediateAncestor.weight || immediateAncestor.height || immediateAncestor.width || immediateAncestor.length) {\n        parcel = {\n          weight: immediateAncestor.weight,\n          height: immediateAncestor.height,\n          width: immediateAncestor.width,\n          length: immediateAncestor.length\n        };\n      }\n    } // if it's set at the option level then that overrides\n\n\n    if (variant.weight || variant.height || variant.width || variant.length) {\n      parcel = {\n        weight: variant.weight,\n        height: variant.height,\n        width: variant.width,\n        length: variant.length\n      };\n    } // cart variant doesn't exist\n\n\n    let updateResult;\n    const newItemId = Random.id();\n\n    try {\n      updateResult = Collections.Cart.update({\n        _id: cart._id\n      }, {\n        $addToSet: {\n          items: {\n            _id: newItemId,\n            shopId: product.shopId,\n            productId,\n            quantity,\n            product,\n            variants: variant,\n            metafields: options.metafields,\n            title: product.title,\n            type: product.type,\n            parcel\n          }\n        }\n      });\n    } catch (error) {\n      Logger.error(\"Error adding to cart.\", error);\n      Logger.error(\"Error adding to cart. Invalid keys:\", Collections.Cart.simpleSchema().namedContext().validationErrors());\n      throw error;\n    } // Update add inventory reserve\n\n\n    Hooks.Events.run(\"afterAddItemsToCart\", cart._id, {\n      newItemId\n    }); // Calculate discounts\n\n    Hooks.Events.run(\"afterCartUpdateCalculateDiscount\", cart._id); // refresh shipping quotes\n\n    Meteor.call(\"shipping/updateShipmentQuotes\", cart._id); // revert workflow to checkout shipping step.\n\n    Meteor.call(\"workflow/revertCartWorkflow\", \"coreCheckoutShipping\"); // reset selected shipment method\n\n    Meteor.call(\"cart/resetShipmentMethod\", cart._id); // Calculate taxes\n\n    Hooks.Events.run(\"afterCartUpdateCalculateTaxes\", cart._id);\n    Logger.debug(`cart: add variant ${variantId} to cartId ${cart._id}`);\n    return updateResult;\n  },\n\n  /**\n   * @method cart/removeFromCart\n   * @memberof Methods/Cart\n   * @summary Removes or adjust quantity of a variant from the cart\n   * @param {String} itemId - cart item _id\n   * @param {Number} [quantity] - if provided will adjust increment by quantity\n   * @returns {Number} returns Mongo update result\n   */\n  \"cart/removeFromCart\"(itemId, quantity) {\n    check(itemId, String);\n    check(quantity, Match.Optional(Number));\n    const userId = Meteor.userId();\n    const cart = Collections.Cart.findOne({\n      userId\n    });\n\n    if (!cart) {\n      Logger.error(`Cart not found for user: ${this.userId}`);\n      throw new Meteor.Error(\"not-found\", \"Cart not found for user with such id\");\n    }\n\n    let cartItem;\n\n    if (cart.items) {\n      cartItem = _find(cart.items, item => item._id === itemId);\n    } // extra check of item exists\n\n\n    if (typeof cartItem !== \"object\") {\n      Logger.error(`Unable to find an item: ${itemId} within the cart: ${cart._id}`);\n      throw new Meteor.Error(\"not-found\", \"Unable to find an item with such id in cart.\");\n    }\n\n    if (!quantity || quantity >= cartItem.quantity) {\n      let cartResult;\n\n      try {\n        cartResult = Collections.Cart.update({\n          _id: cart._id\n        }, {\n          $pull: {\n            items: {\n              _id: itemId\n            }\n          }\n        }, {\n          getAutoValues: false // See https://github.com/aldeed/meteor-collection2/issues/245\n\n        });\n      } catch (error) {\n        Logger.error(\"Error removing from cart.\", error);\n        Logger.error(\"Error removing from cart. Invalid keys:\", Collections.Cart.simpleSchema().namedContext().validationErrors());\n        throw error;\n      }\n\n      Logger.debug(`cart: deleted cart item variant id ${cartItem.variants._id}`); // Clear inventory reservation\n\n      Meteor.call(\"inventory/clearReserve\", [cartItem]); // Calculate discounts\n\n      Hooks.Events.run(\"afterCartUpdateCalculateDiscount\", cart._id); // TODO: HACK: When calling update shipping the changes to the cart have not taken place yet\n      // TODO: But calling this findOne seems to force this record to update. Extra weird since we aren't\n      // TODO: passing the Cart but just the cartId and regrabbing it so you would think that would work but it does not\n\n      Collections.Cart.findOne(cart._id); // refresh shipping quotes\n\n      Meteor.call(\"shipping/updateShipmentQuotes\", cart._id); // revert workflow\n\n      Meteor.call(\"workflow/revertCartWorkflow\", \"coreCheckoutShipping\"); // reset selected shipment method\n\n      Meteor.call(\"cart/resetShipmentMethod\", cart._id); // Calculate taxes\n\n      Hooks.Events.run(\"afterCartUpdateCalculateTaxes\", cart._id);\n      return cartResult;\n    } // if quantity lets convert to negative and increment\n\n\n    const removeQuantity = Math.abs(quantity) * -1;\n    let cartResult;\n\n    try {\n      cartResult = Collections.Cart.update({\n        \"_id\": cart._id,\n        \"items._id\": cartItem._id\n      }, {\n        $inc: {\n          \"items.$.quantity\": removeQuantity\n        }\n      });\n    } catch (error) {\n      Logger.error(\"Error removing from cart.\", error);\n      Logger.error(\"Error removing from cart. Invalid keys:\", Collections.Cart.simpleSchema().namedContext().validationErrors());\n      throw error;\n    } // Clear inventory status for multiple instances of this item\n    // If quantity is provided, then set cartItem to it, so that quantity\n    // provided will be cleared in the inventory.\n\n\n    cartItem.quantity = quantity;\n    Meteor.call(\"inventory/clearReserve\", [cartItem]); // Calculate discounts\n\n    Hooks.Events.run(\"afterCartUpdateCalculateDiscount\", cart._id);\n    Logger.debug(`cart: removed variant ${cartItem._id} quantity of ${quantity}`); // refresh shipping quotes\n\n    Meteor.call(\"shipping/updateShipmentQuotes\", cart._id); // revert workflow\n\n    Meteor.call(\"workflow/revertCartWorkflow\", \"coreCheckoutShipping\"); // reset selected shipment method\n\n    Meteor.call(\"cart/resetShipmentMethod\", cart._id); // Calculate taxes\n\n    Hooks.Events.run(\"afterCartUpdateCalculateTaxes\", cart._id);\n    return cartResult;\n  },\n\n  /**\n   * @method cart/setShipmentMethod\n   * @memberof Methods/Cart\n   * @summary Saves method as order default\n   * @param {String} cartId - cartId to apply shipmentMethod\n   * @param {Object} method - shipmentMethod object\n   * @return {Number} return Mongo update result\n   */\n  \"cart/setShipmentMethod\"(cartId, method) {\n    check(cartId, String);\n    Reaction.Schemas.ShippingMethod.validate(method); // get current cart\n\n    const cart = Collections.Cart.findOne({\n      _id: cartId,\n      userId: Meteor.userId()\n    });\n\n    if (!cart) {\n      Logger.error(`Cart not found for user: ${this.userId}`);\n      throw new Meteor.Error(\"not-found\", \"Cart not found for user with such id\");\n    } // Sets all shipping methods to the one selected\n    // TODO: Accept an object of shopId to method map to ship via different methods per shop\n\n\n    let update; // if we have an existing item update it, otherwise add to set.\n\n    if (cart.shipping) {\n      const shipping = cart.shipping.map(shipRecord => (0, _objectSpread2.default)({}, shipRecord, {\n        shipmentMethod: method\n      }));\n      update = {\n        $set: {\n          shipping\n        }\n      };\n    } else {\n      update = {\n        $addToSet: {\n          shipping: {\n            shipmentMethod: method,\n            shopId: cart.shopId\n          }\n        }\n      };\n    } // update or insert method\n\n\n    try {\n      Collections.Cart.update({\n        _id: cartId\n      }, update);\n    } catch (e) {\n      Logger.error(e, `Error adding rates to cart ${cartId}`);\n      throw new Meteor.Error(\"server-error\", \"An error occurred saving the order\", e);\n    } // Calculate discounts\n\n\n    Hooks.Events.run(\"afterCartUpdateCalculateDiscount\", cart._id); // this will transition to review\n\n    return Meteor.call(\"workflow/pushCartWorkflow\", \"coreCartWorkflow\", \"coreCheckoutShipping\");\n  },\n\n  /**\n   * @method cart/setUserCurrency\n   * @memberof Methods/Cart\n   * @summary Saves user currency in cart, to be paired with order/setCurrencyExhange\n   * @param {String} cartId - cartId to apply setUserCurrency\n   * @param {String} userCurrency - userCurrency to set to cart\n   * @return {Number} update result\n   */\n  \"cart/setUserCurrency\"(cartId, userCurrency) {\n    check(cartId, String);\n    check(userCurrency, String);\n    const cart = Collections.Cart.findOne({\n      _id: cartId\n    });\n\n    if (!cart) {\n      Logger.error(`Cart not found for user: ${this.userId}`);\n      throw new Meteor.Error(\"not-found\", \"Cart not found for user with such id\");\n    }\n\n    const userCurrencyString = {\n      userCurrency\n    };\n    let selector;\n    let update;\n\n    if (cart.billing) {\n      selector = {\n        \"_id\": cartId,\n        \"billing._id\": cart.billing[0]._id\n      };\n      update = {\n        $set: {\n          \"billing.$.currency\": userCurrencyString\n        }\n      };\n    } else {\n      selector = {\n        _id: cartId\n      };\n      update = {\n        $addToSet: {\n          billing: {\n            currency: userCurrencyString\n          }\n        }\n      };\n    } // add / or set the shipping address\n\n\n    try {\n      Collections.Cart.update(selector, update);\n    } catch (e) {\n      Logger.error(e);\n      throw new Meteor.Error(\"server-error\", \"An error occurred adding the currency\");\n    } // Calculate discounts\n\n\n    Hooks.Events.run(\"afterCartUpdateCalculateDiscount\", cart._id);\n    return true;\n  },\n\n  /**\n   * @method cart/resetShipmentMethod\n   * @memberof Methods/Cart\n   * @summary Removes `shipmentMethod` object from cart\n   * @param {String} cartId - cart _id\n   * @return {Number} update result\n   */\n  \"cart/resetShipmentMethod\"(cartId) {\n    check(cartId, String);\n    const cart = Collections.Cart.findOne({\n      _id: cartId,\n      userId: this.userId\n    });\n\n    if (!cart) {\n      Logger.error(`Cart not found for user: ${this.userId}`);\n      throw new Meteor.Error(\"not-found\", `Cart: ${cartId} not found for user: ${this.userId}`);\n    }\n\n    return Collections.Cart.update({\n      _id: cartId\n    }, {\n      $unset: {\n        \"shipping.0.shipmentMethod\": \"\"\n      }\n    });\n  },\n\n  /**\n   * @method cart/setShipmentAddress\n   * @memberof Methods/Cart\n   * @summary Adds address book to cart shipping\n   * @param {String} cartId - cartId to apply shipmentMethod\n   * @param {Object} address - addressBook object\n   * @return {Number} update result\n   */\n  \"cart/setShipmentAddress\"(cartId, address) {\n    check(cartId, String);\n    Reaction.Schemas.Address.validate(address);\n    const cart = Collections.Cart.findOne({\n      _id: cartId,\n      userId: this.userId\n    });\n\n    if (!cart) {\n      Logger.error(`Cart not found for user: ${this.userId}`);\n      throw new Meteor.Error(\"not-found\", \"Cart not found for user with such id\");\n    } // TODO: When we have a front end for doing more than one address\n    // TODO: we need to not use the same address for every record\n    // TODO: this is a temporary workaround so that we have a valid address\n    // TODO: for every shipping record\n\n\n    let selector;\n    let update;\n    let updated = false; // if we update inline set to true, otherwise fault to update at the end\n    // We have two behaviors depending on if we have existing shipping records and if we\n    // have items in the cart.\n\n    if (cart.shipping && cart.shipping.length > 0 && cart.items) {\n      // if we have shipping records and cart.items, update each one by shop\n      const shopIds = Object.keys(cart.getItemsByShop());\n      shopIds.forEach(shopId => {\n        selector = {\n          \"_id\": cartId,\n          \"shipping.shopId\": shopId\n        };\n        update = {\n          $set: {\n            \"shipping.$.address\": address\n          }\n        };\n\n        try {\n          Collections.Cart.update(selector, update);\n          updated = true;\n        } catch (error) {\n          Logger.error(error, \"An error occurred adding the address\");\n          throw new Meteor.Error(error, \"An error occurred adding the address\");\n        }\n      });\n    } else if (!cart.items) {\n      // if no items in cart just add or modify one record for the carts shop\n      // add a shipping record if it doesn't exist\n      if (!cart.shipping) {\n        selector = {\n          _id: cartId\n        };\n        update = {\n          $push: {\n            shipping: {\n              address,\n              shopId: cart.shopId\n            }\n          }\n        };\n\n        try {\n          Collections.Cart.update(selector, update);\n          updated = true;\n        } catch (error) {\n          Logger.error(error);\n          throw new Meteor.Error(\"server-error\", \"An error occurred adding the address\");\n        }\n      } else {\n        // modify an existing record if we have one already\n        selector = {\n          \"_id\": cartId,\n          \"shipping.shopId\": cart.shopId\n        };\n        update = {\n          $set: {\n            \"shipping.$.address\": address\n          }\n        };\n      }\n    } else {\n      // if we have items in the cart but we didn't have existing shipping records\n      // add a record for each shop that's represented in the items\n      const shopIds = Object.keys(cart.getItemsByShop());\n      shopIds.forEach(shopId => {\n        selector = {\n          _id: cartId\n        };\n        update = {\n          $addToSet: {\n            shipping: {\n              address,\n              shopId\n            }\n          }\n        };\n      });\n    }\n\n    if (!updated) {\n      // if we didn't do one of the inline updates, then run the update here\n      try {\n        Collections.Cart.update(selector, update);\n      } catch (error) {\n        Logger.error(error);\n        throw new Meteor.Error(\"server-error\", \"An error occurred adding the address\");\n      }\n    } // refresh shipping quotes\n\n\n    Meteor.call(\"shipping/updateShipmentQuotes\", cartId); // Calculate discounts\n\n    Hooks.Events.run(\"afterCartUpdateCalculateDiscount\", cartId); // Calculate taxes\n\n    Hooks.Events.run(\"afterCartUpdateCalculateTaxes\", cartId);\n\n    if (typeof cart.workflow !== \"object\") {\n      throw new Meteor.Error(\"server-error\", \"Cart workflow object not detected.\");\n    } // ~~it's ok for this to be called multiple times~~\n    // call it only once when we at the `checkoutAddressBook` step\n\n\n    if (typeof cart.workflow.workflow === \"object\" && cart.workflow.workflow.length < 2) {\n      Meteor.call(\"workflow/pushCartWorkflow\", \"coreCartWorkflow\", \"coreCheckoutShipping\");\n    } // if we change default address during further steps, we need to revert\n    // workflow back to `coreCheckoutShipping` step\n\n\n    if (typeof cart.workflow.workflow === \"object\" && cart.workflow.workflow.length > 2) {\n      // \"2\" index of\n      // `coreCheckoutShipping`\n      Meteor.call(\"workflow/revertCartWorkflow\", \"coreCheckoutShipping\");\n    }\n\n    return true;\n  },\n\n  /**\n   * @method cart/setPaymentAddress\n   * @memberof Methods/Cart\n   * @summary Adds addressbook to cart payments\n   * @param {String} cartId - cartId to apply payment address\n   * @param {Object} address - addressBook object\n   * @todo maybe we need to rename this method to `cart/setBillingAddress`?\n   * @return {Number} return Mongo update result\n   */\n  \"cart/setPaymentAddress\"(cartId, address) {\n    check(cartId, String);\n    Reaction.Schemas.Address.validate(address);\n    const cart = Collections.Cart.findOne({\n      _id: cartId,\n      userId: this.userId\n    });\n\n    if (!cart) {\n      Logger.error(`Cart not found for user: ${this.userId}`);\n      throw new Meteor.Error(\"not-found\", \"Cart not found for user with such id\");\n    }\n\n    let selector;\n    let update; // temp hack until we build out multiple billing handlers\n    // if we have an existing item update it, otherwise add to set.\n\n    if (Array.isArray(cart.billing) && cart.billing.length > 0) {\n      selector = {\n        \"_id\": cartId,\n        \"billing._id\": cart.billing[0]._id\n      };\n      update = {\n        $set: {\n          \"billing.$.address\": address\n        }\n      };\n    } else {\n      selector = {\n        _id: cartId\n      };\n      update = {\n        $addToSet: {\n          billing: {\n            address\n          }\n        }\n      };\n    }\n\n    const result = Collections.Cart.update(selector, update); // Calculate discounts\n\n    Hooks.Events.run(\"afterCartUpdateCalculateDiscount\", cartId); // Calculate taxes\n\n    Hooks.Events.run(\"afterCartUpdateCalculateTaxes\", cartId);\n    return result;\n  },\n\n  /**\n   * @method cart/unsetAddresses\n   * @summary Removes address from cart.\n   * @memberof Methods/Cart\n   * @param {String} addressId - address._id\n   * @param {String} userId - cart owner _id\n   * @param {String} [type] - billing default or shipping default\n   * @since 0.10.1\n   * @todo Check if no more address in cart as shipping, we should reset `cartWorkflow` to second step\n   * @return {Number|Object|Boolean} The number of removed documents or\n   * error object or `false` if we don't need to update cart\n   */\n  \"cart/unsetAddresses\"(addressId, userId, type) {\n    check(addressId, String);\n    check(userId, String);\n    check(type, Match.Optional(String)); // do we actually need to change anything?\n\n    let needToUpdate = false; // we need to revert the workflow after a \"shipping\" address was removed\n\n    let isShippingDeleting = false;\n    const cart = Collections.Cart.findOne({\n      userId\n    });\n    const selector = {\n      _id: cart._id\n    };\n    const update = {\n      $unset: {}\n    }; // user could turn off the checkbox in address to not to be default, then we\n    // receive `type` arg\n\n    if (typeof type === \"string\") {\n      // we assume that the billing/shipping arrays can hold only one element [0]\n      if (cart[type] && typeof cart[type][0].address === \"object\" && cart[type][0].address._id === addressId) {\n        update.$unset[`${type}.0.address`] = \"\";\n        needToUpdate = true;\n        isShippingDeleting = type === \"shipping\";\n      }\n    } else {\n      // or if we remove address itself, when we run this part we assume\n      // that the billing/shipping arrays can hold only one element [0]\n      if (cart.billing && typeof cart.billing[0].address === \"object\" && cart.billing[0].address._id === addressId) {\n        update.$unset[\"billing.0.address\"] = \"\";\n        needToUpdate = true;\n      }\n\n      if (cart.shipping && typeof cart.shipping[0].address === \"object\" && cart.shipping[0].address._id === addressId) {\n        removeShippingAddresses(cart);\n        isShippingDeleting = true;\n      }\n    }\n\n    if (needToUpdate) {\n      try {\n        Collections.Cart.update(selector, update);\n      } catch (e) {\n        Logger.error(e);\n        throw new Meteor.Error(\"server-error\", \"Error updating cart\");\n      } // Calculate discounts\n\n\n      Hooks.Events.run(\"afterCartUpdateCalculateDiscount\", cart._id);\n\n      if (isShippingDeleting) {\n        // if we remove shipping address from cart, we need to revert\n        // `cartWorkflow` to the `checkoutAddressBook` step.\n        Meteor.call(\"workflow/revertCartWorkflow\", \"checkoutAddressBook\");\n      }\n    }\n\n    return true;\n  },\n\n  /**\n   * @method cart/submitPayment\n   * @memberof Methods/Cart\n   * @summary Saves a submitted payment to cart, triggers workflow and adds \"paymentSubmitted\" to cart workflow\n   * Note: this method also has a client stub, that forwards to cartCompleted\n   * @param {Object|Array} paymentMethods - an array of paymentMethods or (deprecated) a single paymentMethod object\n   * @return {String} returns update result\n   */\n  \"cart/submitPayment\"(paymentMethods) {\n    PaymentMethodArgument.validate(paymentMethods);\n    const cart = Collections.Cart.findOne({\n      userId: Meteor.userId()\n    });\n    const cartId = cart._id;\n    const cartShipping = cart.getShippingTotal();\n    const cartShippingByShop = cart.getShippingTotalByShop();\n    const cartSubTotal = cart.getSubTotal();\n    const cartSubtotalByShop = cart.getSubtotalByShop();\n    const cartTaxes = cart.getTaxTotal();\n    const cartTaxesByShop = cart.getTaxesByShop();\n    const cartDiscounts = cart.getDiscounts();\n    const cartTotal = cart.getTotal();\n    const cartTotalByShop = cart.getTotalByShop(); // we won't actually close the order at this stage.\n    // we'll just update the workflow and billing data where\n    // method-hooks can process the workflow update.\n    // Find the payment address associated that the user input during the\n    // checkout process\n\n    let paymentAddress;\n\n    if (Array.isArray(cart.billing) && cart.billing[0]) {\n      paymentAddress = cart.billing[0].address;\n    }\n\n    const payments = []; // Payment plugins which have been updated for marketplace are passing an array as paymentMethods\n\n    if (Array.isArray(paymentMethods)) {\n      paymentMethods.forEach(paymentMethod => {\n        const {\n          shopId\n        } = paymentMethod;\n        const invoice = {\n          shipping: parseFloat(cartShippingByShop[shopId]),\n          subtotal: parseFloat(cartSubtotalByShop[shopId]),\n          taxes: parseFloat(cartTaxesByShop[shopId]),\n          discounts: parseFloat(cartDiscounts),\n          total: parseFloat(cartTotalByShop[shopId])\n        };\n        payments.push({\n          paymentMethod,\n          invoice,\n          address: paymentAddress,\n          shopId\n        });\n      });\n    } else {\n      // Legacy payment integration - transactions are not split by shop\n      // Create an invoice based on cart totals.\n      const invoice = {\n        shipping: cartShipping,\n        subtotal: cartSubTotal,\n        taxes: cartTaxes,\n        discounts: cartDiscounts,\n        total: cartTotal\n      }; // Legacy payment plugins are passing in a single paymentMethod object\n\n      payments.push({\n        paymentMethod: paymentMethods,\n        invoice,\n        address: paymentAddress,\n        shopId: Reaction.getPrimaryShopId()\n      });\n    } // e.g. discount records would be already present on the billing array. Add to the end of the array.\n\n\n    const discountRecords = cart.billing.filter(billingInfo => billingInfo.paymentMethod);\n    payments.push(...discountRecords);\n    const selector = {\n      _id: cartId\n    };\n    const update = {\n      $set: {\n        billing: payments\n      }\n    };\n\n    try {\n      Collections.Cart.update(selector, update);\n    } catch (e) {\n      Logger.error(e);\n      throw new Meteor.Error(\"server-error\", \"An error occurred saving the order\");\n    } // Calculate discounts\n\n\n    Hooks.Events.run(\"afterCartUpdateCalculateDiscount\", cartId); // Calculate taxes\n\n    Hooks.Events.run(\"afterCartUpdateCalculateTaxes\", cartId);\n    return Collections.Cart.findOne(selector);\n  },\n\n  /**\n   * @method cart/setAnonymousUserEmail\n   * @memberof Methods/Cart\n   * @summary Assigns email to anonymous user's cart instance\n   * @param {Object} userId - current user's Id\n   * @param {String} email - email to set for anonymous user's cart instance\n   * @return {Number} returns update result\n   */\n  \"cart/setAnonymousUserEmail\"(userId, email) {\n    check(userId, String);\n    check(email, String);\n    const currentUserCart = Collections.Cart.findOne({\n      userId\n    });\n    const cartId = currentUserCart._id;\n    let newEmail = \"\";\n\n    if (!currentUserCart.email) {\n      newEmail = email;\n    }\n\n    return Collections.Cart.update({\n      _id: cartId\n    }, {\n      $set: {\n        email: newEmail\n      }\n    });\n  }\n\n});","map":{"version":3,"sources":["server/methods/core/cart.js"],"names":["_find","module","watch","require","default","v","Meteor","check","Match","Roles","Random","Collections","Hooks","Logger","Reaction","PaymentMethodArgument","quantityProcessing","product","variant","itemQty","quantity","MIN","minOrderQuantity","MAX","inventoryQuantity","Infinity","inventoryPolicy","debug","_id","Error","type","getSessionCarts","userId","sessionId","shopId","carts","Cart","find","$and","$ne","$eq","allowedCarts","forEach","cart","userIsInRole","push","removeShippingAddresses","cartShipping","shipping","map","sRecord","address","update","$set","Events","run","methods","cartId","currentSessionId","String","Optional","currentCart","findOne","getShopId","sessionCarts","sessionCart","items","workflow","length","call","cartSum","concat","mergedItems","reduce","newItems","item","existingItem","cartItem","variants","$push","$each","$slice","remove","Accounts","users","status","marketplaceSettings","getMarketplaceSettings","public","merchantCart","getPrimaryShopId","anonymousUser","sessionCartCount","currentCartId","insert","account","profile","addressBook","isBillingDefault","isShippingDefault","currentUser","user","userCurrency","getShopCurrency","currency","productId","variantId","additionalOptions","Number","Object","options","overwriteExistingMetafields","metafields","undefined","error","Products","$in","doc","warn","cartVariantExists","some","modifier","updateResult","$inc","simpleSchema","namedContext","validationErrors","immediateAncestors","ancestors","filter","ancestor","immediateAncestor","parcel","weight","height","width","newItemId","id","$addToSet","title","itemId","cartResult","$pull","getAutoValues","removeQuantity","Math","abs","method","Schemas","ShippingMethod","validate","shipRecord","shipmentMethod","e","userCurrencyString","selector","billing","$unset","Address","updated","shopIds","keys","getItemsByShop","Array","isArray","result","addressId","needToUpdate","isShippingDeleting","paymentMethods","getShippingTotal","cartShippingByShop","getShippingTotalByShop","cartSubTotal","getSubTotal","cartSubtotalByShop","getSubtotalByShop","cartTaxes","getTaxTotal","cartTaxesByShop","getTaxesByShop","cartDiscounts","getDiscounts","cartTotal","getTotal","cartTotalByShop","getTotalByShop","paymentAddress","payments","paymentMethod","invoice","parseFloat","subtotal","taxes","discounts","total","discountRecords","billingInfo","email","currentUserCart","newEmail"],"mappings":"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","sourcesContent":["import _ from \"lodash\";\nimport { Meteor } from \"meteor/meteor\";\nimport { check, Match } from \"meteor/check\";\nimport { Roles } from \"meteor/alanning:roles\";\nimport { Random } from \"meteor/random\";\nimport * as Collections from \"/lib/collections\";\nimport { Hooks, Logger, Reaction } from \"/server/api\";\nimport { PaymentMethodArgument } from \"/lib/collections/schemas\";\n\n/**\n * @method quantityProcessing\n * @private\n * @summary Perform calculations admissibility of adding product to cart\n * @param {Object} product - product to add to Cart\n * @param {Object} variant - product variant\n * @param {Number} itemQty - qty to add to cart, defaults to 1, deducts\n *  from inventory\n * @since 1.10.1\n * @return {Number} quantity - revised quantity to be added to cart\n */\nfunction quantityProcessing(product, variant, itemQty = 1) {\n  let quantity = itemQty;\n  const MIN = variant.minOrderQuantity || 1;\n  const MAX = variant.inventoryQuantity || Infinity;\n\n  if (variant.inventoryPolicy && MIN > MAX) {\n    Logger.debug(`productId: ${product._id}, variantId ${variant._id\n    }: inventoryQuantity lower then minimum order`);\n    throw new Meteor.Error(\"invalid-parameter\", `productId: ${product._id}, variantId ${variant._id\n    }: inventoryQuantity lower then minimum order`);\n  }\n\n  // TODO: think about #152 implementation here\n  switch (product.type) {\n    case \"not-in-stock\":\n      break;\n    default: // type: `simple` // todo: maybe it should be \"variant\"\n      if (quantity < MIN) {\n        quantity = MIN;\n      } else if (variant.inventoryPolicy && quantity > MAX) {\n        quantity = MAX;\n      }\n  }\n\n  return quantity;\n}\n\n/**\n * @method getSessionCarts\n * @private\n * @summary Get Cart cursor with all session carts\n * @param {String} userId - current user _id\n * @param {String} sessionId - current user session id\n * @param {String} shopId - shop id\n * @since 0.10.2\n * @return {Mongo.Cursor} with array of session carts\n */\nfunction getSessionCarts(userId, sessionId, shopId) {\n  const carts = Collections.Cart.find({\n    $and: [{\n      userId: {\n        $ne: userId\n      }\n    }, {\n      sessionId: {\n        $eq: sessionId\n      }\n    }, {\n      shopId: {\n        $eq: shopId\n      }\n    }]\n  });\n\n  // we can't use Array.map here, because we need to reduce the number of array\n  // elements if element belongs to registered user, we should throw it.\n  const allowedCarts = [];\n\n  // only anonymous user carts allowed\n  carts.forEach((cart) => {\n    if (Roles.userIsInRole(cart.userId, \"anonymous\", shopId)) {\n      allowedCarts.push(cart);\n    }\n  });\n\n  return allowedCarts;\n}\n\n/**\n * @method removeShippingAddresses\n * @private\n * @summary Remove shipping address from cart\n * @param {String} cart - current cart\n * @return null\n */\nfunction removeShippingAddresses(cart) {\n  const cartShipping = cart.shipping;\n  cartShipping.map((sRecord) => delete sRecord.address);\n  Collections.Cart.update({\n    _id: cart._id\n  }, {\n    $set: { shipping: cartShipping }\n  });\n\n  // Calculate discounts\n  Hooks.Events.run(\"afterCartUpdateCalculateDiscount\", cart._id);\n\n  // Calculate taxes\n  Hooks.Events.run(\"afterCartUpdateCalculateTaxes\", cart._id);\n}\n\n/**\n * @file Methods for Cart - Use these methods by running `Meteor.call()`\n * @example Meteor.call(\"cart/createCart\", this.userId, sessionId)\n * @namespace Methods/Cart\n */\n\nMeteor.methods({\n  /**\n   * @method cart/mergeCart\n   * @summary Merge matching sessionId cart into specified userId cart\n   * There should be one cart for each independent, non-logged-in user session.\n   * When a user logs in that cart now belongs to that user and we use the a single user cart.\n   * If they are logged in on more than one devices, regardless of session,the user cart will be used\n   * If they had more than one cart, on more than one device,logged in at separate times then merge the carts\n   * @memberof Methods/Cart\n   * @param {String} cartId - cartId of the cart to merge matching session carts into.\n   * @param {String} [currentSessionId] - current client session id\n   * @todo I think this method should be moved out from methods to a Function Declaration to keep it more secure\n   * @return {Object|Boolean} cartId - cartId on success or false\n   */\n  \"cart/mergeCart\"(cartId, currentSessionId) {\n    check(cartId, String);\n    // TODO: Review this. currentSessionId sometimes come in as false. e.g from Accounts.onLogin\n    check(currentSessionId, Match.Optional(String));\n\n    // we don't process current cart, but merge into it.\n    const currentCart = Collections.Cart.findOne(cartId);\n    if (!currentCart) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n    // just used to filter out the current cart\n    // we do additional check of cart exists here and if it not exist, next\n    // check supposed to throw 403 error\n    const userId = currentCart && currentCart.userId;\n    // user should have an access to operate with only one - his - cart\n    if (this.userId !== null && userId !== this.userId) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n    // persistent sessions, see: publications/sessions.js\n    // this is the last place where we still need `Reaction.sessionId`.\n    // The use case is: on user log in. I don't know how pass `sessionId` down\n    // at that moment.\n    const sessionId = currentSessionId || Reaction.sessionId;\n    const shopId = Reaction.getShopId();\n\n    // no need to merge anonymous carts\n    if (Roles.userIsInRole(userId, \"anonymous\", shopId)) {\n      return false;\n    }\n    Logger.debug(\"merge cart: matching sessionId\");\n    Logger.debug(\"current userId:\", userId);\n    Logger.debug(\"sessionId:\", sessionId);\n    // get session carts without current user cart cursor\n    const sessionCarts = getSessionCarts(userId, sessionId, shopId);\n\n    Logger.debug(`merge cart: begin merge processing of session ${\n      sessionId} into: ${currentCart._id}`);\n    // loop through session carts and merge into user cart\n    sessionCarts.forEach((sessionCart) => {\n      Logger.debug(`merge cart: merge user userId: ${userId}, sessionCart.userId: ${\n        sessionCart.userId}, sessionCart id: ${sessionCart._id}`);\n      // really if we have no items, there's nothing to merge\n      if (sessionCart.items) {\n        // if currentCart already have a cartWorkflow, we don't need to clean it\n        // up completely, just to `coreCheckoutShipping` stage. Also, we will\n        // need to recalculate shipping rates\n        if (typeof currentCart.workflow === \"object\" &&\n        typeof currentCart.workflow.workflow === \"object\") {\n          if (currentCart.workflow.workflow.length > 2) {\n            Meteor.call(\"workflow/revertCartWorkflow\", \"coreCheckoutShipping\");\n            // refresh shipping quotes\n            Meteor.call(\"shipping/updateShipmentQuotes\", cartId);\n          }\n        } else {\n          // if user logged in he doesn't need to show `checkoutLogin` step\n          Meteor.call(\"workflow/revertCartWorkflow\", \"checkoutAddressBook\");\n        }\n\n        const cartSum = sessionCart.items.concat(currentCart.items);\n        const mergedItems = cartSum.reduce((newItems, item) => {\n          if (item) {\n            const existingItem = newItems.find((cartItem) => cartItem.variants._id === item.variants._id);\n            if (existingItem) {\n              existingItem.quantity += item.quantity;\n            } else {\n              newItems.push(item);\n            }\n          }\n          return newItems;\n        }, []);\n        Collections.Cart.update(currentCart._id, {\n          $push: {\n            items: { $each: mergedItems, $slice: -(mergedItems.length) }\n          }\n        });\n\n        // Calculate discounts\n        Hooks.Events.run(\"afterCartUpdateCalculateDiscount\", currentCart._id);\n      }\n\n      // cleanup session Carts after merge.\n      if (sessionCart.userId !== this.userId) {\n        // clear the cart that was used for a session\n        // and we're also going to do some garbage Collection\n        Collections.Cart.remove(sessionCart._id);\n        // cleanup user/accounts\n        Collections.Accounts.remove({\n          userId: sessionCart.userId\n        });\n        Hooks.Events.run(\"afterAccountsRemove\", this.userId, sessionCart.userId);\n        Meteor.users.remove(sessionCart.userId);\n        Logger.debug(`merge cart: delete cart ${\n          sessionCart._id} and user: ${sessionCart.userId}`);\n      }\n      Logger.debug(`merge cart: processed merge for cartId ${sessionCart._id}`);\n    });\n\n    // `checkoutLogin` should be used for anonymous only. Registered users\n    // no need see this.\n    if (currentCart.workflow && currentCart.workflow.status === \"new\") {\n      // to call `workflow/pushCartWorkflow` two times is the only way to move\n      // from status \"new\" to \"checkoutAddressBook\" which I found without\n      // refactoring of `workflow/pushCartWorkflow`\n      // We send `cartId` as arguments because this method could be called from\n      // publication method and in half cases it could be so, that\n      // Meteor.userId() will be null.\n      Meteor.call(\n        \"workflow/pushCartWorkflow\", \"coreCartWorkflow\",\n        \"checkoutLogin\", cartId\n      );\n      Meteor.call(\n        \"workflow/pushCartWorkflow\", \"coreCartWorkflow\",\n        \"checkoutAddressBook\", cartId\n      );\n    }\n\n    return currentCart._id;\n  },\n\n  /**\n   * @method cart/createCart\n   * @summary create new cart for user,\n   * but all checks for current cart's existence should go before this method will be called, to keep it clean\n   * @memberof Methods/Cart\n   * @param {String} userId - userId to create cart for\n   * @param {String} sessionId - current client session id\n   * @todo I think this method should be moved out from methods to a Function Declaration to keep it more secure\n   * @returns {String} cartId - users cartId\n   */\n  \"cart/createCart\"(userId, sessionId) {\n    check(userId, String);\n    check(sessionId, String);\n\n    const marketplaceSettings = Reaction.getMarketplaceSettings();\n    let shopId;\n    if (marketplaceSettings && marketplaceSettings.public && marketplaceSettings.public.merchantCart) {\n      shopId = Reaction.getShopId();\n    } else {\n      shopId = Reaction.getPrimaryShopId();\n    }\n\n    // check if user has `anonymous` role.( this is a visitor)\n    const anonymousUser = Roles.userIsInRole(userId, \"anonymous\", shopId);\n    const sessionCartCount = getSessionCarts(userId, sessionId, shopId).length;\n\n    Logger.debug(\"create cart: shopId\", shopId);\n    Logger.debug(\"create cart: userId\", userId);\n    Logger.debug(\"create cart: sessionId\", sessionId);\n    Logger.debug(\"create cart: sessionCarts.count\", sessionCartCount);\n    Logger.debug(\"create cart: anonymousUser\", anonymousUser);\n\n    // we need to create a user cart for the new authenticated user or\n    // anonymous.\n    const currentCartId = Collections.Cart.insert({\n      sessionId,\n      userId\n    });\n    Logger.debug(`create cart: into new user cart. created: ${currentCartId} for user ${userId}`);\n\n    // merge session carts into the current cart\n    if (sessionCartCount > 0 && !anonymousUser) {\n      Logger.debug(`create cart: found existing cart. merge into ${currentCartId} for user ${userId}`);\n      Meteor.call(\"cart/mergeCart\", currentCartId, sessionId);\n    }\n\n    // we should check for an default billing/shipping address in user account.\n    // this needed after submitting order, when user receives new cart\n    const account = Collections.Accounts.findOne(userId);\n    if (account && account.profile && account.profile.addressBook) {\n      account.profile.addressBook.forEach((address) => {\n        if (address.isBillingDefault) {\n          Meteor.call(\"cart/setPaymentAddress\", currentCartId, address);\n        }\n        if (address.isShippingDefault) {\n          Meteor.call(\"cart/setShipmentAddress\", currentCartId, address);\n        }\n      });\n    }\n\n    // attach current user currency to cart\n    const currentUser = Meteor.user();\n    let userCurrency = Reaction.getShopCurrency();\n\n    // Check to see if the user has a custom currency saved to their profile\n    // Use it if they do\n    if (currentUser && currentUser.profile && currentUser.profile.currency) {\n      userCurrency = currentUser.profile.currency;\n    }\n    Meteor.call(\"cart/setUserCurrency\", currentCartId, userCurrency);\n\n    return currentCartId;\n  },\n\n  /**\n   *  @method cart/addToCart\n   *  @summary Add items to a user cart. When we add an item to the cart,\n   *  we want to break all relationships with the existing item.\n   *  We want to fix price, qty, etc into history.\n   *  However, we could check reactively for price /qty etc, adjustments on the original and notify them.\n   *  @memberof Methods/Cart\n   *  @param {String} productId - productId to add to Cart\n   *  @param {String} variantId - product variant _id\n   *  @param {Number} [itemQty] - qty to add to cart\n   *  @param {Object} [additionalOptions] - object containing additional options and fields for cart item\n   *  @return {Number|Object} Mongo insert response\n   */\n  \"cart/addToCart\"(productId, variantId, itemQty, additionalOptions) {\n    check(productId, String);\n    check(variantId, String);\n    check(itemQty, Match.Optional(Number));\n    check(additionalOptions, Match.Optional(Object));\n\n    // Copy additionalOptions into an options object to use througout the method\n    const options = {\n      overwriteExistingMetafields: false, // Allows updating of metafields on quantity change\n      metafields: undefined, // Array of MetaFields to set on the CartItem\n      ...additionalOptions || {}\n    };\n\n    const cart = Collections.Cart.findOne({ userId: this.userId });\n    if (!cart) {\n      Logger.error(`Cart not found for user: ${this.userId}`);\n      throw new Meteor.Error(\n        \"invalid-parameter\",\n        \"Cart not found for user with such id\"\n      );\n    }\n    // With the flattened model we no longer need to work directly with the\n    // products. But product still could be necessary for a `quantityProcessing`\n    // TODO: need to understand: do we really need product inside\n    // `quantityProcessing`?\n    let product;\n    let variant;\n    Collections.Products.find({\n      _id: {\n        $in: [\n          productId,\n          variantId\n        ]\n      }\n    }).forEach((doc) => {\n      if (doc.type === \"simple\") {\n        product = doc;\n      } else {\n        variant = doc;\n      }\n    });\n\n    // TODO: this lines still needed. We could uncomment them in future if\n    // decide to not completely remove product data from this method\n    // const product = Collections.Products.findOne(productId);\n    // const variant = Collections.Products.findOne(variantId);\n    if (!product) {\n      Logger.warn(`Product: ${productId} was not found in database`);\n      throw new Meteor.Error(\n        \"not-found\",\n        \"Product with such id was not found\"\n      );\n    }\n    if (!variant) {\n      Logger.warn(`Product variant: ${variantId} was not found in database`);\n      throw new Meteor.Error(\n        \"not-found\",\n        \"ProductVariant with such id was not found\"\n      );\n    }\n    // performs calculations admissibility of adding product to cart\n    const quantity = quantityProcessing(product, variant, itemQty);\n    // performs search of variant inside cart\n    const cartVariantExists = cart.items && cart.items\n      .some((item) => item.variants._id === variantId);\n\n    if (cartVariantExists) {\n      let modifier = {};\n\n      // Allows for updating metafields on an existing item when the quantity also changes\n      if (options.overwriteExistingMetafields) {\n        modifier = {\n          $set: {\n            \"items.$.metafields\": options.metafields\n          }\n        };\n      }\n\n      let updateResult;\n\n      try {\n        updateResult = Collections.Cart.update({\n          \"_id\": cart._id,\n          \"items.product._id\": productId,\n          \"items.variants._id\": variantId\n        }, {\n          $inc: {\n            \"items.$.quantity\": quantity\n          },\n          ...modifier\n        });\n      } catch (error) {\n        Logger.error(\"Error adding to cart.\", error);\n        Logger.error(\n          \"Error adding to cart. Invalid keys:\",\n          Collections.Cart.simpleSchema().namedContext().validationErrors()\n        );\n        throw error;\n      }\n\n      // Update inventory\n      Hooks.Events.run(\"afterModifyQuantityInCart\", cart._id, { productId, variantId });\n      // Calculate discounts\n      Hooks.Events.run(\"afterCartUpdateCalculateDiscount\", cart._id);\n      // refresh shipping quotes\n      Meteor.call(\"shipping/updateShipmentQuotes\", cart._id);\n      // revert workflow to checkout shipping step.\n      Meteor.call(\"workflow/revertCartWorkflow\", \"coreCheckoutShipping\");\n      // reset selected shipment method\n      Meteor.call(\"cart/resetShipmentMethod\", cart._id);\n      // Calculate taxes\n      Hooks.Events.run(\"afterCartUpdateCalculateTaxes\", cart._id);\n\n      Logger.debug(`cart: increment variant ${variantId} quantity by ${quantity}`);\n\n      return updateResult;\n    }\n\n    // TODO: Handle more than 2 levels of variant hierarchy for determining parcel dimensions\n    // we need to get the parent of the option to check if parcel info is stored there\n    const immediateAncestors = variant.ancestors.filter((ancestor) => ancestor !== product._id);\n    const immediateAncestor = Collections.Products.findOne({ _id: immediateAncestors[0] });\n    let parcel = null;\n    if (immediateAncestor) {\n      if (immediateAncestor.weight || immediateAncestor.height || immediateAncestor.width || immediateAncestor.length) {\n        parcel = { weight: immediateAncestor.weight, height: immediateAncestor.height, width: immediateAncestor.width, length: immediateAncestor.length };\n      }\n    }\n    // if it's set at the option level then that overrides\n    if (variant.weight || variant.height || variant.width || variant.length) {\n      parcel = { weight: variant.weight, height: variant.height, width: variant.width, length: variant.length };\n    }\n    // cart variant doesn't exist\n    let updateResult;\n    const newItemId = Random.id();\n\n    try {\n      updateResult = Collections.Cart.update({\n        _id: cart._id\n      }, {\n        $addToSet: {\n          items: {\n            _id: newItemId,\n            shopId: product.shopId,\n            productId,\n            quantity,\n            product,\n            variants: variant,\n            metafields: options.metafields,\n            title: product.title,\n            type: product.type,\n            parcel\n          }\n        }\n      });\n    } catch (error) {\n      Logger.error(\"Error adding to cart.\", error);\n      Logger.error(\n        \"Error adding to cart. Invalid keys:\",\n        Collections.Cart.simpleSchema().namedContext().validationErrors()\n      );\n      throw error;\n    }\n\n    // Update add inventory reserve\n    Hooks.Events.run(\"afterAddItemsToCart\", cart._id, { newItemId });\n    // Calculate discounts\n    Hooks.Events.run(\"afterCartUpdateCalculateDiscount\", cart._id);\n    // refresh shipping quotes\n    Meteor.call(\"shipping/updateShipmentQuotes\", cart._id);\n    // revert workflow to checkout shipping step.\n    Meteor.call(\"workflow/revertCartWorkflow\", \"coreCheckoutShipping\");\n    // reset selected shipment method\n    Meteor.call(\"cart/resetShipmentMethod\", cart._id);\n    // Calculate taxes\n    Hooks.Events.run(\"afterCartUpdateCalculateTaxes\", cart._id);\n\n    Logger.debug(`cart: add variant ${variantId} to cartId ${cart._id}`);\n\n    return updateResult;\n  },\n\n  /**\n   * @method cart/removeFromCart\n   * @memberof Methods/Cart\n   * @summary Removes or adjust quantity of a variant from the cart\n   * @param {String} itemId - cart item _id\n   * @param {Number} [quantity] - if provided will adjust increment by quantity\n   * @returns {Number} returns Mongo update result\n   */\n  \"cart/removeFromCart\"(itemId, quantity) {\n    check(itemId, String);\n    check(quantity, Match.Optional(Number));\n\n    const userId = Meteor.userId();\n    const cart = Collections.Cart.findOne({ userId });\n    if (!cart) {\n      Logger.error(`Cart not found for user: ${this.userId}`);\n      throw new Meteor.Error(\"not-found\", \"Cart not found for user with such id\");\n    }\n\n    let cartItem;\n\n    if (cart.items) {\n      cartItem = _.find(cart.items, (item) => item._id === itemId);\n    }\n\n    // extra check of item exists\n    if (typeof cartItem !== \"object\") {\n      Logger.error(`Unable to find an item: ${itemId} within the cart: ${cart._id}`);\n      throw new Meteor.Error(\"not-found\", \"Unable to find an item with such id in cart.\");\n    }\n\n    if (!quantity || quantity >= cartItem.quantity) {\n      let cartResult;\n      try {\n        cartResult = Collections.Cart.update({\n          _id: cart._id\n        }, {\n          $pull: {\n            items: {\n              _id: itemId\n            }\n          }\n        }, {\n          getAutoValues: false // See https://github.com/aldeed/meteor-collection2/issues/245\n        });\n      } catch (error) {\n        Logger.error(\"Error removing from cart.\", error);\n        Logger.error(\n          \"Error removing from cart. Invalid keys:\",\n          Collections.Cart.simpleSchema().namedContext().validationErrors()\n        );\n        throw error;\n      }\n\n      Logger.debug(`cart: deleted cart item variant id ${cartItem.variants._id}`);\n\n      // Clear inventory reservation\n      Meteor.call(\"inventory/clearReserve\", [cartItem]);\n      // Calculate discounts\n      Hooks.Events.run(\"afterCartUpdateCalculateDiscount\", cart._id);\n      // TODO: HACK: When calling update shipping the changes to the cart have not taken place yet\n      // TODO: But calling this findOne seems to force this record to update. Extra weird since we aren't\n      // TODO: passing the Cart but just the cartId and regrabbing it so you would think that would work but it does not\n      Collections.Cart.findOne(cart._id);\n      // refresh shipping quotes\n      Meteor.call(\"shipping/updateShipmentQuotes\", cart._id);\n      // revert workflow\n      Meteor.call(\"workflow/revertCartWorkflow\", \"coreCheckoutShipping\");\n      // reset selected shipment method\n      Meteor.call(\"cart/resetShipmentMethod\", cart._id);\n      // Calculate taxes\n      Hooks.Events.run(\"afterCartUpdateCalculateTaxes\", cart._id);\n      return cartResult;\n    }\n\n    // if quantity lets convert to negative and increment\n    const removeQuantity = Math.abs(quantity) * -1;\n\n    let cartResult;\n    try {\n      cartResult = Collections.Cart.update({\n        \"_id\": cart._id,\n        \"items._id\": cartItem._id\n      }, {\n        $inc: {\n          \"items.$.quantity\": removeQuantity\n        }\n      });\n    } catch (error) {\n      Logger.error(\"Error removing from cart.\", error);\n      Logger.error(\n        \"Error removing from cart. Invalid keys:\",\n        Collections.Cart.simpleSchema().namedContext().validationErrors()\n      );\n      throw error;\n    }\n\n    // Clear inventory status for multiple instances of this item\n    // If quantity is provided, then set cartItem to it, so that quantity\n    // provided will be cleared in the inventory.\n    cartItem.quantity = quantity;\n    Meteor.call(\"inventory/clearReserve\", [cartItem]);\n    // Calculate discounts\n    Hooks.Events.run(\"afterCartUpdateCalculateDiscount\", cart._id);\n    Logger.debug(`cart: removed variant ${cartItem._id} quantity of ${quantity}`);\n    // refresh shipping quotes\n    Meteor.call(\"shipping/updateShipmentQuotes\", cart._id);\n    // revert workflow\n    Meteor.call(\"workflow/revertCartWorkflow\", \"coreCheckoutShipping\");\n    // reset selected shipment method\n    Meteor.call(\"cart/resetShipmentMethod\", cart._id);\n    // Calculate taxes\n    Hooks.Events.run(\"afterCartUpdateCalculateTaxes\", cart._id);\n\n    return cartResult;\n  },\n\n  /**\n   * @method cart/setShipmentMethod\n   * @memberof Methods/Cart\n   * @summary Saves method as order default\n   * @param {String} cartId - cartId to apply shipmentMethod\n   * @param {Object} method - shipmentMethod object\n   * @return {Number} return Mongo update result\n   */\n  \"cart/setShipmentMethod\"(cartId, method) {\n    check(cartId, String);\n    Reaction.Schemas.ShippingMethod.validate(method);\n\n    // get current cart\n    const cart = Collections.Cart.findOne({\n      _id: cartId,\n      userId: Meteor.userId()\n    });\n    if (!cart) {\n      Logger.error(`Cart not found for user: ${this.userId}`);\n      throw new Meteor.Error(\n        \"not-found\",\n        \"Cart not found for user with such id\"\n      );\n    }\n\n    // Sets all shipping methods to the one selected\n    // TODO: Accept an object of shopId to method map to ship via different methods per shop\n    let update;\n    // if we have an existing item update it, otherwise add to set.\n    if (cart.shipping) {\n      const shipping = cart.shipping.map((shipRecord) => ({\n        ...shipRecord,\n        shipmentMethod: method\n      }));\n      update = { $set: { shipping } };\n    } else {\n      update = {\n        $addToSet: {\n          shipping: {\n            shipmentMethod: method,\n            shopId: cart.shopId\n          }\n        }\n      };\n    }\n\n    // update or insert method\n    try {\n      Collections.Cart.update({ _id: cartId }, update);\n    } catch (e) {\n      Logger.error(e, `Error adding rates to cart ${cartId}`);\n      throw new Meteor.Error(\"server-error\", \"An error occurred saving the order\", e);\n    }\n\n\n    // Calculate discounts\n    Hooks.Events.run(\"afterCartUpdateCalculateDiscount\", cart._id);\n\n    // this will transition to review\n    return Meteor.call(\"workflow/pushCartWorkflow\", \"coreCartWorkflow\", \"coreCheckoutShipping\");\n  },\n\n  /**\n   * @method cart/setUserCurrency\n   * @memberof Methods/Cart\n   * @summary Saves user currency in cart, to be paired with order/setCurrencyExhange\n   * @param {String} cartId - cartId to apply setUserCurrency\n   * @param {String} userCurrency - userCurrency to set to cart\n   * @return {Number} update result\n   */\n  \"cart/setUserCurrency\"(cartId, userCurrency) {\n    check(cartId, String);\n    check(userCurrency, String);\n    const cart = Collections.Cart.findOne({ _id: cartId });\n    if (!cart) {\n      Logger.error(`Cart not found for user: ${this.userId}`);\n      throw new Meteor.Error(\"not-found\", \"Cart not found for user with such id\");\n    }\n\n    const userCurrencyString = {\n      userCurrency\n    };\n\n    let selector;\n    let update;\n\n    if (cart.billing) {\n      selector = {\n        \"_id\": cartId,\n        \"billing._id\": cart.billing[0]._id\n      };\n      update = {\n        $set: {\n          \"billing.$.currency\": userCurrencyString\n        }\n      };\n    } else {\n      selector = {\n        _id: cartId\n      };\n      update = {\n        $addToSet: {\n          billing: {\n            currency: userCurrencyString\n          }\n        }\n      };\n    }\n\n    // add / or set the shipping address\n    try {\n      Collections.Cart.update(selector, update);\n    } catch (e) {\n      Logger.error(e);\n      throw new Meteor.Error(\"server-error\", \"An error occurred adding the currency\");\n    }\n\n    // Calculate discounts\n    Hooks.Events.run(\"afterCartUpdateCalculateDiscount\", cart._id);\n\n    return true;\n  },\n\n  /**\n   * @method cart/resetShipmentMethod\n   * @memberof Methods/Cart\n   * @summary Removes `shipmentMethod` object from cart\n   * @param {String} cartId - cart _id\n   * @return {Number} update result\n   */\n  \"cart/resetShipmentMethod\"(cartId) {\n    check(cartId, String);\n\n    const cart = Collections.Cart.findOne({\n      _id: cartId,\n      userId: this.userId\n    });\n    if (!cart) {\n      Logger.error(`Cart not found for user: ${this.userId}`);\n      throw new Meteor.Error(\n        \"not-found\",\n        `Cart: ${cartId} not found for user: ${this.userId}`\n      );\n    }\n\n    return Collections.Cart.update({ _id: cartId }, {\n      $unset: { \"shipping.0.shipmentMethod\": \"\" }\n    });\n  },\n\n  /**\n   * @method cart/setShipmentAddress\n   * @memberof Methods/Cart\n   * @summary Adds address book to cart shipping\n   * @param {String} cartId - cartId to apply shipmentMethod\n   * @param {Object} address - addressBook object\n   * @return {Number} update result\n   */\n  \"cart/setShipmentAddress\"(cartId, address) {\n    check(cartId, String);\n    Reaction.Schemas.Address.validate(address);\n\n    const cart = Collections.Cart.findOne({\n      _id: cartId,\n      userId: this.userId\n    });\n    if (!cart) {\n      Logger.error(`Cart not found for user: ${this.userId}`);\n      throw new Meteor.Error(\n        \"not-found\",\n        \"Cart not found for user with such id\"\n      );\n    }\n    // TODO: When we have a front end for doing more than one address\n    // TODO: we need to not use the same address for every record\n    // TODO: this is a temporary workaround so that we have a valid address\n    // TODO: for every shipping record\n    let selector;\n    let update;\n    let updated = false; // if we update inline set to true, otherwise fault to update at the end\n    // We have two behaviors depending on if we have existing shipping records and if we\n    // have items in the cart.\n    if (cart.shipping && cart.shipping.length > 0 && cart.items) {\n      // if we have shipping records and cart.items, update each one by shop\n      const shopIds = Object.keys(cart.getItemsByShop());\n      shopIds.forEach((shopId) => {\n        selector = {\n          \"_id\": cartId,\n          \"shipping.shopId\": shopId\n        };\n\n        update = {\n          $set: {\n            \"shipping.$.address\": address\n          }\n        };\n        try {\n          Collections.Cart.update(selector, update);\n          updated = true;\n        } catch (error) {\n          Logger.error(error, \"An error occurred adding the address\");\n          throw new Meteor.Error(error, \"An error occurred adding the address\");\n        }\n      });\n    } else if (!cart.items) { // if no items in cart just add or modify one record for the carts shop\n      // add a shipping record if it doesn't exist\n      if (!cart.shipping) {\n        selector = {\n          _id: cartId\n        };\n        update = {\n          $push: {\n            shipping: {\n              address,\n              shopId: cart.shopId\n            }\n          }\n        };\n\n        try {\n          Collections.Cart.update(selector, update);\n          updated = true;\n        } catch (error) {\n          Logger.error(error);\n          throw new Meteor.Error(\"server-error\", \"An error occurred adding the address\");\n        }\n      } else {\n        // modify an existing record if we have one already\n        selector = {\n          \"_id\": cartId,\n          \"shipping.shopId\": cart.shopId\n        };\n\n        update = {\n          $set: {\n            \"shipping.$.address\": address\n          }\n        };\n      }\n    } else {\n      // if we have items in the cart but we didn't have existing shipping records\n      // add a record for each shop that's represented in the items\n      const shopIds = Object.keys(cart.getItemsByShop());\n      shopIds.forEach((shopId) => {\n        selector = {\n          _id: cartId\n        };\n        update = {\n          $addToSet: {\n            shipping: {\n              address,\n              shopId\n            }\n          }\n        };\n      });\n    }\n    if (!updated) {\n      // if we didn't do one of the inline updates, then run the update here\n      try {\n        Collections.Cart.update(selector, update);\n      } catch (error) {\n        Logger.error(error);\n        throw new Meteor.Error(\"server-error\", \"An error occurred adding the address\");\n      }\n    }\n    // refresh shipping quotes\n    Meteor.call(\"shipping/updateShipmentQuotes\", cartId);\n\n    // Calculate discounts\n    Hooks.Events.run(\"afterCartUpdateCalculateDiscount\", cartId);\n\n    // Calculate taxes\n    Hooks.Events.run(\"afterCartUpdateCalculateTaxes\", cartId);\n\n    if (typeof cart.workflow !== \"object\") {\n      throw new Meteor.Error(\n        \"server-error\",\n        \"Cart workflow object not detected.\"\n      );\n    }\n\n    // ~~it's ok for this to be called multiple times~~\n    // call it only once when we at the `checkoutAddressBook` step\n    if (typeof cart.workflow.workflow === \"object\" &&\n      cart.workflow.workflow.length < 2) {\n      Meteor.call(\n        \"workflow/pushCartWorkflow\", \"coreCartWorkflow\",\n        \"coreCheckoutShipping\"\n      );\n    }\n\n    // if we change default address during further steps, we need to revert\n    // workflow back to `coreCheckoutShipping` step\n    if (typeof cart.workflow.workflow === \"object\" &&\n      cart.workflow.workflow.length > 2) { // \"2\" index of\n      // `coreCheckoutShipping`\n      Meteor.call(\"workflow/revertCartWorkflow\", \"coreCheckoutShipping\");\n    }\n\n    return true;\n  },\n\n  /**\n   * @method cart/setPaymentAddress\n   * @memberof Methods/Cart\n   * @summary Adds addressbook to cart payments\n   * @param {String} cartId - cartId to apply payment address\n   * @param {Object} address - addressBook object\n   * @todo maybe we need to rename this method to `cart/setBillingAddress`?\n   * @return {Number} return Mongo update result\n   */\n  \"cart/setPaymentAddress\"(cartId, address) {\n    check(cartId, String);\n    Reaction.Schemas.Address.validate(address);\n\n    const cart = Collections.Cart.findOne({\n      _id: cartId,\n      userId: this.userId\n    });\n\n    if (!cart) {\n      Logger.error(`Cart not found for user: ${this.userId}`);\n      throw new Meteor.Error(\n        \"not-found\",\n        \"Cart not found for user with such id\"\n      );\n    }\n\n    let selector;\n    let update;\n    // temp hack until we build out multiple billing handlers\n    // if we have an existing item update it, otherwise add to set.\n    if (Array.isArray(cart.billing) && cart.billing.length > 0) {\n      selector = {\n        \"_id\": cartId,\n        \"billing._id\": cart.billing[0]._id\n      };\n      update = {\n        $set: {\n          \"billing.$.address\": address\n        }\n      };\n    } else {\n      selector = {\n        _id: cartId\n      };\n      update = {\n        $addToSet: {\n          billing: {\n            address\n          }\n        }\n      };\n    }\n\n    const result = Collections.Cart.update(selector, update);\n\n    // Calculate discounts\n    Hooks.Events.run(\"afterCartUpdateCalculateDiscount\", cartId);\n\n    // Calculate taxes\n    Hooks.Events.run(\"afterCartUpdateCalculateTaxes\", cartId);\n\n    return result;\n  },\n\n  /**\n   * @method cart/unsetAddresses\n   * @summary Removes address from cart.\n   * @memberof Methods/Cart\n   * @param {String} addressId - address._id\n   * @param {String} userId - cart owner _id\n   * @param {String} [type] - billing default or shipping default\n   * @since 0.10.1\n   * @todo Check if no more address in cart as shipping, we should reset `cartWorkflow` to second step\n   * @return {Number|Object|Boolean} The number of removed documents or\n   * error object or `false` if we don't need to update cart\n   */\n  \"cart/unsetAddresses\"(addressId, userId, type) {\n    check(addressId, String);\n    check(userId, String);\n    check(type, Match.Optional(String));\n\n    // do we actually need to change anything?\n    let needToUpdate = false;\n    // we need to revert the workflow after a \"shipping\" address was removed\n    let isShippingDeleting = false;\n    const cart = Collections.Cart.findOne({\n      userId\n    });\n    const selector = {\n      _id: cart._id\n    };\n    const update = { $unset: {} };\n    // user could turn off the checkbox in address to not to be default, then we\n    // receive `type` arg\n    if (typeof type === \"string\") {\n      // we assume that the billing/shipping arrays can hold only one element [0]\n      if (cart[type] && typeof cart[type][0].address === \"object\" &&\n        cart[type][0].address._id === addressId) {\n        update.$unset[`${type}.0.address`] = \"\";\n        needToUpdate = true;\n        isShippingDeleting = type === \"shipping\";\n      }\n    } else { // or if we remove address itself, when we run this part we assume\n      // that the billing/shipping arrays can hold only one element [0]\n      if (cart.billing && typeof cart.billing[0].address === \"object\" &&\n        cart.billing[0].address._id === addressId) {\n        update.$unset[\"billing.0.address\"] = \"\";\n        needToUpdate = true;\n      }\n      if (cart.shipping && typeof cart.shipping[0].address === \"object\" && cart.shipping[0].address._id === addressId) {\n        removeShippingAddresses(cart);\n        isShippingDeleting = true;\n      }\n    }\n\n    if (needToUpdate) {\n      try {\n        Collections.Cart.update(selector, update);\n      } catch (e) {\n        Logger.error(e);\n        throw new Meteor.Error(\"server-error\", \"Error updating cart\");\n      }\n\n      // Calculate discounts\n      Hooks.Events.run(\"afterCartUpdateCalculateDiscount\", cart._id);\n\n      if (isShippingDeleting) {\n        // if we remove shipping address from cart, we need to revert\n        // `cartWorkflow` to the `checkoutAddressBook` step.\n        Meteor.call(\"workflow/revertCartWorkflow\", \"checkoutAddressBook\");\n      }\n    }\n    return true;\n  },\n\n  /**\n   * @method cart/submitPayment\n   * @memberof Methods/Cart\n   * @summary Saves a submitted payment to cart, triggers workflow and adds \"paymentSubmitted\" to cart workflow\n   * Note: this method also has a client stub, that forwards to cartCompleted\n   * @param {Object|Array} paymentMethods - an array of paymentMethods or (deprecated) a single paymentMethod object\n   * @return {String} returns update result\n   */\n  \"cart/submitPayment\"(paymentMethods) {\n    PaymentMethodArgument.validate(paymentMethods);\n\n    const cart = Collections.Cart.findOne({\n      userId: Meteor.userId()\n    });\n\n    const cartId = cart._id;\n\n    const cartShipping = cart.getShippingTotal();\n    const cartShippingByShop = cart.getShippingTotalByShop();\n    const cartSubTotal = cart.getSubTotal();\n    const cartSubtotalByShop = cart.getSubtotalByShop();\n    const cartTaxes = cart.getTaxTotal();\n    const cartTaxesByShop = cart.getTaxesByShop();\n    const cartDiscounts = cart.getDiscounts();\n    const cartTotal = cart.getTotal();\n    const cartTotalByShop = cart.getTotalByShop();\n\n    // we won't actually close the order at this stage.\n    // we'll just update the workflow and billing data where\n    // method-hooks can process the workflow update.\n\n    // Find the payment address associated that the user input during the\n    // checkout process\n    let paymentAddress;\n    if (Array.isArray(cart.billing) && cart.billing[0]) {\n      paymentAddress = cart.billing[0].address;\n    }\n\n    const payments = [];\n\n    // Payment plugins which have been updated for marketplace are passing an array as paymentMethods\n    if (Array.isArray(paymentMethods)) {\n      paymentMethods.forEach((paymentMethod) => {\n        const { shopId } = paymentMethod;\n        const invoice = {\n          shipping: parseFloat(cartShippingByShop[shopId]),\n          subtotal: parseFloat(cartSubtotalByShop[shopId]),\n          taxes: parseFloat(cartTaxesByShop[shopId]),\n          discounts: parseFloat(cartDiscounts),\n          total: parseFloat(cartTotalByShop[shopId])\n        };\n\n        payments.push({\n          paymentMethod,\n          invoice,\n          address: paymentAddress,\n          shopId\n        });\n      });\n    } else {\n      // Legacy payment integration - transactions are not split by shop\n      // Create an invoice based on cart totals.\n      const invoice = {\n        shipping: cartShipping,\n        subtotal: cartSubTotal,\n        taxes: cartTaxes,\n        discounts: cartDiscounts,\n        total: cartTotal\n      };\n\n      // Legacy payment plugins are passing in a single paymentMethod object\n      payments.push({\n        paymentMethod: paymentMethods,\n        invoice,\n        address: paymentAddress,\n        shopId: Reaction.getPrimaryShopId()\n      });\n    }\n\n    // e.g. discount records would be already present on the billing array. Add to the end of the array.\n    const discountRecords = cart.billing.filter((billingInfo) => billingInfo.paymentMethod);\n    payments.push(...discountRecords);\n\n    const selector = {\n      _id: cartId\n    };\n\n    const update = {\n      $set: {\n        billing: payments\n      }\n    };\n\n    try {\n      Collections.Cart.update(selector, update);\n    } catch (e) {\n      Logger.error(e);\n      throw new Meteor.Error(\"server-error\", \"An error occurred saving the order\");\n    }\n\n    // Calculate discounts\n    Hooks.Events.run(\"afterCartUpdateCalculateDiscount\", cartId);\n\n    // Calculate taxes\n    Hooks.Events.run(\"afterCartUpdateCalculateTaxes\", cartId);\n\n    return Collections.Cart.findOne(selector);\n  },\n\n  /**\n   * @method cart/setAnonymousUserEmail\n   * @memberof Methods/Cart\n   * @summary Assigns email to anonymous user's cart instance\n   * @param {Object} userId - current user's Id\n   * @param {String} email - email to set for anonymous user's cart instance\n   * @return {Number} returns update result\n   */\n  \"cart/setAnonymousUserEmail\"(userId, email) {\n    check(userId, String);\n    check(email, String);\n\n    const currentUserCart = Collections.Cart.findOne({ userId });\n    const cartId = currentUserCart._id;\n    let newEmail = \"\";\n\n    if (!currentUserCart.email) {\n      newEmail = email;\n    }\n\n    return Collections.Cart.update({ _id: cartId }, { $set: { email: newEmail } });\n  }\n});\n"]},"sourceType":"script","hash":"28142d68564b1e13cfd196c619ae63afaa734dd4"}
