{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$1$2","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"ast":true,"babelrc":false,"sourceFileName":"lib/api/products.js","filename":"lib/api/products.js","sourceMaps":true,"envName":"development","cwd":"/Users/estebandev/test-knowledge","passPerPreset":false,"presets":[],"parserOpts":{"sourceType":"module","sourceFileName":"lib/api/products.js","plugins":["jsx","jsx","flow","flow","objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties"]},"generatorOpts":{"filename":"lib/api/products.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"lib/api/products.js"}},"code":"module.export({\n  applyProductRevision: () => applyProductRevision,\n  variantIsSelected: () => variantIsSelected,\n  resubscribeAfterCloning: () => resubscribeAfterCloning\n});\n\nlet _isArray;\n\nmodule.watch(require(\"lodash/isArray\"), {\n  default(v) {\n    _isArray = v;\n  }\n\n}, 0);\nlet i18next;\nmodule.watch(require(\"i18next\"), {\n  default(v) {\n    i18next = v;\n  }\n\n}, 1);\nlet orderBy;\nmodule.watch(require(\"lodash/orderBy\"), {\n  default(v) {\n    orderBy = v;\n  }\n\n}, 2);\nlet Meteor;\nmodule.watch(require(\"meteor/meteor\"), {\n  Meteor(v) {\n    Meteor = v;\n  }\n\n}, 3);\nlet ReactiveDict;\nmodule.watch(require(\"meteor/reactive-dict\"), {\n  ReactiveDict(v) {\n    ReactiveDict = v;\n  }\n\n}, 4);\nlet ReactiveVar;\nmodule.watch(require(\"meteor/reactive-var\"), {\n  ReactiveVar(v) {\n    ReactiveVar = v;\n  }\n\n}, 5);\nlet Router;\nmodule.watch(require(\"../../imports/plugins/core/router/lib\"), {\n  Router(v) {\n    Router = v;\n  }\n\n}, 6);\nlet getCurrentTag, getShopName;\nmodule.watch(require(\"./index\"), {\n  getCurrentTag(v) {\n    getCurrentTag = v;\n  },\n\n  getShopName(v) {\n    getShopName = v;\n  }\n\n}, 7);\nlet Products, Revisions;\nmodule.watch(require(\"../collections\"), {\n  Products(v) {\n    Products = v;\n  },\n\n  Revisions(v) {\n    Revisions = v;\n  }\n\n}, 8);\nlet Catalog;\nmodule.watch(require(\"./catalog\"), {\n  default(v) {\n    Catalog = v;\n  }\n\n}, 9);\nlet MetaData;\nmodule.watch(require(\"./router/metadata\"), {\n  MetaData(v) {\n    MetaData = v;\n  }\n\n}, 10);\n\n/**\n * @file ReactionProduct is only intended to be used on the client, but it's placed\n * in common code because it is imported by the Products schema.\n * ReactionProduct is a\n * {@link https://github.com/meteor/meteor/blob/master/packages/reactive-dict/README.md| ReactiveDict},\n * a general-purpose reactive datatype to use with\n * {@link https://github.com/meteor/meteor/tree/master/packages/tracker|Meteor Tracker}.\n * ReactionProduct allows the current product to be reactive, without Session.\n * @namespace ReactionProduct\n */\n\n/**\n * @name ReactionProduct\n * @method\n * @memberof ReactionProduct\n * @summary Reactive current product dependency, ensuring reactive products, without session\n * ReactionProduct is a `ReactiveDict`, a general-purpose reactive datatype to use with Meteor Tracker.\n * @see {@link https://github.com/meteor/meteor/blob/master/packages/reactive-dict/README.md|Meteor ReactiveDict}\n * @see {@link https://github.com/meteor/meteor/tree/master/packages/tracker|Meteor Tracker}\n * @todo this is a messy class implementation, normalize it.\n */\nconst ReactionProduct = new ReactiveDict(\"currentProduct\");\n/**\n * @name applyProductRevision\n * @method\n * @memberof ReactionProduct\n * @summary Apply revision to product\n * @example applyProductRevision(product)\n * @param  {Object} product product\n * @return {Object|null} product or null, if no product found\n */\n\nfunction applyProductRevision(product) {\n  if (product) {\n    if (product.__revisions && product.__revisions.length) {\n      const cleanProduct = Object.assign({}, product);\n      delete cleanProduct.__revisions;\n      let revisedProduct; // check for product revisions and set that as the current product\n\n      for (const revision of product.__revisions) {\n        if (!revision.parentDocument) {\n          revisedProduct = product.__revisions[0].documentData;\n        }\n      } // if there are no revision to product (image and/or tag only) just set the original product as the product\n\n\n      if (!revisedProduct) {\n        revisedProduct = cleanProduct;\n      }\n\n      return Object.assign({}, revisedProduct, {\n        __published: cleanProduct,\n        __draft: product.__revisions[0]\n      });\n    }\n\n    return product;\n  }\n\n  return null;\n}\n\nfunction variantIsSelected(variantId) {\n  const current = Object.assign({}, ReactionProduct.selectedVariant());\n\n  if (current.ancestors && (variantId === current._id || current.ancestors.indexOf(variantId) >= 0)) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * @name sortProducts\n * @method\n * @memberof ReactionProduct\n * @summary Sort products by tag, creation date by tag and creation date\n * @param  {Array} products Array of products\n * @param  {String} tag     Tag\n * @return {Array}         Array of products\n */\nReactionProduct.sortProducts = (products, tag) => {\n  let sorted = [];\n  sorted = orderBy(products, // Sort by postion for tag\n  product => product.positions && product.positions[tag] && product.positions[tag].position, // Then by creation date for tag\n  product => product.positions && product.positions[tag] && product.positions[tag].createdAt, // Finally sort by creation date\n  \"createdAt\");\n  return sorted;\n};\n/**\n * @name setCurrentVariant\n * @method\n * @memberof ReactionProduct\n * @param {String} variantId - set current variantId\n * @return {undefined}\n */\n\n\nReactionProduct.setCurrentVariant = variantId => {\n  if (variantId === null) {\n    ReactionProduct.set(\"variantId\", null);\n    ReactionProduct.set(\"variantId\", ReactionProduct.selectedVariantId());\n  }\n\n  if (!variantId) {\n    return;\n  }\n\n  const currentId = ReactionProduct.selectedVariantId();\n\n  if (currentId === variantId) {\n    return;\n  }\n\n  ReactionProduct.set(\"variantId\", variantId);\n};\n/**\n * @name setProduct\n * @todo this will be deprecated in favor of template.instance data.\n * @method\n * @memberof ReactionProduct\n * @summary method to set default/parameterized product variant\n * @param {String} currentProductId - set current productId\n * @param {String} currentVariantId - set current variantId\n * @return {Object} product object\n */\n\n\nReactionProduct.setProduct = (currentProductId, currentVariantId) => {\n  let productId = currentProductId || Router.getParam(\"handle\");\n  let variantId = currentVariantId || Router.getParam(\"variantId\"); // Find the current product\n\n  const product = Products.findOne({\n    $or: [{\n      handle: productId.toLowerCase()\n    }, // Try the handle (slug) lowercased\n    {\n      handle: productId\n    }, // Otherwise try the handle (slug) untouched\n    {\n      _id: productId\n    }, // try the product id\n    {\n      changedHandleWas: productId // Last attempt: the permalink may have changed.\n\n    }]\n  });\n  productId = product && product._id;\n\n  if (product) {\n    if (Router.getParam(\"handle\") !== product.handle && product.changedHandleWas && product.changedHandleWas !== product.handle) {\n      const newUrl = Router.pathFor(\"product\", {\n        hash: {\n          handle: product.handle\n        }\n      });\n      Router.go(newUrl);\n    } // Check if selected variant id really belongs to the product.\n    // This has been working previously rather accidentally, because variantIsSelected(variantId) below returned always false,\n    // because the Product subscription ensured, that the correct Product is in Mini-Mongo. This is not guaranteed, though.\n    // If Products collection would have other products, it would fail.\n\n\n    let isVariantValidChild = true;\n    const variants = Products.find({\n      ancestors: {\n        $in: [productId]\n      }\n    }).map(variant => variant._id);\n\n    if (variantId && !variants.includes(variantId)) {\n      isVariantValidChild = false;\n    } // set the default variant\n    // as the default.\n\n\n    if (!isVariantValidChild || !variantId || !variantIsSelected(variantId)) {\n      const topVariants = ReactionProduct.getTopVariants(productId);\n      variantId = Array.isArray(topVariants) && topVariants.length && topVariants[0]._id || null;\n    } // set in our reactive dictionary\n\n\n    ReactionProduct.set(\"productId\", productId);\n    ReactionProduct.set(\"variantId\", variantId);\n  } // Update the meta data when a product is selected\n\n\n  MetaData.init(Router.current());\n  return applyProductRevision(product);\n};\n/**\n * @name selectedProductId\n * @method\n * @memberof ReactionProduct\n * @summary get the currently active/requested product\n * @return {String} currently selected product id\n */\n\n\nReactionProduct.selectedProductId = () => ReactionProduct.get(\"productId\");\n/**\n * @name selectedVariantId\n * @method\n * @memberof ReactionProduct\n * @summary get the currently active/requested variant\n * @return {String} currently selected variant id\n */\n\n\nReactionProduct.selectedVariantId = () => {\n  let id = ReactionProduct.get(\"variantId\");\n\n  if (id !== null) {\n    return id;\n  }\n\n  const variants = ReactionProduct.getVariants();\n\n  if (!(variants.length > 0)) {\n    return [];\n  }\n\n  id = variants[0]._id; // ReactionProduct.set(\"variantId\", id);\n\n  return id;\n};\n/**\n * @name selectedVariant\n * @method\n * @memberof ReactionProduct\n * @summary get the currently active/requested variant object\n * @return {Object} currently selected variant object\n */\n\n\nReactionProduct.selectedVariant = function () {\n  const id = ReactionProduct.selectedVariantId();\n\n  if (typeof id === \"string\") {\n    return applyProductRevision(Products.findOne(id));\n  }\n\n  return [];\n};\n/**\n * @name selectedTopVariant\n * @method\n * @memberof ReactionProduct\n * @summary get the currently active TOP variant object\n * @return {Object} currently selected TOP variant object\n */\n\n\nReactionProduct.selectedTopVariant = function () {\n  const topVariants = ReactionProduct.getTopVariants();\n  const topVariant = topVariants.find(variant => variantIsSelected(variant._id));\n  return topVariant;\n};\n/**\n * @name selectedProduct\n * @method\n * @memberof ReactionProduct\n * @summary get the currently active/requested product object\n * @return {Object|undefined} currently selected product cursor\n */\n\n\nReactionProduct.selectedProduct = function () {\n  const id = ReactionProduct.selectedProductId();\n\n  if (typeof id === \"string\") {\n    return applyProductRevision(Products.findOne(id));\n  }\n\n  return undefined;\n};\n/**\n * @name checkChildVariants\n * @method\n * @memberof ReactionProduct\n * @summary return number of child variants for a parent\n * @param {String} parentVariantId - parentVariantId\n * @return {Number} count of childVariants for this parentVariantId\n */\n\n\nReactionProduct.checkChildVariants = function (parentVariantId) {\n  const childVariants = ReactionProduct.getVariants(parentVariantId);\n  return childVariants.length ? childVariants.length : 0;\n};\n/**\n * @name checkInventoryVariants\n * @method\n * @memberof ReactionProduct\n * @summary return number of inventory variants for a parent\n * @param {String} parentVariantId - parentVariantId\n * @todo could be combined with checkChildVariants in one method\n * @todo inventoryVariants are deprecated. remove this.\n * @return {Number} count of inventory variants for this parentVariantId\n */\n\n\nReactionProduct.checkInventoryVariants = function (parentVariantId) {\n  const inventoryVariants = ReactionProduct.getVariants(parentVariantId, \"inventory\");\n  return inventoryVariants.length ? inventoryVariants.length : 0;\n};\n/**\n * @name getVariantPriceRange\n * @method\n * @memberof ReactionProduct\n * @summary get price range of a variant if it has child options.\n * if no child options, return main price value\n * @todo remove string return and replace with object\n * @param {String} [id] - current variant _Id\n * @return {String} formatted price or price range\n */\n\n\nReactionProduct.getVariantPriceRange = id => Catalog.getVariantPriceRange(id || ReactionProduct.selectedVariant()._id);\n/**\n * @name getProductPriceRange\n * @method\n * @memberof ReactionProduct\n * @summary get price range of a product\n * if no only one price available, return it\n * otherwise return a string range\n * @todo remove string return and replace with object\n * @param {String} [id] - current product _id\n * @return {String} formatted price or price range\n */\n\n\nReactionProduct.getProductPriceRange = id => Catalog.getProductPriceRange(id || ReactionProduct.selectedProductId());\n/**\n * @name getVariantQuantity\n * @method\n * @memberof ReactionProduct\n * @summary middleware method which calls the same named common method.\n * @todo maybe we could remove this after 1.3. But for now I like how it looks.\n * @param {Object} doc - variant object\n * @return {Number} summary of options quantity or top-level variant\n * inventoryQuantity\n */\n\n\nReactionProduct.getVariantQuantity = doc => Catalog.getVariantQuantity(doc);\n/**\n * @method getProduct\n * @method\n * @memberof ReactionProduct\n * @summary Get product object. Could be useful for products and for top level variants\n * @param {String} [id] - product _id\n * @return {Object} Product data\n */\n\n\nReactionProduct.getProduct = id => Catalog.getProduct(id);\n/**\n * @method getVariants\n * @method\n * @memberof ReactionProduct\n * @summary Get all parent variants. Could be useful for products and for top level variants\n * @param {String} [id] - product _id\n * @param {String} [type] - type of variant\n * @return {Array} Parent variants or empty array\n */\n\n\nReactionProduct.getVariants = (id, type) => Catalog.getVariants(id || ReactionProduct.selectedProductId(), type);\n/**\n * @method getSiblings\n * @method\n * @memberof ReactionProduct\n * @summary Get all sibling variants - variants with the same ancestor tree\n * could be useful for child variants relationships with top-level variants\n * @param {Object} [variant] - product / variant object\n * @param {String} [type] - type of variant\n * @param {Boolean} [includeSelf] - include current variant in results\n * @return {Array} Sibling variants or empty array\n */\n\n\nReactionProduct.getSiblings = (variant, type) => Catalog.getSiblings(variant, type);\n/**\n * @method getVariantParent\n * @method\n * @memberof ReactionProduct\n * @summary Get direct parent variant - could be useful for lower level variants to get direct parents\n * @param {Object} [variant] - product / variant object\n * @return {Array} Parent variant or empty\n */\n\n\nReactionProduct.getVariantParent = variant => Catalog.getVariantParent(variant);\n/**\n * @method getTopVariants\n * @summary Get only product top level variants\n * @param {String} [id] - product _id\n * @return {Array} Product top level variants or empty array\n */\n\n\nReactionProduct.getTopVariants = id => Catalog.getTopVariants(id || ReactionProduct.selectedProductId());\n/**\n * @name getTag\n * @method\n * @memberof ReactionProduct\n * @summary This needed for naming `positions` object. Method could return `tag`\n * route name or shop name as default name.\n * @return {String} tag name or shop name\n */\n\n\nReactionProduct.getTag = () => getCurrentTag() || getShopName().toLowerCase();\n/**\n * @name getProductsByTag\n * @method\n * @memberof ReactionProduct\n * @summary method to return tag specific product\n * @param {String} tag - tag string\n * @return {Object} - return products collection cursor filtered by tag\n */\n\n\nReactionProduct.getProductsByTag = function (tag) {\n  let hashtags;\n  let newRelatedTags;\n  let relatedTag;\n  let relatedTags;\n  const selector = {};\n\n  if (tag) {\n    hashtags = [];\n    relatedTags = [tag];\n\n    while (relatedTags.length) {\n      newRelatedTags = [];\n\n      for (relatedTag of relatedTags) {\n        if (hashtags.indexOf(relatedTag._id) === -1) {\n          hashtags.push(relatedTag._id);\n        }\n      }\n\n      relatedTags = newRelatedTags;\n    }\n\n    selector.hashtags = {\n      $in: hashtags\n    };\n  }\n\n  const cursor = Products.find(selector);\n  return cursor;\n};\n/**\n * @name publishProduct\n * @method\n * @memberof ReactionProduct\n * @summary product publishing and alert\n * @todo review process for publishing arrays of product\n * @param {Object} productOrArray - product Object\n * @returns {undefined} - returns nothing, and alerts, happen here\n */\n\n\nReactionProduct.publishProduct = function (productOrArray) {\n  const products = !_isArray(productOrArray) ? [productOrArray] : productOrArray;\n  /* eslint no-loop-func: 1 */\n\n  for (const product of products) {\n    Meteor.call(\"products/publishProduct\", product._id, (error, result) => {\n      // eslint-disable-line no-loop-func\n      if (error) {\n        Alerts.add(error, \"danger\", {\n          placement: \"productGridItem\",\n          id: product._id\n        });\n        throw new Meteor.Error(\"error-occurred\", error);\n      }\n\n      const alertSettings = {\n        placement: \"productGridItem\",\n        id: product._id,\n        autoHide: true,\n        dismissable: false\n      };\n\n      if (result) {\n        Alerts.add(i18next.t(\"productDetail.publishProductVisible\", {\n          product: product.title\n        }), \"success\", alertSettings);\n      } else {\n        Alerts.add(i18next.t(\"productDetail.publishProductHidden\", {\n          product: product.title\n        }), \"warning\", alertSettings);\n      }\n    });\n  }\n};\n/**\n * @name toggleVisibility\n * @method\n * @memberof ReactionProduct\n * @summary product publishing and alert\n * @param {Object} productOrArray - product Object\n * @returns {undefined} - returns nothing, and alerts, happen here\n */\n\n\nReactionProduct.toggleVisibility = function (productOrArray) {\n  const products = !_isArray(productOrArray) ? [productOrArray] : productOrArray;\n\n  for (const product of products) {\n    Meteor.call(\"products/toggleVisibility\", product._id, (error, result) => {\n      // eslint-disable-line no-loop-func\n      if (error) {\n        Alerts.add(error, \"danger\", {\n          placement: \"productGridItem\",\n          id: product._id\n        });\n        throw new Meteor.Error(\"error-occurred\", error);\n      }\n\n      const alertSettings = {\n        placement: \"productGridItem\",\n        id: product._id,\n        autoHide: true,\n        dismissable: false\n      };\n\n      if (result) {\n        Alerts.add(i18next.t(\"productDetail.publishProductVisible\", {\n          product: product.title\n        }), \"success\", alertSettings);\n      } else {\n        Alerts.add(i18next.t(\"productDetail.publishProductHidden\", {\n          product: product.title\n        }), \"warning\", alertSettings);\n      }\n    });\n  }\n};\n/**\n * A reactive data source that tells any dependents that they should resubscribe their\n * active publication.\n * @type {ReactiveVar}\n */\n\n\nconst resubscribeAfterCloning = new ReactiveVar(false);\n\n/**\n * @name cloneProduct\n * @method\n * @memberof ReactionProduct\n * @summary product cloning and alert\n * @param {Object|Array} productOrArray - if this method calls from productGrid\n * it receives and array with product _id or _ids, but if it calls from PDP, when\n * it receive a `Object` with _id. It needed to determine the source of call.\n * @returns {undefined} - returns nothing, and alerts, happen here\n */\nReactionProduct.cloneProduct = function (productOrArray) {\n  const products = !Array.isArray(productOrArray) ? [productOrArray] : productOrArray;\n  return Meteor.call(\"products/cloneProduct\", products, (error, result) => {\n    if (error) {\n      Alerts.add(error, \"danger\", {\n        placement: \"productGridItem\"\n      });\n      throw new Meteor.Error(\"error-occurred\", error);\n    }\n\n    if (result) {\n      if (products.length === 1) {\n        Alerts.add(i18next.t(\"productDetail.clonedAlert\", {\n          product: products[0].title\n        }), \"success\", {\n          placement: \"productGridItem\",\n          id: products[0]._id,\n          autoHide: true,\n          dismissable: false\n        });\n      } else {\n        Alerts.add(i18next.t(\"productDetail.clonedAlert_plural\", {\n          product: i18next.t(\"productDetail.theSelectedProducts\"),\n          count: 0\n        }), \"success\", {\n          placement: \"productGridItem\",\n          id: products[0]._id,\n          autoHide: true,\n          dismissable: false\n        });\n      }\n    } // this statement allow us to redirect to a new clone PDP if clone action\n    // was fired within PDP, not within productGrid.\n\n\n    if (!Array.isArray(productOrArray)) {\n      Router.go(\"product\", {\n        handle: result[0]\n      });\n    } else {\n      resubscribeAfterCloning.set(true);\n    }\n  });\n};\n/**\n * @name archiveProduct\n * @method\n * @memberof ReactionProduct\n * @summary confirm to archive product\n * @param {Object} productOrArray - product Object\n * @returns {undefined} - returns nothing, and alerts, happen here\n */\n\n\nReactionProduct.archiveProduct = function (productOrArray) {\n  const products = !Array.isArray(productOrArray) ? [productOrArray] : productOrArray;\n  const productIds = products.map(product => typeof product === \"string\" ? product : product._id);\n  let confirmTitle; // we have to use so difficult logic with `length` check because of some\n  // languages, which have different phrase forms for each of cases.\n  // we are using i18next `plural` functionality here.\n  // @see: http://i18next.com/translate/pluralSimple\n\n  if (products.length === 1) {\n    confirmTitle = i18next.t(\"productDetailEdit.archiveThisProduct\");\n  } else {\n    confirmTitle = i18next.t(\"productDetailEdit.archiveSelectedProducts\");\n  }\n\n  Alerts.alert({\n    title: confirmTitle,\n    type: \"warning\",\n    showCancelButton: true,\n    confirmButtonText: \"Archive\"\n  }, isConfirm => {\n    if (isConfirm) {\n      Meteor.call(\"products/archiveProduct\", productIds, (error, result) => {\n        let title;\n\n        if (error) {\n          title = products.length === 1 ? products[0].title || i18next.t(\"productDetail.archiveErrorTheProduct\") : i18next.t(\"productDetail.theSelectedProducts\");\n          Alerts.toast(i18next.t(\"productDetail.productArchiveError\", {\n            product: title\n          }), \"error\");\n          throw new Meteor.Error(`error-occurred${title}`, error);\n        }\n\n        if (result) {\n          Router.go(\"/\");\n\n          if (products.length === 1) {\n            title = products[0].title || i18next.t(\"productDetail.theProduct\");\n            Alerts.toast(i18next.t(\"productDetail.archivedAlert\", {\n              product: title\n            }), \"info\");\n          } else {\n            title = i18next.t(\"productDetail.theSelectedProducts\");\n            Alerts.toast(i18next.t(\"productDetail.archivedAlert_plural\", {\n              product: title,\n              count: 0\n            }), \"info\");\n          }\n        }\n      });\n    }\n  });\n};\n/**\n * @name isAncestorDeleted\n * @method\n * @memberof ReactionProduct\n * @summary Verify there are no deleted ancestors\n * Variants cannot be restored if their parent product / variant is deleted\n * @param  {Object} product     product Object\n * @param  {Boolean} includeSelf include product\n * @return {Boolean}             True or false\n */\n\n\nReactionProduct.isAncestorDeleted = function (product, includeSelf) {\n  const productIds = [...product.ancestors // Avoid mutations\n  ];\n\n  if (includeSelf) {\n    productIds.push(product._id);\n  } // Verify there are no deleted ancestors,\n  // Variants cannot be restored if their parent product / variant is deleted\n\n\n  const archivedCount = Revisions.find({\n    \"documentId\": {\n      $in: productIds\n    },\n    \"documentData.isDeleted\": true,\n    \"workflow.status\": {\n      $nin: [\"revision/published\"]\n    }\n  }).count();\n\n  if (archivedCount > 0) {\n    return true;\n  }\n\n  return false;\n};\n\nmodule.exportDefault(ReactionProduct);","map":{"version":3,"sources":["lib/api/products.js"],"names":["module","export","applyProductRevision","variantIsSelected","resubscribeAfterCloning","_isArray","watch","require","default","v","i18next","orderBy","Meteor","ReactiveDict","ReactiveVar","Router","getCurrentTag","getShopName","Products","Revisions","Catalog","MetaData","ReactionProduct","product","__revisions","length","cleanProduct","Object","assign","revisedProduct","revision","parentDocument","documentData","__published","__draft","variantId","current","selectedVariant","ancestors","_id","indexOf","sortProducts","products","tag","sorted","positions","position","createdAt","setCurrentVariant","set","selectedVariantId","currentId","setProduct","currentProductId","currentVariantId","productId","getParam","findOne","$or","handle","toLowerCase","changedHandleWas","newUrl","pathFor","hash","go","isVariantValidChild","variants","find","$in","map","variant","includes","topVariants","getTopVariants","Array","isArray","init","selectedProductId","get","id","getVariants","selectedTopVariant","topVariant","selectedProduct","undefined","checkChildVariants","parentVariantId","childVariants","checkInventoryVariants","inventoryVariants","getVariantPriceRange","getProductPriceRange","getVariantQuantity","doc","getProduct","type","getSiblings","getVariantParent","getTag","getProductsByTag","hashtags","newRelatedTags","relatedTag","relatedTags","selector","push","cursor","publishProduct","productOrArray","call","error","result","Alerts","add","placement","Error","alertSettings","autoHide","dismissable","t","title","toggleVisibility","cloneProduct","count","archiveProduct","productIds","confirmTitle","alert","showCancelButton","confirmButtonText","isConfirm","toast","isAncestorDeleted","includeSelf","archivedCount","$nin","exportDefault"],"mappings":"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","sourcesContent":["import i18next from \"i18next\";\nimport orderBy from \"lodash/orderBy\";\nimport _ from \"lodash\";\nimport { Meteor } from \"meteor/meteor\";\nimport { ReactiveDict } from \"meteor/reactive-dict\";\nimport { ReactiveVar } from \"meteor/reactive-var\";\nimport { Router } from \"/imports/plugins/core/router/lib\";\nimport { getCurrentTag, getShopName } from \"/lib/api\";\nimport { Products, Revisions } from \"/lib/collections\";\nimport Catalog from \"./catalog\";\nimport { MetaData } from \"/lib/api/router/metadata\";\n\n/**\n * @file ReactionProduct is only intended to be used on the client, but it's placed\n * in common code because it is imported by the Products schema.\n * ReactionProduct is a\n * {@link https://github.com/meteor/meteor/blob/master/packages/reactive-dict/README.md| ReactiveDict},\n * a general-purpose reactive datatype to use with\n * {@link https://github.com/meteor/meteor/tree/master/packages/tracker|Meteor Tracker}.\n * ReactionProduct allows the current product to be reactive, without Session.\n * @namespace ReactionProduct\n */\n\n/**\n * @name ReactionProduct\n * @method\n * @memberof ReactionProduct\n * @summary Reactive current product dependency, ensuring reactive products, without session\n * ReactionProduct is a `ReactiveDict`, a general-purpose reactive datatype to use with Meteor Tracker.\n * @see {@link https://github.com/meteor/meteor/blob/master/packages/reactive-dict/README.md|Meteor ReactiveDict}\n * @see {@link https://github.com/meteor/meteor/tree/master/packages/tracker|Meteor Tracker}\n * @todo this is a messy class implementation, normalize it.\n */\nconst ReactionProduct = new ReactiveDict(\"currentProduct\");\n\n/**\n * @name applyProductRevision\n * @method\n * @memberof ReactionProduct\n * @summary Apply revision to product\n * @example applyProductRevision(product)\n * @param  {Object} product product\n * @return {Object|null} product or null, if no product found\n */\nexport function applyProductRevision(product) {\n  if (product) {\n    if (product.__revisions && product.__revisions.length) {\n      const cleanProduct = Object.assign({}, product);\n      delete cleanProduct.__revisions;\n      let revisedProduct;\n      // check for product revisions and set that as the current product\n      for (const revision of product.__revisions) {\n        if (!revision.parentDocument) {\n          revisedProduct = product.__revisions[0].documentData;\n        }\n      }\n\n      // if there are no revision to product (image and/or tag only) just set the original product as the product\n      if (!revisedProduct) {\n        revisedProduct = cleanProduct;\n      }\n\n      return Object.assign(\n        {},\n        revisedProduct,\n        {\n          __published: cleanProduct,\n          __draft: product.__revisions[0]\n        }\n      );\n    }\n    return product;\n  }\n\n  return null;\n}\n\n/**\n * @name variantIsSelected\n * @method\n * @memberof ReactionProduct\n * @param  {String} variantId ID of variant to check\n * @return {Boolean}          True if variant is selected\n */\nexport function variantIsSelected(variantId) {\n  const current = Object.assign({}, ReactionProduct.selectedVariant());\n  if (current.ancestors && (variantId === current._id || current.ancestors.indexOf(variantId) >= 0)) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * @name sortProducts\n * @method\n * @memberof ReactionProduct\n * @summary Sort products by tag, creation date by tag and creation date\n * @param  {Array} products Array of products\n * @param  {String} tag     Tag\n * @return {Array}         Array of products\n */\nReactionProduct.sortProducts = (products, tag) => {\n  let sorted = [];\n\n  sorted = orderBy(\n    products,\n    // Sort by postion for tag\n    (product) => product.positions && product.positions[tag] && product.positions[tag].position,\n    // Then by creation date for tag\n    (product) => product.positions && product.positions[tag] && product.positions[tag].createdAt,\n    // Finally sort by creation date\n    \"createdAt\"\n  );\n\n  return sorted;\n};\n\n/**\n * @name setCurrentVariant\n * @method\n * @memberof ReactionProduct\n * @param {String} variantId - set current variantId\n * @return {undefined}\n */\nReactionProduct.setCurrentVariant = (variantId) => {\n  if (variantId === null) {\n    ReactionProduct.set(\"variantId\", null);\n    ReactionProduct.set(\"variantId\", ReactionProduct.selectedVariantId());\n  }\n  if (!variantId) {\n    return;\n  }\n  const currentId = ReactionProduct.selectedVariantId();\n  if (currentId === variantId) {\n    return;\n  }\n  ReactionProduct.set(\"variantId\", variantId);\n};\n\n/**\n * @name setProduct\n * @todo this will be deprecated in favor of template.instance data.\n * @method\n * @memberof ReactionProduct\n * @summary method to set default/parameterized product variant\n * @param {String} currentProductId - set current productId\n * @param {String} currentVariantId - set current variantId\n * @return {Object} product object\n */\nReactionProduct.setProduct = (currentProductId, currentVariantId) => {\n  let productId = currentProductId || Router.getParam(\"handle\");\n  let variantId = currentVariantId || Router.getParam(\"variantId\");\n\n  // Find the current product\n  const product = Products.findOne({\n    $or: [\n      { handle: productId.toLowerCase() }, // Try the handle (slug) lowercased\n      { handle: productId }, // Otherwise try the handle (slug) untouched\n      { _id: productId }, // try the product id\n      { changedHandleWas: productId } // Last attempt: the permalink may have changed.\n    ]\n  });\n\n  productId = product && product._id;\n\n  if (product) {\n    if (Router.getParam(\"handle\") !== product.handle && product.changedHandleWas && product.changedHandleWas !== product.handle) {\n      const newUrl = Router.pathFor(\"product\", {\n        hash: {\n          handle: product.handle\n        }\n      });\n      Router.go(newUrl);\n    }\n\n    // Check if selected variant id really belongs to the product.\n    // This has been working previously rather accidentally, because variantIsSelected(variantId) below returned always false,\n    // because the Product subscription ensured, that the correct Product is in Mini-Mongo. This is not guaranteed, though.\n    // If Products collection would have other products, it would fail.\n    let isVariantValidChild = true;\n    const variants = Products.find({\n      ancestors: { $in: [productId] }\n    }).map((variant) => variant._id);\n    if (variantId && !variants.includes(variantId)) {\n      isVariantValidChild = false;\n    }\n\n    // set the default variant\n    // as the default.\n    if (!isVariantValidChild || !variantId || !variantIsSelected(variantId)) {\n      const topVariants = ReactionProduct.getTopVariants(productId);\n      variantId = (Array.isArray(topVariants) && topVariants.length && topVariants[0]._id) || null;\n    }\n    // set in our reactive dictionary\n    ReactionProduct.set(\"productId\", productId);\n    ReactionProduct.set(\"variantId\", variantId);\n  }\n\n  // Update the meta data when a product is selected\n  MetaData.init(Router.current());\n\n  return applyProductRevision(product);\n};\n\n/**\n * @name selectedProductId\n * @method\n * @memberof ReactionProduct\n * @summary get the currently active/requested product\n * @return {String} currently selected product id\n */\nReactionProduct.selectedProductId = () => ReactionProduct.get(\"productId\");\n\n/**\n * @name selectedVariantId\n * @method\n * @memberof ReactionProduct\n * @summary get the currently active/requested variant\n * @return {String} currently selected variant id\n */\nReactionProduct.selectedVariantId = () => {\n  let id = ReactionProduct.get(\"variantId\");\n  if (id !== null) {\n    return id;\n  }\n  const variants = ReactionProduct.getVariants();\n\n  if (!(variants.length > 0)) {\n    return [];\n  }\n\n  id = variants[0]._id;\n  // ReactionProduct.set(\"variantId\", id);\n  return id;\n};\n\n/**\n * @name selectedVariant\n * @method\n * @memberof ReactionProduct\n * @summary get the currently active/requested variant object\n * @return {Object} currently selected variant object\n */\nReactionProduct.selectedVariant = function () {\n  const id = ReactionProduct.selectedVariantId();\n  if (typeof id === \"string\") {\n    return applyProductRevision(Products.findOne(id));\n  }\n  return [];\n};\n\n/**\n * @name selectedTopVariant\n * @method\n * @memberof ReactionProduct\n * @summary get the currently active TOP variant object\n * @return {Object} currently selected TOP variant object\n */\nReactionProduct.selectedTopVariant = function () {\n  const topVariants = ReactionProduct.getTopVariants();\n  const topVariant = topVariants.find((variant) => variantIsSelected(variant._id));\n\n  return topVariant;\n};\n\n/**\n * @name selectedProduct\n * @method\n * @memberof ReactionProduct\n * @summary get the currently active/requested product object\n * @return {Object|undefined} currently selected product cursor\n */\nReactionProduct.selectedProduct = function () {\n  const id = ReactionProduct.selectedProductId();\n  if (typeof id === \"string\") {\n    return applyProductRevision(Products.findOne(id));\n  }\n  return undefined;\n};\n\n/**\n * @name checkChildVariants\n * @method\n * @memberof ReactionProduct\n * @summary return number of child variants for a parent\n * @param {String} parentVariantId - parentVariantId\n * @return {Number} count of childVariants for this parentVariantId\n */\nReactionProduct.checkChildVariants = function (parentVariantId) {\n  const childVariants = ReactionProduct.getVariants(parentVariantId);\n  return childVariants.length ? childVariants.length : 0;\n};\n\n/**\n * @name checkInventoryVariants\n * @method\n * @memberof ReactionProduct\n * @summary return number of inventory variants for a parent\n * @param {String} parentVariantId - parentVariantId\n * @todo could be combined with checkChildVariants in one method\n * @todo inventoryVariants are deprecated. remove this.\n * @return {Number} count of inventory variants for this parentVariantId\n */\nReactionProduct.checkInventoryVariants = function (parentVariantId) {\n  const inventoryVariants = ReactionProduct.getVariants(parentVariantId, \"inventory\");\n  return inventoryVariants.length ? inventoryVariants.length : 0;\n};\n\n/**\n * @name getVariantPriceRange\n * @method\n * @memberof ReactionProduct\n * @summary get price range of a variant if it has child options.\n * if no child options, return main price value\n * @todo remove string return and replace with object\n * @param {String} [id] - current variant _Id\n * @return {String} formatted price or price range\n */\n\nReactionProduct.getVariantPriceRange = (id) => Catalog\n  .getVariantPriceRange(id || ReactionProduct.selectedVariant()._id);\n\n/**\n * @name getProductPriceRange\n * @method\n * @memberof ReactionProduct\n * @summary get price range of a product\n * if no only one price available, return it\n * otherwise return a string range\n * @todo remove string return and replace with object\n * @param {String} [id] - current product _id\n * @return {String} formatted price or price range\n */\n\nReactionProduct.getProductPriceRange = (id) => Catalog\n  .getProductPriceRange(id || ReactionProduct.selectedProductId());\n\n/**\n * @name getVariantQuantity\n * @method\n * @memberof ReactionProduct\n * @summary middleware method which calls the same named common method.\n * @todo maybe we could remove this after 1.3. But for now I like how it looks.\n * @param {Object} doc - variant object\n * @return {Number} summary of options quantity or top-level variant\n * inventoryQuantity\n */\nReactionProduct.getVariantQuantity = (doc) => Catalog.getVariantQuantity(doc);\n\n/**\n * @method getProduct\n * @method\n * @memberof ReactionProduct\n * @summary Get product object. Could be useful for products and for top level variants\n * @param {String} [id] - product _id\n * @return {Object} Product data\n */\nReactionProduct.getProduct = (id) => Catalog.getProduct(id);\n\n/**\n * @method getVariants\n * @method\n * @memberof ReactionProduct\n * @summary Get all parent variants. Could be useful for products and for top level variants\n * @param {String} [id] - product _id\n * @param {String} [type] - type of variant\n * @return {Array} Parent variants or empty array\n */\nReactionProduct.getVariants = (id, type) => Catalog.getVariants(id || ReactionProduct.selectedProductId(), type);\n\n/**\n * @method getSiblings\n * @method\n * @memberof ReactionProduct\n * @summary Get all sibling variants - variants with the same ancestor tree\n * could be useful for child variants relationships with top-level variants\n * @param {Object} [variant] - product / variant object\n * @param {String} [type] - type of variant\n * @param {Boolean} [includeSelf] - include current variant in results\n * @return {Array} Sibling variants or empty array\n */\nReactionProduct.getSiblings = (variant, type) => Catalog.getSiblings(variant, type);\n\n/**\n * @method getVariantParent\n * @method\n * @memberof ReactionProduct\n * @summary Get direct parent variant - could be useful for lower level variants to get direct parents\n * @param {Object} [variant] - product / variant object\n * @return {Array} Parent variant or empty\n */\nReactionProduct.getVariantParent = (variant) => Catalog.getVariantParent(variant);\n\n/**\n * @method getTopVariants\n * @summary Get only product top level variants\n * @param {String} [id] - product _id\n * @return {Array} Product top level variants or empty array\n */\nReactionProduct.getTopVariants = (id) => Catalog.getTopVariants(id || ReactionProduct.selectedProductId());\n\n/**\n * @name getTag\n * @method\n * @memberof ReactionProduct\n * @summary This needed for naming `positions` object. Method could return `tag`\n * route name or shop name as default name.\n * @return {String} tag name or shop name\n */\nReactionProduct.getTag = () => getCurrentTag() || getShopName().toLowerCase();\n\n/**\n * @name getProductsByTag\n * @method\n * @memberof ReactionProduct\n * @summary method to return tag specific product\n * @param {String} tag - tag string\n * @return {Object} - return products collection cursor filtered by tag\n */\nReactionProduct.getProductsByTag = function (tag) {\n  let hashtags;\n  let newRelatedTags;\n  let relatedTag;\n  let relatedTags;\n  const selector = {};\n\n  if (tag) {\n    hashtags = [];\n    relatedTags = [tag];\n    while (relatedTags.length) {\n      newRelatedTags = [];\n      for (relatedTag of relatedTags) {\n        if (hashtags.indexOf(relatedTag._id) === -1) {\n          hashtags.push(relatedTag._id);\n        }\n      }\n      relatedTags = newRelatedTags;\n    }\n    selector.hashtags = {\n      $in: hashtags\n    };\n  }\n  const cursor = Products.find(selector);\n  return cursor;\n};\n\n/**\n * @name publishProduct\n * @method\n * @memberof ReactionProduct\n * @summary product publishing and alert\n * @todo review process for publishing arrays of product\n * @param {Object} productOrArray - product Object\n * @returns {undefined} - returns nothing, and alerts, happen here\n */\nReactionProduct.publishProduct = function (productOrArray) {\n  const products = !_.isArray(productOrArray) ? [productOrArray] : productOrArray;\n  /* eslint no-loop-func: 1 */\n  for (const product of products) {\n    Meteor.call(\"products/publishProduct\", product._id, (error, result) => { // eslint-disable-line no-loop-func\n      if (error) {\n        Alerts.add(error, \"danger\", {\n          placement: \"productGridItem\",\n          id: product._id\n        });\n        throw new Meteor.Error(\"error-occurred\", error);\n      }\n      const alertSettings = {\n        placement: \"productGridItem\",\n        id: product._id,\n        autoHide: true,\n        dismissable: false\n      };\n      if (result) {\n        Alerts.add(i18next.t(\"productDetail.publishProductVisible\", { product: product.title }), \"success\", alertSettings);\n      } else {\n        Alerts.add(i18next.t(\"productDetail.publishProductHidden\", { product: product.title }), \"warning\", alertSettings);\n      }\n    });\n  }\n};\n\n/**\n * @name toggleVisibility\n * @method\n * @memberof ReactionProduct\n * @summary product publishing and alert\n * @param {Object} productOrArray - product Object\n * @returns {undefined} - returns nothing, and alerts, happen here\n */\nReactionProduct.toggleVisibility = function (productOrArray) {\n  const products = !_.isArray(productOrArray) ? [productOrArray] : productOrArray;\n  for (const product of products) {\n    Meteor.call(\"products/toggleVisibility\", product._id, (error, result) => { // eslint-disable-line no-loop-func\n      if (error) {\n        Alerts.add(error, \"danger\", {\n          placement: \"productGridItem\",\n          id: product._id\n        });\n        throw new Meteor.Error(\"error-occurred\", error);\n      }\n      const alertSettings = {\n        placement: \"productGridItem\",\n        id: product._id,\n        autoHide: true,\n        dismissable: false\n      };\n      if (result) {\n        Alerts.add(i18next.t(\"productDetail.publishProductVisible\", { product: product.title }), \"success\", alertSettings);\n      } else {\n        Alerts.add(i18next.t(\"productDetail.publishProductHidden\", { product: product.title }), \"warning\", alertSettings);\n      }\n    });\n  }\n};\n\n/**\n * A reactive data source that tells any dependents that they should resubscribe their\n * active publication.\n * @type {ReactiveVar}\n */\nexport const resubscribeAfterCloning = new ReactiveVar(false);\n\n\n/**\n * @name cloneProduct\n * @method\n * @memberof ReactionProduct\n * @summary product cloning and alert\n * @param {Object|Array} productOrArray - if this method calls from productGrid\n * it receives and array with product _id or _ids, but if it calls from PDP, when\n * it receive a `Object` with _id. It needed to determine the source of call.\n * @returns {undefined} - returns nothing, and alerts, happen here\n */\nReactionProduct.cloneProduct = function (productOrArray) {\n  const products = !Array.isArray(productOrArray) ? [productOrArray] : productOrArray;\n\n  return Meteor.call(\"products/cloneProduct\", products, (error, result) => {\n    if (error) {\n      Alerts.add(error, \"danger\", { placement: \"productGridItem\" });\n      throw new Meteor.Error(\"error-occurred\", error);\n    }\n    if (result) {\n      if (products.length === 1) {\n        Alerts.add(i18next.t(\"productDetail.clonedAlert\", { product: products[0].title }), \"success\", {\n          placement: \"productGridItem\",\n          id: products[0]._id,\n          autoHide: true,\n          dismissable: false\n        });\n      } else {\n        Alerts.add(\n          i18next.t(\"productDetail.clonedAlert_plural\", { product: i18next.t(\"productDetail.theSelectedProducts\"), count: 0 }),\n          \"success\", {\n            placement: \"productGridItem\",\n            id: products[0]._id,\n            autoHide: true,\n            dismissable: false\n          }\n        );\n      }\n    }\n    // this statement allow us to redirect to a new clone PDP if clone action\n    // was fired within PDP, not within productGrid.\n    if (!Array.isArray(productOrArray)) {\n      Router.go(\"product\", {\n        handle: result[0]\n      });\n    } else {\n      resubscribeAfterCloning.set(true);\n    }\n  });\n};\n\n/**\n * @name archiveProduct\n * @method\n * @memberof ReactionProduct\n * @summary confirm to archive product\n * @param {Object} productOrArray - product Object\n * @returns {undefined} - returns nothing, and alerts, happen here\n */\nReactionProduct.archiveProduct = function (productOrArray) {\n  const products = !Array.isArray(productOrArray) ? [productOrArray] : productOrArray;\n  const productIds = products.map((product) => (typeof product === \"string\" ? product : product._id));\n  let confirmTitle;\n  // we have to use so difficult logic with `length` check because of some\n  // languages, which have different phrase forms for each of cases.\n  // we are using i18next `plural` functionality here.\n  // @see: http://i18next.com/translate/pluralSimple\n  if (products.length === 1) {\n    confirmTitle = i18next.t(\"productDetailEdit.archiveThisProduct\");\n  } else {\n    confirmTitle = i18next.t(\"productDetailEdit.archiveSelectedProducts\");\n  }\n\n  Alerts.alert({\n    title: confirmTitle,\n    type: \"warning\",\n    showCancelButton: true,\n    confirmButtonText: \"Archive\"\n  }, (isConfirm) => {\n    if (isConfirm) {\n      Meteor.call(\"products/archiveProduct\", productIds, (error, result) => {\n        let title;\n        if (error) {\n          title = products.length === 1 ?\n            products[0].title || i18next.t(\"productDetail.archiveErrorTheProduct\") :\n            i18next.t(\"productDetail.theSelectedProducts\");\n          Alerts.toast(i18next.t(\"productDetail.productArchiveError\", { product: title }), \"error\");\n          throw new Meteor.Error(`error-occurred${title}`, error);\n        }\n        if (result) {\n          Router.go(\"/\");\n          if (products.length === 1) {\n            title = products[0].title || i18next.t(\"productDetail.theProduct\");\n            Alerts.toast(i18next.t(\"productDetail.archivedAlert\", { product: title }), \"info\");\n          } else {\n            title = i18next.t(\"productDetail.theSelectedProducts\");\n            Alerts.toast(i18next.t(\"productDetail.archivedAlert_plural\", { product: title, count: 0 }), \"info\");\n          }\n        }\n      });\n    }\n  });\n};\n\n/**\n * @name isAncestorDeleted\n * @method\n * @memberof ReactionProduct\n * @summary Verify there are no deleted ancestors\n * Variants cannot be restored if their parent product / variant is deleted\n * @param  {Object} product     product Object\n * @param  {Boolean} includeSelf include product\n * @return {Boolean}             True or false\n */\nReactionProduct.isAncestorDeleted = function (product, includeSelf) {\n  const productIds = [\n    ...product.ancestors // Avoid mutations\n  ];\n\n  if (includeSelf) {\n    productIds.push(product._id);\n  }\n\n  // Verify there are no deleted ancestors,\n  // Variants cannot be restored if their parent product / variant is deleted\n  const archivedCount = Revisions.find({\n    \"documentId\": { $in: productIds },\n    \"documentData.isDeleted\": true,\n    \"workflow.status\": {\n      $nin: [\n        \"revision/published\"\n      ]\n    }\n  }).count();\n\n  if (archivedCount > 0) {\n    return true;\n  }\n\n  return false;\n};\n\nexport default ReactionProduct;\n"]},"sourceType":"script","hash":"aea9b3bd04f997a5f8ed75b6418bec05442e6cd4"}
