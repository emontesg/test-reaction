{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$1$2","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"ast":true,"babelrc":false,"sourceFileName":"server/methods/accounts/accounts.js","filename":"server/methods/accounts/accounts.js","sourceMaps":true,"envName":"development","cwd":"/Users/estebandev/test-knowledge","passPerPreset":false,"presets":[],"parserOpts":{"sourceType":"module","sourceFileName":"server/methods/accounts/accounts.js","plugins":["jsx","jsx","flow","flow","objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties"]},"generatorOpts":{"filename":"server/methods/accounts/accounts.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"server/methods/accounts/accounts.js"}},"code":"var _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/builtin/objectSpread\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nmodule.export({\n  verifyAccount: () => verifyAccount,\n  updateEmailAddress: () => updateEmailAddress,\n  removeEmailAddress: () => removeEmailAddress,\n  syncUsersAndAccounts: () => syncUsersAndAccounts,\n  validateAddress: () => validateAddress,\n  addressBookAdd: () => addressBookAdd,\n  addressBookUpdate: () => addressBookUpdate,\n  addressBookRemove: () => addressBookRemove,\n  inviteShopOwner: () => inviteShopOwner,\n  inviteShopMember: () => inviteShopMember,\n  sendWelcomeEmail: () => sendWelcomeEmail,\n  addUserPermissions: () => addUserPermissions,\n  removeUserPermissions: () => removeUserPermissions,\n  setUserPermissions: () => setUserPermissions,\n  createFallbackLoginToken: () => createFallbackLoginToken,\n  setProfileCurrency: () => setProfileCurrency\n});\n\nlet _startCase;\n\nmodule.watch(require(\"lodash/startCase\"), {\n  default(v) {\n    _startCase = v;\n  }\n\n}, 0);\n\nlet _upperCase;\n\nmodule.watch(require(\"lodash/upperCase\"), {\n  default(v) {\n    _upperCase = v;\n  }\n\n}, 1);\n\nlet _trim;\n\nmodule.watch(require(\"lodash/trim\"), {\n  default(v) {\n    _trim = v;\n  }\n\n}, 2);\n\nlet _get;\n\nmodule.watch(require(\"lodash/get\"), {\n  default(v) {\n    _get = v;\n  }\n\n}, 3);\nlet Meteor;\nmodule.watch(require(\"meteor/meteor\"), {\n  Meteor(v) {\n    Meteor = v;\n  }\n\n}, 4);\nlet Random;\nmodule.watch(require(\"meteor/random\"), {\n  Random(v) {\n    Random = v;\n  }\n\n}, 5);\nlet MeteorAccounts;\nmodule.watch(require(\"meteor/accounts-base\"), {\n  Accounts(v) {\n    MeteorAccounts = v;\n  }\n\n}, 6);\nlet check, Match;\nmodule.watch(require(\"meteor/check\"), {\n  check(v) {\n    check = v;\n  },\n\n  Match(v) {\n    Match = v;\n  }\n\n}, 7);\nlet Roles;\nmodule.watch(require(\"meteor/alanning:roles\"), {\n  Roles(v) {\n    Roles = v;\n  }\n\n}, 8);\nlet SSR;\nmodule.watch(require(\"meteor/meteorhacks:ssr\"), {\n  SSR(v) {\n    SSR = v;\n  }\n\n}, 9);\nlet Accounts, Cart, Groups, Shops, Packages;\nmodule.watch(require(\"../../../lib/collections\"), {\n  Accounts(v) {\n    Accounts = v;\n  },\n\n  Cart(v) {\n    Cart = v;\n  },\n\n  Groups(v) {\n    Groups = v;\n  },\n\n  Shops(v) {\n    Shops = v;\n  },\n\n  Packages(v) {\n    Packages = v;\n  }\n\n}, 10);\nlet Schemas;\nmodule.watch(require(\"../../../lib/collections/schemas\"), {\n  \"*\"(v) {\n    Schemas = v;\n  }\n\n}, 11);\nlet Hooks, Logger, Reaction;\nmodule.watch(require(\"../../api\"), {\n  Hooks(v) {\n    Hooks = v;\n  },\n\n  Logger(v) {\n    Logger = v;\n  },\n\n  Reaction(v) {\n    Reaction = v;\n  }\n\n}, 12);\nlet sendUpdatedVerificationEmail;\nmodule.watch(require(\"../../api/core/accounts\"), {\n  sendUpdatedVerificationEmail(v) {\n    sendUpdatedVerificationEmail = v;\n  }\n\n}, 13);\n\nfunction verifyAccount() {\n  if (!this.userId) {\n    // not logged in\n    return;\n  }\n\n  const user = Meteor.user();\n  const addresses = user.emails.filter(email => email.verified).map(email => email.address);\n  const result = Accounts.update({\n    \"userId\": this.userId,\n    \"emails.address\": {\n      $in: addresses\n    }\n  }, {\n    $set: {\n      \"emails.$.verified\": true\n    }\n  });\n\n  if (result) {\n    Hooks.Events.run(\"afterAccountsUpdate\", this.userId, {\n      accountId: Accounts.findOne({\n        userId: this.userId\n      })._id,\n      updatedFields: [\"emails\"]\n    });\n  }\n\n  return result;\n}\n\nfunction updateEmailAddress(email) {\n  check(email, String);\n  const user = Meteor.user(); // Add email to user account\n\n  MeteorAccounts.addEmail(user._id, email);\n  return true;\n}\n\nfunction removeEmailAddress(email) {\n  check(email, String);\n  const user = Meteor.user(); // Remove email address from user\n\n  MeteorAccounts.removeEmail(user._id, email); // Verify new address\n\n  sendUpdatedVerificationEmail(user._id); // Sync users and accounts collections\n\n  syncUsersAndAccounts();\n  return true;\n}\n\nfunction syncUsersAndAccounts() {\n  const user = Meteor.user();\n  Accounts.update({\n    _id: user._id\n  }, {\n    $set: {\n      emails: [user.emails[0]]\n    }\n  });\n  Hooks.Events.run(\"afterAccountsUpdate\", user._id, {\n    accountId: user._id,\n    updatedFields: [\"emails\"]\n  });\n  return true;\n}\n\n/**\n * @name getValidator\n * @summary Returns the name of the geocoder method to use\n * @returns {string} Name of the Geocoder method to use\n * @private\n */\nfunction getValidator() {\n  const shopId = Reaction.getShopId();\n  const geoCoders = Packages.find({\n    \"registry\": {\n      $elemMatch: {\n        provides: \"addressValidation\"\n      }\n    },\n    \"settings.addressValidation.enabled\": true,\n    shopId,\n    \"enabled\": true\n  }).fetch();\n\n  if (!geoCoders.length) {\n    return \"\";\n  }\n\n  let geoCoder; // Just one?, use that one\n\n  if (geoCoders.length === 1) {\n    [geoCoder] = geoCoders;\n  } // If there are two, we default to the one that is not the Reaction one\n\n\n  if (geoCoders.length === 2) {\n    geoCoder = geoCoders.find(coder => !coder.name.includes(\"reaction\"));\n  } // check if addressValidation is enabled but the package is disabled, don't do address validation\n\n\n  let registryName;\n\n  for (const registry of geoCoder.registry) {\n    if (registry.provides && registry.provides.includes(\"addressValidation\")) {\n      registryName = registry.name;\n    }\n  }\n\n  const packageKey = registryName.split(\"/\")[2]; // \"taxes/addressValidation/{packageKey}\"\n\n  if (!_get(geoCoder.settings[packageKey], \"enabled\")) {\n    return \"\";\n  }\n\n  const methodName = geoCoder.settings.addressValidation.addressValidationMethod;\n  return methodName;\n}\n/**\n * @name compareAddress\n * @summary Compare individual fields of address and accumulate errors\n * @param {Object} address - the address provided by the customer\n * @param {Object} validationAddress - address provided by validator\n * @returns {Object} An object with an array of errors per field\n * @private\n */\n\n\nfunction compareAddress(address, validationAddress) {\n  const errors = {\n    address1: [],\n    address2: [],\n    city: [],\n    postal: [],\n    region: [],\n    country: [],\n    totalErrors: 0\n  }; // first check, if a field is missing (and was present in original address), that means it didn't validate\n  // TODO rewrite with just a loop over field names but KISS for now\n\n  if (address.address1 && !validationAddress.address1) {\n    errors.address1.push(\"Address line one did not validate\");\n    errors.totalErrors += 1;\n  }\n\n  if (address.address2 && validationAddress.address2 && _trim(_upperCase(address.address2)) !== _trim(_upperCase(validationAddress.address2))) {\n    errors.address2.push(\"Address line 2 did not validate\");\n    errors.totalErrors += 1;\n  }\n\n  if (!validationAddress.city) {\n    errors.city.push(\"City did not validate\");\n    errors.totalErrors += 1;\n  }\n\n  if (address.postal && !validationAddress.postal) {\n    errors.postal.push(\"Postal did not validate\");\n    errors.totalErrors += 1;\n  }\n\n  if (address.region && !validationAddress.region) {\n    errors.region.push(\"Region did not validate\");\n    errors.totalErrors += 1;\n  }\n\n  if (address.country && !validationAddress.country) {\n    errors.country.push(\"Country did not validate\");\n    errors.totalErrors += 1;\n  } // second check if both fields exist, but they don't match (which almost always happen for certain fields on first time)\n\n\n  if (validationAddress.address1 && address.address1 && _trim(_upperCase(address.address1)) !== _trim(_upperCase(validationAddress.address1))) {\n    errors.address1.push({\n      address1: \"Address line 1 did not match\"\n    });\n    errors.totalErrors += 1;\n  }\n\n  if (validationAddress.address2 && address.address2 && _upperCase(address.address2) !== _upperCase(validationAddress.address2)) {\n    errors.address2.push(\"Address line 2 did not match\");\n    errors.totalErrors += 1;\n  }\n\n  if (validationAddress.city && address.city && _trim(_upperCase(address.city)) !== _trim(_upperCase(validationAddress.city))) {\n    errors.city.push(\"City did not match\");\n    errors.totalErrors += 1;\n  }\n\n  if (validationAddress.postal && address.postal && _trim(_upperCase(address.postal)) !== _trim(_upperCase(validationAddress.postal))) {\n    errors.postal.push(\"Postal Code did not match\");\n    errors.totalErrors += 1;\n  }\n\n  if (validationAddress.region && address.region && _trim(_upperCase(address.region)) !== _trim(_upperCase(validationAddress.region))) {\n    errors.region.push(\"Region did not match\");\n    errors.totalErrors += 1;\n  }\n\n  if (validationAddress.country && address.country && _upperCase(address.country) !== _upperCase(validationAddress.country)) {\n    errors.country.push(\"Country did not match\");\n    errors.totalErrors += 1;\n  }\n\n  return errors;\n}\n/**\n * @name accounts/validateAddress\n * @memberof Methods/Accounts\n * @method\n * @summary Validates an address, and if fails returns details of issues\n * @param {Object} address - The address object to validate\n * @returns {{validated: boolean, address: *}} - The results of the validation\n */\n\n\nfunction validateAddress(address) {\n  Schemas.Address.clean(address);\n  Schemas.Address.validate(address);\n  let validated = true;\n  let validationErrors;\n  let suggestedAddress = {};\n  let formErrors;\n  const validator = getValidator();\n\n  if (validator) {\n    const validationResult = Meteor.call(validator, address);\n    ({\n      validatedAddress: suggestedAddress\n    } = validationResult);\n    formErrors = validationResult.errors;\n\n    if (suggestedAddress) {\n      validationErrors = compareAddress(address, suggestedAddress);\n\n      if (validationErrors.totalErrors || formErrors.length) {\n        validated = false;\n        suggestedAddress.failedValidation = true;\n      }\n    } else {\n      // No address, fail validation\n      validated = false;\n      suggestedAddress = {\n        failedValidation: true\n      };\n    }\n  }\n\n  suggestedAddress = (0, _objectSpread2.default)({}, address, suggestedAddress);\n  const validationResults = {\n    validated,\n    fieldErrors: validationErrors,\n    formErrors,\n    suggestedAddress,\n    enteredAddress: address\n  };\n  return validationResults;\n}\n\n/**\n * @name currentUserHasPassword\n * @summary Check if current user has password\n * @returns {Boolean} True if current user has password\n * @private\n */\nfunction currentUserHasPassword() {\n  const user = Meteor.users.findOne(Meteor.userId());\n  return !!user.services.password;\n}\n/**\n * @name accounts/addressBookAdd\n * @memberof Methods/Accounts\n * @method\n * @summary Add new addresses to an account\n * @example Meteor.call(\"accounts/addressBookAdd\", address, callBackFunction(error, result))\n * @param {Object} address - address\n * @param {String} [accountUserId] - `account.userId` used by admin to edit users\n * @return {Object} with updated address\n */\n\n\nfunction addressBookAdd(address, accountUserId) {\n  Schemas.Address.validate(address);\n  check(accountUserId, Match.Optional(String)); // security, check for admin access. We don't need to check every user call\n  // here because we are calling `Meteor.userId` from within this Method.\n\n  if (typeof accountUserId === \"string\") {\n    // if this will not be a String -\n    // `check` will not pass it.\n    if (Meteor.userId() !== accountUserId && !Reaction.hasPermission(\"reaction-accounts\")) {\n      throw new Meteor.Error(\"access-denied\", \"Access denied\");\n    }\n  }\n\n  this.unblock();\n  const userId = accountUserId || Meteor.userId();\n  const account = Accounts.findOne({\n    userId\n  }); // required default id\n\n  if (!address._id) {\n    address._id = Random.id();\n  } // if address got shippment or billing default, we need to update cart\n  // addresses accordingly\n\n\n  if (address.isShippingDefault || address.isBillingDefault) {\n    const cart = Cart.findOne({\n      userId\n    }); // if cart exists\n    // First amend the cart,\n\n    if (typeof cart === \"object\") {\n      if (address.isShippingDefault) {\n        Meteor.call(\"cart/setShipmentAddress\", cart._id, address);\n      }\n\n      if (address.isBillingDefault) {\n        Meteor.call(\"cart/setPaymentAddress\", cart._id, address);\n      }\n    } // then change the address that has been affected\n\n\n    if (address.isShippingDefault) {\n      Accounts.update({\n        userId,\n        \"profile.addressBook.isShippingDefault\": true\n      }, {\n        $set: {\n          \"profile.addressBook.$.isShippingDefault\": false\n        }\n      });\n      Hooks.Events.run(\"afterAccountsUpdate\", Meteor.userId(), {\n        accountId: account._id,\n        updatedFields: [\"isShippingDefault\"]\n      });\n    }\n\n    if (address.isBillingDefault) {\n      Accounts.update({\n        userId,\n        \"profile.addressBook.isBillingDefault\": true\n      }, {\n        $set: {\n          \"profile.addressBook.$.isBillingDefault\": false\n        }\n      });\n      Hooks.Events.run(\"afterAccountsUpdate\", Meteor.userId(), {\n        accountId: account._id,\n        updatedFields: [\"isBillingDefault\"]\n      });\n    }\n  }\n\n  const userUpdateQuery = {\n    $set: {\n      \"profile.addressBook\": address\n    }\n  };\n  const accountsUpdateQuery = {\n    $set: {\n      userId\n    },\n    $addToSet: {\n      \"profile.addressBook\": address\n    }\n  };\n\n  if (!account.name || _get(account, \"profile.addressBook.length\", 0) === 0) {\n    userUpdateQuery.$set.name = address.fullName;\n    accountsUpdateQuery.$set.name = address.fullName;\n  }\n\n  Meteor.users.update(Meteor.userId(), userUpdateQuery);\n  const result = Accounts.upsert({\n    userId\n  }, accountsUpdateQuery); // If the address update was successful, then return the full updated addrtess\n\n  if (result.numberAffected === 1) {\n    // Find the account\n    const updatedAccount = Accounts.findOne({\n      userId\n    }); // Pull the updated address and return it\n\n    return updatedAccount.profile.addressBook.find(updatedAddress => address._id === updatedAddress._id);\n  }\n\n  throw new Meteor.Error(\"server-error\", \"Unable to add address to account\");\n}\n\nfunction addressBookUpdate(address, accountUserId, type) {\n  Schemas.Address.validate(address);\n  check(accountUserId, Match.OneOf(String, null, undefined));\n  check(type, Match.Maybe(String)); // security, check for admin access. We don't need to check every user call\n  // here because we are calling `Meteor.userId` from within this Method.\n\n  if (typeof accountUserId === \"string\") {\n    // if this will not be a String -\n    // `check` will not pass it.\n    if (Meteor.userId() !== accountUserId && !Reaction.hasPermission(\"reaction-accounts\")) {\n      throw new Meteor.Error(\"access-denied\", \"Access denied\");\n    }\n  }\n\n  this.unblock(); // If no userId is provided, use the current user\n\n  const userId = accountUserId || Meteor.userId(); // Find old state of isShippingDefault & isBillingDefault to compare and reflect in cart\n\n  const account = Accounts.findOne({\n    userId\n  });\n  const oldAddress = (account.profile.addressBook || []).find(addr => addr._id === address._id);\n  if (!oldAddress) throw new Meteor.Error(\"not-found\", `No existing address found with ID ${address._id}`); // Set new address to be default for `type`\n\n  if (typeof type === \"string\") {\n    Object.assign(address, {\n      [type]: true\n    });\n  } // We want the cart addresses to be updated when current default address\n  // (shipping or Billing) are different than the previous one, but also\n  // when the current default address(ship or bill) gets edited(so Current and Previous default are the same).\n  // This check can be simplified to :\n\n\n  if (address.isShippingDefault || address.isBillingDefault || oldAddress.isShippingDefault || oldAddress.isBillingDefault) {\n    // Find user cart\n    // Cart should exist to this moment, so we don't need to to verify its existence.\n    const cart = Cart.findOne({\n      userId\n    }); // If isShippingDefault address has changed\n\n    if (oldAddress.isShippingDefault !== address.isShippingDefault) {\n      // Update the cart to use new default shipping address\n      if (address.isShippingDefault) {\n        Meteor.call(\"cart/setShipmentAddress\", cart._id, address);\n      } else {\n        // If the new address is not the shipping default, remove it from the cart\n        Meteor.call(\"cart/unsetAddresses\", address._id, userId, \"shipping\");\n      }\n    } else if (address.isShippingDefault && oldAddress.isShippingDefault) {\n      // If shipping address was edited, but isShippingDefault status not changed, update the cart address\n      Meteor.call(\"cart/setShipmentAddress\", cart._id, address);\n    } // If isBillingDefault address has changed\n\n\n    if (oldAddress.isBillingDefault !== address.isBillingDefault) {\n      // Update the cart to use new default billing address\n      if (address.isBillingDefault) {\n        Meteor.call(\"cart/setPaymentAddress\", cart._id, address);\n      } else {\n        // If the new address is not the shipping default, remove it from the cart\n        Meteor.call(\"cart/unsetAddresses\", address._id, userId, \"billing\");\n      }\n    } else if (address.isBillingDefault && oldAddress.isBillingDefault) {\n      // If shipping address was edited, but isShippingDefault status not changed, update the cart address\n      Meteor.call(\"cart/setPaymentAddress\", cart._id, address);\n    }\n  } // Update all other to set the default type to false\n\n\n  account.profile.addressBook.forEach(addr => {\n    if (addr._id === address._id) {\n      Object.assign(addr, address);\n    } else if (typeof type === \"string\") {\n      Object.assign(addr, {\n        [type]: false\n      });\n    }\n  }); // TODO: revisit why we update Meteor.users differently than accounts\n  // We could possibly remove the whole `userUpdateQuery` variable\n  // and update Meteor.users with the accountsUpdateQuery data\n\n  const userUpdateQuery = {\n    $set: {\n      \"profile.addressBook\": address\n    }\n  };\n  const accountsUpdateQuery = {\n    $set: {\n      \"profile.addressBook\": account.profile.addressBook\n    }\n  }; // update the name when there is no name or the user updated his only shipping address\n\n  if (!account.name || _get(account, \"profile.addressBook.length\", 0) <= 1) {\n    userUpdateQuery.$set.name = address.fullName;\n    accountsUpdateQuery.$set.name = address.fullName;\n  } // Update the Meteor.users collection with new address info\n\n\n  Meteor.users.update(Meteor.userId(), userUpdateQuery); // Update the Reaction Accounts collection with new address info\n\n  const updatedAccountResult = Accounts.update({\n    userId\n  }, accountsUpdateQuery); // Create an array which contains all fields that have changed\n  // This is used for search, to determine if we need to re-index\n\n  const updatedFields = [];\n  Object.keys(address).forEach(key => {\n    if (address[key] !== oldAddress[key]) {\n      updatedFields.push(key);\n    }\n  }); // Run afterAccountsUpdate hook to update Accounts Search\n\n  Hooks.Events.run(\"afterAccountsUpdate\", Meteor.userId(), {\n    accountId: account._id,\n    updatedFields\n  }); // If the address update was successful, then return the full updated addrtess\n\n  if (updatedAccountResult === 1) {\n    // Find the account\n    const updatedAccount = Accounts.findOne({\n      userId\n    }); // Pull the updated address and return it\n\n    return updatedAccount.profile.addressBook.find(updatedAddress => address._id === updatedAddress._id);\n  }\n\n  throw new Meteor.Error(\"server-error\", \"Unable to update account address\");\n}\n\nfunction addressBookRemove(addressId, accountUserId) {\n  check(addressId, String);\n  check(accountUserId, Match.Optional(String)); // security, check for admin access. We don't need to check every user call\n  // here because we are calling `Meteor.userId` from within this Method.\n\n  if (typeof accountUserId === \"string\") {\n    // if this will not be a String -\n    // `check` will not pass it.\n    if (Meteor.userId() !== accountUserId && !Reaction.hasPermission(\"reaction-accounts\")) {\n      throw new Meteor.Error(\"access-denied\", \"Access denied\");\n    }\n  }\n\n  this.unblock();\n  const userId = accountUserId || Meteor.userId();\n  const account = Accounts.findOne({\n    userId\n  }); // remove this address in cart, if used, before completely removing\n\n  Meteor.call(\"cart/unsetAddresses\", addressId, userId);\n  const updatedAccountResult = Accounts.update({\n    userId,\n    \"profile.addressBook._id\": addressId\n  }, {\n    $pull: {\n      \"profile.addressBook\": {\n        _id: addressId\n      }\n    }\n  }, {\n    bypassCollection2: true\n  }); // forceIndex when removing an address\n\n  Hooks.Events.run(\"afterAccountsUpdate\", Meteor.userId(), {\n    accountId: account._id,\n    updatedFields: [\"forceIndex\"]\n  }); // If the address remove was successful, then return the removed addrtess\n\n  if (updatedAccountResult === 1) {\n    // Pull the address from the account before it was updated and return it\n    return account.profile.addressBook.find(removedAddress => addressId === removedAddress._id);\n  }\n\n  throw new Meteor.Error(\"server-error\", \"Unable to remove address from account\");\n}\n\nfunction inviteShopOwner(options, shopData) {\n  check(options, Object);\n  check(options.email, String);\n  check(options.name, String);\n  check(shopData, Match.Maybe(Object));\n  const {\n    name,\n    email\n  } = options;\n\n  if (!Reaction.hasPermission(\"admin\", this.userId, Reaction.getPrimaryShopId())) {\n    throw new Meteor.Error(\"access-denied\", \"Access denied\");\n  }\n\n  const user = Meteor.users.findOne({\n    \"emails.address\": email\n  });\n  let userId;\n\n  if (user) {\n    // TODO: Verify email address\n    userId = user._id;\n  } else {\n    userId = MeteorAccounts.createUser({\n      email,\n      name,\n      profile: {\n        invited: true\n      }\n    });\n  }\n\n  Meteor.call(\"shop/createShop\", userId, shopData);\n  const primaryShop = Reaction.getPrimaryShop(); // Compile Email with SSR\n\n  const tpl = \"accounts/inviteShopOwner\";\n  const subject = \"accounts/inviteShopOwner/subject\";\n  SSR.compileTemplate(tpl, Reaction.Email.getTemplate(tpl));\n  SSR.compileTemplate(subject, Reaction.Email.getSubject(tpl));\n  const emailLogo = Reaction.Email.getShopLogo(primaryShop);\n  const token = Random.id();\n  const currentUser = Meteor.users.findOne(this.userId);\n  const currentUserName = getCurrentUserName(currentUser); // uses primaryShop's data (name, address etc) in email copy sent to new merchant\n\n  const dataForEmail = getDataForEmail({\n    shop: primaryShop,\n    currentUserName,\n    name,\n    token,\n    emailLogo\n  });\n  Meteor.users.update(userId, {\n    $set: {\n      \"services.password.reset\": {\n        token,\n        email,\n        when: new Date()\n      },\n      name\n    }\n  });\n  Reaction.Email.send({\n    to: email,\n    from: `${_get(dataForEmail, \"primaryShop.name\")} <${_get(dataForEmail, \"primaryShop.emails[0].address\")}>`,\n    subject: SSR.render(subject, dataForEmail),\n    html: SSR.render(tpl, dataForEmail)\n  });\n  return true;\n}\n\nfunction inviteShopMember(options) {\n  const {\n    shopId,\n    email,\n    name,\n    groupId\n  } = options;\n  check(options, Object);\n  check(shopId, String);\n  check(email, String);\n  check(name, String);\n  check(groupId, String);\n  this.unblock();\n  const shop = Shops.findOne(shopId);\n  const primaryShop = Reaction.getPrimaryShop();\n\n  if (!shop) {\n    const msg = `accounts/inviteShopMember - Shop ${shopId} not found`;\n    Logger.error(msg);\n    throw new Meteor.Error(\"not-found\", msg);\n  }\n\n  if (!Reaction.hasPermission(\"reaction-accounts\", this.userId, shopId)) {\n    Logger.error(`User ${this.userId} does not have reaction-accounts permissions`);\n    throw new Meteor.Error(\"access-denied\", \"Access denied\");\n  }\n\n  const group = Groups.findOne({\n    _id: groupId\n  }) || {}; // check to ensure that invitee has roles required to perform the invitation\n\n  if (!Reaction.canInviteToGroup({\n    group,\n    user: Meteor.user()\n  })) {\n    throw new Meteor.Error(\"access-denied\", \"Cannot invite to group\");\n  }\n\n  if (group.slug === \"owner\") {\n    throw new Meteor.Error(\"bad-request\", \"Cannot directly invite owner\");\n  }\n\n  const currentUser = Meteor.users.findOne(this.userId);\n  const currentUserName = getCurrentUserName(currentUser);\n  const emailLogo = Reaction.Email.getShopLogo(primaryShop);\n  const user = Meteor.users.findOne({\n    \"emails.address\": email\n  });\n  const token = Random.id();\n  let dataForEmail;\n  let userId;\n  let tpl;\n  let subject; // If the user already has an account, send informative email, not \"invite\" email\n\n  if (user) {\n    // The user already exists, we promote the account, rather than creating a new one\n    userId = user._id;\n    Meteor.call(\"group/addUser\", userId, groupId); // do not send token, as no password reset is needed\n\n    const url = Meteor.absoluteUrl(); // use primaryShop's data (name, address etc) in email copy sent to new shop manager\n\n    dataForEmail = getDataForEmail({\n      shop: primaryShop,\n      currentUserName,\n      name,\n      emailLogo,\n      url\n    }); // Get email template and subject\n\n    tpl = \"accounts/inviteShopMember\";\n    subject = \"accounts/inviteShopMember/subject\";\n  } else {\n    // The user does not already exist, we need to create a new account\n    userId = MeteorAccounts.createUser({\n      profile: {\n        invited: true\n      },\n      email,\n      name,\n      groupId\n    }); // set token to be used for first login for the new account\n\n    const tokenUpdate = {\n      \"services.password.reset\": {\n        token,\n        email,\n        when: new Date()\n      },\n      name\n    };\n    Meteor.users.update(userId, {\n      $set: tokenUpdate\n    }); // use primaryShop's data (name, address etc) in email copy sent to new shop manager\n\n    dataForEmail = getDataForEmail({\n      shop: primaryShop,\n      currentUserName,\n      name,\n      token,\n      emailLogo\n    }); // Get email template and subject\n\n    tpl = \"accounts/inviteNewShopMember\";\n    subject = \"accounts/inviteNewShopMember/subject\";\n  }\n\n  dataForEmail.groupName = _startCase(group.name); // Compile Email with SSR\n\n  SSR.compileTemplate(tpl, Reaction.Email.getTemplate(tpl));\n  SSR.compileTemplate(subject, Reaction.Email.getSubject(tpl)); // send invitation email from primary shop email\n\n  Reaction.Email.send({\n    to: email,\n    from: `${dataForEmail.primaryShop.name} <${dataForEmail.primaryShop.emails[0].address}>`,\n    subject: SSR.render(subject, dataForEmail),\n    html: SSR.render(tpl, dataForEmail)\n  });\n  return Accounts.findOne({\n    userId\n  });\n}\n\nfunction sendWelcomeEmail(shopId, userId, token) {\n  check(shopId, String);\n  check(userId, String);\n  check(token, String);\n  this.unblock();\n  const account = Accounts.findOne(userId); // anonymous users arent welcome here\n\n  if (!account.emails || !account.emails.length > 0) {\n    return false;\n  }\n\n  const shop = Shops.findOne(shopId); // Get shop logo, if available. If not, use default logo from file-system\n\n  const emailLogo = Reaction.Email.getShopLogo(shop);\n  const copyrightDate = new Date().getFullYear();\n  const user = Meteor.user();\n  const dataForEmail = {\n    // Shop Data\n    shop,\n    contactEmail: shop.emails[0].address,\n    emailLogo,\n    copyrightDate,\n    legalName: _get(shop, \"addressBook[0].company\"),\n    physicalAddress: {\n      address: `${_get(shop, \"addressBook[0].address1\")} ${_get(shop, \"addressBook[0].address2\")}`,\n      city: _get(shop, \"addressBook[0].city\"),\n      region: _get(shop, \"addressBook[0].region\"),\n      postal: _get(shop, \"addressBook[0].postal\")\n    },\n    shopName: shop.name,\n    socialLinks: {\n      display: true,\n      facebook: {\n        display: true,\n        icon: `${Meteor.absoluteUrl()}resources/email-templates/facebook-icon.png`,\n        link: \"https://www.facebook.com\"\n      },\n      googlePlus: {\n        display: true,\n        icon: `${Meteor.absoluteUrl()}resources/email-templates/google-plus-icon.png`,\n        link: \"https://plus.google.com\"\n      },\n      twitter: {\n        display: true,\n        icon: `${Meteor.absoluteUrl()}resources/email-templates/twitter-icon.png`,\n        link: \"https://www.twitter.com\"\n      }\n    },\n    user\n  };\n  dataForEmail.verificationUrl = MeteorAccounts.urls.verifyEmail(token);\n  const userEmail = account.emails[0].address;\n  let shopEmail; // provide some defaults for missing shop email.\n\n  if (!shop.emails) {\n    shopEmail = `${shop.name}@localhost`;\n    Logger.debug(`Shop email address not configured. Using ${shopEmail}`);\n  } else {\n    shopEmail = shop.emails[0].address;\n  }\n\n  const tpl = \"accounts/sendWelcomeEmail\";\n  const subject = \"accounts/sendWelcomeEmail/subject\";\n  SSR.compileTemplate(tpl, Reaction.Email.getTemplate(tpl));\n  SSR.compileTemplate(subject, Reaction.Email.getSubject(tpl));\n  Reaction.Email.send({\n    to: userEmail,\n    from: `${shop.name} <${shopEmail}>`,\n    subject: SSR.render(subject, dataForEmail),\n    html: SSR.render(tpl, dataForEmail)\n  });\n  return true;\n}\n\nfunction addUserPermissions(userId, permissions, group) {\n  if (!Reaction.hasPermission(\"reaction-accounts\", Meteor.userId(), group)) {\n    throw new Meteor.Error(\"access-denied\", \"Access denied\");\n  }\n\n  check(userId, Match.OneOf(String, Array));\n  check(permissions, Match.OneOf(String, Array));\n  check(group, Match.Optional(String));\n  this.unblock();\n\n  try {\n    return Roles.addUsersToRoles(userId, permissions, group);\n  } catch (error) {\n    return Logger.error(error);\n  }\n}\n\nfunction removeUserPermissions(userId, permissions, group) {\n  if (!Reaction.hasPermission(\"reaction-accounts\", Meteor.userId(), group)) {\n    throw new Meteor.Error(\"access-denied\", \"Access denied\");\n  }\n\n  check(userId, String);\n  check(permissions, Match.OneOf(String, Array));\n  check(group, Match.Optional(String, null));\n  this.unblock();\n\n  try {\n    return Roles.removeUsersFromRoles(userId, permissions, group);\n  } catch (error) {\n    Logger.error(error);\n    throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n  }\n}\n\nfunction setUserPermissions(userId, permissions, group) {\n  if (!Reaction.hasPermission(\"reaction-accounts\", Meteor.userId(), group)) {\n    throw new Meteor.Error(\"access-denied\", \"Access denied\");\n  }\n\n  check(userId, String);\n  check(permissions, Match.OneOf(String, Array));\n  check(group, Match.Optional(String));\n  this.unblock();\n\n  try {\n    return Roles.setUserRoles(userId, permissions, group);\n  } catch (error) {\n    Logger.error(error);\n    return error;\n  }\n}\n\n/**\n * @name getCurrentUserName\n * @memberof Methods/Accounts\n * @method\n * @private\n * @param  {Object} currentUser - User\n * @return {String} Name of currentUser or \"Admin\"\n */\nfunction getCurrentUserName(currentUser) {\n  if (currentUser) {\n    if (currentUser.profile && currentUser.profile.name) {\n      return currentUser.profile.name;\n    }\n\n    if (currentUser.name) {\n      return currentUser.name;\n    }\n\n    if (currentUser.username) {\n      return currentUser.username;\n    }\n  }\n\n  return \"Admin\";\n}\n/**\n * @name getDataForEmail\n * @memberof Methods/Accounts\n * @method\n * @private\n * @param  {Object} options - shop, currentUserName, token, emailLogo, name\n * @return {Object} data - primaryShop, shop, contactEmail, homepage,\n * emailLogo, legalName, physicalAddress, shopName, socialLinks, user, invitedUserName, url\n */\n\n\nfunction getDataForEmail(options) {\n  const {\n    shop,\n    currentUserName,\n    token,\n    emailLogo,\n    name,\n    url\n  } = options;\n  const primaryShop = Shops.findOne(Reaction.getPrimaryShopId());\n  const copyrightDate = new Date().getFullYear();\n  return {\n    primaryShop,\n    // Primary shop data - may or may not be the same as shop\n    shop,\n    // Shop Data\n    contactEmail: _get(shop, \"emails[0].address\"),\n    homepage: Meteor.absoluteUrl(),\n    emailLogo,\n    copyrightDate,\n    legalName: _get(shop, \"addressBook[0].company\"),\n    physicalAddress: {\n      address: `${_get(shop, \"addressBook[0].address1\")} ${_get(shop, \"addressBook[0].address2\")}`,\n      city: _get(shop, \"addressBook[0].city\"),\n      region: _get(shop, \"addressBook[0].region\"),\n      postal: _get(shop, \"addressBook[0].postal\")\n    },\n    shopName: shop.name,\n    socialLinks: {\n      display: true,\n      facebook: {\n        display: true,\n        icon: `${Meteor.absoluteUrl()}resources/email-templates/facebook-icon.png`,\n        link: \"https://www.facebook.com\"\n      },\n      googlePlus: {\n        display: true,\n        icon: `${Meteor.absoluteUrl()}resources/email-templates/google-plus-icon.png`,\n        link: \"https://plus.google.com\"\n      },\n      twitter: {\n        display: true,\n        icon: `${Meteor.absoluteUrl()}resources/email-templates/twitter-icon.png`,\n        link: \"https://www.twitter.com\"\n      }\n    },\n    user: Meteor.user(),\n    // Account Data\n    currentUserName,\n    invitedUserName: name,\n    url: url || getEmailUrl(token)\n  };\n\n  function getEmailUrl(userToken) {\n    if (userToken) {\n      return MeteorAccounts.urls.enrollAccount(userToken);\n    }\n\n    return Meteor.absoluteUrl();\n  }\n}\n/**\n * @name accounts/createFallbackLoginToken\n * @memberof Methods/Accounts\n * @method\n * @summary Returns a new loginToken for current user, that can be used for special login scenarios\n * e.g. store the newly created token as cookie on the browser, if the client does not offer local storage.\n * @returns {String} loginToken for current user\n */\n\n\nfunction createFallbackLoginToken() {\n  if (this.userId) {\n    const stampedLoginToken = MeteorAccounts._generateStampedLoginToken();\n\n    const loginToken = stampedLoginToken.token;\n\n    MeteorAccounts._insertLoginToken(this.userId, stampedLoginToken);\n\n    return loginToken;\n  }\n}\n\nfunction setProfileCurrency(currencyName, accountId) {\n  check(currencyName, String);\n  check(accountId, Match.Maybe(String));\n  const currentUserId = this.userId;\n  const userId = accountId || currentUserId;\n  if (!userId) throw new Meteor.Error(\"access-denied\", \"You must be logged in to set profile currency\");\n  const account = Accounts.findOne({\n    userId\n  }, {\n    fields: {\n      shopId: 1\n    }\n  });\n  if (!account) throw new Meteor.Error(\"not-found\", \"Account not found\");\n\n  if (userId !== currentUserId && !Reaction.hasPermission(\"reaction-accounts\", currentUserId, account.shopId)) {\n    throw new Meteor.Error(\"access-denied\", \"Access denied\");\n  } // Make sure this currency code is in the related shop currencies list\n\n\n  const shop = Shops.findOne({\n    _id: account.shopId\n  }, {\n    fields: {\n      currencies: 1\n    }\n  });\n\n  if (!shop || !shop.currencies || !shop.currencies[currencyName]) {\n    throw new Meteor.Error(\"invalid-argument\", `The shop for this account does not define any currency with code \"${currencyName}\"`);\n  }\n\n  Accounts.update({\n    userId\n  }, {\n    $set: {\n      \"profile.currency\": currencyName\n    }\n  });\n  Hooks.Events.run(\"afterAccountsUpdate\", userId, {\n    accountId: account._id,\n    updatedFields: [\"currency\"]\n  });\n  return Accounts.findOne({\n    userId\n  });\n}\n\n/**\n * @name markAddressValidationBypassed\n * @summary Write that the customer has bypassed address validation\n * @returns {Number} updateResult - Result of the update\n */\nfunction markAddressValidationBypassed(value = true) {\n  check(value, Boolean);\n  const userId = Meteor.userId();\n  const updateResult = Cart.update({\n    userId\n  }, {\n    $set: {\n      bypassAddressValidation: value\n    }\n  });\n  return updateResult;\n}\n/**\n * @name markTaxCalculationFailed\n * @summary Write tax calculation has failed for this customer\n * @returns {Number} updateResult - Result of the update\n */\n\n\nfunction markTaxCalculationFailed(value = true) {\n  check(value, Boolean);\n  const userId = Meteor.userId();\n  const updateResult = Cart.update({\n    userId\n  }, {\n    $set: {\n      taxCalculationFailed: value\n    }\n  });\n  return updateResult;\n}\n\nMeteor.methods({\n  \"accounts/verifyAccount\": verifyAccount,\n  \"accounts/validateAddress\": validateAddress,\n  \"accounts/currentUserHasPassword\": currentUserHasPassword,\n  \"accounts/addressBookAdd\": addressBookAdd,\n  \"accounts/addressBookUpdate\": addressBookUpdate,\n  \"accounts/addressBookRemove\": addressBookRemove,\n  \"accounts/inviteShopMember\": inviteShopMember,\n  \"accounts/inviteShopOwner\": inviteShopOwner,\n  \"accounts/sendWelcomeEmail\": sendWelcomeEmail,\n  \"accounts/addUserPermissions\": addUserPermissions,\n  \"accounts/removeUserPermissions\": removeUserPermissions,\n  \"accounts/setUserPermissions\": setUserPermissions,\n  \"accounts/createFallbackLoginToken\": createFallbackLoginToken,\n  \"accounts/updateEmailAddress\": updateEmailAddress,\n  \"accounts/removeEmailAddress\": removeEmailAddress,\n  \"accounts/setProfileCurrency\": setProfileCurrency,\n  \"accounts/markAddressValidationBypassed\": markAddressValidationBypassed,\n  \"accounts/markTaxCalculationFailed\": markTaxCalculationFailed\n});","map":{"version":3,"sources":["server/methods/accounts/accounts.js"],"names":["module","export","verifyAccount","updateEmailAddress","removeEmailAddress","syncUsersAndAccounts","validateAddress","addressBookAdd","addressBookUpdate","addressBookRemove","inviteShopOwner","inviteShopMember","sendWelcomeEmail","addUserPermissions","removeUserPermissions","setUserPermissions","createFallbackLoginToken","setProfileCurrency","_startCase","watch","require","default","v","_upperCase","_trim","_get","Meteor","Random","MeteorAccounts","Accounts","check","Match","Roles","SSR","Cart","Groups","Shops","Packages","Schemas","Hooks","Logger","Reaction","sendUpdatedVerificationEmail","userId","user","addresses","emails","filter","email","verified","map","address","result","update","$in","$set","Events","run","accountId","findOne","_id","updatedFields","String","addEmail","removeEmail","getValidator","shopId","getShopId","geoCoders","find","$elemMatch","provides","fetch","length","geoCoder","coder","name","includes","registryName","registry","packageKey","split","settings","methodName","addressValidation","addressValidationMethod","compareAddress","validationAddress","errors","address1","address2","city","postal","region","country","totalErrors","push","Address","clean","validate","validated","validationErrors","suggestedAddress","formErrors","validator","validationResult","call","validatedAddress","failedValidation","validationResults","fieldErrors","enteredAddress","currentUserHasPassword","users","services","password","accountUserId","Optional","hasPermission","Error","unblock","account","id","isShippingDefault","isBillingDefault","cart","userUpdateQuery","accountsUpdateQuery","$addToSet","fullName","upsert","numberAffected","updatedAccount","profile","addressBook","updatedAddress","type","OneOf","undefined","Maybe","oldAddress","addr","Object","assign","forEach","updatedAccountResult","keys","key","addressId","$pull","bypassCollection2","removedAddress","options","shopData","getPrimaryShopId","createUser","invited","primaryShop","getPrimaryShop","tpl","subject","compileTemplate","Email","getTemplate","getSubject","emailLogo","getShopLogo","token","currentUser","currentUserName","getCurrentUserName","dataForEmail","getDataForEmail","shop","when","Date","send","to","from","render","html","groupId","msg","error","group","canInviteToGroup","slug","url","absoluteUrl","tokenUpdate","groupName","copyrightDate","getFullYear","contactEmail","legalName","physicalAddress","shopName","socialLinks","display","facebook","icon","link","googlePlus","twitter","verificationUrl","urls","verifyEmail","userEmail","shopEmail","debug","permissions","Array","addUsersToRoles","removeUsersFromRoles","setUserRoles","username","homepage","invitedUserName","getEmailUrl","userToken","enrollAccount","stampedLoginToken","_generateStampedLoginToken","loginToken","_insertLoginToken","currencyName","currentUserId","fields","currencies","markAddressValidationBypassed","value","Boolean","updateResult","bypassAddressValidation","markTaxCalculationFailed","taxCalculationFailed","methods"],"mappings":"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","sourcesContent":["import _ from \"lodash\";\nimport { Meteor } from \"meteor/meteor\";\nimport { Random } from \"meteor/random\";\nimport { Accounts as MeteorAccounts } from \"meteor/accounts-base\";\nimport { check, Match } from \"meteor/check\";\nimport { Roles } from \"meteor/alanning:roles\";\nimport { SSR } from \"meteor/meteorhacks:ssr\";\nimport { Accounts, Cart, Groups, Shops, Packages } from \"/lib/collections\";\nimport * as Schemas from \"/lib/collections/schemas\";\nimport { Hooks, Logger, Reaction } from \"/server/api\";\nimport { sendUpdatedVerificationEmail } from \"/server/api/core/accounts\";\n\n/**\n * @file Extends Meteor's {@link https://github.com/meteor/meteor/tree/master/packages/accounts-base Accounts-Base}\n * with methods for Reaction-specific behavior and user interaction. Run these methods using: `Meteor.call()`\n * @example Meteor.call(\"accounts/verifyAccount\", email, token)\n * @namespace Methods/Accounts\n */\n\n/**\n * @name accounts/verifyAccount\n * @memberof Methods/Accounts\n * @method\n * @summary Verifies the email address in account document (if user verification in users collection was successful already)\n * @example Meteor.call(\"accounts/verifyAccount\")\n * @returns {Boolean} - returns true on success\n */\nexport function verifyAccount() {\n  if (!this.userId) {\n    // not logged in\n    return;\n  }\n\n  const user = Meteor.user();\n  const addresses = user.emails\n    .filter((email) => email.verified)\n    .map((email) => email.address);\n  const result = Accounts.update({\n    \"userId\": this.userId,\n    \"emails.address\": { $in: addresses }\n  }, {\n    $set: {\n      \"emails.$.verified\": true\n    }\n  });\n\n  if (result) {\n    Hooks.Events.run(\n      \"afterAccountsUpdate\",\n      this.userId, {\n        accountId: Accounts.findOne({ userId: this.userId })._id,\n        updatedFields: [\"emails\"]\n      }\n    );\n  }\n  return result;\n}\n\n/**\n * @name accounts/updateEmailAddress\n * @memberof Methods/Accounts\n * @method\n * @summary Update a user's email address\n * @param {String} email - user email\n * @returns {Boolean} - return True on success\n */\nexport function updateEmailAddress(email) {\n  check(email, String);\n  const user = Meteor.user();\n\n  // Add email to user account\n  MeteorAccounts.addEmail(user._id, email);\n\n  return true;\n}\n\n/**\n * @name accounts/removeEmailAddress\n * @memberof Methods/Accounts\n * @method\n * @summary Remove a user's email address.\n * @param {String} email - user email.\n * @returns {Boolean} - returns boolean.\n */\nexport function removeEmailAddress(email) {\n  check(email, String);\n\n  const user = Meteor.user();\n\n  // Remove email address from user\n  MeteorAccounts.removeEmail(user._id, email);\n\n  // Verify new address\n  sendUpdatedVerificationEmail(user._id);\n\n  // Sync users and accounts collections\n  syncUsersAndAccounts();\n\n  return true;\n}\n\n/**\n * @name accounts/syncUsersAndAccounts\n * @memberof Methods/Accounts\n * @method\n * @summary Syncs emails associated with a user profile between the Users and Accounts collections.\n * @returns {Boolean} - returns boolean.\n */\nexport function syncUsersAndAccounts() {\n  const user = Meteor.user();\n\n  Accounts.update({\n    _id: user._id\n  }, {\n    $set: {\n      emails: [\n        user.emails[0]\n      ]\n    }\n  });\n  Hooks.Events.run(\"afterAccountsUpdate\", user._id, {\n    accountId: user._id,\n    updatedFields: [\"emails\"]\n  });\n\n  return true;\n}\n\n/**\n * @name getValidator\n * @summary Returns the name of the geocoder method to use\n * @returns {string} Name of the Geocoder method to use\n * @private\n */\nfunction getValidator() {\n  const shopId = Reaction.getShopId();\n  const geoCoders = Packages.find({\n    \"registry\": { $elemMatch: { provides: \"addressValidation\" } },\n    \"settings.addressValidation.enabled\": true,\n    shopId,\n    \"enabled\": true\n  }).fetch();\n\n  if (!geoCoders.length) {\n    return \"\";\n  }\n  let geoCoder;\n  // Just one?, use that one\n  if (geoCoders.length === 1) {\n    [geoCoder] = geoCoders;\n  }\n  // If there are two, we default to the one that is not the Reaction one\n  if (geoCoders.length === 2) {\n    geoCoder = geoCoders.find((coder) => !coder.name.includes(\"reaction\"));\n  }\n\n  // check if addressValidation is enabled but the package is disabled, don't do address validation\n  let registryName;\n  for (const registry of geoCoder.registry) {\n    if (registry.provides && registry.provides.includes(\"addressValidation\")) {\n      registryName = registry.name;\n    }\n  }\n  const packageKey = registryName.split(\"/\")[2]; // \"taxes/addressValidation/{packageKey}\"\n  if (!_.get(geoCoder.settings[packageKey], \"enabled\")) {\n    return \"\";\n  }\n\n  const methodName = geoCoder.settings.addressValidation.addressValidationMethod;\n  return methodName;\n}\n\n/**\n * @name compareAddress\n * @summary Compare individual fields of address and accumulate errors\n * @param {Object} address - the address provided by the customer\n * @param {Object} validationAddress - address provided by validator\n * @returns {Object} An object with an array of errors per field\n * @private\n */\nfunction compareAddress(address, validationAddress) {\n  const errors = {\n    address1: [],\n    address2: [],\n    city: [],\n    postal: [],\n    region: [],\n    country: [],\n    totalErrors: 0\n  };\n  // first check, if a field is missing (and was present in original address), that means it didn't validate\n  // TODO rewrite with just a loop over field names but KISS for now\n  if (address.address1 && !validationAddress.address1) {\n    errors.address1.push(\"Address line one did not validate\");\n    errors.totalErrors += 1;\n  }\n\n  if (address.address2 && validationAddress.address2 && _.trim(_.upperCase(address.address2)) !== _.trim(_.upperCase(validationAddress.address2))) {\n    errors.address2.push(\"Address line 2 did not validate\");\n    errors.totalErrors += 1;\n  }\n\n  if (!validationAddress.city) {\n    errors.city.push(\"City did not validate\");\n    errors.totalErrors += 1;\n  }\n  if (address.postal && !validationAddress.postal) {\n    errors.postal.push(\"Postal did not validate\");\n    errors.totalErrors += 1;\n  }\n\n  if (address.region && !validationAddress.region) {\n    errors.region.push(\"Region did not validate\");\n    errors.totalErrors += 1;\n  }\n\n  if (address.country && !validationAddress.country) {\n    errors.country.push(\"Country did not validate\");\n    errors.totalErrors += 1;\n  }\n  // second check if both fields exist, but they don't match (which almost always happen for certain fields on first time)\n  if (validationAddress.address1 && address.address1 && _.trim(_.upperCase(address.address1)) !== _.trim(_.upperCase(validationAddress.address1))) {\n    errors.address1.push({ address1: \"Address line 1 did not match\" });\n    errors.totalErrors += 1;\n  }\n\n  if (validationAddress.address2 && address.address2 && (_.upperCase(address.address2) !== _.upperCase(validationAddress.address2))) {\n    errors.address2.push(\"Address line 2 did not match\");\n    errors.totalErrors += 1;\n  }\n\n  if (validationAddress.city && address.city && _.trim(_.upperCase(address.city)) !== _.trim(_.upperCase(validationAddress.city))) {\n    errors.city.push(\"City did not match\");\n    errors.totalErrors += 1;\n  }\n\n  if (validationAddress.postal && address.postal && _.trim(_.upperCase(address.postal)) !== _.trim(_.upperCase(validationAddress.postal))) {\n    errors.postal.push(\"Postal Code did not match\");\n    errors.totalErrors += 1;\n  }\n\n  if (validationAddress.region && address.region && _.trim(_.upperCase(address.region)) !== _.trim(_.upperCase(validationAddress.region))) {\n    errors.region.push(\"Region did not match\");\n    errors.totalErrors += 1;\n  }\n\n  if (validationAddress.country && address.country && _.upperCase(address.country) !== _.upperCase(validationAddress.country)) {\n    errors.country.push(\"Country did not match\");\n    errors.totalErrors += 1;\n  }\n  return errors;\n}\n\n/**\n * @name accounts/validateAddress\n * @memberof Methods/Accounts\n * @method\n * @summary Validates an address, and if fails returns details of issues\n * @param {Object} address - The address object to validate\n * @returns {{validated: boolean, address: *}} - The results of the validation\n */\nexport function validateAddress(address) {\n  Schemas.Address.clean(address);\n  Schemas.Address.validate(address);\n\n  let validated = true;\n  let validationErrors;\n  let suggestedAddress = {};\n  let formErrors;\n  const validator = getValidator();\n  if (validator) {\n    const validationResult = Meteor.call(validator, address);\n    ({ validatedAddress: suggestedAddress } = validationResult);\n    formErrors = validationResult.errors;\n    if (suggestedAddress) {\n      validationErrors = compareAddress(address, suggestedAddress);\n      if (validationErrors.totalErrors || formErrors.length) {\n        validated = false;\n        suggestedAddress.failedValidation = true;\n      }\n    } else {\n      // No address, fail validation\n      validated = false;\n      suggestedAddress = {\n        failedValidation: true\n      };\n    }\n  }\n  suggestedAddress = { ...address, ...suggestedAddress };\n  const validationResults = { validated, fieldErrors: validationErrors, formErrors, suggestedAddress, enteredAddress: address };\n  return validationResults;\n}\n\n/**\n * @name currentUserHasPassword\n * @summary Check if current user has password\n * @returns {Boolean} True if current user has password\n * @private\n */\nfunction currentUserHasPassword() {\n  const user = Meteor.users.findOne(Meteor.userId());\n  return !!user.services.password;\n}\n\n/**\n * @name accounts/addressBookAdd\n * @memberof Methods/Accounts\n * @method\n * @summary Add new addresses to an account\n * @example Meteor.call(\"accounts/addressBookAdd\", address, callBackFunction(error, result))\n * @param {Object} address - address\n * @param {String} [accountUserId] - `account.userId` used by admin to edit users\n * @return {Object} with updated address\n */\nexport function addressBookAdd(address, accountUserId) {\n  Schemas.Address.validate(address);\n  check(accountUserId, Match.Optional(String));\n  // security, check for admin access. We don't need to check every user call\n  // here because we are calling `Meteor.userId` from within this Method.\n  if (typeof accountUserId === \"string\") { // if this will not be a String -\n    // `check` will not pass it.\n    if (Meteor.userId() !== accountUserId && !Reaction.hasPermission(\"reaction-accounts\")) {\n      throw new Meteor.Error(\"access-denied\", \"Access denied\");\n    }\n  }\n  this.unblock();\n\n  const userId = accountUserId || Meteor.userId();\n  const account = Accounts.findOne({\n    userId\n  });\n  // required default id\n  if (!address._id) {\n    address._id = Random.id();\n  }\n  // if address got shippment or billing default, we need to update cart\n  // addresses accordingly\n  if (address.isShippingDefault || address.isBillingDefault) {\n    const cart = Cart.findOne({ userId });\n    // if cart exists\n    // First amend the cart,\n    if (typeof cart === \"object\") {\n      if (address.isShippingDefault) {\n        Meteor.call(\"cart/setShipmentAddress\", cart._id, address);\n      }\n      if (address.isBillingDefault) {\n        Meteor.call(\"cart/setPaymentAddress\", cart._id, address);\n      }\n    }\n    // then change the address that has been affected\n    if (address.isShippingDefault) {\n      Accounts.update({\n        userId,\n        \"profile.addressBook.isShippingDefault\": true\n      }, {\n        $set: {\n          \"profile.addressBook.$.isShippingDefault\": false\n        }\n      });\n      Hooks.Events.run(\"afterAccountsUpdate\", Meteor.userId(), {\n        accountId: account._id,\n        updatedFields: [\"isShippingDefault\"]\n      });\n    }\n    if (address.isBillingDefault) {\n      Accounts.update({\n        userId,\n        \"profile.addressBook.isBillingDefault\": true\n      }, {\n        $set: {\n          \"profile.addressBook.$.isBillingDefault\": false\n        }\n      });\n      Hooks.Events.run(\"afterAccountsUpdate\", Meteor.userId(), {\n        accountId: account._id,\n        updatedFields: [\"isBillingDefault\"]\n      });\n    }\n  }\n\n  const userUpdateQuery = {\n    $set: {\n      \"profile.addressBook\": address\n    }\n  };\n  const accountsUpdateQuery = {\n    $set: {\n      userId\n    },\n    $addToSet: {\n      \"profile.addressBook\": address\n    }\n  };\n\n  if (!account.name || _.get(account, \"profile.addressBook.length\", 0) === 0) {\n    userUpdateQuery.$set.name = address.fullName;\n    accountsUpdateQuery.$set.name = address.fullName;\n  }\n\n  Meteor.users.update(Meteor.userId(), userUpdateQuery);\n\n  const result = Accounts.upsert({\n    userId\n  }, accountsUpdateQuery);\n\n  // If the address update was successful, then return the full updated addrtess\n  if (result.numberAffected === 1) {\n    // Find the account\n    const updatedAccount = Accounts.findOne({\n      userId\n    });\n\n    // Pull the updated address and return it\n    return updatedAccount.profile.addressBook.find((updatedAddress) => address._id === updatedAddress._id);\n  }\n\n  throw new Meteor.Error(\"server-error\", \"Unable to add address to account\");\n}\n\n/**\n * @name accounts/addressBookUpdate\n * @memberof Methods/Accounts\n * @method\n * @summary Update existing address in user's profile\n * @param {Object} address - address\n * @param {String|null} [accountUserId] - `account.userId` used by admin to edit users\n * @param {shipping|billing} [type] - name of selected address type\n * @return {Object} The updated address\n */\nexport function addressBookUpdate(address, accountUserId, type) {\n  Schemas.Address.validate(address);\n  check(accountUserId, Match.OneOf(String, null, undefined));\n  check(type, Match.Maybe(String));\n  // security, check for admin access. We don't need to check every user call\n  // here because we are calling `Meteor.userId` from within this Method.\n  if (typeof accountUserId === \"string\") { // if this will not be a String -\n    // `check` will not pass it.\n    if (Meteor.userId() !== accountUserId && !Reaction.hasPermission(\"reaction-accounts\")) {\n      throw new Meteor.Error(\"access-denied\", \"Access denied\");\n    }\n  }\n  this.unblock();\n\n  // If no userId is provided, use the current user\n  const userId = accountUserId || Meteor.userId();\n  // Find old state of isShippingDefault & isBillingDefault to compare and reflect in cart\n  const account = Accounts.findOne({ userId });\n  const oldAddress = (account.profile.addressBook || []).find((addr) => addr._id === address._id);\n\n  if (!oldAddress) throw new Meteor.Error(\"not-found\", `No existing address found with ID ${address._id}`);\n\n  // Set new address to be default for `type`\n  if (typeof type === \"string\") {\n    Object.assign(address, { [type]: true });\n  }\n\n  // We want the cart addresses to be updated when current default address\n  // (shipping or Billing) are different than the previous one, but also\n  // when the current default address(ship or bill) gets edited(so Current and Previous default are the same).\n  // This check can be simplified to :\n  if (address.isShippingDefault || address.isBillingDefault ||\n    oldAddress.isShippingDefault || oldAddress.isBillingDefault) {\n    // Find user cart\n    // Cart should exist to this moment, so we don't need to to verify its existence.\n    const cart = Cart.findOne({ userId });\n\n    // If isShippingDefault address has changed\n    if (oldAddress.isShippingDefault !== address.isShippingDefault) {\n      // Update the cart to use new default shipping address\n      if (address.isShippingDefault) {\n        Meteor.call(\"cart/setShipmentAddress\", cart._id, address);\n      } else {\n        // If the new address is not the shipping default, remove it from the cart\n        Meteor.call(\"cart/unsetAddresses\", address._id, userId, \"shipping\");\n      }\n    } else if (address.isShippingDefault && oldAddress.isShippingDefault) {\n      // If shipping address was edited, but isShippingDefault status not changed, update the cart address\n      Meteor.call(\"cart/setShipmentAddress\", cart._id, address);\n    }\n\n    // If isBillingDefault address has changed\n    if (oldAddress.isBillingDefault !== address.isBillingDefault) {\n      // Update the cart to use new default billing address\n      if (address.isBillingDefault) {\n        Meteor.call(\"cart/setPaymentAddress\", cart._id, address);\n      } else {\n        // If the new address is not the shipping default, remove it from the cart\n        Meteor.call(\"cart/unsetAddresses\", address._id, userId, \"billing\");\n      }\n    } else if (address.isBillingDefault && oldAddress.isBillingDefault) {\n      // If shipping address was edited, but isShippingDefault status not changed, update the cart address\n      Meteor.call(\"cart/setPaymentAddress\", cart._id, address);\n    }\n  }\n\n  // Update all other to set the default type to false\n  account.profile.addressBook.forEach((addr) => {\n    if (addr._id === address._id) {\n      Object.assign(addr, address);\n    } else if (typeof type === \"string\") {\n      Object.assign(addr, { [type]: false });\n    }\n  });\n\n  // TODO: revisit why we update Meteor.users differently than accounts\n  // We could possibly remove the whole `userUpdateQuery` variable\n  // and update Meteor.users with the accountsUpdateQuery data\n  const userUpdateQuery = {\n    $set: {\n      \"profile.addressBook\": address\n    }\n  };\n\n  const accountsUpdateQuery = {\n    $set: {\n      \"profile.addressBook\": account.profile.addressBook\n    }\n  };\n  // update the name when there is no name or the user updated his only shipping address\n  if (!account.name || _.get(account, \"profile.addressBook.length\", 0) <= 1) {\n    userUpdateQuery.$set.name = address.fullName;\n    accountsUpdateQuery.$set.name = address.fullName;\n  }\n\n  // Update the Meteor.users collection with new address info\n  Meteor.users.update(Meteor.userId(), userUpdateQuery);\n\n  // Update the Reaction Accounts collection with new address info\n  const updatedAccountResult = Accounts.update({\n    userId\n  }, accountsUpdateQuery);\n\n  // Create an array which contains all fields that have changed\n  // This is used for search, to determine if we need to re-index\n  const updatedFields = [];\n  Object.keys(address).forEach((key) => {\n    if (address[key] !== oldAddress[key]) {\n      updatedFields.push(key);\n    }\n  });\n\n  // Run afterAccountsUpdate hook to update Accounts Search\n  Hooks.Events.run(\"afterAccountsUpdate\", Meteor.userId(), {\n    accountId: account._id,\n    updatedFields\n  });\n\n  // If the address update was successful, then return the full updated addrtess\n  if (updatedAccountResult === 1) {\n    // Find the account\n    const updatedAccount = Accounts.findOne({\n      userId\n    });\n\n    // Pull the updated address and return it\n    return updatedAccount.profile.addressBook.find((updatedAddress) => address._id === updatedAddress._id);\n  }\n\n  throw new Meteor.Error(\"server-error\", \"Unable to update account address\");\n}\n\n/**\n * @name accounts/addressBookRemove\n * @memberof Methods/Accounts\n * @method\n * @summary Remove existing address in user's profile\n * @param {String} addressId - address `_id`\n * @param {String} [accountUserId] - `account.userId` used by admin to edit users\n * @return {Object} Removed address object\n */\nexport function addressBookRemove(addressId, accountUserId) {\n  check(addressId, String);\n  check(accountUserId, Match.Optional(String));\n  // security, check for admin access. We don't need to check every user call\n  // here because we are calling `Meteor.userId` from within this Method.\n  if (typeof accountUserId === \"string\") { // if this will not be a String -\n    // `check` will not pass it.\n    if (Meteor.userId() !== accountUserId && !Reaction.hasPermission(\"reaction-accounts\")) {\n      throw new Meteor.Error(\"access-denied\", \"Access denied\");\n    }\n  }\n  this.unblock();\n\n  const userId = accountUserId || Meteor.userId();\n  const account = Accounts.findOne({ userId });\n  // remove this address in cart, if used, before completely removing\n  Meteor.call(\"cart/unsetAddresses\", addressId, userId);\n\n  const updatedAccountResult = Accounts.update({\n    userId,\n    \"profile.addressBook._id\": addressId\n  }, {\n    $pull: {\n      \"profile.addressBook\": {\n        _id: addressId\n      }\n    }\n  }, { bypassCollection2: true });\n\n  // forceIndex when removing an address\n  Hooks.Events.run(\"afterAccountsUpdate\", Meteor.userId(), {\n    accountId: account._id,\n    updatedFields: [\"forceIndex\"]\n  });\n\n  // If the address remove was successful, then return the removed addrtess\n  if (updatedAccountResult === 1) {\n    // Pull the address from the account before it was updated and return it\n    return account.profile.addressBook.find((removedAddress) => addressId === removedAddress._id);\n  }\n\n  throw new Meteor.Error(\"server-error\", \"Unable to remove address from account\");\n}\n\n/**\n * @name accounts/inviteShopOwner\n * @summary Invite a new user as owner of a new shop\n * @memberof Methods/Accounts\n * @method\n * @param {Object} options -\n * @param {String} options.email - email of invitee\n * @param {String} options.name - name of invitee\n * @param {Object} shopData - (optional) data used to create the new shop\n * @returns {Boolean} returns true\n */\nexport function inviteShopOwner(options, shopData) {\n  check(options, Object);\n  check(options.email, String);\n  check(options.name, String);\n  check(shopData, Match.Maybe(Object));\n  const { name, email } = options;\n\n  if (!Reaction.hasPermission(\"admin\", this.userId, Reaction.getPrimaryShopId())) {\n    throw new Meteor.Error(\"access-denied\", \"Access denied\");\n  }\n  const user = Meteor.users.findOne({ \"emails.address\": email });\n  let userId;\n  if (user) {\n    // TODO: Verify email address\n    userId = user._id;\n  } else {\n    userId = MeteorAccounts.createUser({\n      email,\n      name,\n      profile: { invited: true }\n    });\n  }\n\n  Meteor.call(\"shop/createShop\", userId, shopData);\n  const primaryShop = Reaction.getPrimaryShop();\n\n  // Compile Email with SSR\n  const tpl = \"accounts/inviteShopOwner\";\n  const subject = \"accounts/inviteShopOwner/subject\";\n\n  SSR.compileTemplate(tpl, Reaction.Email.getTemplate(tpl));\n  SSR.compileTemplate(subject, Reaction.Email.getSubject(tpl));\n\n  const emailLogo = Reaction.Email.getShopLogo(primaryShop);\n  const token = Random.id();\n  const currentUser = Meteor.users.findOne(this.userId);\n  const currentUserName = getCurrentUserName(currentUser);\n  // uses primaryShop's data (name, address etc) in email copy sent to new merchant\n  const dataForEmail = getDataForEmail({ shop: primaryShop, currentUserName, name, token, emailLogo });\n\n  Meteor.users.update(userId, {\n    $set: {\n      \"services.password.reset\": { token, email, when: new Date() },\n      name\n    }\n  });\n\n  Reaction.Email.send({\n    to: email,\n    from: `${_.get(dataForEmail, \"primaryShop.name\")} <${_.get(dataForEmail, \"primaryShop.emails[0].address\")}>`,\n    subject: SSR.render(subject, dataForEmail),\n    html: SSR.render(tpl, dataForEmail)\n  });\n\n  return true;\n}\n\n/**\n * @name accounts/inviteShopMember\n * @summary Invite new admin users (not consumers) to secure access in the dashboard to permissions\n * as specified in packages/roles\n * @memberof Methods/Accounts\n * @method\n * @param {Object} options -\n * @param {String} options.shopId - shop to invite user\n * @param {String} options.groupId - groupId to invite user\n * @param {String} options.email - email of invitee\n * @param {String} options.name - name of invitee\n * @returns {Boolean} returns true\n */\nexport function inviteShopMember(options) {\n  const { shopId, email, name, groupId } = options;\n  check(options, Object);\n  check(shopId, String);\n  check(email, String);\n  check(name, String);\n  check(groupId, String);\n\n  this.unblock();\n\n  const shop = Shops.findOne(shopId);\n  const primaryShop = Reaction.getPrimaryShop();\n\n  if (!shop) {\n    const msg = `accounts/inviteShopMember - Shop ${shopId} not found`;\n    Logger.error(msg);\n    throw new Meteor.Error(\"not-found\", msg);\n  }\n\n  if (!Reaction.hasPermission(\"reaction-accounts\", this.userId, shopId)) {\n    Logger.error(`User ${this.userId} does not have reaction-accounts permissions`);\n    throw new Meteor.Error(\"access-denied\", \"Access denied\");\n  }\n\n  const group = Groups.findOne({ _id: groupId }) || {};\n\n  // check to ensure that invitee has roles required to perform the invitation\n  if (!Reaction.canInviteToGroup({ group, user: Meteor.user() })) {\n    throw new Meteor.Error(\"access-denied\", \"Cannot invite to group\");\n  }\n\n  if (group.slug === \"owner\") {\n    throw new Meteor.Error(\"bad-request\", \"Cannot directly invite owner\");\n  }\n\n  const currentUser = Meteor.users.findOne(this.userId);\n  const currentUserName = getCurrentUserName(currentUser);\n  const emailLogo = Reaction.Email.getShopLogo(primaryShop);\n  const user = Meteor.users.findOne({ \"emails.address\": email });\n  const token = Random.id();\n  let dataForEmail;\n  let userId;\n  let tpl;\n  let subject;\n\n  // If the user already has an account, send informative email, not \"invite\" email\n  if (user) {\n    // The user already exists, we promote the account, rather than creating a new one\n    userId = user._id;\n    Meteor.call(\"group/addUser\", userId, groupId);\n\n    // do not send token, as no password reset is needed\n    const url = Meteor.absoluteUrl();\n\n    // use primaryShop's data (name, address etc) in email copy sent to new shop manager\n    dataForEmail = getDataForEmail({ shop: primaryShop, currentUserName, name, emailLogo, url });\n\n    // Get email template and subject\n    tpl = \"accounts/inviteShopMember\";\n    subject = \"accounts/inviteShopMember/subject\";\n  } else {\n    // The user does not already exist, we need to create a new account\n    userId = MeteorAccounts.createUser({\n      profile: { invited: true },\n      email,\n      name,\n      groupId\n    });\n    // set token to be used for first login for the new account\n    const tokenUpdate = {\n      \"services.password.reset\": { token, email, when: new Date() },\n      name\n    };\n    Meteor.users.update(userId, { $set: tokenUpdate });\n\n    // use primaryShop's data (name, address etc) in email copy sent to new shop manager\n    dataForEmail = getDataForEmail({ shop: primaryShop, currentUserName, name, token, emailLogo });\n\n    // Get email template and subject\n    tpl = \"accounts/inviteNewShopMember\";\n    subject = \"accounts/inviteNewShopMember/subject\";\n  }\n\n  dataForEmail.groupName = _.startCase(group.name);\n\n  // Compile Email with SSR\n  SSR.compileTemplate(tpl, Reaction.Email.getTemplate(tpl));\n  SSR.compileTemplate(subject, Reaction.Email.getSubject(tpl));\n\n  // send invitation email from primary shop email\n  Reaction.Email.send({\n    to: email,\n    from: `${dataForEmail.primaryShop.name} <${dataForEmail.primaryShop.emails[0].address}>`,\n    subject: SSR.render(subject, dataForEmail),\n    html: SSR.render(tpl, dataForEmail)\n  });\n\n  return Accounts.findOne({ userId });\n}\n\n/**\n * @name accounts/sendWelcomeEmail\n * @summary Send an email to consumers on sign up\n * @memberof Methods/Accounts\n * @method\n * @param {String} shopId - shopId of new User\n * @param {String} userId - new userId to welcome\n * @param {String} token - the token for the verification URL\n * @returns {Boolean} returns true on success\n */\nexport function sendWelcomeEmail(shopId, userId, token) {\n  check(shopId, String);\n  check(userId, String);\n  check(token, String);\n\n  this.unblock();\n\n  const account = Accounts.findOne(userId);\n  // anonymous users arent welcome here\n  if (!account.emails || !account.emails.length > 0) {\n    return false;\n  }\n\n  const shop = Shops.findOne(shopId);\n\n  // Get shop logo, if available. If not, use default logo from file-system\n  const emailLogo = Reaction.Email.getShopLogo(shop);\n  const copyrightDate = new Date().getFullYear();\n  const user = Meteor.user();\n  const dataForEmail = {\n    // Shop Data\n    shop,\n    contactEmail: shop.emails[0].address,\n    emailLogo,\n    copyrightDate,\n    legalName: _.get(shop, \"addressBook[0].company\"),\n    physicalAddress: {\n      address: `${_.get(shop, \"addressBook[0].address1\")} ${_.get(shop, \"addressBook[0].address2\")}`,\n      city: _.get(shop, \"addressBook[0].city\"),\n      region: _.get(shop, \"addressBook[0].region\"),\n      postal: _.get(shop, \"addressBook[0].postal\")\n    },\n    shopName: shop.name,\n    socialLinks: {\n      display: true,\n      facebook: {\n        display: true,\n        icon: `${Meteor.absoluteUrl()}resources/email-templates/facebook-icon.png`,\n        link: \"https://www.facebook.com\"\n      },\n      googlePlus: {\n        display: true,\n        icon: `${Meteor.absoluteUrl()}resources/email-templates/google-plus-icon.png`,\n        link: \"https://plus.google.com\"\n      },\n      twitter: {\n        display: true,\n        icon: `${Meteor.absoluteUrl()}resources/email-templates/twitter-icon.png`,\n        link: \"https://www.twitter.com\"\n      }\n    },\n    user\n  };\n\n  dataForEmail.verificationUrl = MeteorAccounts.urls.verifyEmail(token);\n\n  const userEmail = account.emails[0].address;\n  let shopEmail;\n  // provide some defaults for missing shop email.\n  if (!shop.emails) {\n    shopEmail = `${shop.name}@localhost`;\n    Logger.debug(`Shop email address not configured. Using ${shopEmail}`);\n  } else {\n    shopEmail = shop.emails[0].address;\n  }\n\n  const tpl = \"accounts/sendWelcomeEmail\";\n  const subject = \"accounts/sendWelcomeEmail/subject\";\n  SSR.compileTemplate(tpl, Reaction.Email.getTemplate(tpl));\n  SSR.compileTemplate(subject, Reaction.Email.getSubject(tpl));\n\n  Reaction.Email.send({\n    to: userEmail,\n    from: `${shop.name} <${shopEmail}>`,\n    subject: SSR.render(subject, dataForEmail),\n    html: SSR.render(tpl, dataForEmail)\n  });\n\n  return true;\n}\n\n/**\n * @name accounts/addUserPermissions\n * @memberof Methods/Accounts\n * @method\n * @param {String} userId - userId\n * @param {Array|String} permissions - Name of role/permission.\n * If array, users returned will have at least one of the roles specified but need not have _all_ roles.\n * @param {String} [group] Optional name of group to restrict roles to. User's Roles.GLOBAL_GROUP will also be checked.\n * @returns {Boolean} success/failure\n */\nexport function addUserPermissions(userId, permissions, group) {\n  if (!Reaction.hasPermission(\"reaction-accounts\", Meteor.userId(), group)) {\n    throw new Meteor.Error(\"access-denied\", \"Access denied\");\n  }\n  check(userId, Match.OneOf(String, Array));\n  check(permissions, Match.OneOf(String, Array));\n  check(group, Match.Optional(String));\n  this.unblock();\n  try {\n    return Roles.addUsersToRoles(userId, permissions, group);\n  } catch (error) {\n    return Logger.error(error);\n  }\n}\n\n/**\n * @name accounts/removeUserPermissions\n * @memberof Methods/Accounts\n * @method\n * @param {String} userId - userId\n * @param {Array|String} permissions - Name of role/permission.\n * If array, users returned will have at least one of the roles specified but need not have _all_ roles.\n * @param {String} [group] Optional name of group to restrict roles to.\n * @returns {Boolean} success/failure\n */\nexport function removeUserPermissions(userId, permissions, group) {\n  if (!Reaction.hasPermission(\"reaction-accounts\", Meteor.userId(), group)) {\n    throw new Meteor.Error(\"access-denied\", \"Access denied\");\n  }\n  check(userId, String);\n  check(permissions, Match.OneOf(String, Array));\n  check(group, Match.Optional(String, null));\n  this.unblock();\n  try {\n    return Roles.removeUsersFromRoles(userId, permissions, group);\n  } catch (error) {\n    Logger.error(error);\n    throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n  }\n}\n\n/**\n * @name accounts/setUserPermissions\n * @memberof Methods/Accounts\n * @method\n * @param {String} userId - userId\n * @param {String|Array} permissions - string/array of permissions\n * @param {String} group - group\n * @returns {Boolean} returns Roles.setUserRoles result\n */\nexport function setUserPermissions(userId, permissions, group) {\n  if (!Reaction.hasPermission(\"reaction-accounts\", Meteor.userId(), group)) {\n    throw new Meteor.Error(\"access-denied\", \"Access denied\");\n  }\n  check(userId, String);\n  check(permissions, Match.OneOf(String, Array));\n  check(group, Match.Optional(String));\n  this.unblock();\n  try {\n    return Roles.setUserRoles(userId, permissions, group);\n  } catch (error) {\n    Logger.error(error);\n    return error;\n  }\n}\n\n/**\n * @name getCurrentUserName\n * @memberof Methods/Accounts\n * @method\n * @private\n * @param  {Object} currentUser - User\n * @return {String} Name of currentUser or \"Admin\"\n */\nfunction getCurrentUserName(currentUser) {\n  if (currentUser) {\n    if (currentUser.profile && currentUser.profile.name) {\n      return currentUser.profile.name;\n    }\n\n    if (currentUser.name) {\n      return currentUser.name;\n    }\n\n    if (currentUser.username) {\n      return currentUser.username;\n    }\n  }\n\n  return \"Admin\";\n}\n\n/**\n * @name getDataForEmail\n * @memberof Methods/Accounts\n * @method\n * @private\n * @param  {Object} options - shop, currentUserName, token, emailLogo, name\n * @return {Object} data - primaryShop, shop, contactEmail, homepage,\n * emailLogo, legalName, physicalAddress, shopName, socialLinks, user, invitedUserName, url\n */\nfunction getDataForEmail(options) {\n  const { shop, currentUserName, token, emailLogo, name, url } = options;\n  const primaryShop = Shops.findOne(Reaction.getPrimaryShopId());\n  const copyrightDate = new Date().getFullYear();\n\n  return {\n    primaryShop, // Primary shop data - may or may not be the same as shop\n    shop, // Shop Data\n    contactEmail: _.get(shop, \"emails[0].address\"),\n    homepage: Meteor.absoluteUrl(),\n    emailLogo,\n    copyrightDate,\n    legalName: _.get(shop, \"addressBook[0].company\"),\n    physicalAddress: {\n      address: `${_.get(shop, \"addressBook[0].address1\")} ${_.get(shop, \"addressBook[0].address2\")}`,\n      city: _.get(shop, \"addressBook[0].city\"),\n      region: _.get(shop, \"addressBook[0].region\"),\n      postal: _.get(shop, \"addressBook[0].postal\")\n    },\n    shopName: shop.name,\n    socialLinks: {\n      display: true,\n      facebook: {\n        display: true,\n        icon: `${Meteor.absoluteUrl()}resources/email-templates/facebook-icon.png`,\n        link: \"https://www.facebook.com\"\n      },\n      googlePlus: {\n        display: true,\n        icon: `${Meteor.absoluteUrl()}resources/email-templates/google-plus-icon.png`,\n        link: \"https://plus.google.com\"\n      },\n      twitter: {\n        display: true,\n        icon: `${Meteor.absoluteUrl()}resources/email-templates/twitter-icon.png`,\n        link: \"https://www.twitter.com\"\n      }\n    },\n    user: Meteor.user(), // Account Data\n    currentUserName,\n    invitedUserName: name,\n    url: url || getEmailUrl(token)\n  };\n\n  function getEmailUrl(userToken) {\n    if (userToken) {\n      return MeteorAccounts.urls.enrollAccount(userToken);\n    }\n    return Meteor.absoluteUrl();\n  }\n}\n\n/**\n * @name accounts/createFallbackLoginToken\n * @memberof Methods/Accounts\n * @method\n * @summary Returns a new loginToken for current user, that can be used for special login scenarios\n * e.g. store the newly created token as cookie on the browser, if the client does not offer local storage.\n * @returns {String} loginToken for current user\n */\nexport function createFallbackLoginToken() {\n  if (this.userId) {\n    const stampedLoginToken = MeteorAccounts._generateStampedLoginToken();\n    const loginToken = stampedLoginToken.token;\n    MeteorAccounts._insertLoginToken(this.userId, stampedLoginToken);\n    return loginToken;\n  }\n}\n\n/**\n * @name accounts/setProfileCurrency\n * @memberof Methods/Accounts\n * @method\n * @param {String} currencyName - currency symbol to add to user profile\n * @param {String} [accountId] - accountId of user to set currency of. Defaults to current user ID\n * @summary Sets users profile currency\n */\nexport function setProfileCurrency(currencyName, accountId) {\n  check(currencyName, String);\n  check(accountId, Match.Maybe(String));\n\n  const currentUserId = this.userId;\n  const userId = accountId || currentUserId;\n  if (!userId) throw new Meteor.Error(\"access-denied\", \"You must be logged in to set profile currency\");\n\n  const account = Accounts.findOne({ userId }, { fields: { shopId: 1 } });\n  if (!account) throw new Meteor.Error(\"not-found\", \"Account not found\");\n\n  if (userId !== currentUserId && !Reaction.hasPermission(\"reaction-accounts\", currentUserId, account.shopId)) {\n    throw new Meteor.Error(\"access-denied\", \"Access denied\");\n  }\n\n  // Make sure this currency code is in the related shop currencies list\n  const shop = Shops.findOne({ _id: account.shopId }, { fields: { currencies: 1 } });\n\n  if (!shop || !shop.currencies || !shop.currencies[currencyName]) {\n    throw new Meteor.Error(\"invalid-argument\", `The shop for this account does not define any currency with code \"${currencyName}\"`);\n  }\n\n  Accounts.update({ userId }, { $set: { \"profile.currency\": currencyName } });\n  Hooks.Events.run(\"afterAccountsUpdate\", userId, {\n    accountId: account._id,\n    updatedFields: [\"currency\"]\n  });\n\n  return Accounts.findOne({ userId });\n}\n\n/**\n * @name markAddressValidationBypassed\n * @summary Write that the customer has bypassed address validation\n * @returns {Number} updateResult - Result of the update\n */\nfunction markAddressValidationBypassed(value = true) {\n  check(value, Boolean);\n  const userId = Meteor.userId();\n  const updateResult = Cart.update({ userId }, { $set: { bypassAddressValidation: value } });\n  return updateResult;\n}\n\n/**\n * @name markTaxCalculationFailed\n * @summary Write tax calculation has failed for this customer\n * @returns {Number} updateResult - Result of the update\n */\nfunction markTaxCalculationFailed(value = true) {\n  check(value, Boolean);\n  const userId = Meteor.userId();\n  const updateResult = Cart.update({ userId }, { $set: { taxCalculationFailed: value } });\n  return updateResult;\n}\n\nMeteor.methods({\n  \"accounts/verifyAccount\": verifyAccount,\n  \"accounts/validateAddress\": validateAddress,\n  \"accounts/currentUserHasPassword\": currentUserHasPassword,\n  \"accounts/addressBookAdd\": addressBookAdd,\n  \"accounts/addressBookUpdate\": addressBookUpdate,\n  \"accounts/addressBookRemove\": addressBookRemove,\n  \"accounts/inviteShopMember\": inviteShopMember,\n  \"accounts/inviteShopOwner\": inviteShopOwner,\n  \"accounts/sendWelcomeEmail\": sendWelcomeEmail,\n  \"accounts/addUserPermissions\": addUserPermissions,\n  \"accounts/removeUserPermissions\": removeUserPermissions,\n  \"accounts/setUserPermissions\": setUserPermissions,\n  \"accounts/createFallbackLoginToken\": createFallbackLoginToken,\n  \"accounts/updateEmailAddress\": updateEmailAddress,\n  \"accounts/removeEmailAddress\": removeEmailAddress,\n  \"accounts/setProfileCurrency\": setProfileCurrency,\n  \"accounts/markAddressValidationBypassed\": markAddressValidationBypassed,\n  \"accounts/markTaxCalculationFailed\": markTaxCalculationFailed\n});\n"]},"sourceType":"script","hash":"bb5aa1c9683dfe0aa1cefa4387c500422d419722"}
