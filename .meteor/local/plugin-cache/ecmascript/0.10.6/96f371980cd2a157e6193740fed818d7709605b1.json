{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$1$2","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"ast":true,"babelrc":false,"sourceFileName":"packages/johanbrook:publication-collector/publication-collector.js","filename":"packages/johanbrook:publication-collector/publication-collector.js","sourceMaps":true,"envName":"development","cwd":"/Users/estebandev/test-knowledge","passPerPreset":false,"presets":[],"parserOpts":{"sourceType":"module","sourceFileName":"packages/johanbrook:publication-collector/publication-collector.js","plugins":["jsx","jsx","flow","flow","objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties"]},"generatorOpts":{"filename":"packages/johanbrook:publication-collector/publication-collector.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/johanbrook:publication-collector/publication-collector.js"}},"code":"module.export({\n  PublicationCollector: () => PublicationCollector\n});\nlet Meteor;\nmodule.watch(require(\"meteor/meteor\"), {\n  Meteor(v) {\n    Meteor = v;\n  }\n\n}, 0);\nlet Match, check;\nmodule.watch(require(\"meteor/check\"), {\n  Match(v) {\n    Match = v;\n  },\n\n  check(v) {\n    check = v;\n  }\n\n}, 1);\nlet Mongo;\nmodule.watch(require(\"meteor/mongo\"), {\n  Mongo(v) {\n    Mongo = v;\n  }\n\n}, 2);\nlet MongoID;\nmodule.watch(require(\"meteor/mongo-id\"), {\n  MongoID(v) {\n    MongoID = v;\n  }\n\n}, 3);\nlet EventEmitter;\nmodule.watch(require(\"events\"), {\n  EventEmitter(v) {\n    EventEmitter = v;\n  }\n\n}, 4);\nconst validMongoId = Match.OneOf(String, Mongo.ObjectID);\n/*\n  This class describes something like Subscription in\n  meteor/meteor/packages/ddp/livedata_server.js, but instead of sending\n  over a socket it just collects data.\n*/\n\nclass PublicationCollector extends EventEmitter {\n  constructor(opts = {}) {\n    super();\n    check(opts.userId, Match.Optional(String));\n    check(opts.delayInMs, Match.Optional(Match.Integer)); // Object where the keys are collection names, and then the keys are _ids\n\n    this._documents = {};\n\n    this.unblock = () => {};\n\n    this.userId = opts.userId;\n    this._idFilter = {\n      idStringify: MongoID.idStringify,\n      idParse: MongoID.idParse\n    };\n\n    this._isDeactivated = () => {};\n\n    this.delayInMs = opts.delayInMs;\n  }\n\n  collect(name, ...args) {\n    let callback; // extracts optional callback from latest argument\n\n    if (_.isFunction(args[args.length - 1])) {\n      callback = args.pop();\n    }\n\n    const handler = Meteor.server.publish_handlers[name];\n\n    if (!handler) {\n      throw new Error(`PublicationCollector: Couldn't find publication \"${name}\"! Did you misspell it?`);\n    }\n\n    return new Promise((resolve, reject) => {\n      const done = (...res) => {\n        callback && callback(...res);\n        resolve(...res);\n      };\n\n      const completeCollecting = collections => {\n        try {\n          done(collections);\n        } finally {\n          // stop the subscription\n          this.stop();\n        }\n      }; // adds a one time listener function for the \"ready\" event\n\n\n      this.once('ready', collections => {\n        if (this.delayInMs) {\n          Meteor.setTimeout(() => {\n            // collections is out of date, so we need to regenerate\n            collections = this._generateResponse();\n            completeCollecting(collections);\n          }, this.delayInMs);\n        } else {\n          // immediately complete\n          completeCollecting(collections);\n        }\n      });\n      const result = handler.call(this, ...args);\n\n      this._publishHandlerResult(result);\n    });\n  }\n  /**\n   * Reproduces \"_publishHandlerResult\" processing\n   * @see {@link https://github.com/meteor/meteor/blob/master/packages/ddp-server/livedata_server.js#L1045}\n   */\n\n\n  _publishHandlerResult(res) {\n    const cursors = []; // publication handlers can return a collection cursor, an array of cursors or nothing.\n\n    if (this._isCursor(res)) {\n      cursors.push(res);\n    } else if (Array.isArray(res)) {\n      // check all the elements are cursors\n      const areCursors = res.reduce((valid, cur) => valid && this._isCursor(cur), true);\n\n      if (!areCursors) {\n        this.error(new Error('PublicationCollector: Publish function returned an array of non-Cursors'));\n        return;\n      } // find duplicate collection names\n\n\n      const collectionNames = {};\n\n      for (let i = 0; i < res.length; ++i) {\n        const collectionName = res[i]._getCollectionName();\n\n        if ({}.hasOwnProperty.call(collectionNames, collectionName)) {\n          this.error(new Error(`PublicationCollector: Publish function returned multiple cursors for collection ${collectionName}`));\n          return;\n        }\n\n        collectionNames[collectionName] = true;\n        cursors.push(res[i]);\n      }\n    } else if (res) {\n      // truthy values other than cursors or arrays are probably a\n      // user mistake (possible returning a Mongo document via, say,\n      // `coll.findOne()`).\n      this.error(new Error('PublicationCollector: Publish function can only return a Cursor or an array of Cursors'));\n    }\n\n    if (cursors.length > 0) {\n      try {\n        // for each cursor we call _publishCursor method which starts observing the cursor and\n        // publishes the results.\n        cursors.forEach(cur => {\n          this._ensureCollectionInRes(cur._getCollectionName());\n\n          cur._publishCursor(this);\n        });\n      } catch (e) {\n        this.error(e);\n        return;\n      } // mark subscription as ready (_publishCursor does NOT call ready())\n\n\n      this.ready();\n    }\n  }\n\n  added(collection, id, fields) {\n    check(collection, String);\n    check(id, validMongoId);\n\n    this._ensureCollectionInRes(collection); // Make sure to ignore the _id in fields\n\n\n    const addedDocument = _.extend({\n      _id: id\n    }, _.omit(fields, '_id'));\n\n    this._documents[collection][id] = addedDocument;\n  }\n\n  changed(collection, id, fields) {\n    check(collection, String);\n    check(id, validMongoId);\n\n    this._ensureCollectionInRes(collection);\n\n    const existingDocument = this._documents[collection][id];\n\n    const fieldsNoId = _.omit(fields, '_id');\n\n    if (existingDocument) {\n      _.extend(existingDocument, fieldsNoId); // Delete all keys that were undefined in fields (except _id)\n\n\n      _.forEach(fields, (value, key) => {\n        if (value === undefined) {\n          delete existingDocument[key];\n        }\n      });\n    }\n  }\n\n  removed(collection, id) {\n    check(collection, String);\n    check(id, validMongoId);\n\n    this._ensureCollectionInRes(collection);\n\n    delete this._documents[collection][id];\n\n    if (_.isEmpty(this._documents[collection])) {\n      delete this._documents[collection];\n    }\n  }\n\n  ready() {\n    // Synchronously calls each of the listeners registered for the \"ready\" event\n    this.emit('ready', this._generateResponse());\n  }\n\n  onStop(callback) {\n    // Adds a one time listener function for the \"stop\" event\n    this.once('stop', callback);\n  }\n\n  stop() {\n    // Synchronously calls each of the listeners registered for the \"stop\" event\n    this.emit('stop');\n  }\n\n  error(error) {\n    throw error;\n  }\n\n  _isCursor(c) {\n    return c && c._publishCursor;\n  }\n\n  _ensureCollectionInRes(collection) {\n    this._documents[collection] = this._documents[collection] || {};\n  }\n\n  _generateResponse() {\n    const output = {};\n\n    _.forEach(this._documents, (documents, collectionName) => {\n      output[collectionName] = _.values(documents);\n    });\n\n    return output;\n  }\n\n}","map":{"version":3,"sources":["packages/johanbrook:publication-collector/publication-collector.js"],"names":["module","export","PublicationCollector","Meteor","watch","require","v","Match","check","Mongo","MongoID","EventEmitter","validMongoId","OneOf","String","ObjectID","constructor","opts","userId","Optional","delayInMs","Integer","_documents","unblock","_idFilter","idStringify","idParse","_isDeactivated","collect","name","args","callback","_","isFunction","length","pop","handler","server","publish_handlers","Error","Promise","resolve","reject","done","res","completeCollecting","collections","stop","once","setTimeout","_generateResponse","result","call","_publishHandlerResult","cursors","_isCursor","push","Array","isArray","areCursors","reduce","valid","cur","error","collectionNames","i","collectionName","_getCollectionName","hasOwnProperty","forEach","_ensureCollectionInRes","_publishCursor","e","ready","added","collection","id","fields","addedDocument","extend","_id","omit","changed","existingDocument","fieldsNoId","value","key","undefined","removed","isEmpty","emit","onStop","c","output","documents","values"],"mappings":"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","sourcesContent":["import { Meteor } from 'meteor/meteor';\nimport { Match, check } from 'meteor/check';\nimport { Mongo } from 'meteor/mongo';\nimport { MongoID } from 'meteor/mongo-id';\nimport { EventEmitter } from 'events';\n\nconst validMongoId = Match.OneOf(String, Mongo.ObjectID);\n\n/*\n  This class describes something like Subscription in\n  meteor/meteor/packages/ddp/livedata_server.js, but instead of sending\n  over a socket it just collects data.\n*/\nexport class PublicationCollector extends EventEmitter {\n\n  constructor(opts = {}) {\n    super();\n    check(opts.userId, Match.Optional(String));\n    check(opts.delayInMs, Match.Optional(Match.Integer));\n\n    // Object where the keys are collection names, and then the keys are _ids\n    this._documents = {};\n    this.unblock = () => {};\n    this.userId = opts.userId;\n    this._idFilter = {\n      idStringify: MongoID.idStringify,\n      idParse: MongoID.idParse\n    };\n    this._isDeactivated = () => {};\n\n    this.delayInMs = opts.delayInMs;\n  }\n\n  collect(name, ...args) {\n    let callback;\n    // extracts optional callback from latest argument\n    if (_.isFunction(args[args.length - 1])) {\n      callback = args.pop();\n    }\n\n    const handler = Meteor.server.publish_handlers[name];\n\n    if (!handler) {\n      throw new Error(`PublicationCollector: Couldn't find publication \"${name}\"! Did you misspell it?`);\n    }\n\n    return new Promise((resolve, reject) => {\n\n      const done = (...res) => {\n        callback && callback(...res);\n        resolve(...res);\n      };\n\n      const completeCollecting = (collections) => {\n        try {\n          done(collections);\n        } finally {\n          // stop the subscription\n          this.stop();\n        }\n      };\n\n      // adds a one time listener function for the \"ready\" event\n      this.once('ready', (collections) => {\n        if (this.delayInMs) {\n          Meteor.setTimeout(() => {\n            // collections is out of date, so we need to regenerate\n            collections = this._generateResponse();\n            completeCollecting(collections);\n          }, this.delayInMs);\n        } else {\n          // immediately complete\n          completeCollecting(collections);\n        }\n      });\n\n      const result = handler.call(this, ...args);\n\n      this._publishHandlerResult(result);\n    });\n  }\n\n  /**\n   * Reproduces \"_publishHandlerResult\" processing\n   * @see {@link https://github.com/meteor/meteor/blob/master/packages/ddp-server/livedata_server.js#L1045}\n   */\n  _publishHandlerResult(res) {\n    const cursors = [];\n\n    // publication handlers can return a collection cursor, an array of cursors or nothing.\n    if (this._isCursor(res)) {\n      cursors.push(res);\n    } else if (Array.isArray(res)) {\n      // check all the elements are cursors\n      const areCursors = res.reduce((valid, cur) => valid && this._isCursor(cur), true);\n      if (!areCursors) {\n        this.error(new Error('PublicationCollector: Publish function returned an array of non-Cursors'));\n        return;\n      }\n      // find duplicate collection names\n      const collectionNames = {};\n      for (let i = 0; i < res.length; ++i) {\n        const collectionName = res[i]._getCollectionName();\n        if ({}.hasOwnProperty.call(collectionNames, collectionName)) {\n          this.error(new Error(\n            `PublicationCollector: Publish function returned multiple cursors for collection ${collectionName}`\n          ));\n          return;\n        }\n        collectionNames[collectionName] = true;\n        cursors.push(res[i]);\n      }\n    } else if (res) {\n      // truthy values other than cursors or arrays are probably a\n      // user mistake (possible returning a Mongo document via, say,\n      // `coll.findOne()`).\n      this.error(new Error('PublicationCollector: Publish function can only return a Cursor or an array of Cursors'));\n    }\n\n    if (cursors.length > 0) {\n      try {\n        // for each cursor we call _publishCursor method which starts observing the cursor and\n        // publishes the results.\n        cursors.forEach((cur) => {\n          this._ensureCollectionInRes(cur._getCollectionName());\n          cur._publishCursor(this);\n        });\n      } catch (e) {\n        this.error(e);\n        return;\n      }\n\n      // mark subscription as ready (_publishCursor does NOT call ready())\n      this.ready();\n    }\n  }\n\n  added(collection, id, fields) {\n    check(collection, String);\n    check(id, validMongoId);\n\n    this._ensureCollectionInRes(collection);\n\n    // Make sure to ignore the _id in fields\n    const addedDocument = _.extend({_id: id}, _.omit(fields, '_id'));\n    this._documents[collection][id] = addedDocument;\n  }\n\n  changed(collection, id, fields) {\n    check(collection, String);\n    check(id, validMongoId);\n\n    this._ensureCollectionInRes(collection);\n\n    const existingDocument = this._documents[collection][id];\n    const fieldsNoId = _.omit(fields, '_id');\n\n    if (existingDocument) {\n      _.extend(existingDocument, fieldsNoId);\n\n      // Delete all keys that were undefined in fields (except _id)\n      _.forEach(fields, (value, key) => {\n        if (value === undefined) {\n          delete existingDocument[key];\n        }\n      });\n    }\n  }\n\n  removed(collection, id) {\n    check(collection, String);\n    check(id, validMongoId);\n\n    this._ensureCollectionInRes(collection);\n\n    delete this._documents[collection][id];\n\n    if (_.isEmpty(this._documents[collection])) {\n      delete this._documents[collection];\n    }\n  }\n\n  ready() {\n    // Synchronously calls each of the listeners registered for the \"ready\" event\n    this.emit('ready', this._generateResponse());\n  }\n\n  onStop(callback) {\n    // Adds a one time listener function for the \"stop\" event\n    this.once('stop', callback);\n  }\n\n  stop() {\n    // Synchronously calls each of the listeners registered for the \"stop\" event\n    this.emit('stop');\n  }\n\n  error(error) {\n    throw error;\n  }\n\n  _isCursor(c) {\n    return c && c._publishCursor;\n  }\n\n  _ensureCollectionInRes(collection) {\n    this._documents[collection] = this._documents[collection] || {};\n  }\n\n  _generateResponse() {\n    const output = {};\n\n    _.forEach(this._documents, (documents, collectionName) => {\n      output[collectionName] = _.values(documents);\n    });\n\n    return output;\n  }\n}\n"]},"sourceType":"script","hash":"96f371980cd2a157e6193740fed818d7709605b1"}
