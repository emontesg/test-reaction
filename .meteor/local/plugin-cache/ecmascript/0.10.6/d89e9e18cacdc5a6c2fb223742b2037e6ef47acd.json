{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$1$2","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"ast":true,"babelrc":false,"sourceFileName":"imports/plugins/core/graphql/server/resolvers/util/applyBeforeAfterToFilter.js","filename":"imports/plugins/core/graphql/server/resolvers/util/applyBeforeAfterToFilter.js","sourceMaps":true,"envName":"development","cwd":"/Users/estebandev/test-knowledge","passPerPreset":false,"presets":[],"parserOpts":{"sourceType":"module","sourceFileName":"imports/plugins/core/graphql/server/resolvers/util/applyBeforeAfterToFilter.js","plugins":["jsx","jsx","flow","flow","objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties"]},"generatorOpts":{"filename":"imports/plugins/core/graphql/server/resolvers/util/applyBeforeAfterToFilter.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"imports/plugins/core/graphql/server/resolvers/util/applyBeforeAfterToFilter.js"}},"code":"var _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/builtin/objectSpread\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nmodule.export({\n  default: () => applyBeforeAfterToFilter\n});\nlet decodeOpaqueId;\nmodule.watch(require(\"../xforms/id\"), {\n  decodeOpaqueId(v) {\n    decodeOpaqueId = v;\n  }\n\n}, 0);\n\nfunction applyBeforeAfterToFilter({\n  after,\n  baseFilter = {},\n  before,\n  collection,\n  sortBy: sortByField = \"_id\",\n  sortOrder = \"asc\"\n}) {\n  return Promise.asyncApply(() => {\n    let filter = baseFilter;\n    const limits = {};\n    const ors = [];\n    if (typeof sortByField !== \"string\") throw new Error(\"sortBy is required\");\n    if (sortOrder !== \"asc\" && sortOrder !== \"desc\") throw new Error(\"sortOrder is required\");\n    if (after && before) throw new Error(\"Including both 'after' and 'before' params is not allowed\");\n    if (!after && !before) return filter;\n    let encodedId;\n    let op;\n\n    if (before) {\n      encodedId = before;\n      op = sortOrder === \"desc\" ? \"$gt\" : \"$lt\";\n    } else {\n      encodedId = after;\n      op = sortOrder === \"desc\" ? \"$lt\" : \"$gt\";\n    } // \"encodedId\" is encoded twice. At this point the cursor has already been decoded\n    // but we are still left with an encoded ID, which we'll now decode.\n\n\n    let internalId;\n\n    if (encodedId.endsWith(\"=\")) {\n      internalId = decodeOpaqueId(encodedId).id;\n    } else {\n      internalId = encodedId; // it was only encoded once\n    }\n\n    if (sortByField === \"_id\") {\n      // We already have _id. Skip the lookup\n      filter = {\n        $and: [(0, _objectSpread2.default)({}, filter), {\n          _id: {\n            [op]: internalId\n          }\n        }]\n      };\n    } else {\n      const doc = Promise.await(collection.findOne({\n        _id: internalId\n      }, {\n        fields: {\n          [sortByField]: 1\n        }\n      }));\n\n      if (doc) {\n        limits[op] = doc[sortByField];\n        ors.push({\n          [sortByField]: doc[sortByField],\n          _id: {\n            [op]: internalId\n          }\n        });\n        filter = {\n          $and: [(0, _objectSpread2.default)({}, filter), {\n            $or: [{\n              [sortByField]: limits\n            }, ...ors]\n          }]\n        };\n      }\n    }\n\n    return filter;\n  });\n}","map":{"version":3,"sources":["imports/plugins/core/graphql/server/resolvers/util/applyBeforeAfterToFilter.js"],"names":["module","export","default","applyBeforeAfterToFilter","decodeOpaqueId","watch","require","v","after","baseFilter","before","collection","sortBy","sortByField","sortOrder","filter","limits","ors","Error","encodedId","op","internalId","endsWith","id","$and","_id","doc","findOne","fields","push","$or"],"mappings":";;;;AAAAA,OAAOC,MAAP,CAAc;AAACC,WAAQ,MAAIC;AAAb,CAAd;AAAsD,IAAIC,cAAJ;AAAmBJ,OAAOK,KAAP,CAAaC,QAAQ,cAAR,CAAb,EAAqC;AAACF,iBAAeG,CAAf,EAAiB;AAACH,qBAAeG,CAAf;AAAiB;;AAApC,CAArC,EAA2E,CAA3E;;AAE1D,SAAeJ,wBAAf,CAAwC;AACrDK,OADqD;AAErDC,eAAa,EAFwC;AAGrDC,QAHqD;AAIrDC,YAJqD;AAKrDC,UAAQC,cAAc,KAL+B;AAMrDC,cAAY;AANyC,CAAxC;AAAA,kCAOZ;AACD,QAAIC,SAASN,UAAb;AACA,UAAMO,SAAS,EAAf;AACA,UAAMC,MAAM,EAAZ;AAEA,QAAI,OAAOJ,WAAP,KAAuB,QAA3B,EAAqC,MAAM,IAAIK,KAAJ,CAAU,oBAAV,CAAN;AACrC,QAAIJ,cAAc,KAAd,IAAuBA,cAAc,MAAzC,EAAiD,MAAM,IAAII,KAAJ,CAAU,uBAAV,CAAN;AAEjD,QAAIV,SAASE,MAAb,EAAqB,MAAM,IAAIQ,KAAJ,CAAU,2DAAV,CAAN;AAErB,QAAI,CAACV,KAAD,IAAU,CAACE,MAAf,EAAuB,OAAOK,MAAP;AAEvB,QAAII,SAAJ;AACA,QAAIC,EAAJ;;AACA,QAAIV,MAAJ,EAAY;AACVS,kBAAYT,MAAZ;AACAU,WAAMN,cAAc,MAAd,GAAuB,KAAvB,GAA+B,KAArC;AACD,KAHD,MAGO;AACLK,kBAAYX,KAAZ;AACAY,WAAMN,cAAc,MAAd,GAAuB,KAAvB,GAA+B,KAArC;AACD,KApBA,CAsBD;AACA;;;AACA,QAAIO,UAAJ;;AACA,QAAIF,UAAUG,QAAV,CAAmB,GAAnB,CAAJ,EAA6B;AAC3BD,mBAAajB,eAAee,SAAf,EAA0BI,EAAvC;AACD,KAFD,MAEO;AACLF,mBAAaF,SAAb,CADK,CACmB;AACzB;;AAED,QAAIN,gBAAgB,KAApB,EAA2B;AACzB;AACAE,eAAS;AACPS,cAAM,iCACCT,MADD,GAEJ;AAAEU,eAAK;AAAE,aAACL,EAAD,GAAMC;AAAR;AAAP,SAFI;AADC,OAAT;AAMD,KARD,MAQO;AACL,YAAMK,oBAAYf,WAAWgB,OAAX,CAAmB;AACnCF,aAAKJ;AAD8B,OAAnB,EAEf;AACDO,gBAAQ;AACN,WAACf,WAAD,GAAe;AADT;AADP,OAFe,CAAZ,CAAN;;AAQA,UAAIa,GAAJ,EAAS;AACPV,eAAOI,EAAP,IAAaM,IAAIb,WAAJ,CAAb;AACAI,YAAIY,IAAJ,CAAS;AACP,WAAChB,WAAD,GAAea,IAAIb,WAAJ,CADR;AAEPY,eAAK;AAAE,aAACL,EAAD,GAAMC;AAAR;AAFE,SAAT;AAKAN,iBAAS;AACPS,gBAAM,iCACCT,MADD,GAEJ;AACEe,iBAAK,CACH;AACE,eAACjB,WAAD,GAAeG;AADjB,aADG,EAIH,GAAGC,GAJA;AADP,WAFI;AADC,SAAT;AAaD;AACF;;AAED,WAAOF,MAAP;AACD,GA/Ec;AAAA","sourcesContent":["import { decodeOpaqueId } from \"@reactioncommerce/reaction-graphql-xforms/id\";\n\nexport default async function applyBeforeAfterToFilter({\n  after,\n  baseFilter = {},\n  before,\n  collection,\n  sortBy: sortByField = \"_id\",\n  sortOrder = \"asc\"\n}) {\n  let filter = baseFilter;\n  const limits = {};\n  const ors = [];\n\n  if (typeof sortByField !== \"string\") throw new Error(\"sortBy is required\");\n  if (sortOrder !== \"asc\" && sortOrder !== \"desc\") throw new Error(\"sortOrder is required\");\n\n  if (after && before) throw new Error(\"Including both 'after' and 'before' params is not allowed\");\n\n  if (!after && !before) return filter;\n\n  let encodedId;\n  let op;\n  if (before) {\n    encodedId = before;\n    op = (sortOrder === \"desc\" ? \"$gt\" : \"$lt\");\n  } else {\n    encodedId = after;\n    op = (sortOrder === \"desc\" ? \"$lt\" : \"$gt\");\n  }\n\n  // \"encodedId\" is encoded twice. At this point the cursor has already been decoded\n  // but we are still left with an encoded ID, which we'll now decode.\n  let internalId;\n  if (encodedId.endsWith(\"=\")) {\n    internalId = decodeOpaqueId(encodedId).id;\n  } else {\n    internalId = encodedId; // it was only encoded once\n  }\n\n  if (sortByField === \"_id\") {\n    // We already have _id. Skip the lookup\n    filter = {\n      $and: [\n        { ...filter },\n        { _id: { [op]: internalId } }\n      ]\n    };\n  } else {\n    const doc = await collection.findOne({\n      _id: internalId\n    }, {\n      fields: {\n        [sortByField]: 1\n      }\n    });\n\n    if (doc) {\n      limits[op] = doc[sortByField];\n      ors.push({\n        [sortByField]: doc[sortByField],\n        _id: { [op]: internalId }\n      });\n\n      filter = {\n        $and: [\n          { ...filter },\n          {\n            $or: [\n              {\n                [sortByField]: limits\n              },\n              ...ors\n            ]\n          }\n        ]\n      };\n    }\n  }\n\n  return filter;\n}\n"]},"sourceType":"script","hash":"d89e9e18cacdc5a6c2fb223742b2037e6ef47acd"}
