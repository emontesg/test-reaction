{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$1$2","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"ast":true,"babelrc":false,"sourceFileName":"imports/plugins/core/checkout/server/methods/workflow.js","filename":"imports/plugins/core/checkout/server/methods/workflow.js","sourceMaps":true,"envName":"development","cwd":"/Users/estebandev/test-knowledge","passPerPreset":false,"presets":[],"parserOpts":{"sourceType":"module","sourceFileName":"imports/plugins/core/checkout/server/methods/workflow.js","plugins":["jsx","jsx","flow","flow","objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties"]},"generatorOpts":{"filename":"imports/plugins/core/checkout/server/methods/workflow.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"imports/plugins/core/checkout/server/methods/workflow.js"}},"code":"let _uniq;\n\nmodule.watch(require(\"lodash/uniq\"), {\n  default(v) {\n    _uniq = v;\n  }\n\n}, 0);\n\nlet _includes;\n\nmodule.watch(require(\"lodash/includes\"), {\n  default(v) {\n    _includes = v;\n  }\n\n}, 1);\n\nlet _each;\n\nmodule.watch(require(\"lodash/each\"), {\n  default(v) {\n    _each = v;\n  }\n\n}, 2);\n\nlet _filter;\n\nmodule.watch(require(\"lodash/filter\"), {\n  default(v) {\n    _filter = v;\n  }\n\n}, 3);\nlet Meteor;\nmodule.watch(require(\"meteor/meteor\"), {\n  Meteor(v) {\n    Meteor = v;\n  }\n\n}, 4);\nlet Roles;\nmodule.watch(require(\"meteor/alanning:roles\"), {\n  Roles(v) {\n    Roles = v;\n  }\n\n}, 5);\nlet check, Match;\nmodule.watch(require(\"meteor/check\"), {\n  check(v) {\n    check = v;\n  },\n\n  Match(v) {\n    Match = v;\n  }\n\n}, 6);\nlet Cart, Orders, Packages, Groups;\nmodule.watch(require(\"../../../../../../lib/collections\"), {\n  Cart(v) {\n    Cart = v;\n  },\n\n  Orders(v) {\n    Orders = v;\n  },\n\n  Packages(v) {\n    Packages = v;\n  },\n\n  Groups(v) {\n    Groups = v;\n  }\n\n}, 7);\nlet Hooks, Logger, Reaction;\nmodule.watch(require(\"../../../../../../server/api\"), {\n  Hooks(v) {\n    Hooks = v;\n  },\n\n  Logger(v) {\n    Logger = v;\n  },\n\n  Reaction(v) {\n    Reaction = v;\n  }\n\n}, 8);\n\n/* eslint no-shadow: 0 */\n\n/**\n * @method updateOrderWorkflow\n * @summary Updates a hook to update orders status before updating an order.\n *\n * @param {String} userId - currently logged in user\n * @param {Object} selector - selector for product to update\n * @param {Object} modifier - Object describing what parts of the document to update.\n * @param {Object} validation\n * @return {String} _id of updated document\n */\nfunction updateOrderWorkflow(userId, selector, modifier, validation) {\n  const order = Orders.findOne(selector);\n  Hooks.Events.run(\"beforeUpdateOrderWorkflow\", order, {\n    userId,\n    modifier,\n    validation\n  });\n  Logger.debug(\"beforeUpdateOrderWorkflow hook executed before Order is updated\");\n  const result = Orders.update(selector, modifier, validation); // Update mongo search record\n\n  Hooks.Events.run(\"afterUpdateOrderUpdateSearchRecord\", order);\n  return result;\n}\n/**\n * @file Methods for Workflow. Run these methods using `Meteor.call()`.\n * @example Meteor.call(\"workflow/pushCartWorkflow\", \"coreCartWorkflow\", \"checkoutLogin\");\n *\n * @namespace Methods/Workflow\n*/\n\n\nMeteor.methods({\n  /**\n   * @name workflow/pushCartWorkflow\n   * @memberof Methods/Workflow\n   * @method\n   * @example Meteor.call(\"workflow/pushCartWorkflow\", \"coreCartWorkflow\", \"checkoutLogin\");\n   * @summary updates cart workflow status\n   * @description status in the workflow is stored as the current active workflow step.\n   * first sets, second call moves status to next workflow\n   * additional calls do nothing\n   * user permissions to template are verified\n   * @param {String} workflow - name of workflow\n   * @param {String} newWorkflowStatus - name of the next workflow stage\n   * @param {String} [cartId] - cart._id\n   * @return {Array|Boolean|Number} return\n   */\n  \"workflow/pushCartWorkflow\"(workflow, newWorkflowStatus, cartId) {\n    check(workflow, String);\n    check(newWorkflowStatus, String);\n    check(cartId, Match.Optional(String));\n    this.unblock();\n    let currentCart;\n    const defaultPackageWorkflows = [];\n    let nextWorkflowStep = {\n      template: \"\"\n    }; // This method could be called indirectly from publication method in a time\n    // when `this.userId` will be null, that's why we have a third argument in\n    // this method - `cartId`. So, we can't completely rely on `Meteor.userId()`\n    // here.\n\n    if (typeof cartId === \"string\") {\n      currentCart = Cart.findOne(cartId);\n    } else {\n      currentCart = Cart.findOne({\n        userId: this.userId\n      });\n    } // exit if a cart doesn't exist.\n\n\n    if (!currentCart) return []; // TODO doc this\n\n    const currentWorkflowStatus = currentCart.workflow.status;\n    const packages = Packages.find({\n      \"shopId\": Reaction.getShopId(),\n      \"layout.workflow\": workflow\n    }); // loop through packages and set the defaultPackageWorkflows\n\n    packages.forEach(reactionPackage => {\n      // todo fix this hack for not filtering nicely\n      if (!reactionPackage.layout.layout) {\n        const layouts = _filter(reactionPackage.layout, {\n          workflow\n        }); // for every layout, process the associated workflows\n\n\n        _each(layouts, layout => {\n          // audience is the layout permissions\n          if (typeof layout.audience !== \"object\") {\n            const defaultRoles = Groups.findOne({\n              slug: \"customer\",\n              shopId: Reaction.getShopId()\n            }).permissions;\n            layout.audience = defaultRoles;\n          } // check permissions so you don't have to on template. For a case, when\n          // this method calls indirectly from publication method, we do this\n          // check which is looks not pretty secure\n\n\n          let hasPermission;\n\n          if (typeof Meteor.userId() !== \"string\") {\n            hasPermission = Roles.userIsInRole(currentCart.userId, layout.audience, Reaction.getShopId());\n          } else {\n            hasPermission = Roles.userIsInRole(Meteor.userId(), layout.audience, Reaction.getShopId());\n          }\n\n          if (hasPermission && !layout.layout) {\n            defaultPackageWorkflows.push(layout);\n          }\n        });\n      }\n    }); // statusExistsInWorkflow boolean\n\n    const statusExistsInWorkflow = _includes(currentCart.workflow.workflow, newWorkflowStatus);\n\n    const maxSteps = defaultPackageWorkflows.length;\n    let nextWorkflowStepIndex;\n    let templateProcessedinWorkflow = false;\n    let gotoNextWorkflowStep = false; // if we haven't populated workflows lets exit\n\n    if (!defaultPackageWorkflows.length > 0) {\n      return [];\n    } // loop through all shop configured layouts, and their default workflows\n    // to determine what the next workflow step should be\n    // the cart workflow status while processing is neither true nor false (set to template)\n\n\n    _each(defaultPackageWorkflows, (workflow, currentStatusIndex) => {\n      if (workflow.template === currentWorkflowStatus) {\n        // don't go past the end of the workflow\n        if (currentStatusIndex < maxSteps - 1) {\n          Logger.debug(\"currentStatusIndex, maxSteps\", currentStatusIndex, maxSteps);\n          Logger.debug(\"currentStatusIndex, maxSteps\", currentStatusIndex, maxSteps);\n          nextWorkflowStepIndex = currentStatusIndex + 1;\n        } else {\n          nextWorkflowStepIndex = currentStatusIndex;\n        }\n\n        Logger.debug(\"nextWorkflowStepIndex\", nextWorkflowStepIndex); // set the nextWorkflowStep as the next workflow object from registry\n\n        nextWorkflowStep = defaultPackageWorkflows[nextWorkflowStepIndex];\n        Logger.debug(\"setting nextWorkflowStep\", nextWorkflowStep.template);\n      }\n    }); // check to see if the next step has already been processed.\n    // templateProcessedinWorkflow boolean\n\n\n    gotoNextWorkflowStep = nextWorkflowStep.template;\n    templateProcessedinWorkflow = _includes(currentCart.workflow.workflow, nextWorkflowStep.template); // debug info\n\n    Logger.debug(\"currentWorkflowStatus: \", currentWorkflowStatus);\n    Logger.debug(\"workflow/pushCartWorkflow workflow: \", workflow);\n    Logger.debug(\"newWorkflowStatus: \", newWorkflowStatus);\n    Logger.debug(\"current cartId: \", currentCart._id);\n    Logger.debug(\"currentWorkflow: \", currentCart.workflow.workflow);\n    Logger.debug(\"nextWorkflowStep: \", nextWorkflowStep.template || defaultPackageWorkflows[0].template);\n    Logger.debug(\"statusExistsInWorkflow: \", statusExistsInWorkflow);\n    Logger.debug(\"templateProcessedinWorkflow: \", templateProcessedinWorkflow);\n    Logger.debug(\"gotoNextWorkflowStep: \", gotoNextWorkflowStep); // Condition One\n    // if you're going to join the workflow you need a status that is a template name.\n    // this status/template is how we know\n    // where you are in the flow and configures `gotoNextWorkflowStep`\n\n    if (!gotoNextWorkflowStep && currentWorkflowStatus !== newWorkflowStatus) {\n      Logger.debug(`######## Condition One #########:\n        initialise the ${currentCart._id} ${workflow}:\n        ${defaultPackageWorkflows[0].template}`);\n      const result = Cart.update(currentCart._id, {\n        $set: {\n          \"workflow.status\": defaultPackageWorkflows[0].template\n        }\n      });\n      Logger.debug(result);\n      return result;\n    } // Condition Two\n    // your're now accepted into the workflow,\n    // but to begin the workflow you need to have a next step\n    // and you should have already be in the current workflow template\n\n\n    if (gotoNextWorkflowStep && statusExistsInWorkflow === false && templateProcessedinWorkflow === false) {\n      Logger.debug(\"######## Condition Two #########: set status to: \", nextWorkflowStep.template);\n      return Cart.update(currentCart._id, {\n        $set: {\n          \"workflow.status\": nextWorkflowStep.template\n        },\n        $addToSet: {\n          \"workflow.workflow\": currentWorkflowStatus\n        }\n      });\n    } // Condition Three\n    // If you got here by skipping around willy nilly\n    // we're going to do our best to ignore you.\n\n\n    if (gotoNextWorkflowStep && statusExistsInWorkflow === true && templateProcessedinWorkflow === false) {\n      Logger.debug(`######## Condition Three #########: complete workflow ${currentWorkflowStatus} updates and move to: `, nextWorkflowStep.template);\n      return Cart.update(currentCart._id, {\n        $set: {\n          \"workflow.status\": nextWorkflowStep.template\n        },\n        $addToSet: {\n          \"workflow.workflow\": currentWorkflowStatus\n        }\n      });\n    } // Condition Four\n    // you got here through hard work, and processed the previous template\n    // nice job. now start over with the next step.\n\n\n    if (gotoNextWorkflowStep && statusExistsInWorkflow === true && templateProcessedinWorkflow === true) {\n      Logger.debug(\"######## Condition Four #########: previously ran, doing nothing. : \", newWorkflowStatus);\n      return true;\n    }\n  },\n\n  /**\n   * @name workflow/revertCartWorkflow\n   * @memberof Methods/Workflow\n   * @method\n   * @summary if something was changed on the previous `cartWorkflow` steps,\n   * we need to revert to this step to renew the order\n   * @param {String} newWorkflowStatus - name of `cartWorkflow` step, which we need to revert\n   * @todo need tests\n   * @return {Number|Boolean} cart update results\n   */\n  \"workflow/revertCartWorkflow\"(newWorkflowStatus) {\n    check(newWorkflowStatus, String);\n    this.unblock();\n    const cart = Cart.findOne({\n      userId: this.userId\n    });\n    if (!cart || typeof cart.workflow !== \"object\") return false;\n    if (typeof cart.workflow.workflow !== \"object\") return false;\n    const {\n      workflow\n    } = cart.workflow; // get index of `newWorkflowStatus`\n\n    const resetToIndex = workflow.indexOf(newWorkflowStatus); // exit if no such step in workflow\n\n    if (resetToIndex < 0) return false; // remove all steps that further `newWorkflowStatus` and itself\n\n    const resetedWorkflow = workflow.slice(0, resetToIndex);\n    return Cart.update(cart._id, {\n      $set: {\n        \"workflow.status\": newWorkflowStatus,\n        \"workflow.workflow\": resetedWorkflow\n      }\n    });\n  },\n\n  /**\n   * @name workflow/pushOrderWorkflow\n   * @summary Update the order workflow: Push the status as the current workflow step,\n   * move the current status to completed worflow steps\n   *\n   * @description Step 1 meteor call to push a new workflow\n   * Meteor.call(\"workflow/pushOrderWorkflow\", \"coreOrderWorkflow\", \"processing\", this);\n   * NOTE: \"coreOrderWorkflow\", \"processing\" will be combined into \"coreOrderWorkflow/processing\" and set as the status\n   * Step 2 (this method) of the \"workflow/pushOrderWorkflow\" flow; Try to update the current status\n   *\n   * @method\n   * @memberof Methods/Workflow\n   * @param  {String} workflow workflow to push to\n   * @param  {String} status - Workflow status\n   * @param  {Order} order - Schemas.Order, an order object\n   * @return {Boolean} true if update was successful\n   */\n  \"workflow/pushOrderWorkflow\"(workflow, status, order) {\n    check(workflow, String);\n    check(status, String);\n    check(order, Match.ObjectIncluding({\n      _id: String\n    }));\n    this.unblock();\n    const workflowStatus = `${workflow}/${status}`;\n    const result = updateOrderWorkflow(this.userId, {\n      _id: order._id\n    }, {\n      $set: {\n        // Combine (workflow) \"coreOrderWorkflow\", (status) \"processing\" into \"coreOrderWorkflow/processing\".\n        // This comoniation will be used to call the method \"workflow/coreOrderWorkflow/processing\", if it exists.\n        \"workflow.status\": `${workflow}/${status}`\n      },\n      $addToSet: {\n        \"workflow.workflow\": workflowStatus\n      }\n    });\n    return result;\n  },\n\n  /**\n   * @name workflow/pullOrderWorkflow\n   * @description Push the status as the current workflow step, move the current status to completed worflow steps\n   * @summary Pull a previous order status\n   * @method\n   * @memberof Methods/Workflow\n   * @param  {String} workflow workflow to push to\n   * @param  {String} status - Workflow status\n   * @param  {Order} order - Schemas.Order, an order object\n   * @return {Boolean} true if update was successful\n   */\n  \"workflow/pullOrderWorkflow\"(workflow, status, order) {\n    check(workflow, String);\n    check(status, String);\n    check(order, Match.ObjectIncluding({\n      _id: String,\n      workflow: Match.ObjectIncluding({\n        status: String\n      })\n    }));\n    this.unblock();\n    const result = Orders.update({\n      _id: order._id\n    }, {\n      $set: {\n        \"workflow.status\": status\n      },\n      $pull: {\n        \"workflow.workflow\": order.workflow.status\n      }\n    });\n    return result;\n  },\n\n  /**\n   * @name workflow/pushItemWorkflow\n   * @method\n   * @memberof Methods/Workflow\n   * @param  {String} status  Workflow status\n   * @param  {Object} order   Schemas.Order, an order object\n   * @param  {String[]} itemIds Array of item IDs\n   * @return {Boolean}         true if update was successful\n   */\n  \"workflow/pushItemWorkflow\"(status, order, itemIds) {\n    check(status, String);\n    check(order, Match.ObjectIncluding({\n      _id: String,\n      items: [Object]\n    }));\n    check(itemIds, Array); // We can't trust the order from the client (for several reasons)\n    // Initially because in a multi-merchant scenario, the order from the client\n    // will contain only the items associated with their shop\n    // We'll get the order from the db that has all the items\n    // TODO: Resolve potential concurrency issue where any writes to the order items\n    // between this read and the Orders.update write below would be lost.\n\n    const dbOrder = Orders.findOne({\n      _id: order._id\n    });\n    const items = dbOrder.items.map(item => {\n      // Don't modify items unless they in our itemIds array\n      if (!itemIds.includes(item._id)) {\n        return item;\n      } // Add the current status to completed workflows\n\n\n      if (item.workflow.status !== \"new\") {\n        const workflows = item.workflow.workflow || [];\n        workflows.push(status);\n        item.workflow.workflow = _uniq(workflows);\n      } // Set the new item status\n\n\n      item.workflow.status = status;\n      return item;\n    });\n    const result = Orders.update({\n      _id: dbOrder._id\n    }, {\n      $set: {\n        items\n      }\n    }); // Update search record\n\n    Hooks.Events.run(\"afterUpdateOrderUpdateSearchRecord\", order);\n    return result;\n  }\n\n});","map":{"version":3,"sources":["imports/plugins/core/checkout/server/methods/workflow.js"],"names":["_uniq","module","watch","require","default","v","_includes","_each","_filter","Meteor","Roles","check","Match","Cart","Orders","Packages","Groups","Hooks","Logger","Reaction","updateOrderWorkflow","userId","selector","modifier","validation","order","findOne","Events","run","debug","result","update","methods","workflow","newWorkflowStatus","cartId","String","Optional","unblock","currentCart","defaultPackageWorkflows","nextWorkflowStep","template","currentWorkflowStatus","status","packages","find","getShopId","forEach","reactionPackage","layout","layouts","audience","defaultRoles","slug","shopId","permissions","hasPermission","userIsInRole","push","statusExistsInWorkflow","maxSteps","length","nextWorkflowStepIndex","templateProcessedinWorkflow","gotoNextWorkflowStep","currentStatusIndex","_id","$set","$addToSet","cart","resetToIndex","indexOf","resetedWorkflow","slice","ObjectIncluding","workflowStatus","$pull","itemIds","items","Object","Array","dbOrder","map","item","includes","workflows"],"mappings":"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","sourcesContent":["import _ from \"lodash\";\nimport { Meteor } from \"meteor/meteor\";\nimport { Roles } from \"meteor/alanning:roles\";\nimport { check, Match } from \"meteor/check\";\nimport { Cart, Orders, Packages, Groups } from \"/lib/collections\";\nimport { Hooks, Logger, Reaction } from \"/server/api\";\n\n/* eslint no-shadow: 0 */\n\n/**\n * @method updateOrderWorkflow\n * @summary Updates a hook to update orders status before updating an order.\n *\n * @param {String} userId - currently logged in user\n * @param {Object} selector - selector for product to update\n * @param {Object} modifier - Object describing what parts of the document to update.\n * @param {Object} validation\n * @return {String} _id of updated document\n */\nfunction updateOrderWorkflow(userId, selector, modifier, validation) {\n  const order = Orders.findOne(selector);\n\n  Hooks.Events.run(\"beforeUpdateOrderWorkflow\", order, {\n    userId,\n    modifier,\n    validation\n  });\n\n  Logger.debug(\"beforeUpdateOrderWorkflow hook executed before Order is updated\");\n\n  const result = Orders.update(selector, modifier, validation);\n\n  // Update mongo search record\n  Hooks.Events.run(\"afterUpdateOrderUpdateSearchRecord\", order);\n\n  return result;\n}\n\n/**\n * @file Methods for Workflow. Run these methods using `Meteor.call()`.\n * @example Meteor.call(\"workflow/pushCartWorkflow\", \"coreCartWorkflow\", \"checkoutLogin\");\n *\n * @namespace Methods/Workflow\n*/\nMeteor.methods({\n  /**\n   * @name workflow/pushCartWorkflow\n   * @memberof Methods/Workflow\n   * @method\n   * @example Meteor.call(\"workflow/pushCartWorkflow\", \"coreCartWorkflow\", \"checkoutLogin\");\n   * @summary updates cart workflow status\n   * @description status in the workflow is stored as the current active workflow step.\n   * first sets, second call moves status to next workflow\n   * additional calls do nothing\n   * user permissions to template are verified\n   * @param {String} workflow - name of workflow\n   * @param {String} newWorkflowStatus - name of the next workflow stage\n   * @param {String} [cartId] - cart._id\n   * @return {Array|Boolean|Number} return\n   */\n  \"workflow/pushCartWorkflow\"(workflow, newWorkflowStatus, cartId) {\n    check(workflow, String);\n    check(newWorkflowStatus, String);\n    check(cartId, Match.Optional(String));\n    this.unblock();\n\n    let currentCart;\n    const defaultPackageWorkflows = [];\n    let nextWorkflowStep = {\n      template: \"\"\n    };\n\n    // This method could be called indirectly from publication method in a time\n    // when `this.userId` will be null, that's why we have a third argument in\n    // this method - `cartId`. So, we can't completely rely on `Meteor.userId()`\n    // here.\n    if (typeof cartId === \"string\") {\n      currentCart = Cart.findOne(cartId);\n    } else {\n      currentCart = Cart.findOne({\n        userId: this.userId\n      });\n    }\n    // exit if a cart doesn't exist.\n    if (!currentCart) return [];\n    // TODO doc this\n    const currentWorkflowStatus = currentCart.workflow.status;\n    const packages = Packages.find({\n      \"shopId\": Reaction.getShopId(),\n      \"layout.workflow\": workflow\n    });\n\n    // loop through packages and set the defaultPackageWorkflows\n    packages.forEach((reactionPackage) => {\n      // todo fix this hack for not filtering nicely\n      if (!reactionPackage.layout.layout) {\n        const layouts = _.filter(reactionPackage.layout, {\n          workflow\n        });\n        // for every layout, process the associated workflows\n        _.each(layouts, (layout) => {\n          // audience is the layout permissions\n          if (typeof layout.audience !== \"object\") {\n            const defaultRoles = Groups.findOne({\n              slug: \"customer\",\n              shopId: Reaction.getShopId()\n            }).permissions;\n            layout.audience = defaultRoles;\n          }\n          // check permissions so you don't have to on template. For a case, when\n          // this method calls indirectly from publication method, we do this\n          // check which is looks not pretty secure\n          let hasPermission;\n          if (typeof Meteor.userId() !== \"string\") {\n            hasPermission = Roles.userIsInRole(currentCart.userId, layout.audience, Reaction.getShopId());\n          } else {\n            hasPermission = Roles.userIsInRole(Meteor.userId(), layout.audience, Reaction.getShopId());\n          }\n\n          if (hasPermission && !layout.layout) {\n            defaultPackageWorkflows.push(layout);\n          }\n        });\n      }\n    });\n\n    // statusExistsInWorkflow boolean\n    const statusExistsInWorkflow = _.includes(currentCart.workflow.workflow, newWorkflowStatus);\n    const maxSteps = defaultPackageWorkflows.length;\n    let nextWorkflowStepIndex;\n    let templateProcessedinWorkflow = false;\n    let gotoNextWorkflowStep = false;\n\n    // if we haven't populated workflows lets exit\n    if (!defaultPackageWorkflows.length > 0) {\n      return [];\n    }\n\n    // loop through all shop configured layouts, and their default workflows\n    // to determine what the next workflow step should be\n    // the cart workflow status while processing is neither true nor false (set to template)\n    _.each(defaultPackageWorkflows, (workflow, currentStatusIndex) => {\n      if (workflow.template === currentWorkflowStatus) {\n        // don't go past the end of the workflow\n        if (currentStatusIndex < maxSteps - 1) {\n          Logger.debug(\"currentStatusIndex, maxSteps\", currentStatusIndex, maxSteps);\n          Logger.debug(\"currentStatusIndex, maxSteps\", currentStatusIndex, maxSteps);\n          nextWorkflowStepIndex = currentStatusIndex + 1;\n        } else {\n          nextWorkflowStepIndex = currentStatusIndex;\n        }\n\n        Logger.debug(\"nextWorkflowStepIndex\", nextWorkflowStepIndex);\n        // set the nextWorkflowStep as the next workflow object from registry\n        nextWorkflowStep = defaultPackageWorkflows[nextWorkflowStepIndex];\n\n        Logger.debug(\"setting nextWorkflowStep\", nextWorkflowStep.template);\n      }\n    });\n\n    // check to see if the next step has already been processed.\n    // templateProcessedinWorkflow boolean\n    gotoNextWorkflowStep = nextWorkflowStep.template;\n    templateProcessedinWorkflow = _.includes(currentCart.workflow.workflow, nextWorkflowStep.template);\n\n    // debug info\n    Logger.debug(\"currentWorkflowStatus: \", currentWorkflowStatus);\n    Logger.debug(\"workflow/pushCartWorkflow workflow: \", workflow);\n    Logger.debug(\"newWorkflowStatus: \", newWorkflowStatus);\n    Logger.debug(\"current cartId: \", currentCart._id);\n    Logger.debug(\"currentWorkflow: \", currentCart.workflow.workflow);\n    Logger.debug(\"nextWorkflowStep: \", nextWorkflowStep.template || defaultPackageWorkflows[0].template);\n    Logger.debug(\"statusExistsInWorkflow: \", statusExistsInWorkflow);\n    Logger.debug(\"templateProcessedinWorkflow: \", templateProcessedinWorkflow);\n    Logger.debug(\"gotoNextWorkflowStep: \", gotoNextWorkflowStep);\n\n    // Condition One\n    // if you're going to join the workflow you need a status that is a template name.\n    // this status/template is how we know\n    // where you are in the flow and configures `gotoNextWorkflowStep`\n\n    if (!gotoNextWorkflowStep && currentWorkflowStatus !== newWorkflowStatus) {\n      Logger.debug(`######## Condition One #########:\n        initialise the ${currentCart._id} ${workflow}:\n        ${defaultPackageWorkflows[0].template}`);\n      const result = Cart.update(currentCart._id, {\n        $set: {\n          \"workflow.status\": defaultPackageWorkflows[0].template\n        }\n      });\n      Logger.debug(result);\n      return result;\n    }\n\n    // Condition Two\n    // your're now accepted into the workflow,\n    // but to begin the workflow you need to have a next step\n    // and you should have already be in the current workflow template\n    if (gotoNextWorkflowStep && statusExistsInWorkflow === false &&\n      templateProcessedinWorkflow === false) {\n      Logger.debug(\"######## Condition Two #########: set status to: \", nextWorkflowStep.template);\n\n      return Cart.update(currentCart._id, {\n        $set: {\n          \"workflow.status\": nextWorkflowStep.template\n        },\n        $addToSet: {\n          \"workflow.workflow\": currentWorkflowStatus\n        }\n      });\n    }\n\n    // Condition Three\n    // If you got here by skipping around willy nilly\n    // we're going to do our best to ignore you.\n    if (gotoNextWorkflowStep && statusExistsInWorkflow === true &&\n      templateProcessedinWorkflow === false) {\n      Logger.debug(\n        `######## Condition Three #########: complete workflow ${currentWorkflowStatus} updates and move to: `,\n        nextWorkflowStep.template\n      );\n      return Cart.update(currentCart._id, {\n        $set: {\n          \"workflow.status\": nextWorkflowStep.template\n        },\n        $addToSet: {\n          \"workflow.workflow\": currentWorkflowStatus\n        }\n      });\n    }\n\n    // Condition Four\n    // you got here through hard work, and processed the previous template\n    // nice job. now start over with the next step.\n    if (gotoNextWorkflowStep && statusExistsInWorkflow === true &&\n      templateProcessedinWorkflow === true) {\n      Logger.debug(\n        \"######## Condition Four #########: previously ran, doing nothing. : \",\n        newWorkflowStatus\n      );\n      return true;\n    }\n  },\n\n  /**\n   * @name workflow/revertCartWorkflow\n   * @memberof Methods/Workflow\n   * @method\n   * @summary if something was changed on the previous `cartWorkflow` steps,\n   * we need to revert to this step to renew the order\n   * @param {String} newWorkflowStatus - name of `cartWorkflow` step, which we need to revert\n   * @todo need tests\n   * @return {Number|Boolean} cart update results\n   */\n  \"workflow/revertCartWorkflow\"(newWorkflowStatus) {\n    check(newWorkflowStatus, String);\n    this.unblock();\n\n    const cart = Cart.findOne({\n      userId: this.userId\n    });\n\n    if (!cart || typeof cart.workflow !== \"object\") return false;\n    if (typeof cart.workflow.workflow !== \"object\") return false;\n\n    const { workflow } = cart.workflow;\n    // get index of `newWorkflowStatus`\n    const resetToIndex = workflow.indexOf(newWorkflowStatus);\n    // exit if no such step in workflow\n    if (resetToIndex < 0) return false;\n    // remove all steps that further `newWorkflowStatus` and itself\n    const resetedWorkflow = workflow.slice(0, resetToIndex);\n\n    return Cart.update(cart._id, {\n      $set: {\n        \"workflow.status\": newWorkflowStatus,\n        \"workflow.workflow\": resetedWorkflow\n      }\n    });\n  },\n\n  /**\n   * @name workflow/pushOrderWorkflow\n   * @summary Update the order workflow: Push the status as the current workflow step,\n   * move the current status to completed worflow steps\n   *\n   * @description Step 1 meteor call to push a new workflow\n   * Meteor.call(\"workflow/pushOrderWorkflow\", \"coreOrderWorkflow\", \"processing\", this);\n   * NOTE: \"coreOrderWorkflow\", \"processing\" will be combined into \"coreOrderWorkflow/processing\" and set as the status\n   * Step 2 (this method) of the \"workflow/pushOrderWorkflow\" flow; Try to update the current status\n   *\n   * @method\n   * @memberof Methods/Workflow\n   * @param  {String} workflow workflow to push to\n   * @param  {String} status - Workflow status\n   * @param  {Order} order - Schemas.Order, an order object\n   * @return {Boolean} true if update was successful\n   */\n  \"workflow/pushOrderWorkflow\"(workflow, status, order) {\n    check(workflow, String);\n    check(status, String);\n    check(order, Match.ObjectIncluding({\n      _id: String\n    }));\n    this.unblock();\n\n    const workflowStatus = `${workflow}/${status}`;\n\n    const result = updateOrderWorkflow(\n      this.userId,\n      {\n        _id: order._id\n      },\n      {\n        $set: {\n          // Combine (workflow) \"coreOrderWorkflow\", (status) \"processing\" into \"coreOrderWorkflow/processing\".\n          // This comoniation will be used to call the method \"workflow/coreOrderWorkflow/processing\", if it exists.\n          \"workflow.status\": `${workflow}/${status}`\n        },\n        $addToSet: {\n          \"workflow.workflow\": workflowStatus\n        }\n      }\n    );\n\n    return result;\n  },\n\n  /**\n   * @name workflow/pullOrderWorkflow\n   * @description Push the status as the current workflow step, move the current status to completed worflow steps\n   * @summary Pull a previous order status\n   * @method\n   * @memberof Methods/Workflow\n   * @param  {String} workflow workflow to push to\n   * @param  {String} status - Workflow status\n   * @param  {Order} order - Schemas.Order, an order object\n   * @return {Boolean} true if update was successful\n   */\n  \"workflow/pullOrderWorkflow\"(workflow, status, order) {\n    check(workflow, String);\n    check(status, String);\n    check(order, Match.ObjectIncluding({\n      _id: String,\n      workflow: Match.ObjectIncluding({\n        status: String\n      })\n    }));\n    this.unblock();\n\n    const result = Orders.update({\n      _id: order._id\n    }, {\n      $set: {\n        \"workflow.status\": status\n      },\n      $pull: {\n        \"workflow.workflow\": order.workflow.status\n      }\n    });\n\n    return result;\n  },\n\n  /**\n   * @name workflow/pushItemWorkflow\n   * @method\n   * @memberof Methods/Workflow\n   * @param  {String} status  Workflow status\n   * @param  {Object} order   Schemas.Order, an order object\n   * @param  {String[]} itemIds Array of item IDs\n   * @return {Boolean}         true if update was successful\n   */\n  \"workflow/pushItemWorkflow\"(status, order, itemIds) {\n    check(status, String);\n    check(order, Match.ObjectIncluding({\n      _id: String,\n      items: [Object]\n    }));\n    check(itemIds, Array);\n\n    // We can't trust the order from the client (for several reasons)\n    // Initially because in a multi-merchant scenario, the order from the client\n    // will contain only the items associated with their shop\n    // We'll get the order from the db that has all the items\n\n    // TODO: Resolve potential concurrency issue where any writes to the order items\n    // between this read and the Orders.update write below would be lost.\n    const dbOrder = Orders.findOne({ _id: order._id });\n    const items = dbOrder.items.map((item) => {\n      // Don't modify items unless they in our itemIds array\n      if (!itemIds.includes(item._id)) {\n        return item;\n      }\n\n      // Add the current status to completed workflows\n      if (item.workflow.status !== \"new\") {\n        const workflows = item.workflow.workflow || [];\n\n        workflows.push(status);\n        item.workflow.workflow = _.uniq(workflows);\n      }\n\n      // Set the new item status\n      item.workflow.status = status;\n      return item;\n    });\n\n    const result = Orders.update({\n      _id: dbOrder._id\n    }, {\n      $set: {\n        items\n      }\n    });\n\n    // Update search record\n    Hooks.Events.run(\"afterUpdateOrderUpdateSearchRecord\", order);\n\n    return result;\n  }\n});\n"]},"sourceType":"script","hash":"b79f0cf8769fc84e91ee709981500217421d6bad"}
