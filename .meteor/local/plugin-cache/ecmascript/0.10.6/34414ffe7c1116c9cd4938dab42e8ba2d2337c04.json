{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$1$2","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"ast":true,"babelrc":false,"sourceFileName":"packages/ongoworks:security/lib/server/Security.Check.js","filename":"packages/ongoworks:security/lib/server/Security.Check.js","sourceMaps":true,"envName":"development","cwd":"/Users/estebandev/test-knowledge","passPerPreset":false,"presets":[],"parserOpts":{"sourceType":"module","sourceFileName":"packages/ongoworks:security/lib/server/Security.Check.js","plugins":["jsx","jsx","flow","flow","objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties"]},"generatorOpts":{"filename":"packages/ongoworks:security/lib/server/Security.Check.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/ongoworks:security/lib/server/Security.Check.js"}},"code":"Security.Check = class {\n  constructor(userId) {\n    this.userId = userId || null;\n  }\n\n  for(collection) {\n    this.collection = collection;\n    this.collectionName = getCollectionName(collection);\n    return this;\n  }\n\n  insert(doc, ...args) {\n    if (this.type) throw new Error(Security.errorMessages.multipleCan);\n    this.type = 'insert';\n    this.doc = doc;\n    this.args = args;\n    return this;\n  }\n\n  update(doc, modifier, ...args) {\n    if (this.type) throw new Error(Security.errorMessages.multipleCan);\n    this.type = 'update';\n    this.doc = doc;\n    this.modifier = modifier;\n    this.args = args;\n    return this;\n  }\n\n  remove(doc, ...args) {\n    if (this.type) throw new Error(Security.errorMessages.multipleCan);\n    this.type = 'remove';\n    this.doc = doc;\n    this.args = args;\n    return this;\n  }\n\n  read(doc, ...args) {\n    if (this.type) throw new Error(Security.errorMessages.multipleCan);\n    this.type = 'read';\n    this.doc = doc;\n    this.args = args;\n    return this;\n  }\n\n  download(doc, ...args) {\n    if (this.type) throw new Error(Security.errorMessages.multipleCan);\n    this.type = 'download';\n    this.doc = doc;\n    this.args = args;\n    return this;\n  } // EXAMPLES:\n  // Security.can(userId).insert(doc).for(MyCollection).check()\n  // Security.can(userId).update(id, modifier).for(MyCollection).check()\n  // Security.can(userId).remove(id).for(MyCollection).check()\n\n\n  check() {\n    // Select only those rules that apply to this operation type\n    const rules = getRulesForCollectionAndType(this.collectionName, this.type); // If this.doc is an ID, we will look up the doc, fetching only the fields needed.\n    // To find out which fields are needed, we will combine all the `fetch` arrays from\n    // all the restrictions in all the rules.\n\n    if (typeof this.doc === 'string' || this.doc instanceof MongoID.ObjectID) {\n      let fields = {};\n\n      _.every(rules, rule => {\n        const fetch = rule.combinedFetch();\n\n        if (fetch === null) {\n          fields = null;\n          return false; // Exit loop\n        }\n\n        rule.combinedFetch().forEach(field => {\n          fields[field] = 1;\n        });\n        return true;\n      });\n\n      let options = {};\n\n      if (fields) {\n        if (_.isEmpty(fields)) {\n          options = {\n            _id: 1\n          };\n        } else {\n          options = {\n            fields\n          };\n        }\n      }\n\n      this.doc = this.collection.findOne(this.doc, options);\n    } // Loop through all defined rules for this collection. There is an OR relationship among\n    // all rules for the collection, so if any \"allow\" function DO return true, we allow.\n\n\n    return _.any(rules, rule => rule.allow(this.type, this.collection, this.userId, this.doc, this.modifier, ...this.args));\n  } // EXAMPLES:\n  // Security.can(userId).insert(doc).for(MyCollection).throw()\n  // Security.can(userId).update(id, modifier).for(MyCollection).throw()\n  // Security.can(userId).remove(id).for(MyCollection).throw()\n\n\n  throw() {\n    if (!this.check()) throw new Meteor.Error('access-denied', Security.errorMessages.notAllowed);\n  }\n\n};","map":{"version":3,"sources":["packages/ongoworks:security/lib/server/Security.Check.js"],"names":["Security","Check","constructor","userId","for","collection","collectionName","getCollectionName","insert","doc","args","type","Error","errorMessages","multipleCan","update","modifier","remove","read","download","check","rules","getRulesForCollectionAndType","MongoID","ObjectID","fields","_","every","rule","fetch","combinedFetch","forEach","field","options","isEmpty","_id","findOne","any","allow","throw","Meteor","notAllowed"],"mappings":"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","sourcesContent":["Security.Check = class {\n  constructor(userId) {\n    this.userId = userId || null;\n  }\n\n  for(collection) {\n    this.collection = collection;\n    this.collectionName = getCollectionName(collection);\n    return this;\n  }\n\n  insert(doc, ...args) {\n    if (this.type) throw new Error(Security.errorMessages.multipleCan);\n    this.type = 'insert';\n    this.doc = doc;\n    this.args = args;\n    return this;\n  }\n\n  update(doc, modifier, ...args) {\n    if (this.type) throw new Error(Security.errorMessages.multipleCan);\n    this.type = 'update';\n    this.doc = doc;\n    this.modifier = modifier;\n    this.args = args;\n    return this;\n  }\n\n  remove(doc, ...args) {\n    if (this.type) throw new Error(Security.errorMessages.multipleCan);\n    this.type = 'remove';\n    this.doc = doc;\n    this.args = args;\n    return this;\n  }\n\n  read(doc, ...args) {\n    if (this.type) throw new Error(Security.errorMessages.multipleCan);\n    this.type = 'read';\n    this.doc = doc;\n    this.args = args;\n    return this;\n  }\n\n  download(doc, ...args) {\n    if (this.type) throw new Error(Security.errorMessages.multipleCan);\n    this.type = 'download';\n    this.doc = doc;\n    this.args = args;\n    return this;\n  }\n\n  // EXAMPLES:\n  // Security.can(userId).insert(doc).for(MyCollection).check()\n  // Security.can(userId).update(id, modifier).for(MyCollection).check()\n  // Security.can(userId).remove(id).for(MyCollection).check()\n  check() {\n    // Select only those rules that apply to this operation type\n    const rules = getRulesForCollectionAndType(this.collectionName, this.type);\n\n    // If this.doc is an ID, we will look up the doc, fetching only the fields needed.\n    // To find out which fields are needed, we will combine all the `fetch` arrays from\n    // all the restrictions in all the rules.\n    if (typeof this.doc === 'string' || this.doc instanceof MongoID.ObjectID) {\n      let fields = {};\n      _.every(rules, rule => {\n        const fetch = rule.combinedFetch();\n        if (fetch === null) {\n          fields = null;\n          return false; // Exit loop\n        }\n        rule.combinedFetch().forEach(field => {\n          fields[field] = 1;\n        });\n        return true;\n      });\n\n      let options = {};\n      if (fields) {\n        if (_.isEmpty(fields)) {\n          options = {_id: 1};\n        } else {\n          options = {fields};\n        }\n      }\n      this.doc = this.collection.findOne(this.doc, options);\n    }\n\n    // Loop through all defined rules for this collection. There is an OR relationship among\n    // all rules for the collection, so if any \"allow\" function DO return true, we allow.\n    return _.any(rules, rule => rule.allow(this.type, this.collection, this.userId, this.doc, this.modifier, ...this.args));\n  }\n\n  // EXAMPLES:\n  // Security.can(userId).insert(doc).for(MyCollection).throw()\n  // Security.can(userId).update(id, modifier).for(MyCollection).throw()\n  // Security.can(userId).remove(id).for(MyCollection).throw()\n  throw() {\n    if (!this.check()) throw new Meteor.Error('access-denied', Security.errorMessages.notAllowed);\n  }\n}\n"]},"sourceType":"script","hash":"34414ffe7c1116c9cd4938dab42e8ba2d2337c04"}
