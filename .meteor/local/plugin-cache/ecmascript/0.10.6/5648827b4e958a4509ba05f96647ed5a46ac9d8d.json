{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$1$2","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"ast":true,"babelrc":false,"sourceFileName":"imports/plugins/core/revisions/server/hooks.js","filename":"imports/plugins/core/revisions/server/hooks.js","sourceMaps":true,"envName":"development","cwd":"/Users/estebandev/test-knowledge","passPerPreset":false,"presets":[],"parserOpts":{"sourceType":"module","sourceFileName":"imports/plugins/core/revisions/server/hooks.js","plugins":["jsx","jsx","flow","flow","objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties"]},"generatorOpts":{"filename":"imports/plugins/core/revisions/server/hooks.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"imports/plugins/core/revisions/server/hooks.js"}},"code":"module.export({\n  ProductRevision: () => ProductRevision\n});\n\nlet _max;\n\nmodule.watch(require(\"lodash/max\"), {\n  default(v) {\n    _max = v;\n  }\n\n}, 0);\n\nlet _min;\n\nmodule.watch(require(\"lodash/min\"), {\n  default(v) {\n    _min = v;\n  }\n\n}, 1);\nlet diff;\nmodule.watch(require(\"deep-diff\"), {\n  diff(v) {\n    diff = v;\n  }\n\n}, 2);\nlet RevisionApi;\nmodule.watch(require(\"../lib/api\"), {\n  RevisionApi(v) {\n    RevisionApi = v;\n  }\n\n}, 3);\nlet insertRevision, updateRevision, markRevisionAsDeleted;\nmodule.watch(require(\"./functions\"), {\n  insertRevision(v) {\n    insertRevision = v;\n  },\n\n  updateRevision(v) {\n    updateRevision = v;\n  },\n\n  markRevisionAsDeleted(v) {\n    markRevisionAsDeleted = v;\n  }\n\n}, 4);\nlet Products, Revisions;\nmodule.watch(require(\"../../../../../lib/collections\"), {\n  Products(v) {\n    Products = v;\n  },\n\n  Revisions(v) {\n    Revisions = v;\n  }\n\n}, 5);\nlet Hooks;\nmodule.watch(require(\"../../../../../server/api\"), {\n  Hooks(v) {\n    Hooks = v;\n  }\n\n}, 6);\nlet Media;\nmodule.watch(require(\"../../files/server\"), {\n  Media(v) {\n    Media = v;\n  }\n\n}, 7);\nconst ProductRevision = {\n  getProductPriceRange(productId) {\n    const product = Products.findOne(productId);\n\n    if (!product) {\n      return {\n        range: \"0\",\n        min: 0,\n        max: 0\n      };\n    }\n\n    const variants = this.getTopVariants(product._id);\n\n    if (variants.length > 0) {\n      const variantPrices = [];\n      variants.forEach(variant => {\n        if (variant.isVisible === true) {\n          const range = this.getVariantPriceRange(variant._id);\n\n          if (typeof range === \"string\") {\n            const firstPrice = parseFloat(range.substr(0, range.indexOf(\" \")));\n            const lastPrice = parseFloat(range.substr(range.lastIndexOf(\" \") + 1));\n            variantPrices.push(firstPrice, lastPrice);\n          } else {\n            variantPrices.push(range);\n          }\n        } else {\n          variantPrices.push(0, 0);\n        }\n      });\n\n      const priceMin = _min(variantPrices);\n\n      const priceMax = _max(variantPrices);\n\n      let priceRange = `${priceMin} - ${priceMax}`; // if we don't have a range\n\n      if (priceMin === priceMax) {\n        priceRange = priceMin.toString();\n      }\n\n      const priceObject = {\n        range: priceRange,\n        min: priceMin,\n        max: priceMax\n      };\n      return priceObject;\n    }\n\n    if (!product.price) {\n      return {\n        range: \"0\",\n        min: 0,\n        max: 0\n      };\n    } // if we have no variants subscribed to (client)\n    // we'll get the price object previously from the product\n\n\n    return product.price;\n  },\n\n  getVariantPriceRange(variantId) {\n    const children = this.getVariants(variantId);\n    const visibleChildren = children.filter(child => child.isVisible && !child.isDeleted);\n\n    switch (visibleChildren.length) {\n      case 0:\n        {\n          const topVariant = this.getProduct(variantId); // topVariant could be undefined when we removing last top variant\n\n          return topVariant && topVariant.price;\n        }\n\n      case 1:\n        {\n          return visibleChildren[0].price;\n        }\n\n      default:\n        {\n          let priceMin = Number.POSITIVE_INFINITY;\n          let priceMax = Number.NEGATIVE_INFINITY;\n          visibleChildren.forEach(child => {\n            if (child.price < priceMin) {\n              priceMin = child.price;\n            }\n\n            if (child.price > priceMax) {\n              priceMax = child.price;\n            }\n          });\n\n          if (priceMin === priceMax) {\n            // TODO check impact on i18n/formatPrice from moving return to string\n            return priceMin.toString();\n          }\n\n          return `${priceMin} - ${priceMax}`;\n        }\n    }\n  },\n\n  findRevision({\n    documentId\n  }) {\n    return Revisions.findOne({\n      documentId,\n      \"workflow.status\": {\n        $nin: [\"revision/published\"]\n      }\n    });\n  },\n\n  getProduct(variantId) {\n    const product = Products.findOne(variantId);\n    const revision = this.findRevision({\n      documentId: variantId\n    });\n    return revision && revision.documentData || product;\n  },\n\n  getTopVariants(id) {\n    const variants = [];\n    Products.find({\n      ancestors: [id],\n      type: \"variant\",\n      isDeleted: false\n    }).forEach(product => {\n      const revision = this.findRevision({\n        documentId: product._id\n      });\n\n      if (revision && revision.documentData.isVisible) {\n        variants.push(revision.documentData);\n      } else if (!revision && product.isVisible) {\n        variants.push(product);\n      }\n\n      return variants;\n    });\n    return variants;\n  },\n\n  getVariants(id, type) {\n    const variants = [];\n    Products.find({\n      ancestors: {\n        $in: [id]\n      },\n      type: type || \"variant\",\n      isDeleted: false\n    }).forEach(product => {\n      const revision = this.findRevision({\n        documentId: product._id\n      });\n\n      if (revision && revision.documentData.isVisible) {\n        variants.push(revision.documentData);\n      } else if (!revision && product.isVisible) {\n        variants.push(product);\n      }\n    });\n    return variants;\n  },\n\n  getVariantQuantity(variant) {\n    const options = this.getVariants(variant._id);\n\n    if (options && options.length) {\n      return options.reduce((sum, option) => sum + option.inventoryQuantity || 0, 0);\n    }\n\n    return variant.inventoryQuantity || 0;\n  }\n\n};\n\n/**\n * @function\n * @name beforeInsertCatalogProductInsertRevision\n *\n * @summary Executes the provided function when beforeInsertCatalogProductInsertRevision\n * hook is ran. The hook is ran before a product is inserted, and it will insert a\n * corresponding revision for the provided product.\n * @param {Function} Callback to execute\n * @return {Object} product - the product in which the callback was called on.\n */\nHooks.Events.add(\"beforeInsertCatalogProductInsertRevision\", product => {\n  insertRevision(product);\n  return product;\n});\n/**\n * @function\n * @name afterInsertCatalogProductInsertRevision\n *\n * @summary Executes the provided function when beforeInsertCatalogProductInsertRevision\n * hook is ran. The hook is ran after a product is inserted, and it will insert a\n * corresponding revision for the provided product.\n * @param {Function} Callback to execute\n * @return {Object} product - the product in which the callback was called on.\n */\n\nHooks.Events.add(\"afterInsertCatalogProductInsertRevision\", product => {\n  insertRevision(product);\n  return product;\n});\n/**\n * @function\n * @name beforeUpdateCatalogProduct\n *\n * @summary Executes the provided function when beforeUpdateCatalogProduct\n * hook is ran. The hook is ran before a product is updated, and it will updated the\n * corresponding revisions for the provided product.\n * @param {Function} Callback to execute\n * @return {Boolean} true|false - Used to determine whether the underlying product should be updated.\n */\n\nHooks.Events.add(\"beforeUpdateCatalogProduct\", (product, options) => updateRevision(product, options));\n/**\n * @function\n * @name beforeRemoveCatalogProduct\n *\n * @summary Executes the provided function when beforeRemoveCatalogProduct\n * hook is ran. The hook is ran before a product or variant is archived, and it will updated the\n * corresponding revisions for the provided product or variant.\n * @param {Function} Callback to execute\n * @return {Boolean} true|false - Used to determine whether the underlying product should be updated.\n */\n\nHooks.Events.add(\"beforeRemoveCatalogProduct\", (product, options) => markRevisionAsDeleted(product, options));\nHooks.Events.add(\"afterRevisionsUpdate\", (userId, revision) => {\n  if (RevisionApi.isRevisionControlEnabled() === false) {\n    return true;\n  }\n\n  let differences;\n\n  if (!revision.documentType || revision.documentType === \"product\") {\n    // Make diff\n    const product = Products.findOne({\n      _id: revision.documentId\n    });\n    differences = diff(product, revision.documentData);\n  }\n\n  if (revision.documentType && revision.documentType === \"image\") {\n    const image = Promise.await(Media.findOne(revision.documentId, {\n      raw: true\n    }));\n    differences = image && diff(image.metadata, revision.documentData);\n  }\n\n  Revisions.update({\n    _id: revision._id\n  }, {\n    $set: {\n      diff: differences && differences.map(d => Object.assign({}, d))\n    }\n  });\n}, {\n  fetchPrevious: false\n});","map":{"version":3,"sources":["imports/plugins/core/revisions/server/hooks.js"],"names":["module","export","ProductRevision","_max","watch","require","default","v","_min","diff","RevisionApi","insertRevision","updateRevision","markRevisionAsDeleted","Products","Revisions","Hooks","Media","getProductPriceRange","productId","product","findOne","range","min","max","variants","getTopVariants","_id","length","variantPrices","forEach","variant","isVisible","getVariantPriceRange","firstPrice","parseFloat","substr","indexOf","lastPrice","lastIndexOf","push","priceMin","priceMax","priceRange","toString","priceObject","price","variantId","children","getVariants","visibleChildren","filter","child","isDeleted","topVariant","getProduct","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","findRevision","documentId","$nin","revision","documentData","id","find","ancestors","type","$in","getVariantQuantity","options","reduce","sum","option","inventoryQuantity","Events","add","userId","isRevisionControlEnabled","differences","documentType","image","Promise","await","raw","metadata","update","$set","map","d","Object","assign","fetchPrevious"],"mappings":"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","sourcesContent":["import _ from \"lodash\";\nimport { diff } from \"deep-diff\";\nimport { RevisionApi } from \"../lib/api\";\nimport { insertRevision, updateRevision, markRevisionAsDeleted } from \"./functions\";\nimport { Products, Revisions } from \"/lib/collections\";\nimport { Hooks } from \"/server/api\";\nimport { Media } from \"/imports/plugins/core/files/server\";\n\nexport const ProductRevision = {\n  getProductPriceRange(productId) {\n    const product = Products.findOne(productId);\n    if (!product) {\n      return {\n        range: \"0\",\n        min: 0,\n        max: 0\n      };\n    }\n\n    const variants = this.getTopVariants(product._id);\n    if (variants.length > 0) {\n      const variantPrices = [];\n      variants.forEach((variant) => {\n        if (variant.isVisible === true) {\n          const range = this.getVariantPriceRange(variant._id);\n          if (typeof range === \"string\") {\n            const firstPrice = parseFloat(range.substr(0, range.indexOf(\" \")));\n            const lastPrice = parseFloat(range.substr(range.lastIndexOf(\" \") + 1));\n            variantPrices.push(firstPrice, lastPrice);\n          } else {\n            variantPrices.push(range);\n          }\n        } else {\n          variantPrices.push(0, 0);\n        }\n      });\n      const priceMin = _.min(variantPrices);\n      const priceMax = _.max(variantPrices);\n      let priceRange = `${priceMin} - ${priceMax}`;\n      // if we don't have a range\n      if (priceMin === priceMax) {\n        priceRange = priceMin.toString();\n      }\n      const priceObject = {\n        range: priceRange,\n        min: priceMin,\n        max: priceMax\n      };\n      return priceObject;\n    }\n\n    if (!product.price) {\n      return {\n        range: \"0\",\n        min: 0,\n        max: 0\n      };\n    }\n\n    // if we have no variants subscribed to (client)\n    // we'll get the price object previously from the product\n    return product.price;\n  },\n\n  getVariantPriceRange(variantId) {\n    const children = this.getVariants(variantId);\n    const visibleChildren = children.filter((child) => child.isVisible && !child.isDeleted);\n\n    switch (visibleChildren.length) {\n      case 0: {\n        const topVariant = this.getProduct(variantId);\n        // topVariant could be undefined when we removing last top variant\n        return topVariant && topVariant.price;\n      }\n      case 1: {\n        return visibleChildren[0].price;\n      }\n      default: {\n        let priceMin = Number.POSITIVE_INFINITY;\n        let priceMax = Number.NEGATIVE_INFINITY;\n\n        visibleChildren.forEach((child) => {\n          if (child.price < priceMin) {\n            priceMin = child.price;\n          }\n          if (child.price > priceMax) {\n            priceMax = child.price;\n          }\n        });\n\n        if (priceMin === priceMax) {\n          // TODO check impact on i18n/formatPrice from moving return to string\n          return priceMin.toString();\n        }\n        return `${priceMin} - ${priceMax}`;\n      }\n    }\n  },\n\n  findRevision({ documentId }) {\n    return Revisions.findOne({\n      documentId,\n      \"workflow.status\": {\n        $nin: [\n          \"revision/published\"\n        ]\n      }\n    });\n  },\n\n  getProduct(variantId) {\n    const product = Products.findOne(variantId);\n    const revision = this.findRevision({\n      documentId: variantId\n    });\n\n    return (revision && revision.documentData) || product;\n  },\n\n  getTopVariants(id) {\n    const variants = [];\n\n    Products.find({\n      ancestors: [id],\n      type: \"variant\",\n      isDeleted: false\n    }).forEach((product) => {\n      const revision = this.findRevision({\n        documentId: product._id\n      });\n\n      if (revision && revision.documentData.isVisible) {\n        variants.push(revision.documentData);\n      } else if (!revision && product.isVisible) {\n        variants.push(product);\n      }\n\n      return variants;\n    });\n\n    return variants;\n  },\n\n  getVariants(id, type) {\n    const variants = [];\n\n    Products.find({\n      ancestors: { $in: [id] },\n      type: type || \"variant\",\n      isDeleted: false\n    }).forEach((product) => {\n      const revision = this.findRevision({\n        documentId: product._id\n      });\n\n      if (revision && revision.documentData.isVisible) {\n        variants.push(revision.documentData);\n      } else if (!revision && product.isVisible) {\n        variants.push(product);\n      }\n    });\n\n    return variants;\n  },\n\n  getVariantQuantity(variant) {\n    const options = this.getVariants(variant._id);\n    if (options && options.length) {\n      return options.reduce((sum, option) =>\n        sum + option.inventoryQuantity || 0, 0);\n    }\n    return variant.inventoryQuantity || 0;\n  }\n};\n\n/**\n * @function\n * @name beforeInsertCatalogProductInsertRevision\n *\n * @summary Executes the provided function when beforeInsertCatalogProductInsertRevision\n * hook is ran. The hook is ran before a product is inserted, and it will insert a\n * corresponding revision for the provided product.\n * @param {Function} Callback to execute\n * @return {Object} product - the product in which the callback was called on.\n */\nHooks.Events.add(\"beforeInsertCatalogProductInsertRevision\", (product) => {\n  insertRevision(product);\n\n  return product;\n});\n\n/**\n * @function\n * @name afterInsertCatalogProductInsertRevision\n *\n * @summary Executes the provided function when beforeInsertCatalogProductInsertRevision\n * hook is ran. The hook is ran after a product is inserted, and it will insert a\n * corresponding revision for the provided product.\n * @param {Function} Callback to execute\n * @return {Object} product - the product in which the callback was called on.\n */\nHooks.Events.add(\"afterInsertCatalogProductInsertRevision\", (product) => {\n  insertRevision(product);\n\n  return product;\n});\n\n/**\n * @function\n * @name beforeUpdateCatalogProduct\n *\n * @summary Executes the provided function when beforeUpdateCatalogProduct\n * hook is ran. The hook is ran before a product is updated, and it will updated the\n * corresponding revisions for the provided product.\n * @param {Function} Callback to execute\n * @return {Boolean} true|false - Used to determine whether the underlying product should be updated.\n */\nHooks.Events.add(\"beforeUpdateCatalogProduct\", (product, options) => updateRevision(product, options));\n\n/**\n * @function\n * @name beforeRemoveCatalogProduct\n *\n * @summary Executes the provided function when beforeRemoveCatalogProduct\n * hook is ran. The hook is ran before a product or variant is archived, and it will updated the\n * corresponding revisions for the provided product or variant.\n * @param {Function} Callback to execute\n * @return {Boolean} true|false - Used to determine whether the underlying product should be updated.\n */\nHooks.Events.add(\"beforeRemoveCatalogProduct\", (product, options) => markRevisionAsDeleted(product, options));\n\nHooks.Events.add(\"afterRevisionsUpdate\", (userId, revision) => {\n  if (RevisionApi.isRevisionControlEnabled() === false) {\n    return true;\n  }\n  let differences;\n\n\n  if (!revision.documentType || revision.documentType === \"product\") {\n    // Make diff\n    const product = Products.findOne({\n      _id: revision.documentId\n    });\n    differences = diff(product, revision.documentData);\n  }\n\n  if (revision.documentType && revision.documentType === \"image\") {\n    const image = Promise.await(Media.findOne(revision.documentId, { raw: true }));\n    differences = image && diff(image.metadata, revision.documentData);\n  }\n\n  Revisions.update({\n    _id: revision._id\n  }, {\n    $set: {\n      diff: differences && differences.map((d) => Object.assign({}, d))\n    }\n  });\n}, {\n  fetchPrevious: false\n});\n"]},"sourceType":"script","hash":"5648827b4e958a4509ba05f96647ed5a46ac9d8d"}
