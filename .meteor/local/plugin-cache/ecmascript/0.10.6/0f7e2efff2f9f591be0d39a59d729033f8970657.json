{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$1$2","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"ast":true,"babelrc":false,"sourceFileName":"server/publications/collections/products.js","filename":"server/publications/collections/products.js","sourceMaps":true,"envName":"development","cwd":"/Users/estebandev/test-knowledge","passPerPreset":false,"presets":[],"parserOpts":{"sourceType":"module","sourceFileName":"server/publications/collections/products.js","plugins":["jsx","jsx","flow","flow","objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties"]},"generatorOpts":{"filename":"server/publications/collections/products.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"server/publications/collections/products.js"}},"code":"var _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/builtin/objectSpread\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nlet _extend;\n\nmodule.watch(require(\"lodash/extend\"), {\n  default(v) {\n    _extend = v;\n  }\n\n}, 0);\n\nlet _omit;\n\nmodule.watch(require(\"lodash/omit\"), {\n  default(v) {\n    _omit = v;\n  }\n\n}, 1);\nlet SimpleSchema;\nmodule.watch(require(\"simpl-schema\"), {\n  default(v) {\n    SimpleSchema = v;\n  }\n\n}, 2);\nlet Meteor;\nmodule.watch(require(\"meteor/meteor\"), {\n  Meteor(v) {\n    Meteor = v;\n  }\n\n}, 3);\nlet Tracker;\nmodule.watch(require(\"meteor/tracker\"), {\n  Tracker(v) {\n    Tracker = v;\n  }\n\n}, 4);\nlet check, Match;\nmodule.watch(require(\"meteor/check\"), {\n  check(v) {\n    check = v;\n  },\n\n  Match(v) {\n    Match = v;\n  }\n\n}, 5);\nlet registerSchema;\nmodule.watch(require(\"@reactioncommerce/schemas\"), {\n  registerSchema(v) {\n    registerSchema = v;\n  }\n\n}, 6);\nlet Products, Shops, Revisions, Catalog;\nmodule.watch(require(\"../../../lib/collections\"), {\n  Products(v) {\n    Products = v;\n  },\n\n  Shops(v) {\n    Shops = v;\n  },\n\n  Revisions(v) {\n    Revisions = v;\n  },\n\n  Catalog(v) {\n    Catalog = v;\n  }\n\n}, 7);\nlet Reaction, Logger;\nmodule.watch(require(\"../../api\"), {\n  Reaction(v) {\n    Reaction = v;\n  },\n\n  Logger(v) {\n    Logger = v;\n  }\n\n}, 8);\nlet RevisionApi;\nmodule.watch(require(\"../../../imports/plugins/core/revisions/lib/api/revisions\"), {\n  RevisionApi(v) {\n    RevisionApi = v;\n  }\n\n}, 9);\n//\n// define search filters as a schema so we can validate\n// params supplied to the products publication\n//\nconst filters = new SimpleSchema({\n  \"shops\": {\n    type: Array,\n    optional: true\n  },\n  \"shops.$\": String,\n  \"tags\": {\n    type: Array,\n    optional: true\n  },\n  \"tags.$\": String,\n  \"query\": {\n    type: String,\n    optional: true\n  },\n  \"visibility\": {\n    type: Boolean,\n    optional: true\n  },\n  \"details\": {\n    type: Object,\n    optional: true\n  },\n  \"details.key\": {\n    type: String,\n    optional: true\n  },\n  \"details.value\": {\n    type: String,\n    optional: true\n  },\n  \"price\": {\n    type: Object,\n    optional: true\n  },\n  \"price.min\": {\n    type: String,\n    optional: true\n  },\n  \"price.max\": {\n    type: String,\n    optional: true\n  },\n  \"weight\": {\n    type: Object,\n    optional: true\n  },\n  \"weight.min\": {\n    type: String,\n    optional: true\n  },\n  \"weight.max\": {\n    type: String,\n    optional: true\n  }\n}, {\n  check,\n  tracker: Tracker\n});\nregisterSchema(\"filters\", filters);\n/**\n * Broadens an existing selector to include all variants of the given top-level productIds\n * Additionally considers the tags product filter, if given\n * Can operate on the \"Revisions\" and the \"Products\" collection\n * @param collectionName {String} - \"Revisions\" or \"Products\"\n * @param selector {object} - the selector that should be extended\n * @param productFilters { object } - the product filter (e.g. orginating from query parameters)\n * @param productIds {String[]} - the top-level productIds we want to get the variants of.\n */\n\nfunction extendSelectorWithVariants(collectionName, selector, productFilters, productIds) {\n  let prefix = \"\";\n\n  if (collectionName.toLowerCase() === \"revisions\") {\n    prefix = \"documentData.\";\n  } else if (collectionName.toLowerCase() !== \"products\") {\n    throw new Error(`Can't extend selector for collection ${collectionName}.`);\n  } // Remove hashtag filter from selector (hashtags are not applied to variants, we need to get variants)\n\n\n  const newSelector = _omit(selector, [\"hashtags\", \"ancestors\"]);\n\n  if (productFilters && productFilters.tags) {\n    // Re-configure selector to pick either Variants of one of the top-level products, or the top-level products in the filter\n    _extend(newSelector, {\n      $or: [{\n        [`${prefix}ancestors`]: {\n          $in: productIds\n        }\n      }, {\n        $and: [{\n          [`${prefix}hashtags`]: {\n            $in: productFilters.tags\n          }\n        }, {\n          [`${prefix}_id`]: {\n            $in: productIds\n          }\n        }]\n      }]\n    });\n  } else {\n    _extend(newSelector, {\n      $or: [{\n        [`${prefix}ancestors`]: {\n          $in: productIds\n        }\n      }, {\n        [`${prefix}_id`]: {\n          $in: productIds\n        }\n      }]\n    });\n  }\n\n  return newSelector;\n}\n\nfunction filterProducts(productFilters) {\n  // if there are filter/params that don't match the schema\n  // validate, catch except but return no results\n  try {\n    if (productFilters) filters.validate(productFilters);\n  } catch (e) {\n    Logger.debug(e, \"Invalid Product Filters\");\n    return false;\n  }\n\n  const shopIdsOrSlugs = productFilters && productFilters.shops;\n\n  if (shopIdsOrSlugs) {\n    // Get all shopIds associated with the slug or Id\n    const shopIds = Shops.find({\n      \"workflow.status\": \"active\",\n      \"$or\": [{\n        _id: {\n          $in: shopIdsOrSlugs\n        }\n      }, {\n        slug: {\n          $in: shopIdsOrSlugs\n        }\n      }]\n    }).map(shop => shop._id); // If we found shops, update the productFilters\n\n    if (shopIds) {\n      productFilters.shops = shopIds;\n    } else {\n      return false;\n    }\n  } // Init default selector - Everyone can see products that fit this selector\n\n\n  const selector = {\n    ancestors: [],\n    // Lookup top-level products\n    isDeleted: {\n      $in: [null, false]\n    },\n    // by default, we don't publish deleted products\n    isVisible: true // by default, only lookup visible products\n\n  };\n\n  if (productFilters) {\n    // handle multiple shops\n    if (productFilters.shops) {\n      _extend(selector, {\n        shopId: {\n          $in: productFilters.shops\n        }\n      });\n    } // filter by tags\n\n\n    if (productFilters.tags) {\n      _extend(selector, {\n        hashtags: {\n          $in: productFilters.tags\n        }\n      });\n    } // filter by query\n\n\n    if (productFilters.query) {\n      const cond = {\n        $regex: productFilters.query,\n        $options: \"i\"\n      };\n\n      _extend(selector, {\n        $or: [{\n          title: cond\n        }, {\n          pageTitle: cond\n        }, {\n          description: cond\n        }]\n      });\n    } // filter by details\n\n\n    if (productFilters.details) {\n      _extend(selector, {\n        metafields: {\n          $elemMatch: {\n            key: {\n              $regex: productFilters.details.key,\n              $options: \"i\"\n            },\n            value: {\n              $regex: productFilters.details.value,\n              $options: \"i\"\n            }\n          }\n        }\n      });\n    } // filter by visibility\n\n\n    if (productFilters.visibility !== undefined) {\n      _extend(selector, {\n        isVisible: productFilters.visibility\n      });\n    } // filter by gte minimum price\n\n\n    if (productFilters[\"price.min\"] && !productFilters[\"price.max\"]) {\n      _extend(selector, {\n        \"price.min\": {\n          $gte: parseFloat(productFilters[\"price.min\"])\n        }\n      });\n    } // filter by lte maximum price\n\n\n    if (productFilters[\"price.max\"] && !productFilters[\"price.min\"]) {\n      _extend(selector, {\n        \"price.max\": {\n          $lte: parseFloat(productFilters[\"price.max\"])\n        }\n      });\n    } // filter with a price range\n\n\n    if (productFilters[\"price.min\"] && productFilters[\"price.max\"]) {\n      const pmin = parseFloat(productFilters[\"price.min\"]);\n      const pmax = parseFloat(productFilters[\"price.max\"]); // where product A has min 12.99 variant and a 19.99 variant\n      // price.min=12.99&price.max=19.98\n      // should return product A\n\n      _extend(selector, {\n        \"price.min\": {\n          $lt: pmax\n        },\n        \"price.max\": {\n          $gt: pmin\n        }\n      });\n    } // filter by gte minimum weight\n\n\n    if (productFilters[\"weight.min\"] && !productFilters[\"weight.max\"]) {\n      _extend(selector, {\n        weight: {\n          $gte: parseFloat(productFilters[\"weight.min\"])\n        }\n      });\n    } // filter by lte maximum weight\n\n\n    if (productFilters[\"weight.max\"] && !productFilters[\"weight.min\"]) {\n      _extend(selector, {\n        weight: {\n          $lte: parseFloat(productFilters[\"weight.max\"])\n        }\n      });\n    } // filter with a weight range\n\n\n    if (productFilters[\"weight.min\"] && productFilters[\"weight.max\"]) {\n      const wmin = parseFloat(productFilters[\"weight.min\"]);\n      const wmax = parseFloat(productFilters[\"weight.max\"]);\n\n      _extend(selector, {\n        weight: {\n          $lt: wmax,\n          $gt: wmin\n        }\n      });\n    }\n  } // end if productFilters\n\n\n  return selector;\n}\n/**\n * products publication\n * @param {Number} [productScrollLimit] - optional, defaults to 24\n * @param {Array} shops - array of shopId to retrieve product from.\n * @return {Object} return product cursor\n */\n\n\nMeteor.publish(\"Products\", function (productScrollLimit = 24, productFilters, sort = {}, editMode = true) {\n  check(productScrollLimit, Number);\n  check(productFilters, Match.OneOf(undefined, Object));\n  check(sort, Match.OneOf(undefined, Object));\n  check(editMode, Match.Maybe(Boolean)); // TODO: Consider publishing the non-admin publication if a user is not in \"edit mode\" to see what is published\n  // Active shop\n\n  const shopId = Reaction.getShopId();\n  const primaryShopId = Reaction.getPrimaryShopId(); // Get a list of shopIds that this user has \"createProduct\" permissions for (owner permission is checked by default)\n\n  const userAdminShopIds = Reaction.getShopsWithRoles([\"createProduct\"], this.userId); // Don't publish if we're missing an active or primary shopId\n\n  if (!shopId || !primaryShopId) {\n    return this.ready();\n  } // Get active shop id's to use for filtering\n\n\n  const activeShopsIds = Shops.find({\n    $or: [{\n      \"workflow.status\": \"active\"\n    }, {\n      _id: Reaction.getPrimaryShopId()\n    }]\n  }).fetch().map(activeShop => activeShop._id);\n  const selector = filterProducts(productFilters);\n\n  if (selector === false) {\n    return this.ready();\n  } // We publish an admin version of this publication to admins of products who are in \"Edit Mode\"\n  // Authorized content curators for shops get special publication of the product\n  // with all relevant revisions all is one package\n  // userAdminShopIds is a list of shopIds that the user has createProduct or owner access for\n\n\n  if (editMode && userAdminShopIds && Array.isArray(userAdminShopIds) && userAdminShopIds.length > 0) {\n    selector.isVisible = {\n      $in: [true, false, null, undefined]\n    };\n    selector.shopId = {\n      $in: activeShopsIds\n    }; // Get _ids of top-level products\n\n    const productIds = Products.find(selector, {\n      sort,\n      limit: productScrollLimit\n    }).map(product => product._id);\n    const productSelectorWithVariants = extendSelectorWithVariants(\"Products\", selector, productFilters, productIds);\n\n    if (RevisionApi.isRevisionControlEnabled()) {\n      const revisionSelector = {\n        \"workflow.status\": {\n          $nin: [\"revision/published\"]\n        }\n      };\n      const revisionSelectorWithVariants = extendSelectorWithVariants(\"Revisions\", revisionSelector, productFilters, productIds);\n      const handle = Revisions.find(revisionSelectorWithVariants).observe({\n        added: revision => {\n          this.added(\"Revisions\", revision._id, revision);\n\n          if (revision.documentType === \"product\") {\n            // Check merge box (session collection view), if product is already in cache.\n            // If yes, we send a `changed`, otherwise `added`. I'm assuming\n            // that this._documents.Products is somewhat equivalent to\n            // the merge box Meteor.server.sessions[sessionId].getCollectionView(\"Products\").documents\n            if (this._documents.Products && this._documents.Products[revision.documentId]) {\n              this.changed(\"Products\", revision.documentId, {\n                __revisions: [revision]\n              });\n            } else {\n              this.added(\"Products\", revision.documentId, {\n                __revisions: [revision]\n              });\n            }\n          }\n        },\n        changed: revision => {\n          this.changed(\"Revisions\", revision._id, revision);\n\n          if (revision.documentType === \"product\") {\n            if (this._documents.Products && this._documents.Products[revision.documentId]) {\n              this.changed(\"Products\", revision.documentId, {\n                __revisions: [revision]\n              });\n            }\n          }\n        },\n        removed: revision => {\n          this.removed(\"Revisions\", revision._id);\n\n          if (revision.documentType === \"product\") {\n            if (this._documents.Products && this._documents.Products[revision.documentId]) {\n              this.changed(\"Products\", revision.documentId, {\n                __revisions: []\n              });\n            }\n          }\n        }\n      });\n      this.onStop(() => {\n        handle.stop();\n      });\n      return Products.find(productSelectorWithVariants);\n    } // Revision control is disabled, but is admin\n\n\n    return Products.find(productSelectorWithVariants, {\n      sort,\n      limit: productScrollLimit\n    });\n  } // This is where the publication begins for non-admin users\n  // Get _ids of top-level products\n\n\n  const productIds = Products.find(selector, {\n    sort,\n    limit: productScrollLimit\n  }).map(product => product._id);\n  let newSelector = (0, _objectSpread2.default)({}, selector); // Remove hashtag filter from selector (hashtags are not applied to variants, we need to get variants)\n\n  if (productFilters && Object.keys(productFilters).length === 0 && productFilters.constructor === Object) {\n    newSelector = _omit(selector, [\"hashtags\", \"ancestors\"]);\n\n    if (productFilters.tags) {\n      // Re-configure selector to pick either Variants of one of the top-level products,\n      // or the top-level products in the filter\n      _extend(newSelector, {\n        $or: [{\n          ancestors: {\n            $in: productIds\n          }\n        }, {\n          $and: [{\n            hashtags: {\n              $in: productFilters.tags\n            }\n          }, {\n            _id: {\n              $in: productIds\n            }\n          }]\n        }]\n      });\n    } // filter by query\n\n\n    if (productFilters.query) {\n      const cond = {\n        $regex: productFilters.query,\n        $options: \"i\"\n      };\n\n      _extend(newSelector, {\n        $or: [{\n          title: cond\n        }, {\n          pageTitle: cond\n        }, {\n          description: cond\n        }, {\n          ancestors: {\n            $in: productIds\n          }\n        }, {\n          _id: {\n            $in: productIds\n          }\n        }]\n      });\n    }\n  } else {\n    newSelector = _omit(selector, [\"hashtags\", \"ancestors\"]);\n\n    _extend(newSelector, {\n      $or: [{\n        ancestors: {\n          $in: productIds\n        }\n      }, {\n        _id: {\n          $in: productIds\n        }\n      }]\n    });\n  } // Adjust the selector to include only active shops\n\n\n  newSelector = (0, _objectSpread2.default)({}, newSelector, {\n    shopId: {\n      $in: activeShopsIds\n    }\n  }); // Returning Complete product tree for top level products to avoid sold out warning.\n\n  return Products.find(newSelector, {\n    sort // TODO: REVIEW Limiting final products publication for non-admins\n    // I think we shouldn't limit here, otherwise we are limited to 24 total products which\n    // could be far less than 24 top-level products\n    // limit: productScrollLimit\n\n  });\n});\n/**\n * @name Products/grid\n * @method\n * @memberof Core\n * @summary Publication method for a customer facing product grid\n * @param {number} productScrollLimit - product find limit\n * @param {object} productFilters - filters to be applied to the product find\n * @param {object} sort - sorting to be applied to the product find\n * @return {MongoCursor} Mongo cursor object of found products\n */\n\nMeteor.publish(\"Products/grid\", function (productScrollLimit = 24, productFilters, sort = {}) {\n  check(productScrollLimit, Number);\n  check(productFilters, Match.OneOf(undefined, Object));\n  check(sort, Match.OneOf(undefined, Object));\n  const newSelector = filterProducts(productFilters);\n\n  if (newSelector === false) {\n    return this.ready();\n  }\n\n  const productCursor = Catalog.find(newSelector, {\n    sort,\n    limit: productScrollLimit,\n    fields: {\n      variants: 0\n    }\n  });\n  return productCursor;\n});","map":{"version":3,"sources":["server/publications/collections/products.js"],"names":["_extend","module","watch","require","default","v","_omit","SimpleSchema","Meteor","Tracker","check","Match","registerSchema","Products","Shops","Revisions","Catalog","Reaction","Logger","RevisionApi","filters","type","Array","optional","String","Boolean","Object","tracker","extendSelectorWithVariants","collectionName","selector","productFilters","productIds","prefix","toLowerCase","Error","newSelector","tags","$or","$in","$and","filterProducts","validate","e","debug","shopIdsOrSlugs","shops","shopIds","find","_id","slug","map","shop","ancestors","isDeleted","isVisible","shopId","hashtags","query","cond","$regex","$options","title","pageTitle","description","details","metafields","$elemMatch","key","value","visibility","undefined","$gte","parseFloat","$lte","pmin","pmax","$lt","$gt","weight","wmin","wmax","publish","productScrollLimit","sort","editMode","Number","OneOf","Maybe","getShopId","primaryShopId","getPrimaryShopId","userAdminShopIds","getShopsWithRoles","userId","ready","activeShopsIds","fetch","activeShop","isArray","length","limit","product","productSelectorWithVariants","isRevisionControlEnabled","revisionSelector","$nin","revisionSelectorWithVariants","handle","observe","added","revision","documentType","_documents","documentId","changed","__revisions","removed","onStop","stop","keys","constructor","productCursor","fields","variants"],"mappings":"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","sourcesContent":["import _ from \"lodash\";\nimport SimpleSchema from \"simpl-schema\";\nimport { Meteor } from \"meteor/meteor\";\nimport { Tracker } from \"meteor/tracker\";\nimport { check, Match } from \"meteor/check\";\nimport { registerSchema } from \"@reactioncommerce/schemas\";\nimport { Products, Shops, Revisions, Catalog } from \"/lib/collections\";\nimport { Reaction, Logger } from \"/server/api\";\nimport { RevisionApi } from \"/imports/plugins/core/revisions/lib/api/revisions\";\n\n//\n// define search filters as a schema so we can validate\n// params supplied to the products publication\n//\nconst filters = new SimpleSchema({\n  \"shops\": {\n    type: Array,\n    optional: true\n  },\n  \"shops.$\": String,\n  \"tags\": {\n    type: Array,\n    optional: true\n  },\n  \"tags.$\": String,\n  \"query\": {\n    type: String,\n    optional: true\n  },\n  \"visibility\": {\n    type: Boolean,\n    optional: true\n  },\n  \"details\": {\n    type: Object,\n    optional: true\n  },\n  \"details.key\": {\n    type: String,\n    optional: true\n  },\n  \"details.value\": {\n    type: String,\n    optional: true\n  },\n  \"price\": {\n    type: Object,\n    optional: true\n  },\n  \"price.min\": {\n    type: String,\n    optional: true\n  },\n  \"price.max\": {\n    type: String,\n    optional: true\n  },\n  \"weight\": {\n    type: Object,\n    optional: true\n  },\n  \"weight.min\": {\n    type: String,\n    optional: true\n  },\n  \"weight.max\": {\n    type: String,\n    optional: true\n  }\n}, { check, tracker: Tracker });\n\nregisterSchema(\"filters\", filters);\n\n/**\n * Broadens an existing selector to include all variants of the given top-level productIds\n * Additionally considers the tags product filter, if given\n * Can operate on the \"Revisions\" and the \"Products\" collection\n * @param collectionName {String} - \"Revisions\" or \"Products\"\n * @param selector {object} - the selector that should be extended\n * @param productFilters { object } - the product filter (e.g. orginating from query parameters)\n * @param productIds {String[]} - the top-level productIds we want to get the variants of.\n */\nfunction extendSelectorWithVariants(collectionName, selector, productFilters, productIds) {\n  let prefix = \"\";\n\n  if (collectionName.toLowerCase() === \"revisions\") {\n    prefix = \"documentData.\";\n  } else if (collectionName.toLowerCase() !== \"products\") {\n    throw new Error(`Can't extend selector for collection ${collectionName}.`);\n  }\n\n  // Remove hashtag filter from selector (hashtags are not applied to variants, we need to get variants)\n  const newSelector = _.omit(selector, [\"hashtags\", \"ancestors\"]);\n  if (productFilters && productFilters.tags) {\n    // Re-configure selector to pick either Variants of one of the top-level products, or the top-level products in the filter\n    _.extend(newSelector, {\n      $or: [{\n        [`${prefix}ancestors`]: {\n          $in: productIds\n        }\n      }, {\n        $and: [{\n          [`${prefix}hashtags`]: {\n            $in: productFilters.tags\n          }\n        }, {\n          [`${prefix}_id`]: {\n            $in: productIds\n          }\n        }]\n      }]\n    });\n  } else {\n    _.extend(newSelector, {\n      $or: [{\n        [`${prefix}ancestors`]: {\n          $in: productIds\n        }\n      }, {\n        [`${prefix}_id`]: {\n          $in: productIds\n        }\n      }]\n    });\n  }\n  return newSelector;\n}\n\nfunction filterProducts(productFilters) {\n  // if there are filter/params that don't match the schema\n  // validate, catch except but return no results\n  try {\n    if (productFilters) filters.validate(productFilters);\n  } catch (e) {\n    Logger.debug(e, \"Invalid Product Filters\");\n    return false;\n  }\n\n  const shopIdsOrSlugs = productFilters && productFilters.shops;\n\n  if (shopIdsOrSlugs) {\n    // Get all shopIds associated with the slug or Id\n    const shopIds = Shops.find({\n      \"workflow.status\": \"active\",\n      \"$or\": [{\n        _id: { $in: shopIdsOrSlugs }\n      }, {\n        slug: { $in: shopIdsOrSlugs }\n      }]\n    }).map((shop) => shop._id);\n\n    // If we found shops, update the productFilters\n    if (shopIds) {\n      productFilters.shops = shopIds;\n    } else {\n      return false;\n    }\n  }\n\n  // Init default selector - Everyone can see products that fit this selector\n  const selector = {\n    ancestors: [], // Lookup top-level products\n    isDeleted: { $in: [null, false] }, // by default, we don't publish deleted products\n    isVisible: true // by default, only lookup visible products\n  };\n\n  if (productFilters) {\n    // handle multiple shops\n    if (productFilters.shops) {\n      _.extend(selector, {\n        shopId: {\n          $in: productFilters.shops\n        }\n      });\n    }\n\n    // filter by tags\n    if (productFilters.tags) {\n      _.extend(selector, {\n        hashtags: {\n          $in: productFilters.tags\n        }\n      });\n    }\n\n    // filter by query\n    if (productFilters.query) {\n      const cond = {\n        $regex: productFilters.query,\n        $options: \"i\"\n      };\n      _.extend(selector, {\n        $or: [{\n          title: cond\n        }, {\n          pageTitle: cond\n        }, {\n          description: cond\n        }]\n      });\n    }\n\n    // filter by details\n    if (productFilters.details) {\n      _.extend(selector, {\n        metafields: {\n          $elemMatch: {\n            key: {\n              $regex: productFilters.details.key,\n              $options: \"i\"\n            },\n            value: {\n              $regex: productFilters.details.value,\n              $options: \"i\"\n            }\n          }\n        }\n      });\n    }\n\n    // filter by visibility\n    if (productFilters.visibility !== undefined) {\n      _.extend(selector, {\n        isVisible: productFilters.visibility\n      });\n    }\n\n    // filter by gte minimum price\n    if (productFilters[\"price.min\"] && !productFilters[\"price.max\"]) {\n      _.extend(selector, {\n        \"price.min\": {\n          $gte: parseFloat(productFilters[\"price.min\"])\n        }\n      });\n    }\n\n    // filter by lte maximum price\n    if (productFilters[\"price.max\"] && !productFilters[\"price.min\"]) {\n      _.extend(selector, {\n        \"price.max\": {\n          $lte: parseFloat(productFilters[\"price.max\"])\n        }\n      });\n    }\n\n    // filter with a price range\n    if (productFilters[\"price.min\"] && productFilters[\"price.max\"]) {\n      const pmin = parseFloat(productFilters[\"price.min\"]);\n      const pmax = parseFloat(productFilters[\"price.max\"]);\n      // where product A has min 12.99 variant and a 19.99 variant\n      // price.min=12.99&price.max=19.98\n      // should return product A\n      _.extend(selector, {\n        \"price.min\": {\n          $lt: pmax\n        },\n        \"price.max\": {\n          $gt: pmin\n        }\n      });\n    }\n\n    // filter by gte minimum weight\n    if (productFilters[\"weight.min\"] && !productFilters[\"weight.max\"]) {\n      _.extend(selector, {\n        weight: {\n          $gte: parseFloat(productFilters[\"weight.min\"])\n        }\n      });\n    }\n\n    // filter by lte maximum weight\n    if (productFilters[\"weight.max\"] && !productFilters[\"weight.min\"]) {\n      _.extend(selector, {\n        weight: {\n          $lte: parseFloat(productFilters[\"weight.max\"])\n        }\n      });\n    }\n\n    // filter with a weight range\n    if (productFilters[\"weight.min\"] && productFilters[\"weight.max\"]) {\n      const wmin = parseFloat(productFilters[\"weight.min\"]);\n      const wmax = parseFloat(productFilters[\"weight.max\"]);\n      _.extend(selector, {\n        weight: {\n          $lt: wmax,\n          $gt: wmin\n        }\n      });\n    }\n  } // end if productFilters\n\n  return selector;\n}\n\n/**\n * products publication\n * @param {Number} [productScrollLimit] - optional, defaults to 24\n * @param {Array} shops - array of shopId to retrieve product from.\n * @return {Object} return product cursor\n */\nMeteor.publish(\"Products\", function (productScrollLimit = 24, productFilters, sort = {}, editMode = true) {\n  check(productScrollLimit, Number);\n  check(productFilters, Match.OneOf(undefined, Object));\n  check(sort, Match.OneOf(undefined, Object));\n  check(editMode, Match.Maybe(Boolean));\n\n  // TODO: Consider publishing the non-admin publication if a user is not in \"edit mode\" to see what is published\n\n  // Active shop\n  const shopId = Reaction.getShopId();\n  const primaryShopId = Reaction.getPrimaryShopId();\n\n  // Get a list of shopIds that this user has \"createProduct\" permissions for (owner permission is checked by default)\n  const userAdminShopIds = Reaction.getShopsWithRoles([\"createProduct\"], this.userId);\n\n  // Don't publish if we're missing an active or primary shopId\n  if (!shopId || !primaryShopId) {\n    return this.ready();\n  }\n\n  // Get active shop id's to use for filtering\n  const activeShopsIds = Shops.find({\n    $or: [\n      { \"workflow.status\": \"active\" },\n      { _id: Reaction.getPrimaryShopId() }\n    ]\n  }).fetch().map((activeShop) => activeShop._id);\n\n  const selector = filterProducts(productFilters);\n\n  if (selector === false) {\n    return this.ready();\n  }\n\n  // We publish an admin version of this publication to admins of products who are in \"Edit Mode\"\n  // Authorized content curators for shops get special publication of the product\n  // with all relevant revisions all is one package\n  // userAdminShopIds is a list of shopIds that the user has createProduct or owner access for\n  if (editMode && userAdminShopIds && Array.isArray(userAdminShopIds) && userAdminShopIds.length > 0) {\n    selector.isVisible = {\n      $in: [true, false, null, undefined]\n    };\n    selector.shopId = {\n      $in: activeShopsIds\n    };\n\n    // Get _ids of top-level products\n    const productIds = Products.find(selector, {\n      sort,\n      limit: productScrollLimit\n    }).map((product) => product._id);\n\n\n    const productSelectorWithVariants = extendSelectorWithVariants(\"Products\", selector, productFilters, productIds);\n\n    if (RevisionApi.isRevisionControlEnabled()) {\n      const revisionSelector = {\n        \"workflow.status\": {\n          $nin: [\n            \"revision/published\"\n          ]\n        }\n      };\n      const revisionSelectorWithVariants = extendSelectorWithVariants(\"Revisions\", revisionSelector, productFilters, productIds);\n      const handle = Revisions.find(revisionSelectorWithVariants).observe({\n        added: (revision) => {\n          this.added(\"Revisions\", revision._id, revision);\n          if (revision.documentType === \"product\") {\n            // Check merge box (session collection view), if product is already in cache.\n            // If yes, we send a `changed`, otherwise `added`. I'm assuming\n            // that this._documents.Products is somewhat equivalent to\n            // the merge box Meteor.server.sessions[sessionId].getCollectionView(\"Products\").documents\n            if (this._documents.Products && this._documents.Products[revision.documentId]) {\n              this.changed(\"Products\", revision.documentId, { __revisions: [revision] });\n            } else {\n              this.added(\"Products\", revision.documentId, { __revisions: [revision] });\n            }\n          }\n        },\n        changed: (revision) => {\n          this.changed(\"Revisions\", revision._id, revision);\n          if (revision.documentType === \"product\") {\n            if (this._documents.Products && this._documents.Products[revision.documentId]) {\n              this.changed(\"Products\", revision.documentId, { __revisions: [revision] });\n            }\n          }\n        },\n        removed: (revision) => {\n          this.removed(\"Revisions\", revision._id);\n          if (revision.documentType === \"product\") {\n            if (this._documents.Products && this._documents.Products[revision.documentId]) {\n              this.changed(\"Products\", revision.documentId, { __revisions: [] });\n            }\n          }\n        }\n      });\n\n      this.onStop(() => {\n        handle.stop();\n      });\n\n      return Products.find(productSelectorWithVariants);\n    }\n\n    // Revision control is disabled, but is admin\n    return Products.find(productSelectorWithVariants, {\n      sort,\n      limit: productScrollLimit\n    });\n  }\n\n  // This is where the publication begins for non-admin users\n  // Get _ids of top-level products\n  const productIds = Products.find(selector, {\n    sort,\n    limit: productScrollLimit\n  }).map((product) => product._id);\n\n  let newSelector = { ...selector };\n\n  // Remove hashtag filter from selector (hashtags are not applied to variants, we need to get variants)\n  if (productFilters && Object.keys(productFilters).length === 0 && productFilters.constructor === Object) {\n    newSelector = _.omit(selector, [\"hashtags\", \"ancestors\"]);\n\n    if (productFilters.tags) {\n      // Re-configure selector to pick either Variants of one of the top-level products,\n      // or the top-level products in the filter\n      _.extend(newSelector, {\n        $or: [{\n          ancestors: {\n            $in: productIds\n          }\n        }, {\n          $and: [{\n            hashtags: {\n              $in: productFilters.tags\n            }\n          }, {\n            _id: {\n              $in: productIds\n            }\n          }]\n        }]\n      });\n    }\n    // filter by query\n    if (productFilters.query) {\n      const cond = {\n        $regex: productFilters.query,\n        $options: \"i\"\n      };\n      _.extend(newSelector, {\n        $or: [{\n          title: cond\n        }, {\n          pageTitle: cond\n        }, {\n          description: cond\n        }, {\n          ancestors: {\n            $in: productIds\n          }\n        },\n        {\n          _id: {\n            $in: productIds\n          }\n        }]\n      });\n    }\n  } else {\n    newSelector = _.omit(selector, [\"hashtags\", \"ancestors\"]);\n\n    _.extend(newSelector, {\n      $or: [{\n        ancestors: {\n          $in: productIds\n        }\n      }, {\n        _id: {\n          $in: productIds\n        }\n      }]\n    });\n  }\n\n  // Adjust the selector to include only active shops\n  newSelector = {\n    ...newSelector,\n    shopId: {\n      $in: activeShopsIds\n    }\n  };\n\n  // Returning Complete product tree for top level products to avoid sold out warning.\n  return Products.find(newSelector, {\n    sort\n    // TODO: REVIEW Limiting final products publication for non-admins\n    // I think we shouldn't limit here, otherwise we are limited to 24 total products which\n    // could be far less than 24 top-level products\n    // limit: productScrollLimit\n  });\n});\n\n/**\n * @name Products/grid\n * @method\n * @memberof Core\n * @summary Publication method for a customer facing product grid\n * @param {number} productScrollLimit - product find limit\n * @param {object} productFilters - filters to be applied to the product find\n * @param {object} sort - sorting to be applied to the product find\n * @return {MongoCursor} Mongo cursor object of found products\n */\nMeteor.publish(\"Products/grid\", function (productScrollLimit = 24, productFilters, sort = {}) {\n  check(productScrollLimit, Number);\n  check(productFilters, Match.OneOf(undefined, Object));\n  check(sort, Match.OneOf(undefined, Object));\n\n  const newSelector = filterProducts(productFilters);\n\n  if (newSelector === false) {\n    return this.ready();\n  }\n\n  const productCursor = Catalog.find(newSelector, {\n    sort,\n    limit: productScrollLimit,\n    fields: {\n      variants: 0\n    }\n  });\n\n  return productCursor;\n});\n"]},"sourceType":"script","hash":"0f7e2efff2f9f591be0d39a59d729033f8970657"}
