{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$1$2","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"ast":true,"babelrc":false,"sourceFileName":"lib/collections/transform/cartOrder.js","filename":"lib/collections/transform/cartOrder.js","sourceMaps":true,"envName":"development","cwd":"/Users/estebandev/test-knowledge","passPerPreset":false,"presets":[],"parserOpts":{"sourceType":"module","sourceFileName":"lib/collections/transform/cartOrder.js","plugins":["jsx","jsx","flow","flow","objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties"]},"generatorOpts":{"filename":"lib/collections/transform/cartOrder.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"lib/collections/transform/cartOrder.js"}},"code":"const module1 = module;\nmodule1.export({\n  cartOrderTransform: () => cartOrderTransform\n});\n\nlet _sortBy;\n\nmodule1.watch(require(\"lodash/sortBy\"), {\n  default(v) {\n    _sortBy = v;\n  }\n\n}, 0);\n\nlet _values;\n\nmodule1.watch(require(\"lodash/values\"), {\n  default(v) {\n    _values = v;\n  }\n\n}, 1);\nlet accounting;\nmodule1.watch(require(\"accounting-js\"), {\n  default(v) {\n    accounting = v;\n  }\n\n}, 2);\nlet Shops;\nmodule1.watch(require(\"./..\"), {\n  Shops(v) {\n    Shops = v;\n  }\n\n}, 3);\n\n/**\n * getSummary\n * @private\n * @summary iterates over cart items with computations\n * @param {Array} items - cart.items array\n * @param {Array} prop - path to item property represented by array\n * @param {Array} [prop2] - path to another item property represented by array\n * @param {String} [shopId] - shopId\n * @return {Number} - computations result\n */\nfunction getSummary(items, prop, prop2, shopId) {\n  try {\n    if (Array.isArray(items)) {\n      return items.reduce((sum, item) => {\n        if (prop2) {\n          if (shopId) {\n            if (shopId === item.shopId) {\n              // if we're looking for a specific shop's items and this item does match\n              // if prop2 is an empty array\n              if (!prop2.length) {\n                return sum + (prop.length === 1 ? item[prop[0]] : item[prop[0]][prop[1]]);\n              }\n\n              return sum + item[prop[0]] * (prop2.length === 1 ? item[prop2[0]] : item[prop2[0]][prop2[1]]);\n            } // If we're looking for a specific shop's items and this item doesn't match\n\n\n            return sum;\n          } // No shopId param\n          // S + a * b, where b could be b1 or b2\n\n\n          return sum + item[prop[0]] * (prop2.length === 1 ? item[prop2[0]] : item[prop2[0]][prop2[1]]);\n        } // No prop2 param\n        // S + b, where b could be b1 or b2\n\n\n        return sum + (prop.length === 1 ? item[prop[0]] : item[prop[0]][prop[1]]);\n      }, 0);\n    }\n  } catch (e) {\n    // If data not prepared we should send a number to avoid exception with\n    // `toFixed`. This could happens if user stuck on `completed` checkout stage\n    // by some reason.\n    return 0;\n  }\n\n  return 0;\n}\n/**\n * Reaction transform methods on Collections\n * @file Use transform methods to return Cart and Order calculated values: count, subTotal, shipping, taxes, total.\n * Use these methods on Cart and Orders in templates, `{{cart.getCount}}` and in code, `Cart.findOne().getTotal()`.\n * These use Meteor Collection {@link http://docs.meteor.com/api/collections.html#Mongo-Collection transforms}.\n * @module cartOrderTransform\n */\n\n\nconst cartOrderTransform = {\n  /**\n   * @summary Return the total quantity on the order\n   * @method getCount\n   * @example {cart ? cart.getCount() : 0}\n   * @returns {Number}  Total quantity of items on the order\n   */\n  getCount() {\n    return getSummary(this.items, [\"quantity\"]);\n  },\n\n  /**\n   * @summary Return the total price of shipping/handling on the order\n   * @method getShippingTotal\n   * @returns {Number} Total price of shipping/handling on the order\n   */\n  getShippingTotal() {\n    // loop through the cart.shipping, sum shipments.\n    const rate = getSummary(this.shipping, [\"shipmentMethod\", \"rate\"]);\n    const handling = getSummary(this.shipping, [\"shipmentMethod\", \"handling\"]);\n    const shipping = handling + rate || 0;\n    return accounting.toFixed(shipping, 2);\n  },\n\n  /**\n   * @summary Get the total price of shipping, broken down by shop\n   * @method getShippingTotalByShop\n   * @returns {{Object}} - Total price of shipping, broken down by shop\n   */\n  getShippingTotalByShop() {\n    return this.shipping.reduce((uniqueShopShippingTotals, shippingRec) => {\n      if (!uniqueShopShippingTotals[shippingRec.shopId]) {\n        const rate = getSummary(this.shipping, [\"shipmentMethod\", \"rate\"], [], shippingRec.shopId);\n        const handling = getSummary(this.shipping, [\"shipmentMethod\", \"handling\"], [], shippingRec.shopId);\n        const shipping = handling + rate || 0;\n        uniqueShopShippingTotals[shippingRec.shopId] = accounting.toFixed(shipping, 2);\n        return uniqueShopShippingTotals;\n      }\n\n      return uniqueShopShippingTotals;\n    }, {});\n  },\n\n  /**\n   * @summary Return the total price of goods on an order\n   * @method getSubTotal\n   * @returns {Number} Total price of goods for the order\n   */\n  getSubTotal() {\n    const subTotal = getSummary(this.items, [\"quantity\"], [\"variants\", \"price\"]);\n    return accounting.toFixed(subTotal, 2);\n  },\n\n  /**\n   * @summary Aggregates the subtotals by shopId\n   * @method getSubtotalByShop\n   * @return {object} Object with a key for each shopId in the cart/order where the value is the subtotal for that shop\n   */\n  getSubtotalByShop() {\n    return this.items.reduce((uniqueShopSubTotals, item) => {\n      if (!uniqueShopSubTotals[item.shopId]) {\n        const subTotal = getSummary(this.items, [\"quantity\"], [\"variants\", \"price\"], item.shopId);\n        uniqueShopSubTotals[item.shopId] = accounting.toFixed(subTotal, 2);\n        return uniqueShopSubTotals;\n      }\n\n      return uniqueShopSubTotals;\n    }, {});\n  },\n\n  /**\n   * @summary Total taxes for order\n   * @method getTaxTotal\n   * @returns {Number} Total price of taxes for an order\n   */\n  getTaxTotal() {\n    // taxes are calculated in a Cart.after.update hooks\n    // the tax value stored with the cart/order is the effective tax rate\n    // calculated by line items\n    // in the imports/core/taxes plugin\n    const tax = this.tax || 0;\n    const subTotal = parseFloat(this.getSubTotal());\n    const taxTotal = subTotal * tax;\n    return accounting.toFixed(taxTotal, 2);\n  },\n\n  /**\n   * @summary Aggregates the taxes by shopId\n   * @method getTaxesByShop\n   * @return {Object} Object with a key for each shopId in cart/order where the value is the tax total for that shop\n   */\n  getTaxesByShop() {\n    const subtotals = this.getSubtotalByShop();\n    const taxRates = this.taxRatesByShop;\n    return Object.keys(subtotals).reduce((shopTaxTotals, shopId) => {\n      if (!shopTaxTotals[shopId]) {\n        const shopSubtotal = parseFloat(subtotals[shopId]); // In case of taxAPI's tax rate is stored in tax.\n\n        const shopTaxRate = taxRates && taxRates[shopId] || this.tax || 0;\n        const shopTaxTotal = shopSubtotal * shopTaxRate;\n        shopTaxTotals[shopId] = accounting.toFixed(shopTaxTotal, 2);\n      }\n\n      return shopTaxTotals;\n    }, {});\n  },\n\n  /**\n   * @summary Discount for cart/order.\n   * @description Grabs discounts from the invoice records if they exist, otherwise from this.discounts\n   * @example const cartTaxesByShop = cart.getTaxesByShop();\n   * @method getDiscounts\n   * @return {Number} Total value of discounts\n   */\n  getDiscounts() {\n    let orderDiscounts = 0;\n    orderDiscounts = this.billing.reduce((acc, item) => {\n      if (item.invoice) {\n        return acc + parseFloat(item.invoice.discounts);\n      }\n\n      return acc;\n    }, 0);\n    const cartDiscount = parseFloat(this.discount) || 0;\n    const discount = orderDiscounts || cartDiscount || 0;\n    return accounting.toFixed(discount, 2);\n  },\n\n  /**\n   * @summary Discounts by Shop\n   * @method getDiscountsByShop\n   * @returns {object} - An object where the key is a shopId and the value is the discount for that shop\n   */\n  getDiscountsByShop() {\n    const discountsByShop = {};\n\n    if (this.billing && this.billing[0].invoice) {\n      // check if we have the invoice object on the billing records\n      for (const billingRecord of this.billing) {\n        discountsByShop[billingRecord.shopId] = accounting.toFixed(billingRecord.invoice.discounts);\n      }\n    }\n\n    return discountsByShop;\n  },\n\n  /**\n   * @summary Total for Order\n   * @method getTotal\n   * @return {Number} Total for order\n   */\n  getTotal() {\n    const subTotal = parseFloat(this.getSubTotal());\n    const shipping = parseFloat(this.getShippingTotal());\n    const taxes = parseFloat(this.getTaxTotal());\n    const discount = parseFloat(this.getDiscounts());\n    const discountTotal = Math.max(0, subTotal - discount);\n    const total = discountTotal + shipping + taxes;\n    return accounting.toFixed(total, 2);\n  },\n\n  /**\n   * @summary Aggregates the cart/order total by shopId\n   * @method getTotalByShop\n   * @return {object} An object with a key for each shopId in the cart/order where the value is the total for that shop\n   */\n  getTotalByShop() {\n    const subtotals = this.getSubtotalByShop();\n    const taxes = this.getTaxesByShop();\n    const shippingTotalByShop = this.getShippingTotalByShop(); // no discounts right now because that will need to support multi-shop\n    // TODO: Build out shop-by-shop discounts and permit discounts to reduce application fee\n\n    const shopsInCart = Object.keys(subtotals);\n    return Object.keys(subtotals).reduce((shopTotals, shopId) => {\n      if (!shopTotals[shopId]) {\n        let shopSubtotal = parseFloat(subtotals[shopId]); // pending the implementation of shop-by-shop discounts, we allow discounts to apply only on single shop carts\n\n        if (shopsInCart.length === 1) {\n          const discount = parseFloat(this.getDiscounts());\n          shopSubtotal = parseFloat(subtotals[shopId]) - discount;\n        }\n\n        const shopTaxes = parseFloat(taxes[shopId]);\n        const shipping = parseFloat(shippingTotalByShop[shopId]);\n        const shopTotal = shopSubtotal + shopTaxes + shipping;\n        shopTotals[shopId] = accounting.toFixed(shopTotal, 2);\n      }\n\n      return shopTotals;\n    }, {});\n  },\n\n  /**\n   * @summary Cart items organized by shopId\n   * @method getItemsByShop\n   * @example const cartTotals = cart.getTotalByShop();\n   * @return {Object} Dict of shopIds with an array of items from that shop that are present in the cart/order\n   */\n  getItemsByShop() {\n    if (this.items) {\n      return this.items.reduce((itemsByShop, item) => {\n        if (!itemsByShop[item.shopId]) {\n          itemsByShop[item.shopId] = [item];\n        } else {\n          itemsByShop[item.shopId].push(item);\n        }\n\n        return itemsByShop;\n      }, {});\n    }\n\n    return {};\n  },\n\n  /**\n   * @summary Returns an array of payment methods, normalized\n   * @method getPaymentMethods\n   * @returns {Array} Array of Payment Method objects\n   */\n  getPaymentMethods() {\n    const billingMethods = this.billing.map(method => method.paymentMethod);\n    const methodObjects = billingMethods.map(method => {\n      const paymentMethodObject = {\n        storedCard: method.storedCard,\n        processor: method.processor,\n        mode: method.mode,\n        transactionId: method.transactionId,\n        amount: method.amount,\n        method: method.method\n      };\n      return paymentMethodObject;\n    });\n    return methodObjects;\n  },\n\n  /**\n   * @summary Return an array of payment methods for display removing duplicates\n   * @method getUniquePaymentMethods\n   * @returns {object} - An object containing the payment methods used on this order excluding duplicates\n   */\n  getUniquePaymentMethods() {\n    const billingMethods = this.billing.map(method => method.paymentMethod);\n    const uniqueMethods = {};\n\n    for (const billingMethod of billingMethods) {\n      const key = `${billingMethod.storedCard}${billingMethod.processor}${billingMethod.method}`;\n\n      if (!uniqueMethods[key]) {\n        uniqueMethods[key] = {\n          storedCard: billingMethod.storedCard,\n          processor: billingMethod.processor,\n          method: billingMethod.method,\n          key\n        };\n      }\n    }\n\n    const uniqueValueArray = _values(uniqueMethods);\n\n    return uniqueValueArray;\n  },\n\n  /**\n   * @summary Create an object that contains a summary for each shop\n   * @method getShopSummary\n   * @return {Object}  An object with a key for each shopId, and name + summary data for each\n   */\n  getShopSummary() {\n    // massage items into an object by Shop\n    const taxesByShop = this.getTaxesByShop();\n    const subTotalsByShop = this.getSubtotalByShop();\n    const shippingByShop = this.getShippingTotalByShop();\n    const {\n      shipping\n    } = this;\n    const itemsByShop = this.items.reduce((shopItems, item) => {\n      if (!shopItems[item.shopId]) {\n        shopItems[item.shopId] = [item];\n      } else {\n        shopItems[item.shopId].push(item);\n      }\n\n      return shopItems;\n    }, {});\n    const shopObjects = Object.keys(itemsByShop).map(shop => ({\n      [shop]: {\n        name: Shops.findOne(shop).name,\n        subTotal: subTotalsByShop[shop],\n        taxes: taxesByShop[shop],\n        items: itemsByShop[shop],\n        quantityTotal: itemsByShop[shop].reduce((qty, item) => qty + item.quantity, 0),\n        shipping: shippingByShop[shop],\n        shippingMethod: shipping[0].shipmentMethod\n      }\n    })); // TODO we just assume now that every shop uses the same carrier, thus the hard-coded zero index\n    // because shipping records are not stored by shop\n\n    const sortedShopObjects = _sortBy(shopObjects, shopObject => shopObject.name);\n\n    return sortedShopObjects;\n  }\n\n};","map":{"version":3,"sources":["lib/collections/transform/cartOrder.js"],"names":["module1","module","export","cartOrderTransform","_sortBy","watch","require","default","v","_values","accounting","Shops","getSummary","items","prop","prop2","shopId","Array","isArray","reduce","sum","item","length","e","getCount","getShippingTotal","rate","shipping","handling","toFixed","getShippingTotalByShop","uniqueShopShippingTotals","shippingRec","getSubTotal","subTotal","getSubtotalByShop","uniqueShopSubTotals","getTaxTotal","tax","parseFloat","taxTotal","getTaxesByShop","subtotals","taxRates","taxRatesByShop","Object","keys","shopTaxTotals","shopSubtotal","shopTaxRate","shopTaxTotal","getDiscounts","orderDiscounts","billing","acc","invoice","discounts","cartDiscount","discount","getDiscountsByShop","discountsByShop","billingRecord","getTotal","taxes","discountTotal","Math","max","total","getTotalByShop","shippingTotalByShop","shopsInCart","shopTotals","shopTaxes","shopTotal","getItemsByShop","itemsByShop","push","getPaymentMethods","billingMethods","map","method","paymentMethod","methodObjects","paymentMethodObject","storedCard","processor","mode","transactionId","amount","getUniquePaymentMethods","uniqueMethods","billingMethod","key","uniqueValueArray","getShopSummary","taxesByShop","subTotalsByShop","shippingByShop","shopItems","shopObjects","shop","name","findOne","quantityTotal","qty","quantity","shippingMethod","shipmentMethod","sortedShopObjects","shopObject"],"mappings":"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","sourcesContent":["import accounting from \"accounting-js\";\nimport _ from \"lodash\";\nimport { Shops } from \"/lib/collections\";\n\n/**\n * getSummary\n * @private\n * @summary iterates over cart items with computations\n * @param {Array} items - cart.items array\n * @param {Array} prop - path to item property represented by array\n * @param {Array} [prop2] - path to another item property represented by array\n * @param {String} [shopId] - shopId\n * @return {Number} - computations result\n */\nfunction getSummary(items, prop, prop2, shopId) {\n  try {\n    if (Array.isArray(items)) {\n      return items.reduce((sum, item) => {\n        if (prop2) {\n          if (shopId) {\n            if (shopId === item.shopId) {\n              // if we're looking for a specific shop's items and this item does match\n              // if prop2 is an empty array\n              if (!prop2.length) {\n                return sum + (prop.length === 1 ? item[prop[0]] :\n                  item[prop[0]][prop[1]]);\n              }\n              return sum + item[prop[0]] * (prop2.length === 1 ? item[prop2[0]] :\n                item[prop2[0]][prop2[1]]);\n            }\n            // If we're looking for a specific shop's items and this item doesn't match\n            return sum;\n          }\n          // No shopId param\n          // S + a * b, where b could be b1 or b2\n          return sum + item[prop[0]] * (prop2.length === 1 ? item[prop2[0]] :\n            item[prop2[0]][prop2[1]]);\n        }\n        // No prop2 param\n        // S + b, where b could be b1 or b2\n        return sum + (prop.length === 1 ? item[prop[0]] :\n          item[prop[0]][prop[1]]);\n      }, 0);\n    }\n  } catch (e) {\n    // If data not prepared we should send a number to avoid exception with\n    // `toFixed`. This could happens if user stuck on `completed` checkout stage\n    // by some reason.\n    return 0;\n  }\n  return 0;\n}\n\n/**\n * Reaction transform methods on Collections\n * @file Use transform methods to return Cart and Order calculated values: count, subTotal, shipping, taxes, total.\n * Use these methods on Cart and Orders in templates, `{{cart.getCount}}` and in code, `Cart.findOne().getTotal()`.\n * These use Meteor Collection {@link http://docs.meteor.com/api/collections.html#Mongo-Collection transforms}.\n * @module cartOrderTransform\n */\n\nexport const cartOrderTransform = {\n  /**\n   * @summary Return the total quantity on the order\n   * @method getCount\n   * @example {cart ? cart.getCount() : 0}\n   * @returns {Number}  Total quantity of items on the order\n   */\n  getCount() {\n    return getSummary(this.items, [\"quantity\"]);\n  },\n  /**\n   * @summary Return the total price of shipping/handling on the order\n   * @method getShippingTotal\n   * @returns {Number} Total price of shipping/handling on the order\n   */\n  getShippingTotal() {\n    // loop through the cart.shipping, sum shipments.\n    const rate = getSummary(this.shipping, [\"shipmentMethod\", \"rate\"]);\n    const handling = getSummary(this.shipping, [\"shipmentMethod\", \"handling\"]);\n    const shipping = handling + rate || 0;\n    return accounting.toFixed(shipping, 2);\n  },\n  /**\n   * @summary Get the total price of shipping, broken down by shop\n   * @method getShippingTotalByShop\n   * @returns {{Object}} - Total price of shipping, broken down by shop\n   */\n  getShippingTotalByShop() {\n    return this.shipping.reduce((uniqueShopShippingTotals, shippingRec) => {\n      if (!uniqueShopShippingTotals[shippingRec.shopId]) {\n        const rate = getSummary(this.shipping, [\"shipmentMethod\", \"rate\"], [], shippingRec.shopId);\n        const handling = getSummary(this.shipping, [\"shipmentMethod\", \"handling\"], [], shippingRec.shopId);\n        const shipping = handling + rate || 0;\n        uniqueShopShippingTotals[shippingRec.shopId] = accounting.toFixed(shipping, 2);\n        return uniqueShopShippingTotals;\n      }\n      return uniqueShopShippingTotals;\n    }, {});\n  },\n  /**\n   * @summary Return the total price of goods on an order\n   * @method getSubTotal\n   * @returns {Number} Total price of goods for the order\n   */\n  getSubTotal() {\n    const subTotal = getSummary(this.items, [\"quantity\"], [\"variants\", \"price\"]);\n    return accounting.toFixed(subTotal, 2);\n  },\n  /**\n   * @summary Aggregates the subtotals by shopId\n   * @method getSubtotalByShop\n   * @return {object} Object with a key for each shopId in the cart/order where the value is the subtotal for that shop\n   */\n  getSubtotalByShop() {\n    return this.items.reduce((uniqueShopSubTotals, item) => {\n      if (!uniqueShopSubTotals[item.shopId]) {\n        const subTotal = getSummary(this.items, [\"quantity\"], [\"variants\", \"price\"], item.shopId);\n        uniqueShopSubTotals[item.shopId] = accounting.toFixed(subTotal, 2);\n        return uniqueShopSubTotals;\n      }\n      return uniqueShopSubTotals;\n    }, {});\n  },\n  /**\n   * @summary Total taxes for order\n   * @method getTaxTotal\n   * @returns {Number} Total price of taxes for an order\n   */\n  getTaxTotal() {\n    // taxes are calculated in a Cart.after.update hooks\n    // the tax value stored with the cart/order is the effective tax rate\n    // calculated by line items\n    // in the imports/core/taxes plugin\n    const tax = this.tax || 0;\n    const subTotal = parseFloat(this.getSubTotal());\n    const taxTotal = subTotal * tax;\n    return accounting.toFixed(taxTotal, 2);\n  },\n  /**\n   * @summary Aggregates the taxes by shopId\n   * @method getTaxesByShop\n   * @return {Object} Object with a key for each shopId in cart/order where the value is the tax total for that shop\n   */\n  getTaxesByShop() {\n    const subtotals = this.getSubtotalByShop();\n    const taxRates = this.taxRatesByShop;\n\n    return Object.keys(subtotals).reduce((shopTaxTotals, shopId) => {\n      if (!shopTaxTotals[shopId]) {\n        const shopSubtotal = parseFloat(subtotals[shopId]);\n        // In case of taxAPI's tax rate is stored in tax.\n        const shopTaxRate = (taxRates && taxRates[shopId]) || this.tax || 0;\n        const shopTaxTotal = shopSubtotal * shopTaxRate;\n        shopTaxTotals[shopId] = accounting.toFixed(shopTaxTotal, 2);\n      }\n      return shopTaxTotals;\n    }, {});\n  },\n  /**\n   * @summary Discount for cart/order.\n   * @description Grabs discounts from the invoice records if they exist, otherwise from this.discounts\n   * @example const cartTaxesByShop = cart.getTaxesByShop();\n   * @method getDiscounts\n   * @return {Number} Total value of discounts\n   */\n  getDiscounts() {\n    let orderDiscounts = 0;\n    orderDiscounts = this.billing.reduce((acc, item) => {\n      if (item.invoice) {\n        return acc + parseFloat(item.invoice.discounts);\n      }\n      return acc;\n    }, 0);\n    const cartDiscount = parseFloat(this.discount) || 0;\n    const discount = orderDiscounts || cartDiscount || 0;\n    return accounting.toFixed(discount, 2);\n  },\n  /**\n   * @summary Discounts by Shop\n   * @method getDiscountsByShop\n   * @returns {object} - An object where the key is a shopId and the value is the discount for that shop\n   */\n  getDiscountsByShop() {\n    const discountsByShop = {};\n    if (this.billing && this.billing[0].invoice) { // check if we have the invoice object on the billing records\n      for (const billingRecord of this.billing) {\n        discountsByShop[billingRecord.shopId] = accounting.toFixed(billingRecord.invoice.discounts);\n      }\n    }\n    return discountsByShop;\n  },\n  /**\n   * @summary Total for Order\n   * @method getTotal\n   * @return {Number} Total for order\n   */\n  getTotal() {\n    const subTotal = parseFloat(this.getSubTotal());\n    const shipping = parseFloat(this.getShippingTotal());\n    const taxes = parseFloat(this.getTaxTotal());\n    const discount = parseFloat(this.getDiscounts());\n    const discountTotal = Math.max(0, subTotal - discount);\n    const total = discountTotal + shipping + taxes;\n    return accounting.toFixed(total, 2);\n  },\n  /**\n   * @summary Aggregates the cart/order total by shopId\n   * @method getTotalByShop\n   * @return {object} An object with a key for each shopId in the cart/order where the value is the total for that shop\n   */\n  getTotalByShop() {\n    const subtotals = this.getSubtotalByShop();\n    const taxes = this.getTaxesByShop();\n    const shippingTotalByShop = this.getShippingTotalByShop();\n\n    // no discounts right now because that will need to support multi-shop\n    // TODO: Build out shop-by-shop discounts and permit discounts to reduce application fee\n    const shopsInCart = Object.keys(subtotals);\n    return Object.keys(subtotals).reduce((shopTotals, shopId) => {\n      if (!shopTotals[shopId]) {\n        let shopSubtotal = parseFloat(subtotals[shopId]);\n        // pending the implementation of shop-by-shop discounts, we allow discounts to apply only on single shop carts\n        if (shopsInCart.length === 1) {\n          const discount = parseFloat(this.getDiscounts());\n          shopSubtotal = parseFloat(subtotals[shopId]) - discount;\n        }\n\n        const shopTaxes = parseFloat(taxes[shopId]);\n        const shipping = parseFloat(shippingTotalByShop[shopId]);\n        const shopTotal = shopSubtotal + shopTaxes + shipping;\n        shopTotals[shopId] = accounting.toFixed(shopTotal, 2);\n      }\n      return shopTotals;\n    }, {});\n  },\n  /**\n   * @summary Cart items organized by shopId\n   * @method getItemsByShop\n   * @example const cartTotals = cart.getTotalByShop();\n   * @return {Object} Dict of shopIds with an array of items from that shop that are present in the cart/order\n   */\n  getItemsByShop() {\n    if (this.items) {\n      return this.items.reduce((itemsByShop, item) => {\n        if (!itemsByShop[item.shopId]) {\n          itemsByShop[item.shopId] = [item];\n        } else {\n          itemsByShop[item.shopId].push(item);\n        }\n        return itemsByShop;\n      }, {});\n    }\n    return {};\n  },\n  /**\n   * @summary Returns an array of payment methods, normalized\n   * @method getPaymentMethods\n   * @returns {Array} Array of Payment Method objects\n   */\n  getPaymentMethods() {\n    const billingMethods = this.billing.map((method) => method.paymentMethod);\n    const methodObjects = billingMethods.map((method) => {\n      const paymentMethodObject = {\n        storedCard: method.storedCard,\n        processor: method.processor,\n        mode: method.mode,\n        transactionId: method.transactionId,\n        amount: method.amount,\n        method: method.method\n      };\n      return paymentMethodObject;\n    });\n    return methodObjects;\n  },\n  /**\n   * @summary Return an array of payment methods for display removing duplicates\n   * @method getUniquePaymentMethods\n   * @returns {object} - An object containing the payment methods used on this order excluding duplicates\n   */\n  getUniquePaymentMethods() {\n    const billingMethods = this.billing.map((method) => method.paymentMethod);\n    const uniqueMethods = {};\n    for (const billingMethod of billingMethods) {\n      const key = `${billingMethod.storedCard}${billingMethod.processor}${billingMethod.method}`;\n      if (!uniqueMethods[key]) {\n        uniqueMethods[key] = {\n          storedCard: billingMethod.storedCard,\n          processor: billingMethod.processor,\n          method: billingMethod.method,\n          key\n        };\n      }\n    }\n    const uniqueValueArray = _.values(uniqueMethods);\n    return uniqueValueArray;\n  },\n  /**\n   * @summary Create an object that contains a summary for each shop\n   * @method getShopSummary\n   * @return {Object}  An object with a key for each shopId, and name + summary data for each\n   */\n  getShopSummary() {\n    // massage items into an object by Shop\n    const taxesByShop = this.getTaxesByShop();\n    const subTotalsByShop = this.getSubtotalByShop();\n    const shippingByShop = this.getShippingTotalByShop();\n    const { shipping } = this;\n    const itemsByShop = this.items.reduce((shopItems, item) => {\n      if (!shopItems[item.shopId]) {\n        shopItems[item.shopId] = [item];\n      } else {\n        shopItems[item.shopId].push(item);\n      }\n      return shopItems;\n    }, {});\n\n    const shopObjects = Object.keys(itemsByShop).map((shop) => ({\n      [shop]: {\n        name: Shops.findOne(shop).name,\n        subTotal: subTotalsByShop[shop],\n        taxes: taxesByShop[shop],\n        items: itemsByShop[shop],\n        quantityTotal: itemsByShop[shop].reduce((qty, item) => qty + item.quantity, 0),\n        shipping: shippingByShop[shop],\n        shippingMethod: shipping[0].shipmentMethod\n      }\n    }));\n    // TODO we just assume now that every shop uses the same carrier, thus the hard-coded zero index\n    // because shipping records are not stored by shop\n    const sortedShopObjects = _.sortBy(shopObjects, (shopObject) => shopObject.name);\n    return sortedShopObjects;\n  }\n};\n"]},"sourceType":"script","hash":"39874da60f48aaf2cb46c4794448f6fcd7bcdac8"}
