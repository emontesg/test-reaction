{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$1$2","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"ast":true,"babelrc":false,"sourceFileName":"server/methods/catalog.js","filename":"server/methods/catalog.js","sourceMaps":true,"envName":"development","cwd":"/Users/estebandev/test-knowledge","passPerPreset":false,"presets":[],"parserOpts":{"sourceType":"module","sourceFileName":"server/methods/catalog.js","plugins":["jsx","jsx","flow","flow","objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties"]},"generatorOpts":{"filename":"server/methods/catalog.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"server/methods/catalog.js"}},"code":"var _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/builtin/objectSpread\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nlet _sortBy;\n\nmodule.watch(require(\"lodash/sortBy\"), {\n  default(v) {\n    _sortBy = v;\n  }\n\n}, 0);\nlet check, Match;\nmodule.watch(require(\"meteor/check\"), {\n  check(v) {\n    check = v;\n  },\n\n  Match(v) {\n    Match = v;\n  }\n\n}, 1);\nlet Random;\nmodule.watch(require(\"meteor/random\"), {\n  Random(v) {\n    Random = v;\n  }\n\n}, 2);\nlet EJSON;\nmodule.watch(require(\"meteor/ejson\"), {\n  EJSON(v) {\n    EJSON = v;\n  }\n\n}, 3);\nlet Meteor;\nmodule.watch(require(\"meteor/meteor\"), {\n  Meteor(v) {\n    Meteor = v;\n  }\n\n}, 4);\nlet ReactionProduct;\nmodule.watch(require(\"../../lib/api\"), {\n  ReactionProduct(v) {\n    ReactionProduct = v;\n  }\n\n}, 5);\nlet Catalog;\nmodule.watch(require(\"../../imports/plugins/core/revisions/server/hooks\"), {\n  ProductRevision(v) {\n    Catalog = v;\n  }\n\n}, 6);\nlet Hooks, Logger, Reaction;\nmodule.watch(require(\"../api\"), {\n  Hooks(v) {\n    Hooks = v;\n  },\n\n  Logger(v) {\n    Logger = v;\n  },\n\n  Reaction(v) {\n    Reaction = v;\n  }\n\n}, 7);\nlet MediaRecords, Products, Revisions, Tags;\nmodule.watch(require(\"../../lib/collections\"), {\n  MediaRecords(v) {\n    MediaRecords = v;\n  },\n\n  Products(v) {\n    Products = v;\n  },\n\n  Revisions(v) {\n    Revisions = v;\n  },\n\n  Tags(v) {\n    Tags = v;\n  }\n\n}, 8);\nlet Media;\nmodule.watch(require(\"../../imports/plugins/core/files/server\"), {\n  Media(v) {\n    Media = v;\n  }\n\n}, 9);\n\n/* eslint new-cap: 0 */\n\n/* eslint no-loop-func: 0 */\n\n/* eslint quotes: 0 */\n\n/**\n * @file Methods for Products. Run these methods using `Meteor.call()`.\n *\n *\n * @namespace Methods/Products\n*/\n\n/**\n * updateVariantProductField\n * @private\n * @summary updates the variant\n * @param {Array} variants - the array of variants\n * @param {String} field - the field to update\n * @param {String} value - the value to add\n * @return {Array} - return an array\n */\nfunction updateVariantProductField(variants, field, value) {\n  return variants.map(variant => Meteor.call(\"products/updateProductField\", variant._id, field, value));\n}\n/**\n * @array toDenormalize\n * @private\n * @summary contains a list of fields, which should be denormalized\n * @type {string[]}\n */\n\n\nconst toDenormalize = [\"price\", \"inventoryQuantity\", \"lowInventoryWarningThreshold\", \"inventoryPolicy\", \"inventoryManagement\"];\n/**\n * @function createTitle\n * @private\n * @description Recursive method which trying to find a new `title`, given the\n * existing copies\n * @param {String} newTitle - product `title`\n * @param {String} productId - current product `_id`\n * @return {String} title - modified `title`\n */\n\nfunction createTitle(newTitle, productId) {\n  // exception product._id needed for cases then double triggering happens\n  let title = newTitle || \"\";\n  const titleCount = Products.find({\n    title,\n    _id: {\n      $nin: [productId]\n    }\n  }).count(); // current product \"copy\" number\n\n  let titleNumberSuffix = 0; // product handle prefix\n\n  let titleString = title; // copySuffix \"-copy-number\" suffix of product\n\n  const copySuffix = titleString.match(/-copy-\\d+$/) || titleString.match(/-copy$/); // if product is a duplicate, we should take the copy number, and cut\n  // the handle\n\n  if (copySuffix) {\n    // we can have two cases here: copy-number and just -copy. If there is\n    // no numbers in copySuffix then we should put 1 in handleNumberSuffix\n    titleNumberSuffix = +String(copySuffix).match(/\\d+$/) || 1; // removing last numbers and last \"-\" if it presents\n\n    titleString = title.replace(/\\d+$/, '').replace(/-$/, '');\n  } // if we have more than one product with the same handle, we should mark\n  // it as \"copy\" or increment our product handle if it contain numbers.\n\n\n  if (titleCount > 0) {\n    // if we have product with name like \"product4\", we should take care\n    // about its uniqueness\n    if (titleNumberSuffix > 0) {\n      title = `${titleString}-${titleNumberSuffix + titleCount}`;\n    } else {\n      // first copy will be \"...-copy\", second: \"...-copy-2\"\n      title = `${titleString}-copy${titleCount > 1 ? `-${titleCount}` : \"\"}`;\n    }\n  } // we should check again if there are any new matches with DB\n\n\n  if (Products.find({\n    title\n  }).count() !== 0) {\n    title = createTitle(title, productId);\n  }\n\n  return title;\n}\n/**\n * @function createHandle\n * @private\n * @description Recursive method which trying to find a new `handle`, given the\n * existing copies\n * @param {String} productHandle - product `handle`\n * @param {String} productId - current product `_id`\n * @return {String} handle - modified `handle`\n */\n\n\nfunction createHandle(productHandle, productId) {\n  let handle = productHandle || \"\"; // exception product._id needed for cases then double triggering happens\n\n  const handleCount = Products.find({\n    handle,\n    _id: {\n      $nin: [productId]\n    }\n  }).count(); // current product \"copy\" number\n\n  let handleNumberSuffix = 0; // product handle prefix\n\n  let handleString = handle; // copySuffix \"-copy-number\" suffix of product\n\n  const copySuffix = handleString.match(/-copy-\\d+$/) || handleString.match(/-copy$/); // if product is a duplicate, we should take the copy number, and cut\n  // the handle\n\n  if (copySuffix) {\n    // we can have two cases here: copy-number and just -copy. If there is\n    // no numbers in copySuffix then we should put 1 in handleNumberSuffix\n    handleNumberSuffix = +String(copySuffix).match(/\\d+$/) || 1; // removing last numbers and last \"-\" if it presents\n\n    handleString = handle.replace(/\\d+$/, '').replace(/-$/, '');\n  } // if we have more than one product with the same handle, we should mark\n  // it as \"copy\" or increment our product handle if it contain numbers.\n\n\n  if (handleCount > 0) {\n    // if we have product with name like \"product4\", we should take care\n    // about its uniqueness\n    if (handleNumberSuffix > 0) {\n      handle = `${handleString}-${handleNumberSuffix + handleCount}`;\n    } else {\n      // first copy will be \"...-copy\", second: \"...-copy-2\"\n      handle = `${handleString}-copy${handleCount > 1 ? `-${handleCount}` : ''}`;\n    }\n  } // we should check again if there are any new matches with DB\n  // exception product._id needed for cases then double triggering happens\n\n\n  const newHandleCount = Products.find({\n    handle,\n    _id: {\n      $nin: [productId]\n    }\n  }).count();\n\n  if (newHandleCount !== 0) {\n    handle = createHandle(handle, productId);\n  }\n\n  return handle;\n}\n/**\n * @function copyMedia\n * @private\n * @description copy images links to cloned variant from original\n * @param {String} newId - [cloned|original] product _id\n * @param {String} variantOldId - old variant _id\n * @param {String} variantNewId - - cloned variant _id\n * @return {undefined}\n */\n\n\nfunction copyMedia(newId, variantOldId, variantNewId) {\n  Media.find({\n    \"metadata.variantId\": variantOldId\n  }).then(fileRecords => {\n    fileRecords.forEach(fileRecord => {\n      // Copy File and insert directly, bypasing revision control\n      fileRecord.fullClone({\n        productId: newId,\n        variantId: variantNewId\n      }).catch(error => {\n        Logger.error(`Error in copyMedia for product ${newId}`, error);\n      });\n    });\n  }).catch(error => {\n    Logger.error(`Error in copyMedia for product ${newId}`, error);\n  });\n}\n/**\n * @function denormalize\n * @private\n * @description With flattened model we do not want to get variant docs in\n * `products` publication, but we need some data from variants to display price,\n * quantity, etc. That's why we are denormalizing these properties into product\n * doc. Also, this way should have a speed benefit comparing the way where we\n * could dynamically build denormalization inside `products` publication.\n * @summary update product denormalized properties if variant was updated or\n * removed\n * @param {String} id - product _id\n * @param {String} field - type of field. Could be:\n * \"price\",\n * \"inventoryQuantity\",\n * \"inventoryManagement\",\n * \"inventoryPolicy\",\n * \"lowInventoryWarningThreshold\"\n * @since 0.11.0\n * @return {Number} - number of successful update operations. Should be \"1\".\n */\n\n\nfunction denormalize(id, field) {\n  const doc = Products.findOne(id);\n  let variants;\n\n  if (doc.type === \"simple\") {\n    variants = Catalog.getTopVariants(id);\n  } else if (doc.type === \"variant\" && doc.ancestors.length === 1) {\n    variants = Catalog.getVariants(id);\n  }\n\n  const update = {};\n\n  switch (field) {\n    case \"inventoryPolicy\":\n    case \"inventoryQuantity\":\n    case \"inventoryManagement\":\n      Object.assign(update, {\n        isSoldOut: isSoldOut(variants),\n        isLowQuantity: isLowQuantity(variants),\n        isBackorder: isBackorder(variants)\n      });\n      break;\n\n    case \"lowInventoryWarningThreshold\":\n      Object.assign(update, {\n        isLowQuantity: isLowQuantity(variants)\n      });\n      break;\n\n    default:\n      {\n        // \"price\" is object with range, min, max\n        const priceObject = Catalog.getProductPriceRange(id);\n        Object.assign(update, {\n          price: priceObject\n        });\n      }\n  } // TODO: Determine if product revision needs to be updated as well.\n\n\n  Products.update(id, {\n    $set: update\n  }, {\n    selector: {\n      type: \"simple\"\n    }\n  });\n}\n/**\n * isSoldOut\n * @private\n * @summary We are stop accepting new orders if product marked as `isSoldOut`.\n * @param {Array} variants - Array with top-level variants\n * @return {Boolean} true if summary product quantity is zero.\n */\n\n\nfunction isSoldOut(variants) {\n  return variants.every(variant => {\n    if (variant.inventoryManagement && variant.inventoryPolicy) {\n      return Catalog.getVariantQuantity(variant) <= 0;\n    }\n\n    return false;\n  });\n}\n/**\n * isLowQuantity\n * @private\n * @summary If at least one of the variants is less than the threshold, then function returns `true`\n * @param {Array} variants - array of child variants\n * @return {boolean} low quantity or not\n */\n\n\nfunction isLowQuantity(variants) {\n  return variants.some(variant => {\n    const quantity = Catalog.getVariantQuantity(variant); // we need to keep an eye on `inventoryPolicy` too and qty > 0\n\n    if (variant.inventoryManagement && variant.inventoryPolicy && quantity) {\n      return quantity <= variant.lowInventoryWarningThreshold;\n    } // TODO: need to test this function with real data\n\n\n    return false;\n  });\n}\n/**\n * isBackorder\n * @private\n * @description Is products variants is still available to be ordered after summary variants quantity is zero\n * @param {Array} variants - array with variant objects\n * @return {boolean} is backorder allowed or not for a product\n */\n\n\nfunction isBackorder(variants) {\n  return variants.every(variant => !variant.inventoryPolicy && variant.inventoryManagement && variant.inventoryQuantity === 0);\n}\n/**\n * flushQuantity\n * @private\n * @summary if variant `inventoryQuantity` not zero, function update it to\n * zero. This needed in case then option with it's own `inventoryQuantity`\n * creates to top-level variant. In that case top-level variant should display\n * sum of his options `inventoryQuantity` fields.\n * @param {String} id - variant _id\n * @return {Number} - collection update results\n */\n\n\nfunction flushQuantity(id) {\n  const variant = Products.findOne(id); // if variant already have descendants, quantity should be 0, and we don't\n  // need to do all next actions\n\n  if (variant.inventoryQuantity === 0) {\n    return 1; // let them think that we have one successful operation here\n  }\n\n  const productUpdate = Products.update({\n    _id: id\n  }, {\n    $set: {\n      inventoryQuantity: 0\n    }\n  }, {\n    selector: {\n      type: \"variant\"\n    }\n  });\n  return productUpdate;\n}\n/**\n * @function createProduct\n * @private\n * @description creates a product\n * @param {Object} props - initial product properties\n * @return {Object} product - new product\n */\n\n\nfunction createProduct(props = null) {\n  const _id = Products.insert((0, _objectSpread2.default)({\n    type: \"simple\"\n  }, props), {\n    validate: false\n  });\n\n  const newProduct = Products.findOne({\n    _id\n  });\n  Hooks.Events.run(\"afterInsertCatalogProduct\", newProduct);\n  return newProduct;\n}\n/**\n * @function\n * @name updateCatalogProduct\n * @summary Updates a product's revision and conditionally updates\n * the underlying product.\n *\n * @param {String} userId - currently logged in user\n * @param {Object} selector - selector for product to update\n * @param {Object} modifier - Object describing what parts of the document to update.\n * @param {Object} validation - simple schema validation options\n * @return {String} _id of updated document\n */\n\n\nfunction updateCatalogProduct(userId, selector, modifier, validation) {\n  const product = Products.findOne(selector);\n  const shouldUpdateProduct = Hooks.Events.run(\"beforeUpdateCatalogProduct\", product, {\n    userId,\n    modifier,\n    validation\n  });\n\n  if (shouldUpdateProduct) {\n    const result = Products.update(selector, modifier, validation);\n    Hooks.Events.run(\"afterUpdateCatalogProduct\", product, {\n      modifier\n    });\n    return result;\n  }\n\n  Logger.debug(`beforeUpdateCatalogProduct hook returned falsy, not updating catalog product`);\n  return false;\n}\n\nMeteor.methods({\n  /**\n   * @name products/cloneVariant\n   * @memberof Methods/Products\n   * @method\n   * @summary clones a product variant into a new variant\n   * @description the method copies variants, but will also create and clone\n   * child variants (options)\n   * @param {String} productId - the productId we're whose variant we're\n   * cloning\n   * @param {String} variantId - the variantId that we're cloning\n   * @todo rewrite @description\n   * @return {Array} - list with cloned variants _ids\n   */\n  \"products/cloneVariant\"(productId, variantId) {\n    check(productId, String);\n    check(variantId, String); // Check first if Variant exists and then if user has the right to clone it\n\n    const variant = Products.findOne(variantId);\n\n    if (!variant) {\n      throw new Meteor.Error(\"not-found\", \"Variant not found\");\n    } else if (!Reaction.hasPermission(\"createProduct\", this.userId, variant.shopId)) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    } // Verify that this variant and any ancestors are not deleted.\n    // Child variants cannot be added if a parent product or product revision\n    // is marked as `{ isDeleted: true }`\n\n\n    if (ReactionProduct.isAncestorDeleted(variant, true)) {\n      throw new Meteor.Error(\"server-error\", \"Unable to create product variant\");\n    }\n\n    const variants = Products.find({\n      $or: [{\n        _id: variantId\n      }, {\n        ancestors: {\n          $in: [variantId]\n        },\n        isDeleted: false\n      }],\n      type: \"variant\"\n    }).fetch(); // exit if we're trying to clone a ghost\n\n    if (variants.length === 0) {\n      return;\n    }\n\n    const variantNewId = Random.id(); // for the parent variant\n    // we need to make sure that top level variant will be cloned first, his\n    // descendants later.\n    // we could use this way in future: http://stackoverflow.com/questions/\n    // 9040161/mongo-order-by-length-of-array, by now following are allowed\n    // @link https://lodash.com/docs#sortBy\n\n    const sortedVariants = _sortBy(variants, doc => doc.ancestors.length);\n\n    return sortedVariants.map(sortedVariant => {\n      const oldId = sortedVariant._id;\n      let type = \"child\";\n      const clone = {};\n\n      if (variantId === sortedVariant._id) {\n        type = \"parent\";\n        Object.assign(clone, sortedVariant, {\n          _id: variantNewId,\n          title: `${sortedVariant.title} - copy`,\n          optionTitle: `${sortedVariant.optionTitle} - copy`,\n          price: `${sortedVariant.price}` ? `${sortedVariant.price}` : `${variant.price}`,\n          compareAtPrice: `${sortedVariant.compareAtPrice}` ? `${sortedVariant.compareAtPrice}` : `${variant.compareAtPrice}`\n        });\n      } else {\n        const parentIndex = sortedVariant.ancestors.indexOf(variantId);\n        const ancestorsClone = sortedVariant.ancestors.slice(0); // if variantId exists in ancestors, we override it by new _id\n\n        if (parentIndex >= 0) ancestorsClone.splice(parentIndex, 1, variantNewId);\n        Object.assign(clone, variant, {\n          _id: Random.id(),\n          ancestors: ancestorsClone,\n          title: `${sortedVariant.title}`,\n          optionTitle: `${sortedVariant.optionTitle}`,\n          price: `${sortedVariant.price}` ? `${sortedVariant.price}` : `${variant.price}`,\n          compareAtPrice: `${sortedVariant.compareAtPrice}` ? `${sortedVariant.compareAtPrice}` : `${variant.compareAtPrice}`,\n          height: `${sortedVariant.height}`,\n          width: `${sortedVariant.width}`,\n          weight: `${sortedVariant.weight}`,\n          length: `${sortedVariant.length}`\n        });\n      }\n\n      delete clone.updatedAt;\n      delete clone.createdAt;\n      delete clone.inventoryQuantity;\n      delete clone.lowInventoryWarningThreshold;\n      copyMedia(productId, oldId, clone._id);\n      let newId;\n\n      try {\n        Hooks.Events.run(\"beforeInsertCatalogProductInsertRevision\", clone);\n        newId = Products.insert(clone, {\n          validate: false\n        });\n        const newProduct = Products.findOne(newId);\n        Hooks.Events.run(\"afterInsertCatalogProduct\", newProduct);\n        Logger.debug(`products/cloneVariant: created ${type === \"child\" ? \"sub child \" : \"\"}clone: ${clone._id} from ${variantId}`);\n      } catch (error) {\n        Logger.error(`products/cloneVariant: cloning of ${variantId} was failed: ${error}`);\n        throw error;\n      }\n\n      Hooks.Events.run(\"afterInsertProduct\", clone);\n      return newId;\n    });\n  },\n\n  /**\n   * @name products/createVariant\n   * @memberof Methods/Products\n   * @method\n   * @summary initializes empty variant template\n   * @param {String} parentId - the product _id or top level variant _id where\n   * we create variant\n   * @param {Object} [newVariant] - variant object\n   * @return {String} new variantId\n   */\n  \"products/createVariant\"(parentId, newVariant) {\n    check(parentId, String);\n    check(newVariant, Match.Optional(Object)); // Check first if Product exists and then if user has the rights\n\n    const product = Products.findOne(parentId);\n\n    if (!product) {\n      throw new Meteor.Error(\"not-found\", \"Product not found\");\n    } else if (!Reaction.hasPermission(\"createProduct\", this.userId, product.shopId)) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    const newVariantId = Random.id(); // get parent ancestors to build new ancestors array\n\n    const {\n      ancestors\n    } = product; // Verify that the parent variant and any ancestors are not deleted.\n    // Child variants cannot be added if a parent product or product revision\n    // is marked as `{ isDeleted: true }`\n\n    if (ReactionProduct.isAncestorDeleted(product, true)) {\n      throw new Meteor.Error(\"server-error\", \"Unable to create product variant\");\n    }\n\n    Array.isArray(ancestors) && ancestors.push(parentId);\n    const assembledVariant = Object.assign(newVariant || {}, {\n      _id: newVariantId,\n      ancestors,\n      type: \"variant\"\n    });\n\n    if (!newVariant) {\n      Object.assign(assembledVariant, {\n        title: `${product.title} - Untitled option`,\n        price: 0.00\n      });\n    } // if we are inserting child variant to top-level variant, we need to remove\n    // all top-level's variant inventory records and flush it's quantity,\n    // because it will be hold sum of all it descendants quantities.\n\n\n    if (ancestors.length === 2) {\n      flushQuantity(parentId);\n    }\n\n    Hooks.Events.run(\"beforeInsertCatalogProduct\", assembledVariant);\n\n    const _id = Products.insert(assembledVariant);\n\n    Hooks.Events.run(\"afterInsertCatalogProduct\", assembledVariant);\n    Hooks.Events.run(\"afterInsertCatalogProductInsertRevision\", Products.findOne({\n      _id\n    }));\n    Logger.debug(`products/createVariant: created variant: ${newVariantId} for ${parentId}`);\n    return newVariantId;\n  },\n\n  /**\n   * @name products/updateVariant\n   * @memberof Methods/Products\n   * @method\n   * @summary update individual variant with new values, merges into original\n   * only need to supply updated information. Currently used for a one use case\n   * - to manage top-level variant autoform.\n   * @param {Object} variant - current variant object\n   * @todo some use cases of this method was moved to \"products/\n   * updateProductField\", but it still used\n   * @return {Number} returns update result\n   */\n  \"products/updateVariant\"(variant) {\n    check(variant, Object); // Check first if Variant exists and then if user has the right to clone it\n\n    const currentVariant = Products.findOne(variant._id);\n\n    if (!currentVariant) {\n      throw new Meteor.Error(\"not-found\", \"Variant not found\");\n    }\n\n    if (!Reaction.hasPermission(\"createProduct\", this.userId, currentVariant.shopId)) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    const newVariant = Object.assign({}, currentVariant, variant);\n    const variantUpdateResult = updateCatalogProduct(this.userId, {\n      _id: variant._id\n    }, {\n      $set: newVariant\n    }, {\n      selector: {\n        type: currentVariant.type\n      },\n      validate: false\n    });\n    const productId = currentVariant.ancestors[0]; // we need manually check is these fields were updated?\n    // we can't stop after successful denormalization, because we have a\n    // case when several fields could be changed in top-level variant\n    // before form will be submitted.\n\n    toDenormalize.forEach(field => {\n      if (currentVariant[field] !== variant[field]) {\n        denormalize(productId, field);\n      }\n    });\n    return variantUpdateResult;\n  },\n\n  /**\n   * @name products/deleteVariant\n   * @memberof Methods/Products\n   * @method\n   * @summary delete variant, which should also delete child variants\n   * @param {String} variantId - variantId to delete\n   * @returns {Boolean} returns update results: `true` - if at least one variant\n   * was removed or `false` if nothing was removed\n   */\n  \"products/deleteVariant\"(variantId) {\n    check(variantId, String); // Check first if Variant exists and then if user has the right to delete it\n\n    const variant = Products.findOne(variantId);\n\n    if (!variant) {\n      throw new Meteor.Error(\"not-found\", \"Variant not found\");\n    } else if (!Reaction.hasPermission(\"createProduct\", this.userId, variant.shopId)) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    const selector = {\n      // Don't \"archive\" variants that are already marked deleted.\n      isDeleted: {\n        $in: [false, undefined]\n      },\n      $or: [{\n        _id: variantId\n      }, {\n        ancestors: {\n          $in: [variantId]\n        }\n      }]\n    };\n    const toDelete = Products.find(selector).fetch(); // out if nothing to delete\n\n    if (!Array.isArray(toDelete) || toDelete.length === 0) return false; // Flag the variant and all its children as deleted in Revisions collection.\n\n    toDelete.forEach(product => {\n      Hooks.Events.run(\"beforeRemoveCatalogProduct\", product, {\n        userId: this.userId\n      });\n      Hooks.Events.run(\"afterRemoveCatalogProduct\", this.userId, product);\n    }); // After variant was removed from product, we need to recalculate all\n    // denormalized fields\n\n    const productId = toDelete[0].ancestors[0];\n    toDenormalize.forEach(field => denormalize(productId, field));\n    Logger.debug(`Flagged variant and all its children as deleted.`);\n    return true;\n  },\n\n  /**\n   * @name products/cloneProduct\n   * @memberof Methods/Products\n   * @method\n   * @summary clone a whole product, defaulting visibility, etc\n   * in the future we are going to do an inheritance product\n   * that maintains relationships with the cloned product tree\n   * @param {Array} productOrArray - products array to clone\n   * @returns {Array} returns insert results\n   */\n  \"products/cloneProduct\"(productOrArray) {\n    check(productOrArray, Match.OneOf(Array, Object)); // REVIEW: This check may be unnecessary now - checks that user has permission to clone\n    // for active shop\n\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    if (Array.isArray(productOrArray)) {\n      // Reduce to unique shops found among producs in this array\n      const shopIds = productOrArray.map(prod => prod.shopId);\n      const uniqueShopIds = [...new Set(shopIds)]; // For each unique shopId check to make sure that user has permission to clone\n\n      uniqueShopIds.forEach(shopId => {\n        if (!Reaction.hasPermission(\"createProduct\", this.userId, shopId)) {\n          throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n        }\n      });\n    } else if (!Reaction.hasPermission(\"createProduct\", this.userId, productOrArray.shopId)) {\n      // Single product was passed in - ensure that user has permission to clone\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    let result;\n    let products;\n    const results = [];\n    const pool = []; // pool of id pairs: { oldId, newId }\n\n    function getIds(id) {\n      return pool.filter(function (pair) {\n        return pair.oldId === this.id;\n      }, {\n        id\n      });\n    }\n\n    function setId(ids) {\n      return pool.push(ids);\n    }\n\n    function buildAncestors(ancestors) {\n      const newAncestors = [];\n      ancestors.map(oldId => {\n        const pair = getIds(oldId); // TODO do we always have newId on this step?\n\n        newAncestors.push(pair[0].newId);\n        return newAncestors;\n      });\n      return newAncestors;\n    }\n\n    if (!Array.isArray(productOrArray)) {\n      products = [productOrArray];\n    } else {\n      products = productOrArray;\n    }\n\n    for (const product of products) {\n      // cloning product\n      const productNewId = Random.id();\n      setId({\n        oldId: product._id,\n        newId: productNewId\n      });\n      const newProduct = Object.assign({}, product, {\n        _id: productNewId // ancestors: product.ancestors.push(product._id)\n\n      });\n      delete newProduct.updatedAt;\n      delete newProduct.createdAt;\n      delete newProduct.publishedAt;\n      delete newProduct.positions;\n      delete newProduct.handle;\n      newProduct.isVisible = false;\n\n      if (newProduct.title) {\n        // todo test this\n        newProduct.title = createTitle(newProduct.title, newProduct._id);\n        newProduct.handle = createHandle(Reaction.getSlug(newProduct.title), newProduct._id);\n      }\n\n      Hooks.Events.run(\"beforeInsertCatalogProductInsertRevision\", newProduct);\n      result = Products.insert(newProduct, {\n        validate: false\n      });\n      Hooks.Events.run(\"afterInsertCatalogProduct\", newProduct);\n      results.push(result); // cloning variants\n\n      const variants = Products.find({\n        ancestors: {\n          $in: [product._id]\n        },\n        type: \"variant\"\n      }).fetch(); // why we are using `_.sortBy` described in `products/cloneVariant`\n\n      const sortedVariants = _sortBy(variants, doc => doc.ancestors.length);\n\n      for (const variant of sortedVariants) {\n        const variantNewId = Random.id();\n        setId({\n          oldId: variant._id,\n          newId: variantNewId\n        });\n        const ancestors = buildAncestors(variant.ancestors);\n        const newVariant = Object.assign({}, variant, {\n          _id: variantNewId,\n          ancestors\n        });\n        delete newVariant.updatedAt;\n        delete newVariant.createdAt;\n        delete newVariant.publishedAt; // TODO can variant have this param?\n\n        Hooks.Events.run(\"beforeInsertCatalogProductInsertRevision\", newVariant);\n        result = Products.insert(newVariant, {\n          validate: false\n        });\n        Hooks.Events.run(\"afterInsertCatalogProduct\", newVariant);\n        copyMedia(productNewId, variant._id, variantNewId);\n        results.push(result);\n      }\n    }\n\n    return results;\n  },\n\n  /**\n   * @name products/createProduct\n   * @memberof Methods/Products\n   * @method\n   * @summary when we create a new product, we create it with an empty variant.\n   * all products have a variant with pricing and details\n   * @param {Object} [product] - optional product object\n   * @return {String} The new product ID\n   */\n  \"products/createProduct\"(product) {\n    check(product, Match.Optional(Object)); // Ensure user has createProduct permission for active shop\n\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    } // also if a product is provided, check first that the user doesn't mock a shop with no permissions to it\n\n\n    if (product) {\n      if (!product.shopId || !Reaction.hasPermission(\"createProduct\", this.userId, product.shopId)) {\n        throw new Meteor.Error(\"invalid-parameter\", \"Product should have a valid shopId\");\n      } // Create product revision\n\n\n      Hooks.Events.run(\"beforeInsertCatalogProductInsertRevision\", product);\n      return Products.insert(product);\n    }\n\n    const newSimpleProduct = createProduct(); // Create simple product revision\n\n    Hooks.Events.run(\"afterInsertCatalogProductInsertRevision\", newSimpleProduct);\n    const newVariant = createProduct({\n      ancestors: [newSimpleProduct._id],\n      price: 0.00,\n      title: \"\",\n      type: \"variant\" // needed for multi-schema\n\n    }); // Create variant revision\n\n    Hooks.Events.run(\"afterInsertCatalogProductInsertRevision\", newVariant);\n    return newSimpleProduct._id;\n  },\n\n  /**\n   * @name products/archiveProduct\n   * @memberof Methods/Products\n   * @method\n   * @summary archive a product and unlink it from all media\n   * @param {String} productId - productId to delete\n   * @returns {Number} returns number of removed products\n   */\n  \"products/archiveProduct\"(productId) {\n    check(productId, Match.OneOf(Array, String));\n    let extractedProductId;\n\n    if (Array.isArray(productId)) {\n      [extractedProductId] = productId;\n    } // Check first if Product exists and then if user has the right to delete it\n\n\n    const product = Products.findOne(extractedProductId || productId);\n\n    if (!product) {\n      throw new Meteor.Error(\"not-found\", \"Product not found\");\n    } else if (!Reaction.hasPermission(\"createProduct\", this.userId, product.shopId)) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    let productIds;\n\n    if (!Array.isArray(productId)) {\n      productIds = [productId];\n    } else {\n      productIds = productId;\n    }\n\n    const productsWithVariants = Products.find({\n      // Don't \"archive\" products that are already marked deleted.\n      isDeleted: {\n        $in: [false, undefined]\n      },\n      $or: [{\n        _id: {\n          $in: productIds\n        }\n      }, {\n        ancestors: {\n          $in: productIds\n        }\n      }]\n    }).fetch();\n    const ids = [];\n    productsWithVariants.map(doc => {\n      ids.push(doc._id);\n      return ids;\n    }); // Flag the product and all its variants as deleted in the Revisions collection.\n\n    productsWithVariants.forEach(toArchiveProduct => {\n      Hooks.Events.run(\"beforeRemoveCatalogProduct\", toArchiveProduct, {\n        userId: this.userId\n      });\n      Hooks.Events.run(\"afterRemoveCatalogProduct\", this.userId, toArchiveProduct);\n    });\n    const numFlaggedAsDeleted = Revisions.find({\n      \"documentId\": {\n        $in: ids\n      },\n      \"documentData.isDeleted\": true\n    }).count();\n\n    if (numFlaggedAsDeleted > 0) {\n      // Flag associated MediaRecords as deleted.\n      MediaRecords.update({\n        \"metadata.productId\": {\n          $in: ids\n        },\n        \"metadata.variantId\": {\n          $in: ids\n        }\n      }, {\n        $set: {\n          \"metadata.isDeleted\": true\n        }\n      });\n      return numFlaggedAsDeleted;\n    }\n\n    Logger.debug(`${numFlaggedAsDeleted} products have been flagged as deleted`);\n  },\n\n  /**\n   * @name products/updateProductField\n   * @memberof Methods/Products\n   * @method\n   * @summary update single product or variant field\n   * @param {String} _id - product._id or variant._id to update\n   * @param {String} field - key to update\n   * @param {*} value - update property value\n   * @todo rename it to something like \"products/updateField\" to  reflect\n   * @todo we need to know which type of entity field belongs. For that we could\n   * do something like: const type = Products.findOne(_id).type or transmit type\n   * as param if it possible\n   * latest changes. its used for products and variants\n   * @return {Number} returns update result\n   */\n  \"products/updateProductField\"(_id, field, value) {\n    check(_id, String);\n    check(field, String);\n    check(value, Match.OneOf(String, Object, Array, Boolean, Number)); // Must have createProduct permission for active shop\n\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    } // Check first if Product exists and then if user has the right to alter it\n\n\n    const doc = Products.findOne(_id);\n\n    if (!doc) {\n      throw new Meteor.Error(\"not-found\", \"Product not found\");\n    } else if (!Reaction.hasPermission(\"createProduct\", this.userId, doc.shopId)) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    const {\n      type\n    } = doc;\n    let update; // handle booleans with correct typing\n\n    if (value === \"false\" || value === \"true\") {\n      const booleanValue = value === \"true\" || value === true;\n      update = EJSON.parse(`{\"${field}\":${booleanValue}}`);\n    } else if (field === \"handle\") {\n      update = {\n        // TODO: write function to ensure new handle is unique.\n        // Should be a call similar to the line below.\n        [field]: createHandle(value, _id) // handle should be unique\n\n      };\n    } else if (field === \"title\" && doc.handle === doc._id) {\n      // update handle once title is set\n      const handle = createHandle(Reaction.getSlug(value), _id);\n      update = {\n        [field]: value,\n        handle\n      };\n    } else {\n      const stringValue = EJSON.stringify(value);\n      update = EJSON.parse(`{\"${field}\":${stringValue}}`);\n    } // we need to use sync mode here, to return correct error and result to UI\n\n\n    let result;\n\n    try {\n      result = updateCatalogProduct(this.userId, {\n        _id\n      }, {\n        $set: update\n      }, {\n        selector: {\n          type\n        }\n      });\n    } catch (e) {\n      throw new Meteor.Error(\"server-error\", e.message);\n    } // If we get a result from the product update,\n    // meaning the update went past revision control,\n    // denormalize and attach results to top-level product\n\n\n    if (result === 1) {\n      if (type === \"variant\" && toDenormalize.indexOf(field) >= 0) {\n        denormalize(doc.ancestors[0], field);\n      }\n    }\n\n    return result;\n  },\n\n  /**\n   * @name products/updateProductTags\n   * @memberof Methods/Products\n   * @method\n   * @summary method to insert or update tag with hierarchy\n   * @param {String} productId - productId\n   * @param {String} tagName - tagName\n   * @param {String} tagId - tagId\n   * @return {Number} return result\n   */\n  \"products/updateProductTags\"(productId, tagName, tagId) {\n    check(productId, String);\n    check(tagName, String);\n    check(tagId, Match.OneOf(String, null)); // Check first if Product exists and then if user has the right to alter it\n\n    const product = Products.findOne(productId);\n\n    if (!product) {\n      throw new Meteor.Error(\"not-found\", \"Product not found\");\n    } else if (!Reaction.hasPermission(\"createProduct\", this.userId, product.shopId)) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    this.unblock();\n    const newTag = {\n      slug: Reaction.getSlug(tagName),\n      name: tagName\n    };\n    const existingTag = Tags.findOne({\n      slug: Reaction.getSlug(tagName)\n    });\n\n    if (existingTag) {\n      const productCount = Products.find({\n        _id: productId,\n        hashtags: existingTag._id\n      }).count();\n\n      if (productCount > 0) {\n        throw new Meteor.Error(\"server-error\", \"Existing Tag, Update Denied\");\n      }\n\n      return updateCatalogProduct(this.userId, {\n        _id: productId\n      }, {\n        $push: {\n          hashtags: existingTag._id\n        }\n      }, {\n        selector: {\n          type: \"simple\"\n        }\n      });\n    } else if (tagId) {\n      return Tags.update(tagId, {\n        $set: newTag\n      });\n    }\n\n    const newTagId = Meteor.call(\"shop/createTag\", tagName, false); // if result is an Error object, we return it immediately\n\n    if (typeof newTagId !== \"string\") {\n      return newTagId;\n    }\n\n    return updateCatalogProduct(this.userId, {\n      _id: productId\n    }, {\n      $push: {\n        hashtags: newTagId\n      }\n    }, {\n      selector: {\n        type: \"simple\"\n      }\n    });\n  },\n\n  /**\n   * @name products/removeProductTag\n   * @memberof Methods/Products\n   * @method\n   * @summary method to remove tag from product\n   * @param {String} productId - productId\n   * @param {String} tagId - tagId\n   * @return {String} return update result\n   */\n  \"products/removeProductTag\"(productId, tagId) {\n    check(productId, String);\n    check(tagId, String); // Check first if Product exists and then if user has the right to alter it\n\n    const product = Products.findOne(productId);\n\n    if (!product) {\n      throw new Meteor.Error(\"not-found\", \"Product not found\");\n    } else if (!Reaction.hasPermission(\"createProduct\", this.userId, product.shopId)) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    updateCatalogProduct(this.userId, {\n      _id: productId\n    }, {\n      $pull: {\n        hashtags: tagId\n      }\n    }, {\n      selector: {\n        type: \"simple\"\n      }\n    });\n  },\n\n  /**\n   * @name products/setHandle\n   * @memberof Methods/Products\n   * @method\n   * @summary copy of \"products/setHandleTag\", but without tag\n   * @param {String} productId - productId\n   * @returns {String} handle - product handle\n   */\n  \"products/setHandle\"(productId) {\n    check(productId, String); // Check first if Product exists and then if user has the right to alter it\n\n    const product = Products.findOne(productId);\n\n    if (!product) {\n      throw new Meteor.Error(\"not-found\", \"Product not found\");\n    } else if (!Reaction.hasPermission(\"createProduct\", this.userId, product.shopId)) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    let handle = Reaction.getSlug(product.title);\n    handle = createHandle(handle, product._id);\n    updateCatalogProduct(this.userId, {\n      _id: product._id\n    }, {\n      $set: {\n        handle,\n        type: \"simple\"\n      }\n    });\n    return handle;\n  },\n\n  /**\n   * @name products/setHandleTag\n   * @memberof Methods/Products\n   * @method\n   * @summary set or toggle product handle\n   * @param {String} productId - productId\n   * @param {String} tagId - tagId\n   * @return {String} return update result\n   */\n  \"products/setHandleTag\"(productId, tagId) {\n    check(productId, String);\n    check(tagId, String); // Check first if Product exists and then if user has the right to alter it\n\n    const product = Products.findOne(productId);\n\n    if (!product) {\n      throw new Meteor.Error(\"not-found\", \"Product not found\");\n    } else if (!Reaction.hasPermission(\"createProduct\", this.userId, product.shopId)) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    function getSet(handle) {\n      return {\n        $set: {\n          handle,\n          type: \"simple\"\n        }\n      };\n    }\n\n    const tag = Tags.findOne(tagId); // set handle\n\n    if (product.handle === tag.slug) {\n      let handle = Reaction.getSlug(product.title);\n      handle = createHandle(handle, product._id);\n      Products.update(product._id, getSet(handle));\n      return handle;\n    } // toggle handle\n\n\n    const existingHandles = Products.find({\n      handle: tag.slug\n    }).fetch(); // this is needed to take care about product's handle which(product) was\n    // previously tagged.\n\n    for (const currentProduct of existingHandles) {\n      const currentProductHandle = createHandle(Reaction.getSlug(currentProduct.title), currentProduct._id);\n      updateCatalogProduct(this.userId, {\n        _id: currentProduct._id\n      }, getSet(currentProductHandle));\n    }\n\n    updateCatalogProduct(this.userId, {\n      _id: product._id\n    }, getSet(tag.slug));\n    return tag.slug;\n  },\n\n  /**\n   * @name products/updateProductPosition\n   * @memberof Methods/Products\n   * @method\n   * @summary update product grid positions\n   * @param {String} productId - productId\n   * @param {Object} positionData -  an object with position,dimensions\n   * @param {String} tag - current route name. If it is not tag, then we using\n   * shop name as base `positions` name. Could be useful for multi-shopping.\n   * @return {Number} collection update returns\n   */\n  \"products/updateProductPosition\"(productId, positionData, tag) {\n    check(productId, String);\n    check(positionData, Object);\n    check(tag, String); // Check first if Product exists and then if user has the proper rights\n\n    const product = Products.findOne(productId);\n\n    if (!product) {\n      throw new Meteor.Error(\"not-found\", \"Product not found\");\n    } else if (!Reaction.hasPermission(\"createProduct\", this.userId, product.shopId)) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    this.unblock();\n    const position = `positions.${tag}.position`;\n    const pinned = `positions.${tag}.pinned`;\n    const weight = `positions.${tag}.weight`;\n    const updatedAt = `positions.${tag}.updatedAt`;\n    return updateCatalogProduct(this.userId, {\n      _id: productId\n    }, {\n      $set: {\n        [position]: positionData.position,\n        [pinned]: positionData.pinned,\n        [weight]: positionData.weight,\n        [updatedAt]: new Date(),\n        type: \"simple\" // for multi-schema\n\n      }\n    });\n  },\n\n  /**\n   * @name products/updateVariantsPosition\n   * @memberof Methods/Products\n   * @method\n   * @description updates top level variant position index\n   * @param {Array} sortedVariantIds - array of top level variant `_id`s\n   * @since 0.11.0\n   * @return {Number} Products.update result\n   */\n  \"products/updateVariantsPosition\"(sortedVariantIds) {\n    check(sortedVariantIds, [String]); // This checks to make sure the user has createProduct permissions for the active shop.\n    // TODO: We should determine if that is the correct role that a user should have\n    // to be permitted to re-arrange products on the grid\n\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    sortedVariantIds.forEach((id, index) => {\n      updateCatalogProduct(this.userId, {\n        _id: id\n      }, {\n        $set: {\n          index\n        }\n      }, {\n        selector: {\n          type: \"variant\"\n        }\n      });\n      Logger.debug(`Variant ${id} position was updated to index ${index}`);\n    });\n  },\n\n  /**\n   * @name products/updateMetaFields\n   * @memberof Methods/Products\n   * @method\n   * @summary update product metafield\n   * @param {String} productId - productId\n   * @param {Object} updatedMeta - update object with metadata\n   * @param {Object|Number|undefined|null} meta - current meta object, or a number index\n   * @todo should this method works for variants also?\n   * @return {Number} collection update result\n   */\n  \"products/updateMetaFields\"(productId, updatedMeta, meta) {\n    check(productId, String);\n    check(updatedMeta, Object);\n    check(meta, Match.OneOf(Object, Number, undefined, null)); // Check first if Product exists and then if user has the proper rights\n\n    const product = Products.findOne(productId);\n\n    if (!product) {\n      throw new Meteor.Error(\"not-found\", \"Product not found\");\n    } else if (!Reaction.hasPermission(\"createProduct\", this.userId, product.shopId)) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    } // update existing metadata\n\n\n    if (typeof meta === \"object\") {\n      return updateCatalogProduct(this.userId, {\n        _id: productId,\n        metafields: meta\n      }, {\n        $set: {\n          \"metafields.$\": updatedMeta\n        }\n      }, {\n        selector: {\n          type: \"simple\",\n          metafields: meta\n        }\n      });\n    } else if (typeof meta === \"number\") {\n      return updateCatalogProduct(this.userId, {\n        _id: productId\n      }, {\n        $set: {\n          [`metafields.${meta}`]: updatedMeta\n        }\n      }, {\n        selector: {\n          type: \"simple\",\n          metafields: meta\n        }\n      });\n    } // adds metadata\n\n\n    return updateCatalogProduct(this.userId, {\n      _id: productId\n    }, {\n      $addToSet: {\n        metafields: updatedMeta\n      }\n    }, {\n      selector: {\n        type: \"simple\"\n      }\n    });\n  },\n\n  /**\n   * @name products/removeMetaFields\n   * @memberof Methods/Products\n   * @method\n   * @summary update product metafield\n   * @param {String} productId - productId\n   * @param {Object} metafields - metadata object to remove\n   * @param {Object} type - optional product type for schema selection\n   * @return {Number} collection update result\n   */\n  \"products/removeMetaFields\"(productId, metafields, type = \"simple\") {\n    check(productId, String);\n    check(metafields, Object);\n    check(type, String); // Check first if Product exists and then if user has the proper rights\n\n    const product = Products.findOne(productId);\n\n    if (!product) {\n      throw new Meteor.Error(\"not-found\", \"Product not found\");\n    } else if (!Reaction.hasPermission(\"createProduct\", this.userId, product.shopId)) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    return updateCatalogProduct(this.userId, {\n      _id: productId,\n      type\n    }, {\n      $pull: {\n        metafields\n      }\n    });\n  },\n\n  /**\n   * @name products/publishProduct\n   * @memberof Methods/Products\n   * @method\n   * @summary publish (visibility) of product\n   * @todo hook into publishing flow\n   * @param {String} productId - productId\n   * @return {Boolean} product.isVisible\n   */\n  \"products/publishProduct\"(productId) {\n    check(productId, String); // Check first if Product exists and then if user has the proper rights\n\n    const product = Products.findOne(productId);\n\n    if (!product) {\n      throw new Meteor.Error(\"not-found\", \"Product not found\");\n    } else if (!Reaction.hasPermission(\"createProduct\", this.userId, product.shopId)) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    const variants = Products.find({\n      ancestors: {\n        $in: [productId]\n      }\n    }).fetch();\n    let variantValidator = true;\n\n    if (typeof product === \"object\" && product.title.length > 1) {\n      if (variants.length > 0) {\n        variants.forEach(variant => {\n          // if this is a top variant with children, we avoid it to check price\n          // because we using price of its children\n          if (variant.ancestors.length === 1 && !Catalog.getVariants(variant._id, \"variant\").length || variant.ancestors.length !== 1) {\n            if (!(typeof variant.price === \"number\" && variant.price > 0)) {\n              variantValidator = false;\n            }\n          } // if variant has no title\n\n\n          if (typeof variant.title === \"string\" && !variant.title.length) {\n            variantValidator = false;\n          }\n\n          if (typeof variant.optionTitle === \"string\" && !variant.optionTitle.length) {\n            variantValidator = false;\n          }\n        });\n      } else {\n        Logger.debug(\"invalid product visibility \", productId);\n        throw new Meteor.Error(\"invalid-parameter\", \"Variant is required\");\n      }\n\n      if (!variantValidator) {\n        Logger.debug(\"invalid product visibility \", productId);\n        throw new Meteor.Error(\"invalid-parameter\", \"Some properties are missing.\");\n      } // update product visibility\n\n\n      Logger.debug(\"toggle product visibility \", product._id, !product.isVisible);\n      const res = updateCatalogProduct(this.userId, {\n        _id: product._id\n      }, {\n        $set: {\n          isVisible: !product.isVisible\n        }\n      }, {\n        selector: {\n          type: \"simple\"\n        }\n      }); // update product variants visibility\n\n      updateVariantProductField(variants, \"isVisible\", !product.isVisible); // if collection updated we return new `isVisible` state\n\n      return res === 1 && !product.isVisible;\n    }\n\n    Logger.debug(\"invalid product visibility \", productId);\n    throw new Meteor.Error(\"invalid-parameter\", \"Bad Request\");\n  },\n\n  /**\n   * @name products/toggleVisibility\n   * @memberof Methods/Products\n   * @method\n   * @summary publish (visibility) of product\n   * @todo hook into publishing flow\n   * @param {String} productId - productId\n   * @return {Boolean} product.isVisible\n   */\n  \"products/toggleVisibility\"(productId) {\n    check(productId, String); // Check first if Product exists and then if user has the proper rights\n\n    const product = Products.findOne(productId);\n\n    if (!product) {\n      throw new Meteor.Error(\"not-found\", \"Product not found\");\n    }\n\n    if (!Reaction.hasPermission(\"createProduct\", this.userId, product.shopId)) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    const res = updateCatalogProduct(this.userId, {\n      _id: productId\n    }, {\n      $set: {\n        isVisible: !product.isVisible\n      }\n    }, {\n      selector: {\n        type: product.type\n      }\n    });\n\n    if (Array.isArray(product.ancestors) && product.ancestors.length) {\n      const updateId = product.ancestors[0] || product._id;\n      const updatedPriceRange = ReactionProduct.getProductPriceRange(updateId);\n      Meteor.call(\"products/updateProductField\", updateId, \"price\", updatedPriceRange);\n    } // if collection updated we return new `isVisible` state\n\n\n    return res === 1 && !product.isVisible;\n  }\n\n});","map":{"version":3,"sources":["server/methods/catalog.js"],"names":["_sortBy","module","watch","require","default","v","check","Match","Random","EJSON","Meteor","ReactionProduct","Catalog","ProductRevision","Hooks","Logger","Reaction","MediaRecords","Products","Revisions","Tags","Media","updateVariantProductField","variants","field","value","map","variant","call","_id","toDenormalize","createTitle","newTitle","productId","title","titleCount","find","$nin","count","titleNumberSuffix","titleString","copySuffix","match","String","replace","createHandle","productHandle","handle","handleCount","handleNumberSuffix","handleString","newHandleCount","copyMedia","newId","variantOldId","variantNewId","then","fileRecords","forEach","fileRecord","fullClone","variantId","catch","error","denormalize","id","doc","findOne","type","getTopVariants","ancestors","length","getVariants","update","Object","assign","isSoldOut","isLowQuantity","isBackorder","priceObject","getProductPriceRange","price","$set","selector","every","inventoryManagement","inventoryPolicy","getVariantQuantity","some","quantity","lowInventoryWarningThreshold","inventoryQuantity","flushQuantity","productUpdate","createProduct","props","insert","validate","newProduct","Events","run","updateCatalogProduct","userId","modifier","validation","product","shouldUpdateProduct","result","debug","methods","Error","hasPermission","shopId","isAncestorDeleted","$or","$in","isDeleted","fetch","sortedVariants","sortedVariant","oldId","clone","optionTitle","compareAtPrice","parentIndex","indexOf","ancestorsClone","slice","splice","height","width","weight","updatedAt","createdAt","parentId","newVariant","Optional","newVariantId","Array","isArray","push","assembledVariant","currentVariant","variantUpdateResult","undefined","toDelete","productOrArray","OneOf","shopIds","prod","uniqueShopIds","Set","products","results","pool","getIds","filter","pair","setId","ids","buildAncestors","newAncestors","productNewId","publishedAt","positions","isVisible","getSlug","newSimpleProduct","extractedProductId","productIds","productsWithVariants","toArchiveProduct","numFlaggedAsDeleted","Boolean","Number","booleanValue","parse","stringValue","stringify","e","message","tagName","tagId","unblock","newTag","slug","name","existingTag","productCount","hashtags","$push","newTagId","$pull","getSet","tag","existingHandles","currentProduct","currentProductHandle","positionData","position","pinned","Date","sortedVariantIds","index","updatedMeta","meta","metafields","$addToSet","variantValidator","res","updateId","updatedPriceRange"],"mappings":"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","sourcesContent":["import _ from \"lodash\";\nimport { check, Match } from \"meteor/check\";\nimport { Random } from \"meteor/random\";\nimport { EJSON } from \"meteor/ejson\";\nimport { Meteor } from \"meteor/meteor\";\nimport { ReactionProduct } from \"/lib/api\";\nimport { ProductRevision as Catalog } from \"/imports/plugins/core/revisions/server/hooks\";\nimport { Hooks, Logger, Reaction } from \"/server/api\";\nimport { MediaRecords, Products, Revisions, Tags } from \"/lib/collections\";\nimport { Media } from \"/imports/plugins/core/files/server\";\n\n/* eslint new-cap: 0 */\n/* eslint no-loop-func: 0 */\n/* eslint quotes: 0 */\n\n/**\n * @file Methods for Products. Run these methods using `Meteor.call()`.\n *\n *\n * @namespace Methods/Products\n*/\n\n/**\n * updateVariantProductField\n * @private\n * @summary updates the variant\n * @param {Array} variants - the array of variants\n * @param {String} field - the field to update\n * @param {String} value - the value to add\n * @return {Array} - return an array\n */\nfunction updateVariantProductField(variants, field, value) {\n  return variants.map((variant) => Meteor.call(\"products/updateProductField\", variant._id, field, value));\n}\n\n/**\n * @array toDenormalize\n * @private\n * @summary contains a list of fields, which should be denormalized\n * @type {string[]}\n */\nconst toDenormalize = [\n  \"price\",\n  \"inventoryQuantity\",\n  \"lowInventoryWarningThreshold\",\n  \"inventoryPolicy\",\n  \"inventoryManagement\"\n];\n\n/**\n * @function createTitle\n * @private\n * @description Recursive method which trying to find a new `title`, given the\n * existing copies\n * @param {String} newTitle - product `title`\n * @param {String} productId - current product `_id`\n * @return {String} title - modified `title`\n */\nfunction createTitle(newTitle, productId) {\n  // exception product._id needed for cases then double triggering happens\n  let title = newTitle || \"\";\n  const titleCount = Products.find({\n    title,\n    _id: {\n      $nin: [productId]\n    }\n  }).count();\n  // current product \"copy\" number\n  let titleNumberSuffix = 0;\n  // product handle prefix\n  let titleString = title;\n  // copySuffix \"-copy-number\" suffix of product\n  const copySuffix = titleString.match(/-copy-\\d+$/) || titleString.match(/-copy$/);\n  // if product is a duplicate, we should take the copy number, and cut\n  // the handle\n  if (copySuffix) {\n    // we can have two cases here: copy-number and just -copy. If there is\n    // no numbers in copySuffix then we should put 1 in handleNumberSuffix\n    titleNumberSuffix = +String(copySuffix).match(/\\d+$/) || 1;\n    // removing last numbers and last \"-\" if it presents\n    titleString = title.replace(/\\d+$/, '').replace(/-$/, '');\n  }\n\n  // if we have more than one product with the same handle, we should mark\n  // it as \"copy\" or increment our product handle if it contain numbers.\n  if (titleCount > 0) {\n    // if we have product with name like \"product4\", we should take care\n    // about its uniqueness\n    if (titleNumberSuffix > 0) {\n      title = `${titleString}-${titleNumberSuffix + titleCount}`;\n    } else {\n      // first copy will be \"...-copy\", second: \"...-copy-2\"\n      title = `${titleString}-copy${titleCount > 1 ? `-${titleCount}` : \"\"}`;\n    }\n  }\n\n  // we should check again if there are any new matches with DB\n  if (Products.find({\n    title\n  }).count() !== 0) {\n    title = createTitle(title, productId);\n  }\n  return title;\n}\n\n/**\n * @function createHandle\n * @private\n * @description Recursive method which trying to find a new `handle`, given the\n * existing copies\n * @param {String} productHandle - product `handle`\n * @param {String} productId - current product `_id`\n * @return {String} handle - modified `handle`\n */\nfunction createHandle(productHandle, productId) {\n  let handle = productHandle || \"\";\n  // exception product._id needed for cases then double triggering happens\n  const handleCount = Products.find({\n    handle,\n    _id: {\n      $nin: [productId]\n    }\n  }).count();\n  // current product \"copy\" number\n  let handleNumberSuffix = 0;\n  // product handle prefix\n  let handleString = handle;\n  // copySuffix \"-copy-number\" suffix of product\n  const copySuffix = handleString.match(/-copy-\\d+$/) || handleString.match(/-copy$/);\n\n  // if product is a duplicate, we should take the copy number, and cut\n  // the handle\n  if (copySuffix) {\n    // we can have two cases here: copy-number and just -copy. If there is\n    // no numbers in copySuffix then we should put 1 in handleNumberSuffix\n    handleNumberSuffix = +String(copySuffix).match(/\\d+$/) || 1;\n    // removing last numbers and last \"-\" if it presents\n    handleString = handle.replace(/\\d+$/, '').replace(/-$/, '');\n  }\n\n  // if we have more than one product with the same handle, we should mark\n  // it as \"copy\" or increment our product handle if it contain numbers.\n  if (handleCount > 0) {\n    // if we have product with name like \"product4\", we should take care\n    // about its uniqueness\n    if (handleNumberSuffix > 0) {\n      handle = `${handleString}-${handleNumberSuffix + handleCount}`;\n    } else {\n      // first copy will be \"...-copy\", second: \"...-copy-2\"\n      handle = `${handleString}-copy${handleCount > 1 ? `-${handleCount}` : ''}`;\n    }\n  }\n\n  // we should check again if there are any new matches with DB\n  // exception product._id needed for cases then double triggering happens\n  const newHandleCount = Products.find({\n    handle,\n    _id: {\n      $nin: [productId]\n    }\n  }).count();\n\n  if (newHandleCount !== 0) {\n    handle = createHandle(handle, productId);\n  }\n\n  return handle;\n}\n\n/**\n * @function copyMedia\n * @private\n * @description copy images links to cloned variant from original\n * @param {String} newId - [cloned|original] product _id\n * @param {String} variantOldId - old variant _id\n * @param {String} variantNewId - - cloned variant _id\n * @return {undefined}\n */\nfunction copyMedia(newId, variantOldId, variantNewId) {\n  Media.find({\n    \"metadata.variantId\": variantOldId\n  })\n    .then((fileRecords) => {\n      fileRecords.forEach((fileRecord) => {\n        // Copy File and insert directly, bypasing revision control\n        fileRecord.fullClone({\n          productId: newId,\n          variantId: variantNewId\n        }).catch((error) => {\n          Logger.error(`Error in copyMedia for product ${newId}`, error);\n        });\n      });\n    })\n    .catch((error) => {\n      Logger.error(`Error in copyMedia for product ${newId}`, error);\n    });\n}\n\n/**\n * @function denormalize\n * @private\n * @description With flattened model we do not want to get variant docs in\n * `products` publication, but we need some data from variants to display price,\n * quantity, etc. That's why we are denormalizing these properties into product\n * doc. Also, this way should have a speed benefit comparing the way where we\n * could dynamically build denormalization inside `products` publication.\n * @summary update product denormalized properties if variant was updated or\n * removed\n * @param {String} id - product _id\n * @param {String} field - type of field. Could be:\n * \"price\",\n * \"inventoryQuantity\",\n * \"inventoryManagement\",\n * \"inventoryPolicy\",\n * \"lowInventoryWarningThreshold\"\n * @since 0.11.0\n * @return {Number} - number of successful update operations. Should be \"1\".\n */\nfunction denormalize(id, field) {\n  const doc = Products.findOne(id);\n  let variants;\n  if (doc.type === \"simple\") {\n    variants = Catalog.getTopVariants(id);\n  } else if (doc.type === \"variant\" && doc.ancestors.length === 1) {\n    variants = Catalog.getVariants(id);\n  }\n  const update = {};\n\n  switch (field) {\n    case \"inventoryPolicy\":\n    case \"inventoryQuantity\":\n    case \"inventoryManagement\":\n      Object.assign(update, {\n        isSoldOut: isSoldOut(variants),\n        isLowQuantity: isLowQuantity(variants),\n        isBackorder: isBackorder(variants)\n      });\n      break;\n    case \"lowInventoryWarningThreshold\":\n      Object.assign(update, {\n        isLowQuantity: isLowQuantity(variants)\n      });\n      break;\n    default: { // \"price\" is object with range, min, max\n      const priceObject = Catalog.getProductPriceRange(id);\n      Object.assign(update, {\n        price: priceObject\n      });\n    }\n  }\n\n  // TODO: Determine if product revision needs to be updated as well.\n  Products.update(id, {\n    $set: update\n  }, {\n    selector: {\n      type: \"simple\"\n    }\n  });\n}\n\n/**\n * isSoldOut\n * @private\n * @summary We are stop accepting new orders if product marked as `isSoldOut`.\n * @param {Array} variants - Array with top-level variants\n * @return {Boolean} true if summary product quantity is zero.\n */\nfunction isSoldOut(variants) {\n  return variants.every((variant) => {\n    if (variant.inventoryManagement && variant.inventoryPolicy) {\n      return Catalog.getVariantQuantity(variant) <= 0;\n    }\n    return false;\n  });\n}\n\n/**\n * isLowQuantity\n * @private\n * @summary If at least one of the variants is less than the threshold, then function returns `true`\n * @param {Array} variants - array of child variants\n * @return {boolean} low quantity or not\n */\nfunction isLowQuantity(variants) {\n  return variants.some((variant) => {\n    const quantity = Catalog.getVariantQuantity(variant);\n    // we need to keep an eye on `inventoryPolicy` too and qty > 0\n    if (variant.inventoryManagement && variant.inventoryPolicy && quantity) {\n      return quantity <= variant.lowInventoryWarningThreshold;\n    }\n    // TODO: need to test this function with real data\n    return false;\n  });\n}\n\n/**\n * isBackorder\n * @private\n * @description Is products variants is still available to be ordered after summary variants quantity is zero\n * @param {Array} variants - array with variant objects\n * @return {boolean} is backorder allowed or not for a product\n */\nfunction isBackorder(variants) {\n  return variants.every((variant) => !variant.inventoryPolicy && variant.inventoryManagement &&\n      variant.inventoryQuantity === 0);\n}\n\n/**\n * flushQuantity\n * @private\n * @summary if variant `inventoryQuantity` not zero, function update it to\n * zero. This needed in case then option with it's own `inventoryQuantity`\n * creates to top-level variant. In that case top-level variant should display\n * sum of his options `inventoryQuantity` fields.\n * @param {String} id - variant _id\n * @return {Number} - collection update results\n */\nfunction flushQuantity(id) {\n  const variant = Products.findOne(id);\n  // if variant already have descendants, quantity should be 0, and we don't\n  // need to do all next actions\n  if (variant.inventoryQuantity === 0) {\n    return 1; // let them think that we have one successful operation here\n  }\n\n  const productUpdate = Products.update({\n    _id: id\n  }, {\n    $set: {\n      inventoryQuantity: 0\n    }\n  }, {\n    selector: {\n      type: \"variant\"\n    }\n  });\n\n  return productUpdate;\n}\n\n/**\n * @function createProduct\n * @private\n * @description creates a product\n * @param {Object} props - initial product properties\n * @return {Object} product - new product\n */\nfunction createProduct(props = null) {\n  const _id = Products.insert({\n    type: \"simple\",\n    ...props\n  }, {\n    validate: false\n  });\n\n  const newProduct = Products.findOne({ _id });\n\n  Hooks.Events.run(\"afterInsertCatalogProduct\", newProduct);\n\n  return newProduct;\n}\n\n/**\n * @function\n * @name updateCatalogProduct\n * @summary Updates a product's revision and conditionally updates\n * the underlying product.\n *\n * @param {String} userId - currently logged in user\n * @param {Object} selector - selector for product to update\n * @param {Object} modifier - Object describing what parts of the document to update.\n * @param {Object} validation - simple schema validation options\n * @return {String} _id of updated document\n */\nfunction updateCatalogProduct(userId, selector, modifier, validation) {\n  const product = Products.findOne(selector);\n\n  const shouldUpdateProduct = Hooks.Events.run(\"beforeUpdateCatalogProduct\", product, {\n    userId,\n    modifier,\n    validation\n  });\n\n  if (shouldUpdateProduct) {\n    const result = Products.update(selector, modifier, validation);\n\n    Hooks.Events.run(\"afterUpdateCatalogProduct\", product, { modifier });\n\n    return result;\n  }\n\n  Logger.debug(`beforeUpdateCatalogProduct hook returned falsy, not updating catalog product`);\n\n  return false;\n}\n\n\nMeteor.methods({\n  /**\n   * @name products/cloneVariant\n   * @memberof Methods/Products\n   * @method\n   * @summary clones a product variant into a new variant\n   * @description the method copies variants, but will also create and clone\n   * child variants (options)\n   * @param {String} productId - the productId we're whose variant we're\n   * cloning\n   * @param {String} variantId - the variantId that we're cloning\n   * @todo rewrite @description\n   * @return {Array} - list with cloned variants _ids\n   */\n  \"products/cloneVariant\"(productId, variantId) {\n    check(productId, String);\n    check(variantId, String);\n\n    // Check first if Variant exists and then if user has the right to clone it\n    const variant = Products.findOne(variantId);\n    if (!variant) {\n      throw new Meteor.Error(\"not-found\", \"Variant not found\");\n    } else if (!Reaction.hasPermission(\"createProduct\", this.userId, variant.shopId)) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    // Verify that this variant and any ancestors are not deleted.\n    // Child variants cannot be added if a parent product or product revision\n    // is marked as `{ isDeleted: true }`\n    if (ReactionProduct.isAncestorDeleted(variant, true)) {\n      throw new Meteor.Error(\"server-error\", \"Unable to create product variant\");\n    }\n\n    const variants = Products.find({\n      $or: [{\n        _id: variantId\n      }, {\n        ancestors: {\n          $in: [variantId]\n        },\n        isDeleted: false\n      }],\n      type: \"variant\"\n    }).fetch();\n    // exit if we're trying to clone a ghost\n    if (variants.length === 0) {\n      return;\n    }\n    const variantNewId = Random.id(); // for the parent variant\n    // we need to make sure that top level variant will be cloned first, his\n    // descendants later.\n    // we could use this way in future: http://stackoverflow.com/questions/\n    // 9040161/mongo-order-by-length-of-array, by now following are allowed\n    // @link https://lodash.com/docs#sortBy\n    const sortedVariants = _.sortBy(variants, (doc) => doc.ancestors.length);\n\n    return sortedVariants.map((sortedVariant) => {\n      const oldId = sortedVariant._id;\n      let type = \"child\";\n      const clone = {};\n      if (variantId === sortedVariant._id) {\n        type = \"parent\";\n        Object.assign(clone, sortedVariant, {\n          _id: variantNewId,\n          title: `${sortedVariant.title} - copy`,\n          optionTitle: `${sortedVariant.optionTitle} - copy`,\n          price: `${sortedVariant.price}` ?\n            `${sortedVariant.price}` :\n            `${variant.price}`,\n          compareAtPrice: `${sortedVariant.compareAtPrice}` ?\n            `${sortedVariant.compareAtPrice}` :\n            `${variant.compareAtPrice}`\n        });\n      } else {\n        const parentIndex = sortedVariant.ancestors.indexOf(variantId);\n        const ancestorsClone = sortedVariant.ancestors.slice(0);\n        // if variantId exists in ancestors, we override it by new _id\n        if (parentIndex >= 0) ancestorsClone.splice(parentIndex, 1, variantNewId);\n        Object.assign(clone, variant, {\n          _id: Random.id(),\n          ancestors: ancestorsClone,\n          title: `${sortedVariant.title}`,\n          optionTitle: `${sortedVariant.optionTitle}`,\n          price: `${sortedVariant.price}` ?\n            `${sortedVariant.price}` :\n            `${variant.price}`,\n          compareAtPrice: `${sortedVariant.compareAtPrice}` ?\n            `${sortedVariant.compareAtPrice}` :\n            `${variant.compareAtPrice}`,\n          height: `${sortedVariant.height}`,\n          width: `${sortedVariant.width}`,\n          weight: `${sortedVariant.weight}`,\n          length: `${sortedVariant.length}`\n        });\n      }\n      delete clone.updatedAt;\n      delete clone.createdAt;\n      delete clone.inventoryQuantity;\n      delete clone.lowInventoryWarningThreshold;\n\n      copyMedia(productId, oldId, clone._id);\n\n      let newId;\n      try {\n        Hooks.Events.run(\"beforeInsertCatalogProductInsertRevision\", clone);\n        newId = Products.insert(clone, { validate: false });\n        const newProduct = Products.findOne(newId);\n        Hooks.Events.run(\"afterInsertCatalogProduct\", newProduct);\n        Logger.debug(`products/cloneVariant: created ${type === \"child\" ? \"sub child \" : \"\"}clone: ${\n          clone._id} from ${variantId}`);\n      } catch (error) {\n        Logger.error(`products/cloneVariant: cloning of ${variantId} was failed: ${error}`);\n        throw error;\n      }\n\n      Hooks.Events.run(\"afterInsertProduct\", clone);\n\n      return newId;\n    });\n  },\n\n  /**\n   * @name products/createVariant\n   * @memberof Methods/Products\n   * @method\n   * @summary initializes empty variant template\n   * @param {String} parentId - the product _id or top level variant _id where\n   * we create variant\n   * @param {Object} [newVariant] - variant object\n   * @return {String} new variantId\n   */\n  \"products/createVariant\"(parentId, newVariant) {\n    check(parentId, String);\n    check(newVariant, Match.Optional(Object));\n\n    // Check first if Product exists and then if user has the rights\n    const product = Products.findOne(parentId);\n    if (!product) {\n      throw new Meteor.Error(\"not-found\", \"Product not found\");\n    } else if (!Reaction.hasPermission(\"createProduct\", this.userId, product.shopId)) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    const newVariantId = Random.id();\n    // get parent ancestors to build new ancestors array\n    const { ancestors } = product;\n\n    // Verify that the parent variant and any ancestors are not deleted.\n    // Child variants cannot be added if a parent product or product revision\n    // is marked as `{ isDeleted: true }`\n    if (ReactionProduct.isAncestorDeleted(product, true)) {\n      throw new Meteor.Error(\"server-error\", \"Unable to create product variant\");\n    }\n\n    Array.isArray(ancestors) && ancestors.push(parentId);\n    const assembledVariant = Object.assign(newVariant || {}, {\n      _id: newVariantId,\n      ancestors,\n      type: \"variant\"\n    });\n\n    if (!newVariant) {\n      Object.assign(assembledVariant, {\n        title: `${product.title} - Untitled option`,\n        price: 0.00\n      });\n    }\n\n    // if we are inserting child variant to top-level variant, we need to remove\n    // all top-level's variant inventory records and flush it's quantity,\n    // because it will be hold sum of all it descendants quantities.\n    if (ancestors.length === 2) {\n      flushQuantity(parentId);\n    }\n\n    Hooks.Events.run(\"beforeInsertCatalogProduct\", assembledVariant);\n    const _id = Products.insert(assembledVariant);\n    Hooks.Events.run(\"afterInsertCatalogProduct\", assembledVariant);\n\n    Hooks.Events.run(\"afterInsertCatalogProductInsertRevision\", Products.findOne({ _id }));\n\n    Logger.debug(`products/createVariant: created variant: ${newVariantId} for ${parentId}`);\n\n    return newVariantId;\n  },\n\n  /**\n   * @name products/updateVariant\n   * @memberof Methods/Products\n   * @method\n   * @summary update individual variant with new values, merges into original\n   * only need to supply updated information. Currently used for a one use case\n   * - to manage top-level variant autoform.\n   * @param {Object} variant - current variant object\n   * @todo some use cases of this method was moved to \"products/\n   * updateProductField\", but it still used\n   * @return {Number} returns update result\n   */\n  \"products/updateVariant\"(variant) {\n    check(variant, Object);\n\n    // Check first if Variant exists and then if user has the right to clone it\n    const currentVariant = Products.findOne(variant._id);\n    if (!currentVariant) {\n      throw new Meteor.Error(\"not-found\", \"Variant not found\");\n    }\n\n    if (!Reaction.hasPermission(\"createProduct\", this.userId, currentVariant.shopId)) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    const newVariant = Object.assign({}, currentVariant, variant);\n\n    const variantUpdateResult = updateCatalogProduct(\n      this.userId,\n      {\n        _id: variant._id\n      },\n      {\n        $set: newVariant\n      },\n      {\n        selector: { type: currentVariant.type },\n        validate: false\n      }\n    );\n\n    const productId = currentVariant.ancestors[0];\n    // we need manually check is these fields were updated?\n    // we can't stop after successful denormalization, because we have a\n    // case when several fields could be changed in top-level variant\n    // before form will be submitted.\n    toDenormalize.forEach((field) => {\n      if (currentVariant[field] !== variant[field]) {\n        denormalize(productId, field);\n      }\n    });\n\n    return variantUpdateResult;\n  },\n\n  /**\n   * @name products/deleteVariant\n   * @memberof Methods/Products\n   * @method\n   * @summary delete variant, which should also delete child variants\n   * @param {String} variantId - variantId to delete\n   * @returns {Boolean} returns update results: `true` - if at least one variant\n   * was removed or `false` if nothing was removed\n   */\n  \"products/deleteVariant\"(variantId) {\n    check(variantId, String);\n\n    // Check first if Variant exists and then if user has the right to delete it\n    const variant = Products.findOne(variantId);\n    if (!variant) {\n      throw new Meteor.Error(\"not-found\", \"Variant not found\");\n    } else if (!Reaction.hasPermission(\"createProduct\", this.userId, variant.shopId)) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    const selector = {\n      // Don't \"archive\" variants that are already marked deleted.\n      isDeleted: {\n        $in: [false, undefined]\n      },\n      $or: [{\n        _id: variantId\n      }, {\n        ancestors: {\n          $in: [variantId]\n        }\n      }]\n    };\n    const toDelete = Products.find(selector).fetch();\n\n    // out if nothing to delete\n    if (!Array.isArray(toDelete) || toDelete.length === 0) return false;\n\n    // Flag the variant and all its children as deleted in Revisions collection.\n    toDelete.forEach((product) => {\n      Hooks.Events.run(\"beforeRemoveCatalogProduct\", product, { userId: this.userId });\n      Hooks.Events.run(\"afterRemoveCatalogProduct\", this.userId, product);\n    });\n\n    // After variant was removed from product, we need to recalculate all\n    // denormalized fields\n    const productId = toDelete[0].ancestors[0];\n    toDenormalize.forEach((field) => denormalize(productId, field));\n\n    Logger.debug(`Flagged variant and all its children as deleted.`);\n\n    return true;\n  },\n\n  /**\n   * @name products/cloneProduct\n   * @memberof Methods/Products\n   * @method\n   * @summary clone a whole product, defaulting visibility, etc\n   * in the future we are going to do an inheritance product\n   * that maintains relationships with the cloned product tree\n   * @param {Array} productOrArray - products array to clone\n   * @returns {Array} returns insert results\n   */\n  \"products/cloneProduct\"(productOrArray) {\n    check(productOrArray, Match.OneOf(Array, Object));\n\n    // REVIEW: This check may be unnecessary now - checks that user has permission to clone\n    // for active shop\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    if (Array.isArray(productOrArray)) {\n      // Reduce to unique shops found among producs in this array\n      const shopIds = productOrArray.map((prod) => prod.shopId);\n      const uniqueShopIds = [...new Set(shopIds)];\n\n      // For each unique shopId check to make sure that user has permission to clone\n      uniqueShopIds.forEach((shopId) => {\n        if (!Reaction.hasPermission(\"createProduct\", this.userId, shopId)) {\n          throw new Meteor.Error(\n            \"access-denied\",\n            \"Access Denied\"\n          );\n        }\n      });\n    } else if (!Reaction.hasPermission(\"createProduct\", this.userId, productOrArray.shopId)) { // Single product was passed in - ensure that user has permission to clone\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    let result;\n    let products;\n    const results = [];\n    const pool = []; // pool of id pairs: { oldId, newId }\n\n    function getIds(id) {\n      return pool.filter(function (pair) {\n        return pair.oldId === this.id;\n      }, {\n        id\n      });\n    }\n\n    function setId(ids) {\n      return pool.push(ids);\n    }\n\n    function buildAncestors(ancestors) {\n      const newAncestors = [];\n      ancestors.map((oldId) => {\n        const pair = getIds(oldId);\n        // TODO do we always have newId on this step?\n        newAncestors.push(pair[0].newId);\n        return newAncestors;\n      });\n      return newAncestors;\n    }\n\n    if (!Array.isArray(productOrArray)) {\n      products = [productOrArray];\n    } else {\n      products = productOrArray;\n    }\n\n    for (const product of products) {\n      // cloning product\n      const productNewId = Random.id();\n      setId({\n        oldId: product._id,\n        newId: productNewId\n      });\n\n      const newProduct = Object.assign({}, product, {\n        _id: productNewId\n        // ancestors: product.ancestors.push(product._id)\n      });\n      delete newProduct.updatedAt;\n      delete newProduct.createdAt;\n      delete newProduct.publishedAt;\n      delete newProduct.positions;\n      delete newProduct.handle;\n      newProduct.isVisible = false;\n      if (newProduct.title) {\n        // todo test this\n        newProduct.title = createTitle(newProduct.title, newProduct._id);\n        newProduct.handle = createHandle(\n          Reaction.getSlug(newProduct.title),\n          newProduct._id\n        );\n      }\n      Hooks.Events.run(\"beforeInsertCatalogProductInsertRevision\", newProduct);\n      result = Products.insert(newProduct, { validate: false });\n      Hooks.Events.run(\"afterInsertCatalogProduct\", newProduct);\n      results.push(result);\n\n      // cloning variants\n      const variants = Products.find({\n        ancestors: {\n          $in: [product._id]\n        },\n        type: \"variant\"\n      }).fetch();\n      // why we are using `_.sortBy` described in `products/cloneVariant`\n      const sortedVariants = _.sortBy(variants, (doc) => doc.ancestors.length);\n      for (const variant of sortedVariants) {\n        const variantNewId = Random.id();\n        setId({\n          oldId: variant._id,\n          newId: variantNewId\n        });\n        const ancestors = buildAncestors(variant.ancestors);\n        const newVariant = Object.assign({}, variant, {\n          _id: variantNewId,\n          ancestors\n        });\n        delete newVariant.updatedAt;\n        delete newVariant.createdAt;\n        delete newVariant.publishedAt; // TODO can variant have this param?\n\n        Hooks.Events.run(\"beforeInsertCatalogProductInsertRevision\", newVariant);\n        result = Products.insert(newVariant, { validate: false });\n        Hooks.Events.run(\"afterInsertCatalogProduct\", newVariant);\n        copyMedia(productNewId, variant._id, variantNewId);\n        results.push(result);\n      }\n    }\n    return results;\n  },\n\n  /**\n   * @name products/createProduct\n   * @memberof Methods/Products\n   * @method\n   * @summary when we create a new product, we create it with an empty variant.\n   * all products have a variant with pricing and details\n   * @param {Object} [product] - optional product object\n   * @return {String} The new product ID\n   */\n  \"products/createProduct\"(product) {\n    check(product, Match.Optional(Object));\n\n    // Ensure user has createProduct permission for active shop\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    // also if a product is provided, check first that the user doesn't mock a shop with no permissions to it\n    if (product) {\n      if (!product.shopId || !Reaction.hasPermission(\"createProduct\", this.userId, product.shopId)) {\n        throw new Meteor.Error(\"invalid-parameter\", \"Product should have a valid shopId\");\n      }\n\n      // Create product revision\n      Hooks.Events.run(\"beforeInsertCatalogProductInsertRevision\", product);\n\n      return Products.insert(product);\n    }\n\n    const newSimpleProduct = createProduct();\n\n    // Create simple product revision\n    Hooks.Events.run(\"afterInsertCatalogProductInsertRevision\", newSimpleProduct);\n\n    const newVariant = createProduct({\n      ancestors: [newSimpleProduct._id],\n      price: 0.00,\n      title: \"\",\n      type: \"variant\" // needed for multi-schema\n    });\n\n    // Create variant revision\n    Hooks.Events.run(\"afterInsertCatalogProductInsertRevision\", newVariant);\n\n    return newSimpleProduct._id;\n  },\n\n  /**\n   * @name products/archiveProduct\n   * @memberof Methods/Products\n   * @method\n   * @summary archive a product and unlink it from all media\n   * @param {String} productId - productId to delete\n   * @returns {Number} returns number of removed products\n   */\n  \"products/archiveProduct\"(productId) {\n    check(productId, Match.OneOf(Array, String));\n\n    let extractedProductId;\n    if (Array.isArray(productId)) {\n      [extractedProductId] = productId;\n    }\n\n    // Check first if Product exists and then if user has the right to delete it\n    const product = Products.findOne(extractedProductId || productId);\n    if (!product) {\n      throw new Meteor.Error(\"not-found\", \"Product not found\");\n    } else if (!Reaction.hasPermission(\"createProduct\", this.userId, product.shopId)) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    let productIds;\n\n    if (!Array.isArray(productId)) {\n      productIds = [productId];\n    } else {\n      productIds = productId;\n    }\n    const productsWithVariants = Products.find({\n      // Don't \"archive\" products that are already marked deleted.\n      isDeleted: {\n        $in: [false, undefined]\n      },\n      $or: [{\n        _id: {\n          $in: productIds\n        }\n      }, {\n        ancestors: {\n          $in: productIds\n        }\n      }]\n    }).fetch();\n\n    const ids = [];\n    productsWithVariants.map((doc) => {\n      ids.push(doc._id);\n      return ids;\n    });\n\n    // Flag the product and all its variants as deleted in the Revisions collection.\n    productsWithVariants.forEach((toArchiveProduct) => {\n      Hooks.Events.run(\"beforeRemoveCatalogProduct\", toArchiveProduct, { userId: this.userId });\n\n      Hooks.Events.run(\"afterRemoveCatalogProduct\", this.userId, toArchiveProduct);\n    });\n\n    const numFlaggedAsDeleted = Revisions.find({\n      \"documentId\": {\n        $in: ids\n      },\n      \"documentData.isDeleted\": true\n    }).count();\n\n    if (numFlaggedAsDeleted > 0) {\n      // Flag associated MediaRecords as deleted.\n      MediaRecords.update({\n        \"metadata.productId\": {\n          $in: ids\n        },\n        \"metadata.variantId\": {\n          $in: ids\n        }\n      }, {\n        $set: {\n          \"metadata.isDeleted\": true\n        }\n      });\n      return numFlaggedAsDeleted;\n    }\n\n    Logger.debug(`${numFlaggedAsDeleted} products have been flagged as deleted`);\n  },\n\n  /**\n   * @name products/updateProductField\n   * @memberof Methods/Products\n   * @method\n   * @summary update single product or variant field\n   * @param {String} _id - product._id or variant._id to update\n   * @param {String} field - key to update\n   * @param {*} value - update property value\n   * @todo rename it to something like \"products/updateField\" to  reflect\n   * @todo we need to know which type of entity field belongs. For that we could\n   * do something like: const type = Products.findOne(_id).type or transmit type\n   * as param if it possible\n   * latest changes. its used for products and variants\n   * @return {Number} returns update result\n   */\n  \"products/updateProductField\"(_id, field, value) {\n    check(_id, String);\n    check(field, String);\n    check(value, Match.OneOf(String, Object, Array, Boolean, Number));\n\n    // Must have createProduct permission for active shop\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    // Check first if Product exists and then if user has the right to alter it\n    const doc = Products.findOne(_id);\n    if (!doc) {\n      throw new Meteor.Error(\"not-found\", \"Product not found\");\n    } else if (!Reaction.hasPermission(\"createProduct\", this.userId, doc.shopId)) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    const { type } = doc;\n    let update;\n    // handle booleans with correct typing\n    if (value === \"false\" || value === \"true\") {\n      const booleanValue = (value === \"true\" || value === true);\n      update = EJSON.parse(`{\"${field}\":${booleanValue}}`);\n    } else if (field === \"handle\") {\n      update = {\n        // TODO: write function to ensure new handle is unique.\n        // Should be a call similar to the line below.\n        [field]: createHandle(value, _id) // handle should be unique\n      };\n    } else if (field === \"title\" && doc.handle === doc._id) { // update handle once title is set\n      const handle = createHandle(Reaction.getSlug(value), _id);\n      update = {\n        [field]: value,\n        handle\n      };\n    } else {\n      const stringValue = EJSON.stringify(value);\n      update = EJSON.parse(`{\"${field}\":${stringValue}}`);\n    }\n\n\n    // we need to use sync mode here, to return correct error and result to UI\n    let result;\n\n    try {\n      result = updateCatalogProduct(\n        this.userId,\n        {\n          _id\n        },\n        {\n          $set: update\n        },\n        {\n          selector: { type }\n        }\n      );\n    } catch (e) {\n      throw new Meteor.Error(\"server-error\", e.message);\n    }\n\n    // If we get a result from the product update,\n    // meaning the update went past revision control,\n    // denormalize and attach results to top-level product\n    if (result === 1) {\n      if (type === \"variant\" && toDenormalize.indexOf(field) >= 0) {\n        denormalize(doc.ancestors[0], field);\n      }\n    }\n    return result;\n  },\n\n  /**\n   * @name products/updateProductTags\n   * @memberof Methods/Products\n   * @method\n   * @summary method to insert or update tag with hierarchy\n   * @param {String} productId - productId\n   * @param {String} tagName - tagName\n   * @param {String} tagId - tagId\n   * @return {Number} return result\n   */\n  \"products/updateProductTags\"(productId, tagName, tagId) {\n    check(productId, String);\n    check(tagName, String);\n    check(tagId, Match.OneOf(String, null));\n\n    // Check first if Product exists and then if user has the right to alter it\n    const product = Products.findOne(productId);\n    if (!product) {\n      throw new Meteor.Error(\"not-found\", \"Product not found\");\n    } else if (!Reaction.hasPermission(\"createProduct\", this.userId, product.shopId)) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    this.unblock();\n\n    const newTag = {\n      slug: Reaction.getSlug(tagName),\n      name: tagName\n    };\n\n    const existingTag = Tags.findOne({\n      slug: Reaction.getSlug(tagName)\n    });\n\n    if (existingTag) {\n      const productCount = Products.find({\n        _id: productId,\n        hashtags: existingTag._id\n      }).count();\n      if (productCount > 0) {\n        throw new Meteor.Error(\"server-error\", \"Existing Tag, Update Denied\");\n      }\n      return updateCatalogProduct(\n        this.userId,\n        {\n          _id: productId\n        },\n        {\n          $push: {\n            hashtags: existingTag._id\n          }\n        },\n        {\n          selector: { type: \"simple\" }\n        }\n      );\n    } else if (tagId) {\n      return Tags.update(tagId, { $set: newTag });\n    }\n\n    const newTagId = Meteor.call(\"shop/createTag\", tagName, false);\n\n    // if result is an Error object, we return it immediately\n    if (typeof newTagId !== \"string\") {\n      return newTagId;\n    }\n\n    return updateCatalogProduct(\n      this.userId,\n      {\n        _id: productId\n      },\n      {\n        $push: {\n          hashtags: newTagId\n        }\n      },\n      {\n        selector: { type: \"simple\" }\n      }\n    );\n  },\n\n  /**\n   * @name products/removeProductTag\n   * @memberof Methods/Products\n   * @method\n   * @summary method to remove tag from product\n   * @param {String} productId - productId\n   * @param {String} tagId - tagId\n   * @return {String} return update result\n   */\n  \"products/removeProductTag\"(productId, tagId) {\n    check(productId, String);\n    check(tagId, String);\n\n    // Check first if Product exists and then if user has the right to alter it\n    const product = Products.findOne(productId);\n    if (!product) {\n      throw new Meteor.Error(\"not-found\", \"Product not found\");\n    } else if (!Reaction.hasPermission(\"createProduct\", this.userId, product.shopId)) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    updateCatalogProduct(\n      this.userId,\n      {\n        _id: productId\n      },\n      {\n        $pull: {\n          hashtags: tagId\n        }\n      },\n      {\n        selector: { type: \"simple\" }\n      }\n    );\n  },\n\n  /**\n   * @name products/setHandle\n   * @memberof Methods/Products\n   * @method\n   * @summary copy of \"products/setHandleTag\", but without tag\n   * @param {String} productId - productId\n   * @returns {String} handle - product handle\n   */\n  \"products/setHandle\"(productId) {\n    check(productId, String);\n\n    // Check first if Product exists and then if user has the right to alter it\n    const product = Products.findOne(productId);\n    if (!product) {\n      throw new Meteor.Error(\"not-found\", \"Product not found\");\n    } else if (!Reaction.hasPermission(\"createProduct\", this.userId, product.shopId)) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    let handle = Reaction.getSlug(product.title);\n    handle = createHandle(handle, product._id);\n    updateCatalogProduct(\n      this.userId,\n      {\n        _id: product._id\n      },\n      {\n        $set: { handle, type: \"simple\" }\n      },\n    );\n\n    return handle;\n  },\n\n  /**\n   * @name products/setHandleTag\n   * @memberof Methods/Products\n   * @method\n   * @summary set or toggle product handle\n   * @param {String} productId - productId\n   * @param {String} tagId - tagId\n   * @return {String} return update result\n   */\n  \"products/setHandleTag\"(productId, tagId) {\n    check(productId, String);\n    check(tagId, String);\n    // Check first if Product exists and then if user has the right to alter it\n    const product = Products.findOne(productId);\n    if (!product) {\n      throw new Meteor.Error(\"not-found\", \"Product not found\");\n    } else if (!Reaction.hasPermission(\"createProduct\", this.userId, product.shopId)) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    function getSet(handle) {\n      return {\n        $set: {\n          handle,\n          type: \"simple\"\n        }\n      };\n    }\n\n    const tag = Tags.findOne(tagId);\n    // set handle\n    if (product.handle === tag.slug) {\n      let handle = Reaction.getSlug(product.title);\n      handle = createHandle(handle, product._id);\n      Products.update(product._id, getSet(handle));\n\n      return handle;\n    }\n    // toggle handle\n    const existingHandles = Products.find({\n      handle: tag.slug\n    }).fetch();\n    // this is needed to take care about product's handle which(product) was\n    // previously tagged.\n    for (const currentProduct of existingHandles) {\n      const currentProductHandle = createHandle(\n        Reaction.getSlug(currentProduct.title),\n        currentProduct._id\n      );\n      updateCatalogProduct(\n        this.userId,\n        {\n          _id: currentProduct._id\n        },\n        getSet(currentProductHandle)\n      );\n    }\n\n    updateCatalogProduct(\n      this.userId,\n      {\n        _id: product._id\n      },\n      getSet(tag.slug)\n    );\n\n    return tag.slug;\n  },\n\n  /**\n   * @name products/updateProductPosition\n   * @memberof Methods/Products\n   * @method\n   * @summary update product grid positions\n   * @param {String} productId - productId\n   * @param {Object} positionData -  an object with position,dimensions\n   * @param {String} tag - current route name. If it is not tag, then we using\n   * shop name as base `positions` name. Could be useful for multi-shopping.\n   * @return {Number} collection update returns\n   */\n  \"products/updateProductPosition\"(productId, positionData, tag) {\n    check(productId, String);\n    check(positionData, Object);\n    check(tag, String);\n\n    // Check first if Product exists and then if user has the proper rights\n    const product = Products.findOne(productId);\n    if (!product) {\n      throw new Meteor.Error(\"not-found\", \"Product not found\");\n    } else if (!Reaction.hasPermission(\"createProduct\", this.userId, product.shopId)) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    this.unblock();\n\n    const position = `positions.${tag}.position`;\n    const pinned = `positions.${tag}.pinned`;\n    const weight = `positions.${tag}.weight`;\n    const updatedAt = `positions.${tag}.updatedAt`;\n\n    return updateCatalogProduct(\n      this.userId,\n      {\n        _id: productId\n      },\n      {\n        $set: {\n          [position]: positionData.position,\n          [pinned]: positionData.pinned,\n          [weight]: positionData.weight,\n          [updatedAt]: new Date(),\n          type: \"simple\" // for multi-schema\n        }\n      }\n    );\n  },\n\n  /**\n   * @name products/updateVariantsPosition\n   * @memberof Methods/Products\n   * @method\n   * @description updates top level variant position index\n   * @param {Array} sortedVariantIds - array of top level variant `_id`s\n   * @since 0.11.0\n   * @return {Number} Products.update result\n   */\n  \"products/updateVariantsPosition\"(sortedVariantIds) {\n    check(sortedVariantIds, [String]);\n\n    // This checks to make sure the user has createProduct permissions for the active shop.\n    // TODO: We should determine if that is the correct role that a user should have\n    // to be permitted to re-arrange products on the grid\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    sortedVariantIds.forEach((id, index) => {\n      updateCatalogProduct(\n        this.userId,\n        {\n          _id: id\n        },\n        {\n          $set: { index }\n        },\n        {\n          selector: { type: \"variant\" }\n        }\n      );\n      Logger.debug(`Variant ${id} position was updated to index ${index}`);\n    });\n  },\n\n  /**\n   * @name products/updateMetaFields\n   * @memberof Methods/Products\n   * @method\n   * @summary update product metafield\n   * @param {String} productId - productId\n   * @param {Object} updatedMeta - update object with metadata\n   * @param {Object|Number|undefined|null} meta - current meta object, or a number index\n   * @todo should this method works for variants also?\n   * @return {Number} collection update result\n   */\n  \"products/updateMetaFields\"(productId, updatedMeta, meta) {\n    check(productId, String);\n    check(updatedMeta, Object);\n    check(meta, Match.OneOf(Object, Number, undefined, null));\n\n    // Check first if Product exists and then if user has the proper rights\n    const product = Products.findOne(productId);\n    if (!product) {\n      throw new Meteor.Error(\"not-found\", \"Product not found\");\n    } else if (!Reaction.hasPermission(\"createProduct\", this.userId, product.shopId)) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    // update existing metadata\n    if (typeof meta === \"object\") {\n      return updateCatalogProduct(\n        this.userId,\n        {\n          _id: productId,\n          metafields: meta\n        }, {\n          $set: {\n            \"metafields.$\": updatedMeta\n          }\n        }, {\n          selector: { type: \"simple\", metafields: meta }\n        }\n      );\n    } else if (typeof meta === \"number\") {\n      return updateCatalogProduct(\n        this.userId,\n        {\n          _id: productId\n        },\n        {\n          $set: {\n            [`metafields.${meta}`]: updatedMeta\n          }\n        },\n        {\n          selector: { type: \"simple\", metafields: meta }\n        }\n      );\n    }\n\n    // adds metadata\n    return updateCatalogProduct(\n      this.userId,\n      {\n        _id: productId\n      },\n      {\n        $addToSet: {\n          metafields: updatedMeta\n        }\n      },\n      {\n        selector: { type: \"simple\" }\n      }\n    );\n  },\n\n  /**\n   * @name products/removeMetaFields\n   * @memberof Methods/Products\n   * @method\n   * @summary update product metafield\n   * @param {String} productId - productId\n   * @param {Object} metafields - metadata object to remove\n   * @param {Object} type - optional product type for schema selection\n   * @return {Number} collection update result\n   */\n  \"products/removeMetaFields\"(productId, metafields, type = \"simple\") {\n    check(productId, String);\n    check(metafields, Object);\n    check(type, String);\n\n    // Check first if Product exists and then if user has the proper rights\n    const product = Products.findOne(productId);\n    if (!product) {\n      throw new Meteor.Error(\"not-found\", \"Product not found\");\n    } else if (!Reaction.hasPermission(\"createProduct\", this.userId, product.shopId)) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    return updateCatalogProduct(\n      this.userId,\n      {\n        _id: productId,\n        type\n      },\n      {\n        $pull: { metafields }\n      }\n    );\n  },\n\n  /**\n   * @name products/publishProduct\n   * @memberof Methods/Products\n   * @method\n   * @summary publish (visibility) of product\n   * @todo hook into publishing flow\n   * @param {String} productId - productId\n   * @return {Boolean} product.isVisible\n   */\n  \"products/publishProduct\"(productId) {\n    check(productId, String);\n\n    // Check first if Product exists and then if user has the proper rights\n    const product = Products.findOne(productId);\n    if (!product) {\n      throw new Meteor.Error(\"not-found\", \"Product not found\");\n    } else if (!Reaction.hasPermission(\"createProduct\", this.userId, product.shopId)) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    const variants = Products.find({\n      ancestors: {\n        $in: [productId]\n      }\n    }).fetch();\n    let variantValidator = true;\n\n    if (typeof product === \"object\" && product.title.length > 1) {\n      if (variants.length > 0) {\n        variants.forEach((variant) => {\n          // if this is a top variant with children, we avoid it to check price\n          // because we using price of its children\n          if ((variant.ancestors.length === 1 && !Catalog.getVariants(variant._id, \"variant\").length) ||\n            variant.ancestors.length !== 1) {\n            if (!(typeof variant.price === \"number\" && variant.price > 0)) {\n              variantValidator = false;\n            }\n          }\n          // if variant has no title\n          if (typeof variant.title === \"string\" && !variant.title.length) {\n            variantValidator = false;\n          }\n          if (typeof variant.optionTitle === \"string\" && !variant.optionTitle.length) {\n            variantValidator = false;\n          }\n        });\n      } else {\n        Logger.debug(\"invalid product visibility \", productId);\n        throw new Meteor.Error(\"invalid-parameter\", \"Variant is required\");\n      }\n\n      if (!variantValidator) {\n        Logger.debug(\"invalid product visibility \", productId);\n        throw new Meteor.Error(\n          \"invalid-parameter\",\n          \"Some properties are missing.\"\n        );\n      }\n\n      // update product visibility\n      Logger.debug(\"toggle product visibility \", product._id, !product.isVisible);\n\n      const res = updateCatalogProduct(\n        this.userId,\n        {\n          _id: product._id\n        },\n        {\n          $set: {\n            isVisible: !product.isVisible\n          }\n        },\n        {\n\n          selector: { type: \"simple\" }\n        }\n      );\n\n      // update product variants visibility\n      updateVariantProductField(variants, \"isVisible\", !product.isVisible);\n      // if collection updated we return new `isVisible` state\n      return res === 1 && !product.isVisible;\n    }\n    Logger.debug(\"invalid product visibility \", productId);\n    throw new Meteor.Error(\"invalid-parameter\", \"Bad Request\");\n  },\n\n  /**\n   * @name products/toggleVisibility\n   * @memberof Methods/Products\n   * @method\n   * @summary publish (visibility) of product\n   * @todo hook into publishing flow\n   * @param {String} productId - productId\n   * @return {Boolean} product.isVisible\n   */\n  \"products/toggleVisibility\"(productId) {\n    check(productId, String);\n\n    // Check first if Product exists and then if user has the proper rights\n    const product = Products.findOne(productId);\n    if (!product) {\n      throw new Meteor.Error(\"not-found\", \"Product not found\");\n    }\n\n    if (!Reaction.hasPermission(\"createProduct\", this.userId, product.shopId)) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    const res = updateCatalogProduct(\n      this.userId,\n      {\n        _id: productId\n      },\n      {\n        $set: {\n          isVisible: !product.isVisible\n        }\n      },\n      {\n        selector: {\n          type: product.type\n        }\n      }\n    );\n\n    if (Array.isArray(product.ancestors) && product.ancestors.length) {\n      const updateId = product.ancestors[0] || product._id;\n      const updatedPriceRange = ReactionProduct.getProductPriceRange(updateId);\n\n      Meteor.call(\"products/updateProductField\", updateId, \"price\", updatedPriceRange);\n    }\n\n    // if collection updated we return new `isVisible` state\n    return res === 1 && !product.isVisible;\n  }\n});\n"]},"sourceType":"script","hash":"8b22b9cccbe22b4101d5c8c303eeed02d85ad990"}
