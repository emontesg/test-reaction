{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$1$2","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"ast":true,"babelrc":false,"sourceFileName":"imports/plugins/included/connectors-shopify/server/methods/export/orders.js","filename":"imports/plugins/included/connectors-shopify/server/methods/export/orders.js","sourceMaps":true,"envName":"development","cwd":"/Users/estebandev/test-knowledge","passPerPreset":false,"presets":[],"parserOpts":{"sourceType":"module","sourceFileName":"imports/plugins/included/connectors-shopify/server/methods/export/orders.js","plugins":["jsx","jsx","flow","flow","objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties"]},"generatorOpts":{"filename":"imports/plugins/included/connectors-shopify/server/methods/export/orders.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"imports/plugins/included/connectors-shopify/server/methods/export/orders.js"}},"code":"module.export({\n  exportToShopify: () => exportToShopify\n});\nlet accounting;\nmodule.watch(require(\"accounting-js\"), {\n  default(v) {\n    accounting = v;\n  }\n\n}, 0);\nlet Shopify;\nmodule.watch(require(\"shopify-api-node\"), {\n  default(v) {\n    Shopify = v;\n  }\n\n}, 1);\nlet parse, format;\nmodule.watch(require(\"libphonenumber-js\"), {\n  parse(v) {\n    parse = v;\n  },\n\n  format(v) {\n    format = v;\n  }\n\n}, 2);\nlet Meteor;\nmodule.watch(require(\"meteor/meteor\"), {\n  Meteor(v) {\n    Meteor = v;\n  }\n\n}, 3);\nlet check, Match;\nmodule.watch(require(\"meteor/check\"), {\n  check(v) {\n    check = v;\n  },\n\n  Match(v) {\n    Match = v;\n  }\n\n}, 4);\nlet Logger;\nmodule.watch(require(\"/server/api\"), {\n  Logger(v) {\n    Logger = v;\n  }\n\n}, 5);\nlet convertWeight;\nmodule.watch(require(\"/lib/api\"), {\n  convertWeight(v) {\n    convertWeight = v;\n  }\n\n}, 6);\nlet Orders, Shops;\nmodule.watch(require(\"/lib/collections\"), {\n  Orders(v) {\n    Orders = v;\n  },\n\n  Shops(v) {\n    Shops = v;\n  }\n\n}, 7);\nlet getApiInfo;\nmodule.watch(require(\"../api\"), {\n  getApiInfo(v) {\n    getApiInfo = v;\n  }\n\n}, 8);\n\n/**\n * @private\n * @summary build a new object for export to Shopify\n * @param {Object} doc - the order to convert\n * @param {Number} index - the sequence number of billing/shipping records we are processing\n * @param {String} shopId - the Id of the shop we are processing for\n * @param {Object} existingCustomer - the existing customer Id if it exists\n * @returns {Object} shopifyOrder - the converted order\n */\nfunction convertOrderToShopifyOrder(doc, index, shopId, existingCustomer = undefined) {\n  check(existingCustomer, Match.OneOf(Object, undefined));\n  const order = Orders.findOne(doc._id); // only this object has the original transforms defined\n\n  const paymentType = order.billing[index].method;\n  const itemsForShop = order.getItemsByShop()[shopId];\n  const shopifyOrder = {};\n  shopifyOrder.billing_address = convertAddress(order.billing[index].address);\n  shopifyOrder.shipping_address = convertAddress(order.shipping[index].address);\n\n  if (!existingCustomer) {\n    shopifyOrder.customer = convertCustomer(shopifyOrder.billing_address, order);\n  } else {\n    shopifyOrder.customer = existingCustomer;\n  }\n\n  shopifyOrder.email = order.email;\n\n  if (paymentType === \"credit\" && order.billing[index].mode === \"authorize\") {\n    shopifyOrder.financial_status = \"authorized\";\n  } else {\n    shopifyOrder.financial_status = \"paid\";\n  }\n\n  shopifyOrder.id = order._id;\n  shopifyOrder.line_items = convertLineItems(itemsForShop, order);\n  shopifyOrder.shipping_lines = convertShipping(order, index);\n  shopifyOrder.phone = order.billing[index].address.phone;\n  shopifyOrder.source_name = \"reaction_export\";\n  shopifyOrder.subtotal_price = order.getSubtotalByShop()[shopId];\n  shopifyOrder.token = order._id;\n  shopifyOrder.total_discounts = order.getDiscountsByShop()[shopId];\n  shopifyOrder.total_line_item_price = order.getItemsByShop()[shopId].reduce((total, item) => total + item.variants.price * item.quantity, 0);\n  shopifyOrder.total_price = order.getTotalByShop()[shopId];\n  shopifyOrder.total_tax = order.getTaxesByShop()[shopId];\n  shopifyOrder.total_weight = shopifyOrder.line_items.reduce((sum, item) => sum + item.grams * item.quantity, 0);\n  return shopifyOrder;\n}\n/**\n * @private\n * @summary Normalize all weights to grams\n * @param {Number} weight - the original weight value\n * @param {String} shopId - the shop we are converting for\n * @returns {Number} the normalized value\n */\n\n\nfunction normalizeWeight(weight, shopId) {\n  // if weight is not grams, convert to grams if is grams just return\n  const shop = Shops.findOne(shopId);\n  const {\n    baseUOM\n  } = shop;\n\n  if (baseUOM === \"g\") {\n    return weight;\n  }\n\n  if (baseUOM === \"lb\") {\n    return convertWeight(\"lb\", \"g\", weight);\n  }\n\n  if (baseUOM === \"oz\") {\n    return convertWeight(\"oz\", \"g\", weight);\n  }\n\n  if (baseUOM === \"kg\") {\n    return convertWeight(\"kg\", \"g\", weight);\n  }\n}\n/**\n * @private\n * @summary Convert individual line items of an order\n * @param {Array} items - The items on the order object\n * @param {Object} order - The order we are converting for\n * @returns {Array} An array of converted line items\n */\n\n\nfunction convertLineItems(items, order) {\n  const lineItems = items.map(item => {\n    const lineItem = {};\n    lineItem.fulfillable_quantity = item.quantity;\n    lineItem.fulfillment_service = \"manual\";\n    lineItem.fullfillment_status = null;\n\n    if (item.parcel && item.parcel.weight) {\n      lineItem.grams = normalizeWeight(item.parcel.weight, item.shopId);\n    }\n\n    lineItem.id = item._id;\n    lineItem.product_id = item.productId;\n    lineItem.quantity = item.quantity;\n    lineItem.requires_shipping = item.product.requiresShipping;\n\n    if (item.variants.sku) {\n      // this doesn't appear to be written anywhere but it's in the schema\n      lineItem.sku = item.variants.sku;\n    }\n\n    lineItem.title = item.product.title;\n    lineItem.variant_id = item.variants._id;\n    lineItem.variant_title = item.variants.title;\n    lineItem.vendor = item.product.vendor;\n    lineItem.taxable = item.variants.taxable;\n    lineItem.price = item.variants.price;\n\n    if (order.taxes) {\n      lineItem.tax_lines = []; // when using Avalara we get tax detail\n      // get the tax iten for this particular line\n\n      const taxItem = order.taxes.find(tax => tax.lineNumber === item._id);\n      taxItem.details.forEach(detail => {\n        const taxLine = {\n          title: detail.taxName,\n          price: accounting.toFixed(detail.taxCalculated, 2),\n          rate: detail.rate\n        };\n        lineItem.tax_lines.push(taxLine);\n      });\n    } // for custom tax codes we get this one data point\n\n\n    if (item.taxData) {\n      lineItem.tax_lines = [{\n        title: item.taxData.taxCode,\n        price: accounting.toFixed(item.taxData.rate / 100 * item.variants.price, 2),\n        rate: item.taxData.rate / 100\n      }];\n    }\n\n    return lineItem;\n  });\n  return lineItems;\n}\n/**\n * @private\n * @summary Convert address object into Shopify-compatible format\n * @param {Object} address - the address to convert\n * @returns {Object} converted address\n */\n\n\nfunction convertAddress(address) {\n  const convertedAddress = {};\n  convertedAddress.address1 = address.address1;\n  convertedAddress.address2 = address.address2 || \"\";\n  convertedAddress.city = address.city;\n  convertedAddress.country = address.country;\n  convertedAddress.country_code = address.country;\n  convertedAddress.name = address.fullName;\n  const [firstName, ...lastName] = address.fullName.split(\" \");\n  convertedAddress.first_name = firstName;\n  convertedAddress.last_name = lastName.join(\" \");\n  convertedAddress.phone = address.phone;\n  convertedAddress.zip = address.postal;\n  convertedAddress.province_code = address.region;\n  return convertedAddress;\n}\n\nfunction isExistingCustomer(address, email, shopify) {\n  return Promise.asyncApply(() => {\n    const query = `email:${email}`;\n    const customerByEmailPromise = shopify.customer.search({\n      query\n    });\n    return customerByEmailPromise;\n  });\n}\n\nfunction normalizePhone(phoneToNormalize, countryCode) {\n  const {\n    phone\n  } = parse(phoneToNormalize, countryCode);\n  const formattedPhone = format(phone, countryCode, \"International\").replace(/\\s/g, \"\");\n  return formattedPhone;\n}\n/**\n * @private\n * @summary Create a customer object in Shopify-compatible format\n * @param {Object} address - Converted address object\n * @param {Object} order - Original order we are converting\n * @returns {Object} Shopify-compatible customer object\n */\n\n\nfunction convertCustomer(address, order) {\n  const formattedPhone = normalizePhone(address.phone, address.country_code);\n  const customer = {\n    accepts_marketing: false,\n    email: order.email,\n    phone: formattedPhone,\n    first_name: address.first_name,\n    last_name: address.last_name\n  };\n  return customer;\n}\n/**\n * @private\n * @summary Create a shippingMethod object to record shipping on a Shopify order\n * @param {Object} order - The order with shipping data\n * @param {Number} index - The shop index to convert\n * @returns {Array} An array of shipping lines\n */\n\n\nfunction convertShipping(order, index) {\n  const shippingLines = []; // I don't think we need to check this because we should **always** have a shipping record per shop\n  // so worst case shipmentMethod is undefined and we will skip\n\n  const method = order.shipping[index].shipmentMethod;\n\n  if (method) {\n    const shippingMethod = {\n      code: method.name,\n      price: method.rate,\n      title: method.name,\n      source: method.carrier\n    };\n    shippingLines.push(shippingMethod);\n  }\n\n  return shippingLines;\n}\n/**\n * @summary Export an order to Shopify\n * @param {Object} doc - The order to convert\n * @returns {Promise.<Array>} - An array of exported orders\n */\n\n\nfunction exportToShopify(doc) {\n  return Promise.asyncApply(() => {\n    const numShopOrders = doc.billing.length; // if we have multiple billing, we have multiple shops\n\n    Logger.debug(`Exporting ${numShopOrders} order(s) to Shopify`);\n    const shopifyOrders = [];\n\n    for (let index = 0; index < numShopOrders; index += 1) {\n      // send a shopify order once for each merchant order\n      const {\n        shopId\n      } = doc.billing[index];\n      const apiCreds = getApiInfo(shopId);\n      const shopify = new Shopify(apiCreds);\n      const existingCustomerQuery = Promise.await(isExistingCustomer(doc.billing[index].address, doc.email, shopify)); // eslint-disable-line no-await-in-loop\n      // this should never happen but I want a meaningful error here in case it does\n\n      if (existingCustomerQuery.length > 1) {\n        throw new Meteor.Error(\"duplicate-customer\", \"Discovered more than one customer in Shopify. Cannot continue\");\n      }\n\n      const existingCustomer = existingCustomerQuery[0];\n      const shopifyOrder = convertOrderToShopifyOrder(doc, index, shopId, existingCustomer);\n      Logger.debug(\"sending shopify order\", shopifyOrder, doc._id);\n      const newShopifyOrder = Promise.await(shopify.order.create(shopifyOrder)); // eslint-disable-line no-await-in-loop\n\n      markExported(newShopifyOrder, shopId, doc);\n      shopifyOrders.push(newShopifyOrder);\n    }\n\n    return shopifyOrders;\n  });\n}\n\n/**\n * @private\n * @summary Mark orders as exported after export\n * @param {Object} exportedOrder the converted order\n * @param {String} shopId - the shopId to attach\n * @param {Object} order - the order to be marked\n */\nfunction markExported(exportedOrder, shopId, order) {\n  Orders.update({\n    _id: order._id\n  }, {\n    $push: {\n      exportHistory: {\n        status: \"success\",\n        dateAttempted: new Date(),\n        exportMethod: \"reaction-connectors-shopify\",\n        destinationIdentifier: exportedOrder.id,\n        shopId\n      }\n    }\n  });\n}","map":{"version":3,"sources":["imports/plugins/included/connectors-shopify/server/methods/export/orders.js"],"names":["module","export","exportToShopify","accounting","watch","require","default","v","Shopify","parse","format","Meteor","check","Match","Logger","convertWeight","Orders","Shops","getApiInfo","convertOrderToShopifyOrder","doc","index","shopId","existingCustomer","undefined","OneOf","Object","order","findOne","_id","paymentType","billing","method","itemsForShop","getItemsByShop","shopifyOrder","billing_address","convertAddress","address","shipping_address","shipping","customer","convertCustomer","email","mode","financial_status","id","line_items","convertLineItems","shipping_lines","convertShipping","phone","source_name","subtotal_price","getSubtotalByShop","token","total_discounts","getDiscountsByShop","total_line_item_price","reduce","total","item","variants","price","quantity","total_price","getTotalByShop","total_tax","getTaxesByShop","total_weight","sum","grams","normalizeWeight","weight","shop","baseUOM","items","lineItems","map","lineItem","fulfillable_quantity","fulfillment_service","fullfillment_status","parcel","product_id","productId","requires_shipping","product","requiresShipping","sku","title","variant_id","variant_title","vendor","taxable","taxes","tax_lines","taxItem","find","tax","lineNumber","details","forEach","detail","taxLine","taxName","toFixed","taxCalculated","rate","push","taxData","taxCode","convertedAddress","address1","address2","city","country","country_code","name","fullName","firstName","lastName","split","first_name","last_name","join","zip","postal","province_code","region","isExistingCustomer","shopify","query","customerByEmailPromise","search","normalizePhone","phoneToNormalize","countryCode","formattedPhone","replace","accepts_marketing","shippingLines","shipmentMethod","shippingMethod","code","source","carrier","numShopOrders","length","debug","shopifyOrders","apiCreds","existingCustomerQuery","Error","newShopifyOrder","create","markExported","exportedOrder","update","$push","exportHistory","status","dateAttempted","Date","exportMethod","destinationIdentifier"],"mappings":"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","sourcesContent":["/* eslint camelcase: 0 */\nimport accounting from \"accounting-js\";\nimport Shopify from \"shopify-api-node\";\nimport { parse, format } from \"libphonenumber-js\";\nimport { Meteor } from \"meteor/meteor\";\nimport { check, Match } from \"meteor/check\";\nimport { Logger } from \"/server/api\";\nimport { convertWeight } from \"/lib/api\";\nimport { Orders, Shops } from \"/lib/collections\";\nimport { getApiInfo } from \"../api\";\n\n/**\n * @private\n * @summary build a new object for export to Shopify\n * @param {Object} doc - the order to convert\n * @param {Number} index - the sequence number of billing/shipping records we are processing\n * @param {String} shopId - the Id of the shop we are processing for\n * @param {Object} existingCustomer - the existing customer Id if it exists\n * @returns {Object} shopifyOrder - the converted order\n */\nfunction convertOrderToShopifyOrder(doc, index, shopId, existingCustomer = undefined) {\n  check(existingCustomer, Match.OneOf(Object, undefined));\n  const order = Orders.findOne(doc._id); // only this object has the original transforms defined\n  const paymentType = order.billing[index].method;\n  const itemsForShop = order.getItemsByShop()[shopId];\n  const shopifyOrder = {};\n  shopifyOrder.billing_address = convertAddress(order.billing[index].address);\n  shopifyOrder.shipping_address = convertAddress(order.shipping[index].address);\n  if (!existingCustomer) {\n    shopifyOrder.customer = convertCustomer(shopifyOrder.billing_address, order);\n  } else {\n    shopifyOrder.customer = existingCustomer;\n  }\n  shopifyOrder.email = order.email;\n  if (paymentType === \"credit\" && order.billing[index].mode === \"authorize\") {\n    shopifyOrder.financial_status = \"authorized\";\n  } else {\n    shopifyOrder.financial_status = \"paid\";\n  }\n  shopifyOrder.id = order._id;\n  shopifyOrder.line_items = convertLineItems(itemsForShop, order);\n  shopifyOrder.shipping_lines = convertShipping(order, index);\n  shopifyOrder.phone = order.billing[index].address.phone;\n  shopifyOrder.source_name = \"reaction_export\";\n  shopifyOrder.subtotal_price = order.getSubtotalByShop()[shopId];\n  shopifyOrder.token = order._id;\n  shopifyOrder.total_discounts = order.getDiscountsByShop()[shopId];\n  shopifyOrder.total_line_item_price = order.getItemsByShop()[shopId].reduce((total, item) => total + (item.variants.price * item.quantity), 0);\n  shopifyOrder.total_price = order.getTotalByShop()[shopId];\n  shopifyOrder.total_tax = order.getTaxesByShop()[shopId];\n  shopifyOrder.total_weight = shopifyOrder.line_items.reduce((sum, item) => sum + (item.grams * item.quantity), 0);\n  return shopifyOrder;\n}\n\n/**\n * @private\n * @summary Normalize all weights to grams\n * @param {Number} weight - the original weight value\n * @param {String} shopId - the shop we are converting for\n * @returns {Number} the normalized value\n */\nfunction normalizeWeight(weight, shopId) {\n  // if weight is not grams, convert to grams if is grams just return\n  const shop = Shops.findOne(shopId);\n  const { baseUOM } = shop;\n  if (baseUOM === \"g\") {\n    return weight;\n  }\n  if (baseUOM === \"lb\") {\n    return convertWeight(\"lb\", \"g\", weight);\n  }\n\n  if (baseUOM === \"oz\") {\n    return convertWeight(\"oz\", \"g\", weight);\n  }\n\n  if (baseUOM === \"kg\") {\n    return convertWeight(\"kg\", \"g\", weight);\n  }\n}\n\n/**\n * @private\n * @summary Convert individual line items of an order\n * @param {Array} items - The items on the order object\n * @param {Object} order - The order we are converting for\n * @returns {Array} An array of converted line items\n */\nfunction convertLineItems(items, order) {\n  const lineItems = items.map((item) => {\n    const lineItem = {};\n    lineItem.fulfillable_quantity = item.quantity;\n    lineItem.fulfillment_service = \"manual\";\n    lineItem.fullfillment_status = null;\n    if (item.parcel && item.parcel.weight) {\n      lineItem.grams = normalizeWeight(item.parcel.weight, item.shopId);\n    }\n    lineItem.id = item._id;\n    lineItem.product_id = item.productId;\n    lineItem.quantity = item.quantity;\n    lineItem.requires_shipping = item.product.requiresShipping;\n    if (item.variants.sku) { // this doesn't appear to be written anywhere but it's in the schema\n      lineItem.sku = item.variants.sku;\n    }\n    lineItem.title = item.product.title;\n    lineItem.variant_id = item.variants._id;\n    lineItem.variant_title = item.variants.title;\n    lineItem.vendor = item.product.vendor;\n    lineItem.taxable = item.variants.taxable;\n    lineItem.price = item.variants.price;\n    if (order.taxes) {\n      lineItem.tax_lines = [];\n      // when using Avalara we get tax detail\n      // get the tax iten for this particular line\n      const taxItem = order.taxes.find((tax) => tax.lineNumber === item._id);\n      taxItem.details.forEach((detail) => {\n        const taxLine = {\n          title: detail.taxName,\n          price: accounting.toFixed(detail.taxCalculated, 2),\n          rate: detail.rate\n        };\n        lineItem.tax_lines.push(taxLine);\n      });\n    }\n    // for custom tax codes we get this one data point\n    if (item.taxData) {\n      lineItem.tax_lines = [{\n        title: item.taxData.taxCode,\n        price: accounting.toFixed((item.taxData.rate / 100) * item.variants.price, 2),\n        rate: item.taxData.rate / 100\n      }];\n    }\n    return lineItem;\n  });\n  return lineItems;\n}\n\n/**\n * @private\n * @summary Convert address object into Shopify-compatible format\n * @param {Object} address - the address to convert\n * @returns {Object} converted address\n */\nfunction convertAddress(address) {\n  const convertedAddress = {};\n  convertedAddress.address1 = address.address1;\n  convertedAddress.address2 = address.address2 || \"\";\n  convertedAddress.city = address.city;\n  convertedAddress.country = address.country;\n  convertedAddress.country_code = address.country;\n  convertedAddress.name = address.fullName;\n  const [firstName, ...lastName] = address.fullName.split(\" \");\n  convertedAddress.first_name = firstName;\n  convertedAddress.last_name = lastName.join(\" \");\n  convertedAddress.phone = address.phone;\n  convertedAddress.zip = address.postal;\n  convertedAddress.province_code = address.region;\n  return convertedAddress;\n}\n\nasync function isExistingCustomer(address, email, shopify) {\n  const query = `email:${email}`;\n  const customerByEmailPromise = shopify.customer.search({ query });\n  return customerByEmailPromise;\n}\n\nfunction normalizePhone(phoneToNormalize, countryCode) {\n  const { phone } = parse(phoneToNormalize, countryCode);\n  const formattedPhone = format(phone, countryCode, \"International\").replace(/\\s/g, \"\");\n  return formattedPhone;\n}\n\n/**\n * @private\n * @summary Create a customer object in Shopify-compatible format\n * @param {Object} address - Converted address object\n * @param {Object} order - Original order we are converting\n * @returns {Object} Shopify-compatible customer object\n */\nfunction convertCustomer(address, order) {\n  const formattedPhone = normalizePhone(address.phone, address.country_code);\n  const customer = {\n    accepts_marketing: false,\n    email: order.email,\n    phone: formattedPhone,\n    first_name: address.first_name,\n    last_name: address.last_name\n  };\n  return customer;\n}\n\n/**\n * @private\n * @summary Create a shippingMethod object to record shipping on a Shopify order\n * @param {Object} order - The order with shipping data\n * @param {Number} index - The shop index to convert\n * @returns {Array} An array of shipping lines\n */\nfunction convertShipping(order, index) {\n  const shippingLines = [];\n  // I don't think we need to check this because we should **always** have a shipping record per shop\n  // so worst case shipmentMethod is undefined and we will skip\n  const method = order.shipping[index].shipmentMethod;\n  if (method) {\n    const shippingMethod = {\n      code: method.name,\n      price: method.rate,\n      title: method.name,\n      source: method.carrier\n    };\n    shippingLines.push(shippingMethod);\n  }\n  return shippingLines;\n}\n\n\n/**\n * @summary Export an order to Shopify\n * @param {Object} doc - The order to convert\n * @returns {Promise.<Array>} - An array of exported orders\n */\nexport async function exportToShopify(doc) {\n  const numShopOrders = doc.billing.length; // if we have multiple billing, we have multiple shops\n  Logger.debug(`Exporting ${numShopOrders} order(s) to Shopify`);\n  const shopifyOrders = [];\n  for (let index = 0; index < numShopOrders; index += 1) {\n    // send a shopify order once for each merchant order\n    const { shopId } = doc.billing[index];\n    const apiCreds = getApiInfo(shopId);\n    const shopify = new Shopify(apiCreds);\n    const existingCustomerQuery = await isExistingCustomer(doc.billing[index].address, doc.email, shopify); // eslint-disable-line no-await-in-loop\n    // this should never happen but I want a meaningful error here in case it does\n    if (existingCustomerQuery.length > 1) {\n      throw new Meteor.Error(\"duplicate-customer\", \"Discovered more than one customer in Shopify. Cannot continue\");\n    }\n    const existingCustomer = existingCustomerQuery[0];\n    const shopifyOrder = convertOrderToShopifyOrder(doc, index, shopId, existingCustomer);\n    Logger.debug(\"sending shopify order\", shopifyOrder, doc._id);\n    const newShopifyOrder = await shopify.order.create(shopifyOrder); // eslint-disable-line no-await-in-loop\n    markExported(newShopifyOrder, shopId, doc);\n    shopifyOrders.push(newShopifyOrder);\n  }\n  return shopifyOrders;\n}\n\n\n/**\n * @private\n * @summary Mark orders as exported after export\n * @param {Object} exportedOrder the converted order\n * @param {String} shopId - the shopId to attach\n * @param {Object} order - the order to be marked\n */\nfunction markExported(exportedOrder, shopId, order) {\n  Orders.update({ _id: order._id }, {\n    $push: {\n      exportHistory: {\n        status: \"success\",\n        dateAttempted: new Date(),\n        exportMethod: \"reaction-connectors-shopify\",\n        destinationIdentifier: exportedOrder.id,\n        shopId\n      }\n    }\n  });\n}\n"]},"sourceType":"script","hash":"d0e45c1e8c6dc89a3ac287f59ce9bf50eea6227b"}
