{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$1$2","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"ast":true,"babelrc":false,"sourceFileName":"imports/plugins/included/jobcontrol/server/jobs/exchangerates.js","filename":"imports/plugins/included/jobcontrol/server/jobs/exchangerates.js","sourceMaps":true,"envName":"development","cwd":"/Users/estebandev/test-knowledge","passPerPreset":false,"presets":[],"parserOpts":{"sourceType":"module","sourceFileName":"imports/plugins/included/jobcontrol/server/jobs/exchangerates.js","plugins":["jsx","jsx","flow","flow","objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties"]},"generatorOpts":{"filename":"imports/plugins/included/jobcontrol/server/jobs/exchangerates.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"imports/plugins/included/jobcontrol/server/jobs/exchangerates.js"}},"code":"module.export({\n  setupFetchFlushCurrencyHooks: () => setupFetchFlushCurrencyHooks,\n  fetchRateJobs: () => fetchRateJobs\n});\nlet Meteor;\nmodule.watch(require(\"meteor/meteor\"), {\n  Meteor(v) {\n    Meteor = v;\n  }\n\n}, 0);\nlet Job;\nmodule.watch(require(\"../../../../core/job-collection/lib\"), {\n  Job(v) {\n    Job = v;\n  }\n\n}, 1);\nlet Jobs;\nmodule.watch(require(\"../../../../../../lib/collections\"), {\n  Jobs(v) {\n    Jobs = v;\n  }\n\n}, 2);\nlet Hooks, Logger, Reaction;\nmodule.watch(require(\"../../../../../../server/api\"), {\n  Hooks(v) {\n    Hooks = v;\n  },\n\n  Logger(v) {\n    Logger = v;\n  },\n\n  Reaction(v) {\n    Reaction = v;\n  }\n\n}, 3);\n\nfunction setupFetchFlushCurrencyHooks() {\n  // While we don't necessarily need to wait for anything to add a job\n  // in this case we need to have packages loaded so we can check for the OER API key\n  Hooks.Events.add(\"afterCoreInit\", () => {\n    const settings = Reaction.getShopSettings();\n    const exchangeConfig = settings.openexchangerates || {};\n\n    if (exchangeConfig.appId) {\n      const refreshPeriod = exchangeConfig.refreshPeriod || \"every 4 hours\";\n      Logger.debug(`Adding shop/fetchCurrencyRates to JobControl. Refresh ${refreshPeriod}`);\n      new Job(Jobs, \"shop/fetchCurrencyRates\", {}).retry({\n        retries: 5,\n        wait: 60000,\n        backoff: \"exponential\" // delay by twice as long for each subsequent retry\n\n      }).repeat({\n        schedule: Jobs.later.parse.text(refreshPeriod)\n      }).save({\n        // Cancel any jobs of the same type,\n        // but only if this job repeats forever.\n        cancelRepeats: true\n      }); // Run the first time immediately after server start. The repeat({schedule}) option via\n      // later.js scheduling won't run before the first scheduled time, even with delay() or after()\n\n      new Job(Jobs, \"shop/fetchCurrencyRates\", {}).retry({\n        retries: 5,\n        wait: 10000\n      }).save();\n    } else {\n      Logger.warn(\"OpenExchangeRates API not configured. Not adding fetchRates job\");\n    }\n  });\n  Hooks.Events.add(\"afterCoreInit\", () => {\n    const settings = Reaction.getShopSettings();\n    const exchangeConfig = settings.openexchangerates || {};\n\n    if (exchangeConfig.appId) {\n      Logger.debug(\"Adding shop/flushCurrencyRates to JobControl\"); // TODO: Add this as a configurable option\n\n      const refreshPeriod = \"Every 24 hours\";\n      new Job(Jobs, \"shop/flushCurrencyRates\", {}).retry({\n        retries: 5,\n        wait: 60000,\n        backoff: \"exponential\"\n      }).repeat({\n        schedule: Jobs.later.parse.text(refreshPeriod)\n      }).save({\n        cancelRepeats: true\n      });\n    } else {\n      Logger.warn(\"OpenExchangeRates API not configured. Not adding flushRates job\");\n    }\n  });\n}\n\nfunction fetchRateJobs() {\n  const fetchCurrencyRates = Jobs.processJobs(\"shop/fetchCurrencyRates\", {\n    pollInterval: 60 * 60 * 1000,\n    // backup polling, see observer below\n    workTimeout: 180 * 1000\n  }, (job, callback) => {\n    Meteor.call(\"shop/fetchCurrencyRate\", error => {\n      if (error) {\n        if (error.error === \"notConfigured\") {\n          Logger.error(error.message);\n          job.done(error.message, {\n            repeatId: true\n          });\n        } else {\n          job.done(error.toString(), {\n            repeatId: true\n          });\n        }\n      } else {\n        // we should always return \"completed\" job here, because errors are fine\n        // result for this task, so that's why we show message if error happens\n        // and return job.done();\n        // you can read more about job.repeat() here:\n        // https://github.com/vsivsi/meteor-job-collection#set-how-many-times-this\n        // -job-will-be-automatically-re-run-by-the-job-collection\n        const success = \"Latest exchange rates were fetched successfully.\";\n        Logger.debug(success);\n        job.done(success, {\n          repeatId: true\n        });\n      }\n    });\n    callback();\n  });\n  Jobs.find({\n    type: \"shop/fetchCurrencyRates\",\n    status: \"ready\"\n  }).observe({\n    added() {\n      return fetchCurrencyRates.trigger();\n    }\n\n  });\n  const flushCurrencyRates = Jobs.processJobs(\"shop/flushCurrencyRates\", {\n    pollInterval: 60 * 60 * 1000,\n    // backup polling, see observer below\n    workTimeout: 180 * 1000\n  }, (job, callback) => {\n    Meteor.call(\"shop/flushCurrencyRate\", error => {\n      if (error) {\n        if (error.error === \"notExists\") {\n          Logger.error(error.message);\n          job.done(error.message, {\n            repeatId: true\n          });\n        } else {\n          // Logger.error(error.toString());\n          job.done(error.toString(), {\n            repeatId: true\n          });\n        }\n      } else {\n        // https://github.com/vsivsi/meteor-job-collection#set-how-many-times-this\n        // -job-will-be-automatically-re-run-by-the-job-collection\n        const success = \"Stale exchange rates were flushed.\";\n        Logger.debug(success);\n        job.done(success, {\n          repeatId: true\n        });\n      }\n    });\n    callback();\n  });\n  Jobs.find({\n    type: \"shop/flushCurrencyRates\",\n    status: \"ready\"\n  }).observe({\n    added() {\n      return flushCurrencyRates.trigger();\n    }\n\n  });\n}","map":{"version":3,"sources":["imports/plugins/included/jobcontrol/server/jobs/exchangerates.js"],"names":["module","export","setupFetchFlushCurrencyHooks","fetchRateJobs","Meteor","watch","require","v","Job","Jobs","Hooks","Logger","Reaction","Events","add","settings","getShopSettings","exchangeConfig","openexchangerates","appId","refreshPeriod","debug","retry","retries","wait","backoff","repeat","schedule","later","parse","text","save","cancelRepeats","warn","fetchCurrencyRates","processJobs","pollInterval","workTimeout","job","callback","call","error","message","done","repeatId","toString","success","find","type","status","observe","added","trigger","flushCurrencyRates"],"mappings":"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","sourcesContent":["import { Meteor } from \"meteor/meteor\";\nimport { Job } from \"/imports/plugins/core/job-collection/lib\";\nimport { Jobs } from \"/lib/collections\";\nimport { Hooks, Logger, Reaction } from \"/server/api\";\n\n\nexport function setupFetchFlushCurrencyHooks() {\n  // While we don't necessarily need to wait for anything to add a job\n  // in this case we need to have packages loaded so we can check for the OER API key\n  Hooks.Events.add(\"afterCoreInit\", () => {\n    const settings = Reaction.getShopSettings();\n    const exchangeConfig = settings.openexchangerates || {};\n\n    if (exchangeConfig.appId) {\n      const refreshPeriod = exchangeConfig.refreshPeriod || \"every 4 hours\";\n      Logger.debug(`Adding shop/fetchCurrencyRates to JobControl. Refresh ${refreshPeriod}`);\n      new Job(Jobs, \"shop/fetchCurrencyRates\", {})\n        .retry({\n          retries: 5,\n          wait: 60000,\n          backoff: \"exponential\" // delay by twice as long for each subsequent retry\n        })\n        .repeat({\n          schedule: Jobs.later.parse.text(refreshPeriod)\n        })\n        .save({\n          // Cancel any jobs of the same type,\n          // but only if this job repeats forever.\n          cancelRepeats: true\n        });\n\n      // Run the first time immediately after server start. The repeat({schedule}) option via\n      // later.js scheduling won't run before the first scheduled time, even with delay() or after()\n      new Job(Jobs, \"shop/fetchCurrencyRates\", {})\n        .retry({\n          retries: 5,\n          wait: 10000\n        })\n        .save();\n    } else {\n      Logger.warn(\"OpenExchangeRates API not configured. Not adding fetchRates job\");\n    }\n  });\n\n  Hooks.Events.add(\"afterCoreInit\", () => {\n    const settings = Reaction.getShopSettings();\n    const exchangeConfig = settings.openexchangerates || {};\n\n    if (exchangeConfig.appId) {\n      Logger.debug(\"Adding shop/flushCurrencyRates to JobControl\");\n      // TODO: Add this as a configurable option\n      const refreshPeriod = \"Every 24 hours\";\n      new Job(Jobs, \"shop/flushCurrencyRates\", {})\n        .retry({\n          retries: 5,\n          wait: 60000,\n          backoff: \"exponential\"\n        })\n        .repeat({\n          schedule: Jobs.later.parse.text(refreshPeriod)\n        })\n        .save({\n          cancelRepeats: true\n        });\n    } else {\n      Logger.warn(\"OpenExchangeRates API not configured. Not adding flushRates job\");\n    }\n  });\n}\n\n\nexport function fetchRateJobs() {\n  const fetchCurrencyRates = Jobs.processJobs(\"shop/fetchCurrencyRates\", {\n    pollInterval: 60 * 60 * 1000, // backup polling, see observer below\n    workTimeout: 180 * 1000\n  }, (job, callback) => {\n    Meteor.call(\"shop/fetchCurrencyRate\", (error) => {\n      if (error) {\n        if (error.error === \"notConfigured\") {\n          Logger.error(error.message);\n          job.done(error.message, { repeatId: true });\n        } else {\n          job.done(error.toString(), { repeatId: true });\n        }\n      } else {\n        // we should always return \"completed\" job here, because errors are fine\n        // result for this task, so that's why we show message if error happens\n        // and return job.done();\n        // you can read more about job.repeat() here:\n        // https://github.com/vsivsi/meteor-job-collection#set-how-many-times-this\n        // -job-will-be-automatically-re-run-by-the-job-collection\n        const success = \"Latest exchange rates were fetched successfully.\";\n        Logger.debug(success);\n        job.done(success, { repeatId: true });\n      }\n    });\n    callback();\n  });\n\n  Jobs.find({\n    type: \"shop/fetchCurrencyRates\",\n    status: \"ready\"\n  }).observe({\n    added() {\n      return fetchCurrencyRates.trigger();\n    }\n  });\n\n\n  const flushCurrencyRates = Jobs.processJobs(\n    \"shop/flushCurrencyRates\", {\n      pollInterval: 60 * 60 * 1000, // backup polling, see observer below\n      workTimeout: 180 * 1000\n    },\n    (job, callback) => {\n      Meteor.call(\"shop/flushCurrencyRate\", (error) => {\n        if (error) {\n          if (error.error === \"notExists\") {\n            Logger.error(error.message);\n            job.done(error.message, { repeatId: true });\n          } else {\n            // Logger.error(error.toString());\n            job.done(error.toString(), { repeatId: true });\n          }\n        } else {\n          // https://github.com/vsivsi/meteor-job-collection#set-how-many-times-this\n          // -job-will-be-automatically-re-run-by-the-job-collection\n          const success = \"Stale exchange rates were flushed.\";\n          Logger.debug(success);\n          job.done(success, { repeatId: true });\n        }\n      });\n      callback();\n    }\n  );\n\n  Jobs.find({\n    type: \"shop/flushCurrencyRates\",\n    status: \"ready\"\n  }).observe({\n    added() {\n      return flushCurrencyRates.trigger();\n    }\n  });\n}\n"]},"sourceType":"script","hash":"d832bf63f29e2f2d3c826971ae2aa3828b004af0"}
