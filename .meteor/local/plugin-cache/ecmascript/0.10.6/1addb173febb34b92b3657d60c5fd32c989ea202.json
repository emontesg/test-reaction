{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$1$2","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"ast":true,"babelrc":false,"sourceFileName":"server/api/method-hooks.js","filename":"server/api/method-hooks.js","sourceMaps":true,"envName":"development","cwd":"/Users/estebandev/test-knowledge","passPerPreset":false,"presets":[],"parserOpts":{"sourceType":"module","sourceFileName":"server/api/method-hooks.js","plugins":["jsx","jsx","flow","flow","objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties"]},"generatorOpts":{"filename":"server/api/method-hooks.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"server/api/method-hooks.js"}},"code":"module.export({\n  MethodHooks: () => MethodHooks\n});\n\nlet _isUndefined;\n\nmodule.watch(require(\"lodash/isUndefined\"), {\n  default(v) {\n    _isUndefined = v;\n  }\n\n}, 0);\n\nlet _each;\n\nmodule.watch(require(\"lodash/each\"), {\n  default(v) {\n    _each = v;\n  }\n\n}, 1);\n\nlet _toArray;\n\nmodule.watch(require(\"lodash/toArray\"), {\n  default(v) {\n    _toArray = v;\n  }\n\n}, 2);\nlet Meteor;\nmodule.watch(require(\"meteor/meteor\"), {\n  Meteor(v) {\n    Meteor = v;\n  }\n\n}, 3);\nconst MethodHooks = {};\n\n/**\n * @method afterHooks\n * @summary A collection of after hooks\n * @type {Object}\n * @summary <String, [Hook]> A mapping from method names to arrays of hooks\n * @private\n */\nMethodHooks._afterHooks = {};\n/**\n * @summary A collection of before hooks\n * @type {Object}\n * @summary <String, [Hook]> A mapping from method names to arrays of hooks\n * @private\n */\n\nMethodHooks._beforeHooks = {};\n/**\n * @method handlers\n * @summary The method handler definitions appropriate to the environment\n */\n\nMethodHooks._handlers = Meteor.isClient ? Meteor.connection._methodHandlers : Meteor.server.method_handlers;\n/**\n * @method _originalMethodHandlers\n * @summary The original method handlers\n * @type {Object}\n * @returns <String, Function> Method handler mapping\n * @private\n */\n\nMethodHooks._originalMethodHandlers = {};\n/**\n * @method Wrappers\n * @type {Object}\n * @summary <String, Function> A mapping from method names to method functions\n * @private\n */\n\nMethodHooks._wrappers = {};\n/**\n * @method initializeHook\n * @summary Initializes a new hook\n * @param {String} mapping - map hook: a is  place to store the mapping\n * @param {String} methodName - The name of the method\n * @param {Function} hookFunction - The hook function\n * @private\n * @return {String} - returns transformed data\n */\n\nMethodHooks._initializeHook = function (mapping, methodName, hookFunction) {\n  mapping[methodName] = mapping[methodName] || [];\n  mapping[methodName].push(hookFunction); // Initialize a wrapper for the given method name. Idempotent, it will not erase existing handlers.\n\n  const method = MethodHooks._handlers[methodName]; // If no method is found, or a wrapper already exists, return\n\n  if (!method || MethodHooks._wrappers[methodName]) {\n    return;\n  } // Get a reference to the original handler\n\n\n  MethodHooks._originalMethodHandlers[methodName] = method;\n\n  MethodHooks._wrappers[methodName] = function (...inputArgs) {\n    // Get arguments you can mutate\n    const args = _toArray(inputArgs);\n\n    let beforeResult; // Call the before hooks\n\n    const beforeHooks = MethodHooks._beforeHooks[methodName];\n\n    _each(beforeHooks, (beforeHook, hooksProcessed) => {\n      beforeResult = beforeHook.call(this, {\n        result: undefined,\n        error: undefined,\n        arguments: args,\n        hooksProcessed\n      });\n\n      if (beforeResult === false) {\n        return false;\n      }\n    });\n\n    if (beforeResult === false) {\n      return false;\n    }\n\n    let methodResult;\n    let methodError; // Call the main method body\n    // check(args, Match.Any);\n\n    try {\n      methodResult = MethodHooks._originalMethodHandlers[methodName].apply(this, args);\n    } catch (error) {\n      methodError = error;\n    } // Call after hooks, providing the result and the original arguments\n\n\n    const afterHooks = MethodHooks._afterHooks[methodName];\n\n    _each(afterHooks, (afterHook, hooksProcessed) => {\n      const hookResult = afterHook.call(this, {\n        result: methodResult,\n        error: methodError,\n        arguments: args,\n        hooksProcessed\n      }); // If the after hook did not return a value and the methodResult is not undefined, warn and fix\n\n      if (_isUndefined(hookResult) && !_isUndefined(methodResult)) {\n        Meteor._debug(\"Expected the after hook to return a value.\");\n      } else {\n        methodResult = hookResult;\n      }\n    }); // If an error was thrown, throw it after the after hooks. Ought to include the correct stack information\n\n\n    if (methodError) {\n      throw methodError;\n    } // Return the method result, possibly modified by the after hook\n\n\n    return methodResult;\n  }; // Assign to a new handler\n\n\n  MethodHooks._handlers[methodName] = MethodHooks._wrappers[methodName];\n};\n/**\n * @method before\n * @memberof MethodHooks\n * @summary Add a function to call before the specified method\n * @param {String} methodName - methodName\n * @param {String} beforeFunction - beforeFunction\n * @return {String} - returns transformed data, Ignored for before hooks\n */\n\n\nMethodHooks.before = function (methodName, beforeFunction) {\n  MethodHooks._initializeHook(MethodHooks._beforeHooks, methodName, beforeFunction);\n};\n/**\n * @method after\n * @memberof MethodHooks\n * @summary Add a function to call after the specified method\n * After hooks can change the result values. Use `hooksProcessed` to keep track of how many modifications have been made. You can mutate the return value in after hooks.\n * @param {String} methodName - methodName\n * @param {String} afterFunction - afterFunction\n * @return {String} - returns transformed data, Passed as the methodResult to subsequent method hooks.\n */\n\n\nMethodHooks.after = function (methodName, afterFunction) {\n  MethodHooks._initializeHook(MethodHooks._afterHooks, methodName, afterFunction);\n};\n/**\n * @method beforeMethods\n * @memberof MethodHooks\n * @summary Call the provided hook in values for the key'd method names\n * @param {Object} dict - <string, Hook> dict\n * @return {String} - returns transformed data, Ignored for before hooks\n */\n\n\nMethodHooks.beforeMethods = function (dict) {\n  _each(dict, (v, k) => {\n    MethodHooks.before(k, v);\n  });\n};\n/**\n * @method afterMethods\n * @memberof MethodHooks\n * @summary Call the provided hook in values for the key'd method names\n * @param {Object} dict - <string, Hook> dict\n * @return {String} - returns transformed data, Passed as the methodResult to subsequent method hooks.\n */\n\n\nMethodHooks.afterMethods = function (dict) {\n  _each(dict, (v, k) => {\n    MethodHooks.after(k, v);\n  });\n};","map":{"version":3,"sources":["server/api/method-hooks.js"],"names":["module","export","MethodHooks","_isUndefined","watch","require","default","v","_each","_toArray","Meteor","_afterHooks","_beforeHooks","_handlers","isClient","connection","_methodHandlers","server","method_handlers","_originalMethodHandlers","_wrappers","_initializeHook","mapping","methodName","hookFunction","push","method","inputArgs","args","beforeResult","beforeHooks","beforeHook","hooksProcessed","call","result","undefined","error","arguments","methodResult","methodError","apply","afterHooks","afterHook","hookResult","_debug","before","beforeFunction","after","afterFunction","beforeMethods","dict","k","afterMethods"],"mappings":"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","sourcesContent":["import _ from \"lodash\";\nimport { Meteor } from \"meteor/meteor\";\n\n/**\n * @file **Method Hooks for Meteor** - Use a hook to run something before or after a method on the server\n * Reused Meteor method hooks from [hitchcott/meteor-method-hooks](https://github.com/hitchcott/meteor-method-hooks) and [Workpop/meteor-method-hooks](https://github.com/Workpop/meteor-method-hooks)\n * Read more on how to use [Method Hooks](https://docs.reactioncommerce.com/reaction-docs/master/method-hooks).\n * @example MethodHooks.after('orders/orderCompleted', callback)\n * @namespace MethodHooks\n */\nexport const MethodHooks = {};\n\n/**\n * @method afterHooks\n * @summary A collection of after hooks\n * @type {Object}\n * @summary <String, [Hook]> A mapping from method names to arrays of hooks\n * @private\n */\nMethodHooks._afterHooks = {};\n\n/**\n * @summary A collection of before hooks\n * @type {Object}\n * @summary <String, [Hook]> A mapping from method names to arrays of hooks\n * @private\n */\nMethodHooks._beforeHooks = {};\n\n/**\n * @method handlers\n * @summary The method handler definitions appropriate to the environment\n */\nMethodHooks._handlers = Meteor.isClient ? Meteor.connection._methodHandlers :\n  Meteor.server.method_handlers;\n\n/**\n * @method _originalMethodHandlers\n * @summary The original method handlers\n * @type {Object}\n * @returns <String, Function> Method handler mapping\n * @private\n */\nMethodHooks._originalMethodHandlers = {};\n\n/**\n * @method Wrappers\n * @type {Object}\n * @summary <String, Function> A mapping from method names to method functions\n * @private\n */\nMethodHooks._wrappers = {};\n\n/**\n * @method initializeHook\n * @summary Initializes a new hook\n * @param {String} mapping - map hook: a is  place to store the mapping\n * @param {String} methodName - The name of the method\n * @param {Function} hookFunction - The hook function\n * @private\n * @return {String} - returns transformed data\n */\nMethodHooks._initializeHook = function (mapping, methodName, hookFunction) {\n  mapping[methodName] = mapping[methodName] || [];\n  mapping[methodName].push(hookFunction);\n\n  // Initialize a wrapper for the given method name. Idempotent, it will not erase existing handlers.\n  const method = MethodHooks._handlers[methodName];\n  // If no method is found, or a wrapper already exists, return\n  if (!method || MethodHooks._wrappers[methodName]) {\n    return;\n  }\n\n  // Get a reference to the original handler\n  MethodHooks._originalMethodHandlers[methodName] = method;\n\n  MethodHooks._wrappers[methodName] = function (...inputArgs) {\n    // Get arguments you can mutate\n    const args = _.toArray(inputArgs);\n    let beforeResult;\n    // Call the before hooks\n\n    const beforeHooks = MethodHooks._beforeHooks[methodName];\n    _.each(beforeHooks, (beforeHook, hooksProcessed) => {\n      beforeResult = beforeHook.call(this, {\n        result: undefined,\n        error: undefined,\n        arguments: args,\n        hooksProcessed\n      });\n\n      if (beforeResult === false) {\n        return false;\n      }\n    });\n\n    if (beforeResult === false) {\n      return false;\n    }\n    let methodResult;\n    let methodError;\n\n    // Call the main method body\n    // check(args, Match.Any);\n    try {\n      methodResult = MethodHooks._originalMethodHandlers[methodName].apply(this, args);\n    } catch (error) {\n      methodError = error;\n    }\n\n    // Call after hooks, providing the result and the original arguments\n    const afterHooks = MethodHooks._afterHooks[methodName];\n    _.each(afterHooks, (afterHook, hooksProcessed) => {\n      const hookResult = afterHook.call(this, {\n        result: methodResult,\n        error: methodError,\n        arguments: args,\n        hooksProcessed\n      });\n      // If the after hook did not return a value and the methodResult is not undefined, warn and fix\n      if (_.isUndefined(hookResult) && !_.isUndefined(methodResult)) {\n        Meteor._debug(\"Expected the after hook to return a value.\");\n      } else {\n        methodResult = hookResult;\n      }\n    });\n\n    // If an error was thrown, throw it after the after hooks. Ought to include the correct stack information\n    if (methodError) {\n      throw methodError;\n    }\n\n    // Return the method result, possibly modified by the after hook\n    return methodResult;\n  };\n\n  // Assign to a new handler\n  MethodHooks._handlers[methodName] = MethodHooks._wrappers[\n    methodName];\n};\n\n/**\n * @method before\n * @memberof MethodHooks\n * @summary Add a function to call before the specified method\n * @param {String} methodName - methodName\n * @param {String} beforeFunction - beforeFunction\n * @return {String} - returns transformed data, Ignored for before hooks\n */\nMethodHooks.before = function (methodName, beforeFunction) {\n  MethodHooks._initializeHook(\n    MethodHooks._beforeHooks,\n    methodName, beforeFunction\n  );\n};\n\n/**\n * @method after\n * @memberof MethodHooks\n * @summary Add a function to call after the specified method\n * After hooks can change the result values. Use `hooksProcessed` to keep track of how many modifications have been made. You can mutate the return value in after hooks.\n * @param {String} methodName - methodName\n * @param {String} afterFunction - afterFunction\n * @return {String} - returns transformed data, Passed as the methodResult to subsequent method hooks.\n */\nMethodHooks.after = function (methodName, afterFunction) {\n  MethodHooks._initializeHook(\n    MethodHooks._afterHooks,\n    methodName, afterFunction\n  );\n};\n\n/**\n * @method beforeMethods\n * @memberof MethodHooks\n * @summary Call the provided hook in values for the key'd method names\n * @param {Object} dict - <string, Hook> dict\n * @return {String} - returns transformed data, Ignored for before hooks\n */\nMethodHooks.beforeMethods = function (dict) {\n  _.each(dict, (v, k) => {\n    MethodHooks.before(k, v);\n  });\n};\n\n/**\n * @method afterMethods\n * @memberof MethodHooks\n * @summary Call the provided hook in values for the key'd method names\n * @param {Object} dict - <string, Hook> dict\n * @return {String} - returns transformed data, Passed as the methodResult to subsequent method hooks.\n */\nMethodHooks.afterMethods = function (dict) {\n  _.each(dict, (v, k) => {\n    MethodHooks.after(k, v);\n  });\n};\n"]},"sourceType":"script","hash":"1addb173febb34b92b3657d60c5fd32c989ea202"}
