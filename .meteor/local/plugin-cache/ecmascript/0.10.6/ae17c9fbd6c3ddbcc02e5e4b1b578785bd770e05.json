{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$1$2","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"ast":true,"babelrc":false,"sourceFileName":"imports/plugins/included/payments-paypal/server/methods/express.js","filename":"imports/plugins/included/payments-paypal/server/methods/express.js","sourceMaps":true,"envName":"development","cwd":"/Users/estebandev/test-knowledge","passPerPreset":false,"presets":[],"parserOpts":{"sourceType":"module","sourceFileName":"imports/plugins/included/payments-paypal/server/methods/express.js","plugins":["jsx","jsx","flow","flow","objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties"]},"generatorOpts":{"filename":"imports/plugins/included/payments-paypal/server/methods/express.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"imports/plugins/included/payments-paypal/server/methods/express.js"}},"code":"module.export({\n  methods: () => methods\n});\n\nlet _last;\n\nmodule.watch(require(\"lodash/last\"), {\n  default(v) {\n    _last = v;\n  }\n\n}, 0);\nlet accounting;\nmodule.watch(require(\"accounting-js\"), {\n  default(v) {\n    accounting = v;\n  }\n\n}, 1);\nlet HTTP;\nmodule.watch(require(\"meteor/http\"), {\n  HTTP(v) {\n    HTTP = v;\n  }\n\n}, 2);\nlet Meteor;\nmodule.watch(require(\"meteor/meteor\"), {\n  Meteor(v) {\n    Meteor = v;\n  }\n\n}, 3);\nlet check;\nmodule.watch(require(\"meteor/check\"), {\n  check(v) {\n    check = v;\n  }\n\n}, 4);\nlet PayPal;\nmodule.watch(require(\"../../lib/api\"), {\n  PayPal(v) {\n    PayPal = v;\n  }\n\n}, 5);\nlet Shops, Cart, Packages;\nmodule.watch(require(\"../../../../../../lib/collections\"), {\n  Shops(v) {\n    Shops = v;\n  },\n\n  Cart(v) {\n    Cart = v;\n  },\n\n  Packages(v) {\n    Packages = v;\n  }\n\n}, 6);\nlet Logger;\nmodule.watch(require(\"../../../../../../server/api\"), {\n  Logger(v) {\n    Logger = v;\n  }\n\n}, 7);\nlet PaymentMethodArgument;\nmodule.watch(require(\"../../../../../../lib/collections/schemas\"), {\n  PaymentMethodArgument(v) {\n    PaymentMethodArgument = v;\n  }\n\n}, 8);\nlet moment;\n\nfunction lazyLoadMoment() {\n  return Promise.asyncApply(() => {\n    if (moment) return;\n    moment = Promise.await(Promise.resolve().then(() => require(\"moment\")));\n  });\n}\n\nconst nvpVersion = \"52.0\";\nconst methods = {\n  /**\n   * Acquire the Token required for PayPal Express transactions\n   * https://developer.paypal.com/docs/classic/api/merchant/SetExpressCheckout_API_Operation_NVP/\n   * @param  {String} cartId Reference to the Cart object to be processed\n   * @return {String} PayPal Token\n   */\n  \"getExpressCheckoutToken\"(cartId) {\n    check(cartId, String);\n    this.unblock();\n    const cart = Cart.findOne(cartId);\n\n    if (!cart) {\n      throw new Meteor.Error(\"invalid-parameter\", \"Bad cart ID\");\n    }\n\n    const shop = Shops.findOne(cart.shopId);\n\n    if (!shop) {\n      throw new Meteor.Error(\"invalid-parameter\", \"Bad shop ID\");\n    }\n\n    const amount = Number(cart.getTotal());\n    const shippingAmt = Number(cart.getShippingTotal());\n    const taxAmt = Number(cart.getTaxTotal());\n    const itemAmt = Number(cart.getSubTotal() - cart.getDiscounts());\n    const description = `${shop.name} Ref: ${cartId}`;\n    const {\n      currency\n    } = shop;\n    const options = PayPal.expressCheckoutAccountOptions();\n    let response;\n\n    try {\n      response = HTTP.post(options.url, {\n        params: {\n          USER: options.username,\n          PWD: options.password,\n          SIGNATURE: options.signature,\n          SOLUTIONTYPE: \"Mark\",\n          VERSION: nvpVersion,\n          PAYMENTACTION: \"Authorization\",\n          AMT: amount,\n          ITEMAMT: itemAmt,\n          SHIPPINGAMT: shippingAmt,\n          TAXAMT: taxAmt,\n          RETURNURL: options.return_url,\n          CANCELURL: options.cancel_url,\n          DESC: description,\n          NOSHIPPING: 1,\n          ALLOWNOTE: 1,\n          CURRENCYCODE: currency,\n          METHOD: \"SetExpressCheckout\",\n          INVNUM: cartId,\n          CUSTOM: `${cartId}|${amount}|${currency}`\n        }\n      });\n    } catch (error) {\n      throw new Meteor.Error(\"checkout-failed\", error.message);\n    }\n\n    if (!response || response.statusCode !== 200) {\n      throw new Meteor.Error(\"bad-response\", \"Bad response from PayPal\");\n    }\n\n    const parsedResponse = parseResponse(response);\n\n    if (parsedResponse.ACK !== \"Success\") {\n      throw new Meteor.Error(`ACK ${parsedResponse.ACK}: ${parsedResponse.L_LONGMESSAGE0}`);\n    }\n\n    return parsedResponse.TOKEN;\n  },\n\n  /**\n   * Perform the PayPal Express payment application\n   * https://developer.paypal.com/docs/classic/api/merchant/DoExpressCheckoutPayment_API_Operation_NVP/\n   * @param  {String} cartId Reference to the cart we are checking out\n   * @param  {String} token The Token provided by PayPal for this transaction\n   * @param  {String} payerId Reference to the payer\n   * @return {Object} results from PayPal normalized\n   */\n  \"confirmPaymentAuthorization\"(cartId, token, payerId) {\n    check(cartId, String);\n    check(token, String);\n    check(payerId, String);\n    this.unblock();\n    const cart = Cart.findOne(cartId);\n\n    if (!cart) {\n      throw new Meteor.Error(\"invalid-parameter\", \"Bad cart ID\");\n    }\n\n    const amount = Number(cart.getTotal());\n    const shippingAmt = Number(cart.getShippingTotal());\n    const taxAmt = Number(cart.getTaxTotal());\n    const itemAmt = Number(cart.getSubTotal() - cart.getDiscounts());\n    const shop = Shops.findOne(cart.shopId);\n    const {\n      currency\n    } = shop;\n    const options = PayPal.expressCheckoutAccountOptions();\n    const captureAtAuth = getSetting(cart.shopId, \"expressAuthAndCapture\");\n    let paymentAction;\n\n    if (captureAtAuth) {\n      paymentAction = \"Sale\";\n    } else {\n      paymentAction = \"Authorization\";\n    }\n\n    let response;\n\n    try {\n      response = HTTP.post(options.url, {\n        params: {\n          USER: options.username,\n          PWD: options.password,\n          SIGNATURE: options.signature,\n          VERSION: nvpVersion,\n          PAYMENTACTION: paymentAction,\n          AMT: amount,\n          ITEMAMT: itemAmt,\n          SHIPPINGAMT: shippingAmt,\n          TAXAMT: taxAmt,\n          METHOD: \"DoExpressCheckoutPayment\",\n          CURRENCYCODE: currency,\n          TOKEN: token,\n          PAYERID: payerId\n        }\n      });\n    } catch (error) {\n      throw new Meteor.Error(\"confirmation-failed\", error.message);\n    }\n\n    if (!response || response.statusCode !== 200) {\n      throw new Meteor.Error(\"bad-response\", \"Bad response from PayPal\");\n    }\n\n    const parsedResponse = parseResponse(response);\n\n    if (parsedResponse.ACK !== \"Success\") {\n      throw new Meteor.Error(`ACK ${parsedResponse.ACK}: ${parsedResponse.L_LONGMESSAGE0}:${parsedResponse.L_ERRORCODE0}`);\n    }\n\n    return parsedResponse;\n  },\n\n  /**\n   * Return the settings for the PayPal Express payment Method\n   * @return {Object} Express Checkout settings\n   */\n  \"getExpressCheckoutSettings\"() {\n    const settings = PayPal.expressCheckoutAccountOptions();\n    const expressCheckoutSettings = {\n      merchantId: settings.merchantId,\n      mode: settings.mode,\n      enabled: settings.enabled\n    };\n    return expressCheckoutSettings;\n  },\n\n  /**\n   * Capture an authorized PayPalExpress transaction\n   * https://developer.paypal.com/docs/classic/api/merchant/DoCapture_API_Operation_NVP/\n   * @param  {Object} paymentMethod A PaymentMethod object\n   * @return {Object} results from PayPal normalized\n   */\n  \"paypalexpress/payment/capture\"(paymentMethod) {\n    // Call both check and validate because by calling `clean`, the audit pkg\n    // thinks that we haven't checked paymentMethod arg\n    check(paymentMethod, Object);\n    PaymentMethodArgument.validate(PaymentMethodArgument.clean(paymentMethod));\n    this.unblock();\n    const options = PayPal.expressCheckoutAccountOptions();\n    const amount = accounting.toFixed(paymentMethod.amount, 2);\n    const authorizationId = paymentMethod.transactions[0].TRANSACTIONID;\n    const currencycode = paymentMethod.transactions[0].CURRENCYCODE;\n    let response; // 100% discounts are not valid when using PayPal Express\n    // If discount is 100%, void authorization instead of applying discount\n\n    if (amount === accounting.toFixed(0, 2)) {\n      try {\n        response = HTTP.post(options.url, {\n          params: {\n            USER: options.username,\n            PWD: options.password,\n            SIGNATURE: options.signature,\n            VERSION: nvpVersion,\n            METHOD: \"DoVoid\",\n            AUTHORIZATIONID: authorizationId,\n            NOTE: \"Your order has been discounted 100%, and will appear as voided or canceled inside your payment account.\"\n          }\n        });\n      } catch (error) {\n        throw new Meteor.Error(\"capture-failed\", error.message);\n      }\n    } else {\n      try {\n        response = HTTP.post(options.url, {\n          params: {\n            USER: options.username,\n            PWD: options.password,\n            SIGNATURE: options.signature,\n            VERSION: nvpVersion,\n            METHOD: \"DoCapture\",\n            AUTHORIZATIONID: authorizationId,\n            CURRENCYCODE: currencycode,\n            AMT: amount,\n            COMPLETETYPE: \"Complete\" // TODO: Allow for partial captures\n\n          }\n        });\n      } catch (error) {\n        throw new Meteor.Error(\"capture-failed\", error.message);\n      }\n    }\n\n    if (!response || response.statusCode !== 200) {\n      throw new Meteor.Error(\"bad-response\", \"Bad Response from PayPal during Capture\");\n    }\n\n    const parsedResponse = parseResponse(response);\n\n    if (parsedResponse.ACK !== \"Success\") {\n      throw new Meteor.Error(`ACK ${parsedResponse.ACK}: ${parsedResponse.L_LONGMESSAGE0}`);\n    }\n\n    const result = {\n      saved: true,\n      authorizationId: parsedResponse.AUTHORIZATIONID,\n      transactionId: parsedResponse.TRANSACTIONID,\n      currencycode,\n      metadata: {},\n      rawTransaction: parsedResponse\n    };\n    return result;\n  },\n\n  /**\n   * Refund an order using the PayPay Express method\n   * https://developer.paypal.com/docs/classic/api/merchant/RefundTransaction_API_Operation_NVP/\n   * @param  {Object} paymentMethod A PaymentMethod object\n   * @param {Number} amount to be refunded\n   * @return {Object} Transaction results from PayPal normalized\n   */\n  \"paypalexpress/refund/create\"(paymentMethod, amount) {\n    check(amount, Number); // Call both check and validate because by calling `clean`, the audit pkg\n    // thinks that we haven't checked paymentMethod arg\n\n    check(paymentMethod, Object);\n    PaymentMethodArgument.validate(PaymentMethodArgument.clean(paymentMethod));\n    this.unblock();\n    const options = PayPal.expressCheckoutAccountOptions();\n\n    const previousTransaction = _last(paymentMethod.transactions);\n\n    const {\n      transactionId,\n      currencycode\n    } = previousTransaction;\n    let response;\n\n    try {\n      response = HTTP.post(options.url, {\n        params: {\n          USER: options.username,\n          PWD: options.password,\n          SIGNATURE: options.signature,\n          VERSION: nvpVersion,\n          METHOD: \"RefundTransaction\",\n          TRANSACTIONID: transactionId,\n          REFUNDTYPE: \"Partial\",\n          AMT: amount,\n          CURRENCYCODE: currencycode\n        }\n      });\n    } catch (error) {\n      Logger.debug(error, \"Failed paypalexpress/refund/create\");\n      throw new Meteor.Error(\"refund-create-failed\", error.message);\n    }\n\n    if (!response || response.statusCode !== 200) {\n      Logger.debug(\"Bad Response from PayPal during Refund Creation\");\n      throw new Meteor.Error(\"bad-response\", \"Bad Response from PayPal during Refund Creation\");\n    }\n\n    const parsedResponse = parseResponse(response);\n\n    if (parsedResponse.ACK !== \"Success\") {\n      throw new Meteor.Error(`ACK ${parsedResponse.ACK}: ${parsedResponse.L_LONGMESSAGE0}`);\n    }\n\n    const amountFormatted = {\n      total: amount,\n      currency: currencycode\n    };\n    const result = {\n      saved: true,\n      type: \"refund\",\n      created: new Date(),\n      transactionId,\n      refundTransactionId: parsedResponse.REFUNDTRANSACTIONID,\n      grossRefundAmount: parsedResponse.GROSSREFUNDAMT,\n      netRefundAmount: parsedResponse.NETREFUNDAMT,\n      correlationId: parsedResponse.CORRELATIONID,\n      currencycode: parsedResponse.CURRENCYCODE,\n      amount: amountFormatted,\n      rawTransaction: parsedResponse\n    };\n    return result;\n  },\n\n  /**\n   * Query PayPal Express NVP API for Refund transactions\n   * Refunds returned here are listed in the dashboard\n   * https://developer.paypal.com/docs/classic/api/merchant/GetTransactionDetails_API_Operation_NVP/\n   * @param  {Object} paymentMethod A PaymentMethod object\n   * @return {array}  Refunds from PayPal query, normalized\n   */\n  \"paypalexpress/refund/list\"(paymentMethod) {\n    // Call both check and validate because by calling `clean`, the audit pkg\n    // thinks that we haven't checked paymentMethod arg\n    check(paymentMethod, Object);\n    PaymentMethodArgument.validate(PaymentMethodArgument.clean(paymentMethod));\n    this.unblock();\n    const options = PayPal.expressCheckoutAccountOptions();\n    const {\n      transactionId\n    } = paymentMethod;\n    let response;\n\n    try {\n      response = HTTP.post(options.url, {\n        params: {\n          USER: options.username,\n          PWD: options.password,\n          SIGNATURE: options.signature,\n          VERSION: nvpVersion,\n          METHOD: \"TransactionSearch\",\n          STARTDATE: \"2013-08-24T05:38:48Z\",\n          TRANSACTIONID: transactionId,\n          TRANSACTIONCLASS: \"Refund\"\n        }\n      });\n    } catch (error) {\n      throw new Meteor.Error(\"refund-list-failed\", error.message);\n    }\n\n    if (!response || response.statusCode !== 200) {\n      throw new Meteor.Error(\"bad-response\", \"Bad Response from PayPal during refund list\");\n    }\n\n    const parsedResponse = parseResponse(response);\n\n    if (parsedResponse.ACK !== \"Success\") {\n      throw new Meteor.Error(`ACK ${parsedResponse.ACK}: ${parsedResponse.L_LONGMESSAGE0}`);\n    }\n\n    const result = parseRefundReponse(parsedResponse);\n    return result;\n  }\n\n};\n\n// internal helpers\nfunction parseResponse(response) {\n  const result = {};\n  const pieces = response.content.split(\"&\");\n  pieces.forEach(piece => {\n    const subpieces = piece.split(\"=\");\n    result[subpieces[0]] = decodeURIComponent(subpieces[1]);\n    const decodedResult = result[subpieces[0]];\n    return decodedResult;\n  });\n  return result;\n}\n/**\n * Parse PayPal's 'unique' Transaction Query response to look for refunds\n * @param  {Object} response The response from PayPal\n * @return {Object} Refunds, normalized to an Array\n */\n\n\nfunction parseRefundReponse(response) {\n  const paypalArray = [];\n  Promise.await(lazyLoadMoment());\n\n  for (let i = 0; i < 101; i += 1) {\n    const timeStampKey = `L_TIMESTAMP${i}`;\n    const timestamp = response[timeStampKey];\n    const typeKey = `L_TYPE${i}`;\n    const transactionType = response[typeKey];\n    const amountKey = `L_AMT${i}`;\n    const amount = response[amountKey];\n    const currencyCodeKey = `L_CURRENCYCODE${i}`;\n    const currencyCode = response[currencyCodeKey];\n\n    if (timestamp !== undefined && transactionType === \"Refund\") {\n      const responseObject = {\n        created: moment(timestamp).valueOf(),\n        type: \"refund\",\n        amount: Math.abs(Number(amount, 10)),\n        currency: currencyCode\n      };\n      paypalArray.push(responseObject);\n    }\n  }\n\n  return paypalArray;\n}\n\nfunction getSetting(shopId, parameter) {\n  const {\n    settings\n  } = Packages.findOne({\n    name: \"reaction-paypal\",\n    shopId,\n    enabled: true\n  });\n  return settings[parameter];\n} // export methods to Meteor\n\n\nMeteor.methods(methods);","map":{"version":3,"sources":["imports/plugins/included/payments-paypal/server/methods/express.js"],"names":["module","export","methods","_last","watch","require","default","v","accounting","HTTP","Meteor","check","PayPal","Shops","Cart","Packages","Logger","PaymentMethodArgument","moment","lazyLoadMoment","nvpVersion","cartId","String","unblock","cart","findOne","Error","shop","shopId","amount","Number","getTotal","shippingAmt","getShippingTotal","taxAmt","getTaxTotal","itemAmt","getSubTotal","getDiscounts","description","name","currency","options","expressCheckoutAccountOptions","response","post","url","params","USER","username","PWD","password","SIGNATURE","signature","SOLUTIONTYPE","VERSION","PAYMENTACTION","AMT","ITEMAMT","SHIPPINGAMT","TAXAMT","RETURNURL","return_url","CANCELURL","cancel_url","DESC","NOSHIPPING","ALLOWNOTE","CURRENCYCODE","METHOD","INVNUM","CUSTOM","error","message","statusCode","parsedResponse","parseResponse","ACK","L_LONGMESSAGE0","TOKEN","token","payerId","captureAtAuth","getSetting","paymentAction","PAYERID","L_ERRORCODE0","settings","expressCheckoutSettings","merchantId","mode","enabled","paymentMethod","Object","validate","clean","toFixed","authorizationId","transactions","TRANSACTIONID","currencycode","AUTHORIZATIONID","NOTE","COMPLETETYPE","result","saved","transactionId","metadata","rawTransaction","previousTransaction","REFUNDTYPE","debug","amountFormatted","total","type","created","Date","refundTransactionId","REFUNDTRANSACTIONID","grossRefundAmount","GROSSREFUNDAMT","netRefundAmount","NETREFUNDAMT","correlationId","CORRELATIONID","STARTDATE","TRANSACTIONCLASS","parseRefundReponse","pieces","content","split","forEach","piece","subpieces","decodeURIComponent","decodedResult","paypalArray","Promise","await","i","timeStampKey","timestamp","typeKey","transactionType","amountKey","currencyCodeKey","currencyCode","undefined","responseObject","valueOf","Math","abs","push","parameter"],"mappings":"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","sourcesContent":["import _ from \"lodash\";\nimport accounting from \"accounting-js\";\nimport { HTTP } from \"meteor/http\";\nimport { Meteor } from \"meteor/meteor\";\nimport { check } from \"meteor/check\";\nimport { PayPal } from \"../../lib/api\";\nimport { Shops, Cart, Packages } from \"/lib/collections\";\nimport { Logger } from \"/server/api\";\nimport { PaymentMethodArgument } from \"/lib/collections/schemas\";\n\nlet moment;\nasync function lazyLoadMoment() {\n  if (moment) return;\n  moment = await import(\"moment\");\n}\n\nconst nvpVersion = \"52.0\";\n\nexport const methods = {\n  /**\n   * Acquire the Token required for PayPal Express transactions\n   * https://developer.paypal.com/docs/classic/api/merchant/SetExpressCheckout_API_Operation_NVP/\n   * @param  {String} cartId Reference to the Cart object to be processed\n   * @return {String} PayPal Token\n   */\n  \"getExpressCheckoutToken\"(cartId) {\n    check(cartId, String);\n    this.unblock();\n    const cart = Cart.findOne(cartId);\n    if (!cart) {\n      throw new Meteor.Error(\"invalid-parameter\", \"Bad cart ID\");\n    }\n    const shop = Shops.findOne(cart.shopId);\n    if (!shop) {\n      throw new Meteor.Error(\"invalid-parameter\", \"Bad shop ID\");\n    }\n    const amount = Number(cart.getTotal());\n    const shippingAmt = Number(cart.getShippingTotal());\n    const taxAmt = Number(cart.getTaxTotal());\n    const itemAmt = Number(cart.getSubTotal() - cart.getDiscounts());\n    const description = `${shop.name} Ref: ${cartId}`;\n    const { currency } = shop;\n    const options = PayPal.expressCheckoutAccountOptions();\n    let response;\n\n    try {\n      response = HTTP.post(options.url, {\n        params: {\n          USER: options.username,\n          PWD: options.password,\n          SIGNATURE: options.signature,\n          SOLUTIONTYPE: \"Mark\",\n          VERSION: nvpVersion,\n          PAYMENTACTION: \"Authorization\",\n          AMT: amount,\n          ITEMAMT: itemAmt,\n          SHIPPINGAMT: shippingAmt,\n          TAXAMT: taxAmt,\n          RETURNURL: options.return_url,\n          CANCELURL: options.cancel_url,\n          DESC: description,\n          NOSHIPPING: 1,\n          ALLOWNOTE: 1,\n          CURRENCYCODE: currency,\n          METHOD: \"SetExpressCheckout\",\n          INVNUM: cartId,\n          CUSTOM: `${cartId}|${amount}|${currency}`\n        }\n      });\n    } catch (error) {\n      throw new Meteor.Error(\"checkout-failed\", error.message);\n    }\n    if (!response || response.statusCode !== 200) {\n      throw new Meteor.Error(\"bad-response\", \"Bad response from PayPal\");\n    }\n    const parsedResponse = parseResponse(response);\n    if (parsedResponse.ACK !== \"Success\") {\n      throw new Meteor.Error(`ACK ${parsedResponse.ACK}: ${parsedResponse.L_LONGMESSAGE0}`);\n    }\n    return parsedResponse.TOKEN;\n  },\n  /**\n   * Perform the PayPal Express payment application\n   * https://developer.paypal.com/docs/classic/api/merchant/DoExpressCheckoutPayment_API_Operation_NVP/\n   * @param  {String} cartId Reference to the cart we are checking out\n   * @param  {String} token The Token provided by PayPal for this transaction\n   * @param  {String} payerId Reference to the payer\n   * @return {Object} results from PayPal normalized\n   */\n  \"confirmPaymentAuthorization\"(cartId, token, payerId) {\n    check(cartId, String);\n    check(token, String);\n    check(payerId, String);\n    this.unblock();\n    const cart = Cart.findOne(cartId);\n    if (!cart) {\n      throw new Meteor.Error(\"invalid-parameter\", \"Bad cart ID\");\n    }\n    const amount = Number(cart.getTotal());\n    const shippingAmt = Number(cart.getShippingTotal());\n    const taxAmt = Number(cart.getTaxTotal());\n    const itemAmt = Number(cart.getSubTotal() - cart.getDiscounts());\n    const shop = Shops.findOne(cart.shopId);\n    const { currency } = shop;\n    const options = PayPal.expressCheckoutAccountOptions();\n    const captureAtAuth = getSetting(cart.shopId, \"expressAuthAndCapture\");\n    let paymentAction;\n    if (captureAtAuth) {\n      paymentAction = \"Sale\";\n    } else {\n      paymentAction = \"Authorization\";\n    }\n    let response;\n    try {\n      response = HTTP.post(options.url, {\n        params: {\n          USER: options.username,\n          PWD: options.password,\n          SIGNATURE: options.signature,\n          VERSION: nvpVersion,\n          PAYMENTACTION: paymentAction,\n          AMT: amount,\n          ITEMAMT: itemAmt,\n          SHIPPINGAMT: shippingAmt,\n          TAXAMT: taxAmt,\n          METHOD: \"DoExpressCheckoutPayment\",\n          CURRENCYCODE: currency,\n          TOKEN: token,\n          PAYERID: payerId\n        }\n      });\n    } catch (error) {\n      throw new Meteor.Error(\"confirmation-failed\", error.message);\n    }\n    if (!response || response.statusCode !== 200) {\n      throw new Meteor.Error(\"bad-response\", \"Bad response from PayPal\");\n    }\n    const parsedResponse = parseResponse(response);\n\n    if (parsedResponse.ACK !== \"Success\") {\n      throw new Meteor.Error(`ACK ${parsedResponse.ACK}: ${parsedResponse.L_LONGMESSAGE0}:${parsedResponse.L_ERRORCODE0}`);\n    }\n    return parsedResponse;\n  },\n\n  /**\n   * Return the settings for the PayPal Express payment Method\n   * @return {Object} Express Checkout settings\n   */\n  \"getExpressCheckoutSettings\"() {\n    const settings = PayPal.expressCheckoutAccountOptions();\n    const expressCheckoutSettings = {\n      merchantId: settings.merchantId,\n      mode: settings.mode,\n      enabled: settings.enabled\n    };\n    return expressCheckoutSettings;\n  },\n\n  /**\n   * Capture an authorized PayPalExpress transaction\n   * https://developer.paypal.com/docs/classic/api/merchant/DoCapture_API_Operation_NVP/\n   * @param  {Object} paymentMethod A PaymentMethod object\n   * @return {Object} results from PayPal normalized\n   */\n  \"paypalexpress/payment/capture\"(paymentMethod) {\n    // Call both check and validate because by calling `clean`, the audit pkg\n    // thinks that we haven't checked paymentMethod arg\n    check(paymentMethod, Object);\n    PaymentMethodArgument.validate(PaymentMethodArgument.clean(paymentMethod));\n    this.unblock();\n    const options = PayPal.expressCheckoutAccountOptions();\n    const amount = accounting.toFixed(paymentMethod.amount, 2);\n    const authorizationId = paymentMethod.transactions[0].TRANSACTIONID;\n    const currencycode = paymentMethod.transactions[0].CURRENCYCODE;\n    let response;\n\n    // 100% discounts are not valid when using PayPal Express\n    // If discount is 100%, void authorization instead of applying discount\n    if (amount === accounting.toFixed(0, 2)) {\n      try {\n        response = HTTP.post(options.url, {\n          params: {\n            USER: options.username,\n            PWD: options.password,\n            SIGNATURE: options.signature,\n            VERSION: nvpVersion,\n            METHOD: \"DoVoid\",\n            AUTHORIZATIONID: authorizationId,\n            NOTE: \"Your order has been discounted 100%, and will appear as voided or canceled inside your payment account.\"\n          }\n        });\n      } catch (error) {\n        throw new Meteor.Error(\"capture-failed\", error.message);\n      }\n    } else {\n      try {\n        response = HTTP.post(options.url, {\n          params: {\n            USER: options.username,\n            PWD: options.password,\n            SIGNATURE: options.signature,\n            VERSION: nvpVersion,\n            METHOD: \"DoCapture\",\n            AUTHORIZATIONID: authorizationId,\n            CURRENCYCODE: currencycode,\n            AMT: amount,\n            COMPLETETYPE: \"Complete\" // TODO: Allow for partial captures\n          }\n        });\n      } catch (error) {\n        throw new Meteor.Error(\"capture-failed\", error.message);\n      }\n    }\n\n    if (!response || response.statusCode !== 200) {\n      throw new Meteor.Error(\"bad-response\", \"Bad Response from PayPal during Capture\");\n    }\n\n    const parsedResponse = parseResponse(response);\n\n    if (parsedResponse.ACK !== \"Success\") {\n      throw new Meteor.Error(`ACK ${parsedResponse.ACK}: ${parsedResponse.L_LONGMESSAGE0}`);\n    }\n\n    const result = {\n      saved: true,\n      authorizationId: parsedResponse.AUTHORIZATIONID,\n      transactionId: parsedResponse.TRANSACTIONID,\n      currencycode,\n      metadata: {},\n      rawTransaction: parsedResponse\n    };\n\n    return result;\n  },\n\n  /**\n   * Refund an order using the PayPay Express method\n   * https://developer.paypal.com/docs/classic/api/merchant/RefundTransaction_API_Operation_NVP/\n   * @param  {Object} paymentMethod A PaymentMethod object\n   * @param {Number} amount to be refunded\n   * @return {Object} Transaction results from PayPal normalized\n   */\n  \"paypalexpress/refund/create\"(paymentMethod, amount) {\n    check(amount, Number);\n\n    // Call both check and validate because by calling `clean`, the audit pkg\n    // thinks that we haven't checked paymentMethod arg\n    check(paymentMethod, Object);\n    PaymentMethodArgument.validate(PaymentMethodArgument.clean(paymentMethod));\n    this.unblock();\n\n    const options = PayPal.expressCheckoutAccountOptions();\n    const previousTransaction = _.last(paymentMethod.transactions);\n    const { transactionId, currencycode } = previousTransaction;\n\n    let response;\n    try {\n      response = HTTP.post(options.url, {\n        params: {\n          USER: options.username,\n          PWD: options.password,\n          SIGNATURE: options.signature,\n          VERSION: nvpVersion,\n          METHOD: \"RefundTransaction\",\n          TRANSACTIONID: transactionId,\n          REFUNDTYPE: \"Partial\",\n          AMT: amount,\n          CURRENCYCODE: currencycode\n        }\n      });\n    } catch (error) {\n      Logger.debug(error, \"Failed paypalexpress/refund/create\");\n      throw new Meteor.Error(\"refund-create-failed\", error.message);\n    }\n\n    if (!response || response.statusCode !== 200) {\n      Logger.debug(\"Bad Response from PayPal during Refund Creation\");\n      throw new Meteor.Error(\"bad-response\", \"Bad Response from PayPal during Refund Creation\");\n    }\n\n    const parsedResponse = parseResponse(response);\n    if (parsedResponse.ACK !== \"Success\") {\n      throw new Meteor.Error(`ACK ${parsedResponse.ACK}: ${parsedResponse.L_LONGMESSAGE0}`);\n    }\n\n    const amountFormatted = {\n      total: amount,\n      currency: currencycode\n    };\n\n    const result = {\n      saved: true,\n      type: \"refund\",\n      created: new Date(),\n      transactionId,\n      refundTransactionId: parsedResponse.REFUNDTRANSACTIONID,\n      grossRefundAmount: parsedResponse.GROSSREFUNDAMT,\n      netRefundAmount: parsedResponse.NETREFUNDAMT,\n      correlationId: parsedResponse.CORRELATIONID,\n      currencycode: parsedResponse.CURRENCYCODE,\n      amount: amountFormatted,\n      rawTransaction: parsedResponse\n    };\n    return result;\n  },\n  /**\n   * Query PayPal Express NVP API for Refund transactions\n   * Refunds returned here are listed in the dashboard\n   * https://developer.paypal.com/docs/classic/api/merchant/GetTransactionDetails_API_Operation_NVP/\n   * @param  {Object} paymentMethod A PaymentMethod object\n   * @return {array}  Refunds from PayPal query, normalized\n   */\n  \"paypalexpress/refund/list\"(paymentMethod) {\n    // Call both check and validate because by calling `clean`, the audit pkg\n    // thinks that we haven't checked paymentMethod arg\n    check(paymentMethod, Object);\n    PaymentMethodArgument.validate(PaymentMethodArgument.clean(paymentMethod));\n    this.unblock();\n\n    const options = PayPal.expressCheckoutAccountOptions();\n    const { transactionId } = paymentMethod;\n    let response;\n\n    try {\n      response = HTTP.post(options.url, {\n        params: {\n          USER: options.username,\n          PWD: options.password,\n          SIGNATURE: options.signature,\n          VERSION: nvpVersion,\n          METHOD: \"TransactionSearch\",\n          STARTDATE: \"2013-08-24T05:38:48Z\",\n          TRANSACTIONID: transactionId,\n          TRANSACTIONCLASS: \"Refund\"\n        }\n      });\n    } catch (error) {\n      throw new Meteor.Error(\"refund-list-failed\", error.message);\n    }\n\n    if (!response || response.statusCode !== 200) {\n      throw new Meteor.Error(\"bad-response\", \"Bad Response from PayPal during refund list\");\n    }\n\n    const parsedResponse = parseResponse(response);\n\n    if (parsedResponse.ACK !== \"Success\") {\n      throw new Meteor.Error(`ACK ${parsedResponse.ACK}: ${parsedResponse.L_LONGMESSAGE0}`);\n    }\n    const result = parseRefundReponse(parsedResponse);\n    return result;\n  }\n\n};\n\n// internal helpers\nfunction parseResponse(response) {\n  const result = {};\n  const pieces = response.content.split(\"&\");\n  pieces.forEach((piece) => {\n    const subpieces = piece.split(\"=\");\n    result[subpieces[0]] = decodeURIComponent(subpieces[1]);\n    const decodedResult = result[subpieces[0]];\n    return decodedResult;\n  });\n  return result;\n}\n\n/**\n * Parse PayPal's 'unique' Transaction Query response to look for refunds\n * @param  {Object} response The response from PayPal\n * @return {Object} Refunds, normalized to an Array\n */\nfunction parseRefundReponse(response) {\n  const paypalArray = [];\n\n  Promise.await(lazyLoadMoment());\n\n  for (let i = 0; i < 101; i += 1) {\n    const timeStampKey = `L_TIMESTAMP${i}`;\n    const timestamp = response[timeStampKey];\n    const typeKey = `L_TYPE${i}`;\n    const transactionType = response[typeKey];\n    const amountKey = `L_AMT${i}`;\n    const amount = response[amountKey];\n    const currencyCodeKey = `L_CURRENCYCODE${i}`;\n    const currencyCode = response[currencyCodeKey];\n\n    if (timestamp !== undefined && transactionType === \"Refund\") {\n      const responseObject = {\n        created: moment(timestamp).valueOf(),\n        type: \"refund\",\n        amount: Math.abs(Number(amount, 10)),\n        currency: currencyCode\n      };\n      paypalArray.push(responseObject);\n    }\n  }\n\n  return paypalArray;\n}\n\nfunction getSetting(shopId, parameter) {\n  const { settings } = Packages.findOne({\n    name: \"reaction-paypal\",\n    shopId,\n    enabled: true\n  });\n  return settings[parameter];\n}\n\n// export methods to Meteor\nMeteor.methods(methods);\n"]},"sourceType":"script","hash":"ae17c9fbd6c3ddbcc02e5e4b1b578785bd770e05"}
