{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$1$2","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"ast":true,"babelrc":false,"sourceFileName":"imports/plugins/core/router/lib/router.js","filename":"imports/plugins/core/router/lib/router.js","sourceMaps":true,"envName":"development","cwd":"/Users/estebandev/test-knowledge","passPerPreset":false,"presets":[],"parserOpts":{"sourceType":"module","sourceFileName":"imports/plugins/core/router/lib/router.js","plugins":["jsx","jsx","flow","flow","objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties"]},"generatorOpts":{"filename":"imports/plugins/core/router/lib/router.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"imports/plugins/core/router/lib/router.js"}},"code":"var _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/builtin/objectSpread\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nmodule.export({\n  history: () => history,\n  ReactionLayout: () => ReactionLayout\n});\n\nlet _uniqBy;\n\nmodule.watch(require(\"lodash/uniqBy\"), {\n  default(v) {\n    _uniqBy = v;\n  }\n\n}, 0);\nlet React;\nmodule.watch(require(\"react\"), {\n  default(v) {\n    React = v;\n  }\n\n}, 1);\nlet Route;\nmodule.watch(require(\"react-router\"), {\n  Route(v) {\n    Route = v;\n  }\n\n}, 2);\nlet createBrowserHistory;\nmodule.watch(require(\"history/createBrowserHistory\"), {\n  default(v) {\n    createBrowserHistory = v;\n  }\n\n}, 3);\nlet createMemoryHistory;\nmodule.watch(require(\"history/createMemoryHistory\"), {\n  default(v) {\n    createMemoryHistory = v;\n  }\n\n}, 4);\nlet pathToRegexp;\nmodule.watch(require(\"path-to-regexp\"), {\n  default(v) {\n    pathToRegexp = v;\n  }\n\n}, 5);\nlet queryParse;\nmodule.watch(require(\"query-parse\"), {\n  default(v) {\n    queryParse = v;\n  }\n\n}, 6);\nlet Immutable;\nmodule.watch(require(\"immutable\"), {\n  default(v) {\n    Immutable = v;\n  }\n\n}, 7);\nlet Meteor;\nmodule.watch(require(\"meteor/meteor\"), {\n  Meteor(v) {\n    Meteor = v;\n  }\n\n}, 8);\nlet Blaze;\nmodule.watch(require(\"meteor/gadicc:blaze-react-component\"), {\n  default(v) {\n    Blaze = v;\n  }\n\n}, 9);\nlet Template;\nmodule.watch(require(\"meteor/templating\"), {\n  Template(v) {\n    Template = v;\n  }\n\n}, 10);\nlet Session;\nmodule.watch(require(\"meteor/session\"), {\n  Session(v) {\n    Session = v;\n  }\n\n}, 11);\nlet Tracker;\nmodule.watch(require(\"meteor/tracker\"), {\n  Tracker(v) {\n    Tracker = v;\n  }\n\n}, 12);\nlet Packages, Shops;\nmodule.watch(require(\"../../../../../lib/collections\"), {\n  Packages(v) {\n    Packages = v;\n  },\n\n  Shops(v) {\n    Shops = v;\n  }\n\n}, 13);\nlet getComponent;\nmodule.watch(require(\"../../components/lib/components\"), {\n  getComponent(v) {\n    getComponent = v;\n  }\n\n}, 14);\nlet Hooks;\nmodule.watch(require(\"./hooks\"), {\n  default(v) {\n    Hooks = v;\n  }\n\n}, 15);\nconst history = Meteor.isClient ? createBrowserHistory() : createMemoryHistory();\n// Private vars\nlet currentRoute = Immutable.Map();\nconst routerReadyDependency = new Tracker.Dependency();\nconst routerChangeDependency = new Tracker.Dependency();\n/** Class representing a static base router */\n\nclass Router {\n  /**\n   * history\n   * @type {history}\n   */\n\n  /**\n   * Hooks\n   * @type {Hooks}\n   */\n\n  /**\n   * Registered route definitions\n   * @type {Array}\n   */\n\n  /**\n   * Router initialization state\n   * @type {Boolean}\n   */\n\n  /**\n   * Active classname for active routes\n   * @type {String}\n   */\n\n  /**\n   * Routes array\n   * @type {Array}\n   * @param {Array} value An array of objects\n   */\n  static set _routes(value) {\n    Router.routes = value;\n  }\n\n  static get _routes() {\n    return Router.routes;\n  }\n  /**\n   * Triggers reactively on router ready state changed\n   * @return {Boolean} Router initalization state\n   */\n\n\n  static ready() {\n    routerReadyDependency.depend();\n    return Router._initialized;\n  }\n  /**\n   * Re-triggers router ready dependency\n   * @return {undefined}\n   */\n\n\n  static triggerRouterReady() {\n    routerReadyDependency.changed();\n  }\n  /**\n   * Hooks\n   * @type {Hooks}\n   */\n\n\n  static get triggers() {\n    return Hooks;\n  }\n  /**\n   * Get the current route date. Not reactive.\n   * @return {Object} Object containing route data\n   */\n\n\n  static current() {\n    return currentRoute.toJS();\n  }\n  /**\n   * Set current route data. Is reactive.\n   * @param {Object} routeData Object containing route data\n   * @return {undefined}\n   */\n\n\n  static setCurrentRoute(routeData) {\n    currentRoute = Immutable.Map(routeData);\n    routerChangeDependency.changed();\n  }\n  /**\n   * Get the name of the current route. Is reactive.\n   * @return {String} Name of current route\n   */\n\n\n  static getRouteName() {\n    const current = Router.current();\n    return current.route && current.route.name || \"\";\n  }\n  /**\n   * Get param by name. Is reactive.\n   * @param  {String} name Param name\n   * @return {String|undefined} String value or undefined\n   */\n\n\n  static getParam(name) {\n    routerChangeDependency.depend();\n    const current = Router.current();\n    return current.params && current.params[name] || undefined;\n  }\n  /**\n   * Get query param by name\n   * @param  {String} name Query param name. Is reactive.\n   * @return {String|undefined} String value or undefined\n   */\n\n\n  static getQueryParam(name) {\n    routerChangeDependency.depend();\n    const current = Router.current();\n    return current.query && current.query[name] || undefined;\n  }\n  /**\n   * Merge new query params with current params\n   * @param {Object} newParams Object containing params\n   * @return {undefined}\n   */\n\n\n  static setQueryParams(newParams) {\n    const current = Router.current(); // Merge current and new params\n\n    const queryParams = Object.assign({}, current.query, newParams); // Any param marked as null or undefined will be removed\n\n    for (const key in queryParams) {\n      if (queryParams[key] === null || queryParams[key] === undefined) {\n        delete queryParams[key];\n      }\n    } // Update route\n\n\n    Router.go(current.route.name, current.params, queryParams);\n  }\n  /**\n   * Watch path change. Is Reactive.\n   * @return {undefined}\n   */\n\n\n  static watchPathChange() {\n    routerChangeDependency.depend();\n  }\n\n}\n/**\n * pathFor\n * @summary get current router path\n * @param {String} path - path to fetch\n * @param {Object} options - url params\n * @return {String} returns current router path\n */\n\n\nRouter.history = history;\nRouter.Hooks = Hooks;\nRouter.routes = [];\nRouter._initialized = false;\nRouter.activeClassName = \"active\";\n\nRouter.pathFor = (path, options = {}) => {\n  const foundPath = Router.routes.find(pathObject => {\n    if (pathObject.route) {\n      if (options.hash && options.hash.shopSlug) {\n        if (pathObject.options.name === path && pathObject.route.includes(\"shopSlug\")) {\n          return true;\n        }\n      } else if (pathObject.options.name === path && !pathObject.route.includes(\"shopSlug\")) {\n        return true;\n      }\n    } // No path found\n\n\n    return false;\n  });\n\n  if (foundPath) {\n    // Pull the hash out of options\n    //\n    // This is becuase of Spacebars that we have hash.\n    // Spacebars takes all params passed into a template tag and places\n    // them into the options.hash object. This will also include any `query` params\n    const hash = options && options.hash || {}; // Create an executable function based on the route regex\n\n    const toPath = pathToRegexp.compile(foundPath.route); // Compile the regex path with the params from the hash\n\n    const compiledPath = toPath(hash); // Convert the query object to a string\n    // e.g. { a: \"one\", b: \"two\"} => \"a=one&b=two\"\n\n    const queryString = queryParse.toString(hash.query); // Return the compiled path + query string if we have one\n\n    if (typeof queryString === \"string\" && queryString.length) {\n      return `${compiledPath}?${queryString}`;\n    } // Return only the compiled path\n\n\n    return compiledPath;\n  }\n\n  return \"/\";\n};\n/**\n * Navigate to path with params and query\n * @param  {String} path Path string\n * @param  {Object} params Route params object\n * @param  {Object} query Query params object\n * @return {undefined} undefined\n */\n\n\nRouter.go = (path, params, query) => {\n  let actualPath;\n\n  const routerGo = () => {\n    if (typeof path === \"string\" && path.startsWith(\"/\")) {\n      actualPath = path;\n    } else {\n      actualPath = Router.pathFor(path, {\n        hash: (0, _objectSpread2.default)({}, params, {\n          query\n        })\n      });\n    }\n\n    if (window) {\n      history.push(actualPath);\n    }\n  }; // if Router is in a non ready/initialized state yet, wait until it is\n\n\n  if (!Router.ready()) {\n    Tracker.autorun(routerReadyWaitFor => {\n      if (Router.ready()) {\n        routerReadyWaitFor.stop();\n        routerGo();\n      }\n    });\n    return;\n  }\n\n  routerGo();\n};\n/**\n * Replace location\n * @param  {String} path Path string\n * @param  {Object} params Route params object\n * @param  {Object} query Query params object\n * @return {undefined} undefined\n */\n\n\nRouter.replace = (path, params, query) => {\n  const actualPath = Router.pathFor(path, {\n    hash: (0, _objectSpread2.default)({}, params, {\n      query\n    })\n  });\n\n  if (window) {\n    history.replace(actualPath);\n  }\n};\n/**\n * Reload router\n * @return {undefined} undefined\n */\n\n\nRouter.reload = () => {\n  const current = Router.current();\n\n  if (window) {\n    history.replace(current.route.fullPath || \"/\");\n  }\n};\n/**\n * isActive\n * @summary general helper to return \"active\" when on current path\n * @example {{active \"name\"}}\n * @param {String} routeName - route name as defined in registry\n * @return {String} return \"active\" or null\n */\n\n\nRouter.isActiveClassName = routeName => {\n  const current = Router.current();\n  const {\n    group\n  } = current.route;\n  let prefix = \"\";\n\n  if (current.route) {\n    const {\n      path\n    } = current.route;\n\n    if (group && group.prefix) {\n      ({\n        prefix\n      } = current.route.group);\n    } // Match route\n\n\n    if (prefix.length && routeName.startsWith(prefix) && path === routeName) {\n      // Route name is a path and starts with the prefix. (default '/reaction')\n      return Router.activeClassName;\n    } else if (routeName.startsWith(\"/\") && path === routeName) {\n      // Route name isa  path and starts with slash, but was not prefixed\n      return Router.activeClassName;\n    } else if (current.route.name === routeName) {\n      // Route name is the actual name of the route\n      return Router.activeClassName;\n    }\n  }\n\n  return \"\";\n};\n/**\n * hasRoutePermission\n * check if user has route permissions\n * @access private\n * @param  {Object} route - route context\n * @return {Boolean} returns `true` if user is allowed to see route, `false` otherwise\n */\n\n\nfunction hasRoutePermission(route) {\n  const routeName = route.name;\n  return routeName === \"index\" || routeName === \"not-found\" || Router.Reaction.hasPermission(route.permissions, Meteor.userId());\n}\n/**\n * getRegistryRouteName\n * assemble route name to be standard\n * prefix/package name + registry name or route\n * @param  {String} packageName  [package name]\n * @param  {Object} registryItem [registry object]\n * @return {String}              [route name]\n */\n\n\nfunction getRegistryRouteName(packageName, registryItem) {\n  let routeName;\n\n  if (packageName && registryItem) {\n    if (registryItem.name) {\n      routeName = registryItem.name;\n    } else if (registryItem.template) {\n      routeName = `${packageName}/${registryItem.template}`;\n    } else {\n      routeName = packageName;\n    } // dont include params in the name\n\n\n    [routeName] = routeName.split(\":\");\n    return routeName;\n  }\n\n  return null;\n}\n/**\n * selectLayout\n * @access private\n * @param {Object} layout - element of shops.layout array\n * @param {Object} setLayout - layout\n * @param {Object} setWorkflow - workflow\n * @returns {Object} layout - return object of template definitions for Blaze Layout\n */\n\n\nfunction selectLayout(layout, setLayout, setWorkflow) {\n  const currentLayout = setLayout || Session.get(\"DEFAULT_LAYOUT\") || \"coreLayout\";\n  const currentWorkflow = setWorkflow || Session.get(\"DEFAULT_WORKFLOW\") || \"coreWorkflow\";\n\n  if (layout.layout === currentLayout && layout.workflow === currentWorkflow && layout.enabled === true) {\n    return layout;\n  }\n\n  return null;\n}\n/**\n * ReactionLayout\n * sets and returns reaction layout structure\n * @access public\n * @param {Object} options - this router context\n * @param {String} options.layout - string of shop.layout.layout (defaults to coreLayout)\n * @param {String} options.workflow - string of shop.layout.workflow (defaults to coreLayout)\n * @returns {Object} layout - return object of template definitions for Blaze Layout\n */\n\n\nfunction ReactionLayout(options = {}) {\n  // Find a workflow layout to render\n  // By default we'll use the primary shop for layouts\n  let shopId = Router.Reaction.getPrimaryShopId(); // We'll check the marketplace settings too so that we can use the active shopId\n  // if merchantTemplates is enabled\n  // XXX: using merchantTemplates is not ready for production and has not been tested! Use at your own risk.\n\n  let marketplaceSettings;\n\n  if (Meteor.isClient) {\n    // If we're on the client, use the cached marketplace settings\n    marketplaceSettings = Router.Reaction.marketplace;\n  } else {\n    // if we're on the server, go get the settings from the db with this method\n    marketplaceSettings = Router.Reaction.getMarketplaceSettings();\n\n    if (marketplaceSettings && marketplaceSettings.public) {\n      // We're only interested in the public settings here\n      marketplaceSettings = marketplaceSettings.public;\n    }\n  } // If merchantTemplates is enabled, use the active shopId\n\n\n  if (marketplaceSettings && marketplaceSettings.merchantTemplates === true) {\n    shopId = Router.Reaction.getShopId();\n  } // Get the shop data\n\n\n  const shop = Shops.findOne(shopId); // get the layout & workflow from options if they exist\n  // Otherwise get them from the Session. this is set in `/client/config/defaults`\n  // Otherwise, default to hard-coded values\n\n  const layoutName = options.layout || Session.get(\"DEFAULT_LAYOUT\") || \"coreLayout\";\n  const workflowName = options.workflow || Session.get(\"DEFAULT_WORKFLOW\") || \"coreWorkflow\"; // Layout object used to render\n  // Defaults provided for reference\n\n  let layoutStructure = {\n    template: \"\",\n    layoutHeader: \"\",\n    layoutFooter: \"\",\n    notFound: \"notFound\",\n    dashboardHeader: \"\",\n    dashboardControls: \"\",\n    dashboardHeaderControls: \"\",\n    adminControlsFooter: \"\"\n  };\n  let layoutTheme = \"default\"; // Find a registered layout using the layoutName and workflowName\n\n  if (shop) {\n    const sortedLayout = shop.layout.sort((prev, next) => prev.priority - next.priority);\n    const foundLayout = sortedLayout.find(x => selectLayout(x, layoutName, workflowName));\n\n    if (foundLayout) {\n      if (foundLayout.structure) {\n        layoutStructure = (0, _objectSpread2.default)({}, foundLayout.structure);\n      }\n\n      if (foundLayout.theme) {\n        layoutTheme = foundLayout.theme;\n      }\n    }\n  } // If the original options did not include a workflow, but did have a template,\n  // then we override the template from the layout with the one provided by the options.\n  //\n  // Why is this? We always need a workflow to render the entire layout of the app.\n  // The default layout has a default template that may not be the one we want to render.\n  // Some routes, such as `/account/profile` do no have a workflow, but define a template.\n  // Without the logic below, it would end up rendering the homepage instead of the profile\n  // page.\n  // const optionsHasWorkflow = typeof options.workflow === \"string\";\n\n\n  const optionsHasTemplate = typeof options.template === \"string\";\n\n  if (optionsHasTemplate) {\n    layoutStructure.template = options.template;\n  } // If there is no Blaze Template (Template[]) or React Component (getComponent)\n  // Then use the notFound template instead\n\n\n  let hasReactComponent = true;\n\n  try {\n    getComponent(layoutStructure.template);\n  } catch (e) {\n    hasReactComponent = false;\n  }\n\n  if (!Template[layoutStructure.template] && !hasReactComponent) {\n    return React.createElement(Blaze, {\n      template: layoutStructure.notFound\n    });\n  } // Render the layout\n\n\n  return {\n    theme: layoutTheme,\n    structure: layoutStructure,\n    component: props => {\n      // eslint-disable-line react/no-multi-comp, react/display-name\n      const {\n        route\n      } = Router.current();\n      const {\n        permissions\n      } = options;\n      const structure = (0, _objectSpread2.default)({}, layoutStructure); // If the current route is unauthorized, and is not the \"not-found\" route,\n      // then override the template to use the default unauthorized template\n\n      if (hasRoutePermission((0, _objectSpread2.default)({}, route, {\n        permissions\n      })) === false && route.name !== \"not-found\" && !Meteor.user()) {\n        if (!Router.Reaction.hasPermission(route.permissions, Meteor.userId())) {\n          structure.template = \"unauthorized\";\n        }\n\n        return false;\n      }\n\n      try {\n        // Try to create a React component if defined\n        return React.createElement(getComponent(layoutName), (0, _objectSpread2.default)({}, props, {\n          structure\n        }));\n      } catch (e) {\n        // eslint-disable-next-line\n        console.warn(e, \"Failed to create a React layout element\");\n      } // If all else fails, render a not found page\n\n\n      return React.createElement(Blaze, {\n        template: structure.notFound\n      });\n    }\n  };\n}\n\n/**\n * initPackageRoutes\n * registers route and template when registry item has\n * registryItem.route && registryItem.template\n * @param {Object} options - options and context for route creation\n * @returns {undefined} returns undefined\n */\nRouter.initPackageRoutes = options => {\n  // make _initialized = false in case router is reinitialized\n  Router._initialized = false;\n  routerReadyDependency.changed();\n  Router.Reaction = options.reactionContext;\n  Router.routes = [];\n  let marketplaceSettings = {\n    shopPrefix: \"/shop\" // default value\n\n  };\n  const marketplace = Packages.findOne({\n    name: \"reaction-marketplace\",\n    shopId: Router.Reaction.getPrimaryShopId()\n  });\n\n  if (marketplace && marketplace.settings && marketplace.settings.public) {\n    marketplaceSettings = marketplace.settings.public;\n  }\n\n  const pkgs = Packages.find().fetch();\n  const routeDefinitions = []; // prefixing isnt necessary if we only have one shop\n  // but we need to bypass the current\n  // subscription to determine this.\n\n  const shopSub = Meteor.subscribe(\"shopsCount\");\n  Tracker.autorun(shopSubWaitFor => {\n    if (shopSub.ready()) {\n      shopSubWaitFor.stop(); // using tmeasday:publish-counts\n      // Default layouts\n\n      const indexLayout = ReactionLayout(options.indexRoute);\n      const notFoundLayout = ReactionLayout({\n        template: \"notFound\"\n      }); // Index route\n\n      routeDefinitions.push({\n        route: \"/\",\n        name: \"index\",\n        options: (0, _objectSpread2.default)({\n          name: \"index\"\n        }, options.indexRoute, {\n          theme: indexLayout.theme,\n          component: indexLayout.component,\n          structure: indexLayout.structure\n        })\n      });\n      routeDefinitions.push({\n        route: `${marketplaceSettings.shopPrefix}/:shopSlug`,\n        name: \"index\",\n        options: (0, _objectSpread2.default)({\n          name: \"index\",\n          type: \"shop-prefix\"\n        }, options.indexRoute, {\n          theme: indexLayout.theme,\n          component: indexLayout.component,\n          structure: indexLayout.structure\n        })\n      }); // Not-found route\n\n      routeDefinitions.push({\n        route: \"/not-found\",\n        name: \"not-found\",\n        options: (0, _objectSpread2.default)({\n          name: \"not-found\"\n        }, notFoundLayout.indexRoute, {\n          theme: notFoundLayout.theme,\n          component: notFoundLayout.component,\n          structure: notFoundLayout.structure\n        })\n      }); // get package registry route configurations\n\n      for (const pkg of pkgs) {\n        const newRoutes = []; // pkg registry\n\n        if (pkg.registry && pkg.enabled) {\n          const registry = Array.from(pkg.registry);\n\n          for (const registryItem of registry) {\n            // registryItems\n            if (registryItem.route) {\n              const {\n                meta,\n                route,\n                permissions,\n                template,\n                layout,\n                workflow // provides\n\n              } = registryItem;\n              const name = getRegistryRouteName(pkg.name, registryItem); // define new route\n              // we could allow the options to be passed in the registry if we need to be more flexible\n\n              const reactionLayout = ReactionLayout({\n                template,\n                workflow,\n                layout,\n                permissions\n              });\n              const newRouteConfig = {\n                route,\n                name,\n                options: {\n                  meta,\n                  name,\n                  template,\n                  layout,\n                  triggersEnter: Router.Hooks.get(\"onEnter\", name),\n                  triggersExit: Router.Hooks.get(\"onExit\", name),\n                  component: reactionLayout.component,\n                  theme: reactionLayout.theme,\n                  structure: reactionLayout.structure\n                }\n              };\n              newRoutes.push((0, _objectSpread2.default)({}, newRouteConfig, {\n                route: `/shop/:shopSlug${route}`,\n                options: (0, _objectSpread2.default)({}, newRouteConfig.options, {\n                  type: \"shop-prefix\"\n                })\n              })); // push new routes\n\n              newRoutes.push(newRouteConfig);\n            } // end registryItems\n\n          } // end package.registry\n          //\n          // add group and routes to routing table\n          //\n\n\n          for (const route of newRoutes) {\n            // allow overriding of prefix in route definitions\n            // define an \"absolute\" url by excluding \"/\"\n            route.group = {};\n\n            if (route.route.substring(0, 1) !== \"/\") {\n              route.route = `/${route.route}`;\n              route.group.prefix = \"\";\n            }\n\n            routeDefinitions.push(route);\n          }\n        }\n      } // end package loop\n      // Uniq-ify routes\n      // Take all route definitions in the order that were received, and reverse it.\n      // Routes defined later, like in the case of custom routes will then have a\n      // higher precedence. Any duplicates after the first instance will be removed.\n      //\n      // TODO: In the future, sort by priority\n      // TODO: Allow duplicated routes with a prefix / suffix / flag\n\n\n      const uniqRoutes = _uniqBy(routeDefinitions.reverse(), \"route\");\n\n      const reactRouterRoutes = uniqRoutes.map((route, index) => React.createElement(Route, {\n        key: `${route.name}-${index}`,\n        path: route.route,\n        exact: true,\n        render: route.options.component\n      })); // Last route, if no other route is matched, this one will be the not-found view\n      // Note: This is last becuase all other routes must at-least attempt a match\n      // before falling back to this not-found route.\n\n      reactRouterRoutes.push(React.createElement(Route, {\n        key: \"not-found\",\n        render: notFoundLayout.component\n      })); // Finish initialization\n\n      Router._initialized = true;\n      Router.reactComponents = reactRouterRoutes;\n      Router._routes = uniqRoutes; // Trigger a reactive refresh to re-render routes\n\n      routerReadyDependency.changed();\n    }\n  });\n};\n\nmodule.exportDefault(Router);","map":{"version":3,"sources":["imports/plugins/core/router/lib/router.js"],"names":["module","export","history","ReactionLayout","_uniqBy","watch","require","default","v","React","Route","createBrowserHistory","createMemoryHistory","pathToRegexp","queryParse","Immutable","Meteor","Blaze","Template","Session","Tracker","Packages","Shops","getComponent","Hooks","isClient","currentRoute","Map","routerReadyDependency","Dependency","routerChangeDependency","Router","_routes","value","routes","ready","depend","_initialized","triggerRouterReady","changed","triggers","current","toJS","setCurrentRoute","routeData","getRouteName","route","name","getParam","params","undefined","getQueryParam","query","setQueryParams","newParams","queryParams","Object","assign","key","go","watchPathChange","activeClassName","pathFor","path","options","foundPath","find","pathObject","hash","shopSlug","includes","toPath","compile","compiledPath","queryString","toString","length","actualPath","routerGo","startsWith","window","push","autorun","routerReadyWaitFor","stop","replace","reload","fullPath","isActiveClassName","routeName","group","prefix","hasRoutePermission","Reaction","hasPermission","permissions","userId","getRegistryRouteName","packageName","registryItem","template","split","selectLayout","layout","setLayout","setWorkflow","currentLayout","get","currentWorkflow","workflow","enabled","shopId","getPrimaryShopId","marketplaceSettings","marketplace","getMarketplaceSettings","public","merchantTemplates","getShopId","shop","findOne","layoutName","workflowName","layoutStructure","layoutHeader","layoutFooter","notFound","dashboardHeader","dashboardControls","dashboardHeaderControls","adminControlsFooter","layoutTheme","sortedLayout","sort","prev","next","priority","foundLayout","x","structure","theme","optionsHasTemplate","hasReactComponent","e","component","props","user","createElement","console","warn","initPackageRoutes","reactionContext","shopPrefix","settings","pkgs","fetch","routeDefinitions","shopSub","subscribe","shopSubWaitFor","indexLayout","indexRoute","notFoundLayout","type","pkg","newRoutes","registry","Array","from","meta","reactionLayout","newRouteConfig","triggersEnter","triggersExit","substring","uniqRoutes","reverse","reactRouterRoutes","map","index","reactComponents","exportDefault"],"mappings":"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","sourcesContent":["import React from \"react\";\nimport { Route } from \"react-router\";\nimport createBrowserHistory from \"history/createBrowserHistory\";\nimport createMemoryHistory from \"history/createMemoryHistory\";\nimport pathToRegexp from \"path-to-regexp\";\nimport queryParse from \"query-parse\";\nimport Immutable from \"immutable\";\nimport { uniqBy } from \"lodash\";\nimport { Meteor } from \"meteor/meteor\";\nimport Blaze from \"meteor/gadicc:blaze-react-component\";\nimport { Template } from \"meteor/templating\";\nimport { Session } from \"meteor/session\";\nimport { Tracker } from \"meteor/tracker\";\nimport { Packages, Shops } from \"/lib/collections\";\nimport { getComponent } from \"@reactioncommerce/reaction-components/components\";\nimport Hooks from \"./hooks\";\n\n// Using a ternary operator here to avoid a mutable export - open to suggestions for a better way to do this\nexport const history = Meteor.isClient ? createBrowserHistory() : createMemoryHistory();\n\n// Private vars\nlet currentRoute = Immutable.Map();\nconst routerReadyDependency = new Tracker.Dependency();\nconst routerChangeDependency = new Tracker.Dependency();\n\n/** Class representing a static base router */\nclass Router {\n  /**\n   * history\n   * @type {history}\n   */\n  static history = history\n\n  /**\n   * Hooks\n   * @type {Hooks}\n   */\n  static Hooks = Hooks\n\n  /**\n   * Registered route definitions\n   * @type {Array}\n   */\n  static routes = []\n\n  /**\n   * Router initialization state\n   * @type {Boolean}\n   */\n  static _initialized = false;\n\n  /**\n   * Active classname for active routes\n   * @type {String}\n   */\n  static activeClassName = \"active\";\n\n  /**\n   * Routes array\n   * @type {Array}\n   * @param {Array} value An array of objects\n   */\n  static set _routes(value) {\n    Router.routes = value;\n  }\n\n  static get _routes() {\n    return Router.routes;\n  }\n\n  /**\n   * Triggers reactively on router ready state changed\n   * @return {Boolean} Router initalization state\n   */\n  static ready() {\n    routerReadyDependency.depend();\n    return Router._initialized;\n  }\n\n  /**\n   * Re-triggers router ready dependency\n   * @return {undefined}\n   */\n  static triggerRouterReady() {\n    routerReadyDependency.changed();\n  }\n\n  /**\n   * Hooks\n   * @type {Hooks}\n   */\n  static get triggers() {\n    return Hooks;\n  }\n\n  /**\n   * Get the current route date. Not reactive.\n   * @return {Object} Object containing route data\n   */\n  static current() {\n    return currentRoute.toJS();\n  }\n\n  /**\n   * Set current route data. Is reactive.\n   * @param {Object} routeData Object containing route data\n   * @return {undefined}\n   */\n  static setCurrentRoute(routeData) {\n    currentRoute = Immutable.Map(routeData);\n    routerChangeDependency.changed();\n  }\n\n  /**\n   * Get the name of the current route. Is reactive.\n   * @return {String} Name of current route\n   */\n  static getRouteName() {\n    const current = Router.current();\n\n    return (current.route && current.route.name) || \"\";\n  }\n\n  /**\n   * Get param by name. Is reactive.\n   * @param  {String} name Param name\n   * @return {String|undefined} String value or undefined\n   */\n  static getParam(name) {\n    routerChangeDependency.depend();\n    const current = Router.current();\n\n    return (current.params && current.params[name]) || undefined;\n  }\n\n  /**\n   * Get query param by name\n   * @param  {String} name Query param name. Is reactive.\n   * @return {String|undefined} String value or undefined\n   */\n  static getQueryParam(name) {\n    routerChangeDependency.depend();\n    const current = Router.current();\n\n    return (current.query && current.query[name]) || undefined;\n  }\n\n  /**\n   * Merge new query params with current params\n   * @param {Object} newParams Object containing params\n   * @return {undefined}\n   */\n  static setQueryParams(newParams) {\n    const current = Router.current();\n\n    // Merge current and new params\n    const queryParams = Object.assign({}, current.query, newParams);\n\n    // Any param marked as null or undefined will be removed\n    for (const key in queryParams) {\n      if (queryParams[key] === null || queryParams[key] === undefined) {\n        delete queryParams[key];\n      }\n    }\n\n    // Update route\n    Router.go(current.route.name, current.params, queryParams);\n  }\n\n  /**\n   * Watch path change. Is Reactive.\n   * @return {undefined}\n   */\n  static watchPathChange() {\n    routerChangeDependency.depend();\n  }\n}\n\n/**\n * pathFor\n * @summary get current router path\n * @param {String} path - path to fetch\n * @param {Object} options - url params\n * @return {String} returns current router path\n */\nRouter.pathFor = (path, options = {}) => {\n  const foundPath = Router.routes.find((pathObject) => {\n    if (pathObject.route) {\n      if (options.hash && options.hash.shopSlug) {\n        if (pathObject.options.name === path && pathObject.route.includes(\"shopSlug\")) {\n          return true;\n        }\n      } else if (pathObject.options.name === path && !pathObject.route.includes(\"shopSlug\")) {\n        return true;\n      }\n    }\n\n    // No path found\n    return false;\n  });\n\n  if (foundPath) {\n    // Pull the hash out of options\n    //\n    // This is becuase of Spacebars that we have hash.\n    // Spacebars takes all params passed into a template tag and places\n    // them into the options.hash object. This will also include any `query` params\n    const hash = (options && options.hash) || {};\n\n    // Create an executable function based on the route regex\n    const toPath = pathToRegexp.compile(foundPath.route);\n\n    // Compile the regex path with the params from the hash\n    const compiledPath = toPath(hash);\n\n    // Convert the query object to a string\n    // e.g. { a: \"one\", b: \"two\"} => \"a=one&b=two\"\n    const queryString = queryParse.toString(hash.query);\n\n    // Return the compiled path + query string if we have one\n    if (typeof queryString === \"string\" && queryString.length) {\n      return `${compiledPath}?${queryString}`;\n    }\n\n    // Return only the compiled path\n    return compiledPath;\n  }\n\n  return \"/\";\n};\n\n/**\n * Navigate to path with params and query\n * @param  {String} path Path string\n * @param  {Object} params Route params object\n * @param  {Object} query Query params object\n * @return {undefined} undefined\n */\nRouter.go = (path, params, query) => {\n  let actualPath;\n\n  const routerGo = () => {\n    if (typeof path === \"string\" && path.startsWith(\"/\")) {\n      actualPath = path;\n    } else {\n      actualPath = Router.pathFor(path, {\n        hash: {\n          ...params,\n          query\n        }\n      });\n    }\n\n    if (window) {\n      history.push(actualPath);\n    }\n  };\n\n  // if Router is in a non ready/initialized state yet, wait until it is\n  if (!Router.ready()) {\n    Tracker.autorun((routerReadyWaitFor) => {\n      if (Router.ready()) {\n        routerReadyWaitFor.stop();\n        routerGo();\n      }\n    });\n\n    return;\n  }\n\n  routerGo();\n};\n\n/**\n * Replace location\n * @param  {String} path Path string\n * @param  {Object} params Route params object\n * @param  {Object} query Query params object\n * @return {undefined} undefined\n */\nRouter.replace = (path, params, query) => {\n  const actualPath = Router.pathFor(path, {\n    hash: {\n      ...params,\n      query\n    }\n  });\n\n  if (window) {\n    history.replace(actualPath);\n  }\n};\n\n/**\n * Reload router\n * @return {undefined} undefined\n */\nRouter.reload = () => {\n  const current = Router.current();\n\n  if (window) {\n    history.replace(current.route.fullPath || \"/\");\n  }\n};\n\n/**\n * isActive\n * @summary general helper to return \"active\" when on current path\n * @example {{active \"name\"}}\n * @param {String} routeName - route name as defined in registry\n * @return {String} return \"active\" or null\n */\nRouter.isActiveClassName = (routeName) => {\n  const current = Router.current();\n  const { group } = current.route;\n  let prefix = \"\";\n\n  if (current.route) {\n    const { path } = current.route;\n\n    if (group && group.prefix) {\n      ({ prefix } = current.route.group);\n    }\n\n    // Match route\n    if (prefix.length && routeName.startsWith(prefix) && path === routeName) {\n      // Route name is a path and starts with the prefix. (default '/reaction')\n      return Router.activeClassName;\n    } else if (routeName.startsWith(\"/\") && path === routeName) {\n      // Route name isa  path and starts with slash, but was not prefixed\n      return Router.activeClassName;\n    } else if (current.route.name === routeName) {\n      // Route name is the actual name of the route\n      return Router.activeClassName;\n    }\n  }\n\n  return \"\";\n};\n\n/**\n * hasRoutePermission\n * check if user has route permissions\n * @access private\n * @param  {Object} route - route context\n * @return {Boolean} returns `true` if user is allowed to see route, `false` otherwise\n */\nfunction hasRoutePermission(route) {\n  const routeName = route.name;\n\n  return routeName === \"index\" ||\n    routeName === \"not-found\" ||\n    Router.Reaction.hasPermission(route.permissions, Meteor.userId());\n}\n\n\n/**\n * getRegistryRouteName\n * assemble route name to be standard\n * prefix/package name + registry name or route\n * @param  {String} packageName  [package name]\n * @param  {Object} registryItem [registry object]\n * @return {String}              [route name]\n */\nfunction getRegistryRouteName(packageName, registryItem) {\n  let routeName;\n  if (packageName && registryItem) {\n    if (registryItem.name) {\n      routeName = registryItem.name;\n    } else if (registryItem.template) {\n      routeName = `${packageName}/${registryItem.template}`;\n    } else {\n      routeName = packageName;\n    }\n    // dont include params in the name\n    [routeName] = routeName.split(\":\");\n    return routeName;\n  }\n  return null;\n}\n\n/**\n * selectLayout\n * @access private\n * @param {Object} layout - element of shops.layout array\n * @param {Object} setLayout - layout\n * @param {Object} setWorkflow - workflow\n * @returns {Object} layout - return object of template definitions for Blaze Layout\n */\nfunction selectLayout(layout, setLayout, setWorkflow) {\n  const currentLayout = setLayout || Session.get(\"DEFAULT_LAYOUT\") || \"coreLayout\";\n  const currentWorkflow = setWorkflow || Session.get(\"DEFAULT_WORKFLOW\") || \"coreWorkflow\";\n  if (layout.layout === currentLayout && layout.workflow === currentWorkflow && layout.enabled === true) {\n    return layout;\n  }\n  return null;\n}\n\n/**\n * ReactionLayout\n * sets and returns reaction layout structure\n * @access public\n * @param {Object} options - this router context\n * @param {String} options.layout - string of shop.layout.layout (defaults to coreLayout)\n * @param {String} options.workflow - string of shop.layout.workflow (defaults to coreLayout)\n * @returns {Object} layout - return object of template definitions for Blaze Layout\n */\nexport function ReactionLayout(options = {}) {\n  // Find a workflow layout to render\n\n  // By default we'll use the primary shop for layouts\n  let shopId = Router.Reaction.getPrimaryShopId();\n\n  // We'll check the marketplace settings too so that we can use the active shopId\n  // if merchantTemplates is enabled\n  // XXX: using merchantTemplates is not ready for production and has not been tested! Use at your own risk.\n  let marketplaceSettings;\n\n  if (Meteor.isClient) { // If we're on the client, use the cached marketplace settings\n    marketplaceSettings = Router.Reaction.marketplace;\n  } else { // if we're on the server, go get the settings from the db with this method\n    marketplaceSettings = Router.Reaction.getMarketplaceSettings();\n    if (marketplaceSettings && marketplaceSettings.public) {\n      // We're only interested in the public settings here\n      marketplaceSettings = marketplaceSettings.public;\n    }\n  }\n\n  // If merchantTemplates is enabled, use the active shopId\n  if (marketplaceSettings && marketplaceSettings.merchantTemplates === true) {\n    shopId = Router.Reaction.getShopId();\n  }\n\n  // Get the shop data\n  const shop = Shops.findOne(shopId);\n\n  // get the layout & workflow from options if they exist\n  // Otherwise get them from the Session. this is set in `/client/config/defaults`\n  // Otherwise, default to hard-coded values\n  const layoutName = options.layout || Session.get(\"DEFAULT_LAYOUT\") || \"coreLayout\";\n  const workflowName = options.workflow || Session.get(\"DEFAULT_WORKFLOW\") || \"coreWorkflow\";\n\n  // Layout object used to render\n  // Defaults provided for reference\n  let layoutStructure = {\n    template: \"\",\n    layoutHeader: \"\",\n    layoutFooter: \"\",\n    notFound: \"notFound\",\n    dashboardHeader: \"\",\n    dashboardControls: \"\",\n    dashboardHeaderControls: \"\",\n    adminControlsFooter: \"\"\n  };\n\n  let layoutTheme = \"default\";\n\n  // Find a registered layout using the layoutName and workflowName\n  if (shop) {\n    const sortedLayout = shop.layout.sort((prev, next) => prev.priority - next.priority);\n    const foundLayout = sortedLayout.find((x) => selectLayout(x, layoutName, workflowName));\n\n    if (foundLayout) {\n      if (foundLayout.structure) {\n        layoutStructure = {\n          ...foundLayout.structure\n        };\n      }\n      if (foundLayout.theme) {\n        layoutTheme = foundLayout.theme;\n      }\n    }\n  }\n\n  // If the original options did not include a workflow, but did have a template,\n  // then we override the template from the layout with the one provided by the options.\n  //\n  // Why is this? We always need a workflow to render the entire layout of the app.\n  // The default layout has a default template that may not be the one we want to render.\n  // Some routes, such as `/account/profile` do no have a workflow, but define a template.\n  // Without the logic below, it would end up rendering the homepage instead of the profile\n  // page.\n  // const optionsHasWorkflow = typeof options.workflow === \"string\";\n  const optionsHasTemplate = typeof options.template === \"string\";\n\n  if (optionsHasTemplate) {\n    layoutStructure.template = options.template;\n  }\n\n  // If there is no Blaze Template (Template[]) or React Component (getComponent)\n  // Then use the notFound template instead\n  let hasReactComponent = true;\n\n  try {\n    getComponent(layoutStructure.template);\n  } catch (e) {\n    hasReactComponent = false;\n  }\n\n  if (!Template[layoutStructure.template] && !hasReactComponent) {\n    return (\n      <Blaze template={layoutStructure.notFound} />\n    );\n  }\n\n  // Render the layout\n  return {\n    theme: layoutTheme,\n    structure: layoutStructure,\n    component: (props) => { // eslint-disable-line react/no-multi-comp, react/display-name\n      const { route } = Router.current();\n      const { permissions } = options;\n      const structure = {\n        ...layoutStructure\n      };\n\n      // If the current route is unauthorized, and is not the \"not-found\" route,\n      // then override the template to use the default unauthorized template\n      if (hasRoutePermission({ ...route, permissions }) === false && route.name !== \"not-found\" && !Meteor.user()) {\n        if (!Router.Reaction.hasPermission(route.permissions, Meteor.userId())) {\n          structure.template = \"unauthorized\";\n        }\n        return false;\n      }\n      try {\n        // Try to create a React component if defined\n        return React.createElement(getComponent(layoutName), {\n          ...props,\n          structure\n        });\n      } catch (e) {\n        // eslint-disable-next-line\n        console.warn(e, \"Failed to create a React layout element\");\n      }\n      // If all else fails, render a not found page\n      return <Blaze template={structure.notFound} />;\n    }\n  };\n}\n\n/**\n * initPackageRoutes\n * registers route and template when registry item has\n * registryItem.route && registryItem.template\n * @param {Object} options - options and context for route creation\n * @returns {undefined} returns undefined\n */\nRouter.initPackageRoutes = (options) => {\n  // make _initialized = false in case router is reinitialized\n  Router._initialized = false;\n  routerReadyDependency.changed();\n\n  Router.Reaction = options.reactionContext;\n  Router.routes = [];\n\n  let marketplaceSettings = {\n    shopPrefix: \"/shop\" // default value\n  };\n\n  const marketplace = Packages.findOne({\n    name: \"reaction-marketplace\",\n    shopId: Router.Reaction.getPrimaryShopId()\n  });\n\n  if (marketplace && marketplace.settings && marketplace.settings.public) {\n    marketplaceSettings = marketplace.settings.public;\n  }\n\n  const pkgs = Packages.find().fetch();\n\n  const routeDefinitions = [];\n\n  // prefixing isnt necessary if we only have one shop\n  // but we need to bypass the current\n  // subscription to determine this.\n  const shopSub = Meteor.subscribe(\"shopsCount\");\n\n  Tracker.autorun((shopSubWaitFor) => {\n    if (shopSub.ready()) {\n      shopSubWaitFor.stop();\n      // using tmeasday:publish-counts\n\n      // Default layouts\n      const indexLayout = ReactionLayout(options.indexRoute);\n      const notFoundLayout = ReactionLayout({ template: \"notFound\" });\n\n      // Index route\n      routeDefinitions.push({\n        route: \"/\",\n        name: \"index\",\n        options: {\n          name: \"index\",\n          ...options.indexRoute,\n          theme: indexLayout.theme,\n          component: indexLayout.component,\n          structure: indexLayout.structure\n        }\n      });\n\n      routeDefinitions.push({\n        route: `${marketplaceSettings.shopPrefix}/:shopSlug`,\n        name: \"index\",\n        options: {\n          name: \"index\",\n          type: \"shop-prefix\",\n          ...options.indexRoute,\n          theme: indexLayout.theme,\n          component: indexLayout.component,\n          structure: indexLayout.structure\n        }\n      });\n\n      // Not-found route\n      routeDefinitions.push({\n        route: \"/not-found\",\n        name: \"not-found\",\n        options: {\n          name: \"not-found\",\n          ...notFoundLayout.indexRoute,\n          theme: notFoundLayout.theme,\n          component: notFoundLayout.component,\n          structure: notFoundLayout.structure\n        }\n      });\n\n      // get package registry route configurations\n      for (const pkg of pkgs) {\n        const newRoutes = [];\n        // pkg registry\n        if (pkg.registry && pkg.enabled) {\n          const registry = Array.from(pkg.registry);\n          for (const registryItem of registry) {\n            // registryItems\n            if (registryItem.route) {\n              const {\n                meta,\n                route,\n                permissions,\n                template,\n                layout,\n                workflow\n                // provides\n              } = registryItem;\n\n              const name = getRegistryRouteName(pkg.name, registryItem);\n\n              // define new route\n              // we could allow the options to be passed in the registry if we need to be more flexible\n              const reactionLayout = ReactionLayout({ template, workflow, layout, permissions });\n              const newRouteConfig = {\n                route,\n                name,\n                options: {\n                  meta,\n                  name,\n                  template,\n                  layout,\n                  triggersEnter: Router.Hooks.get(\"onEnter\", name),\n                  triggersExit: Router.Hooks.get(\"onExit\", name),\n                  component: reactionLayout.component,\n                  theme: reactionLayout.theme,\n                  structure: reactionLayout.structure\n                }\n              };\n              newRoutes.push({\n                ...newRouteConfig,\n                route: `/shop/:shopSlug${route}`,\n                options: {\n                  ...newRouteConfig.options,\n                  type: \"shop-prefix\"\n                }\n              });\n              // push new routes\n              newRoutes.push(newRouteConfig);\n            } // end registryItems\n          } // end package.registry\n\n          //\n          // add group and routes to routing table\n          //\n          for (const route of newRoutes) {\n            // allow overriding of prefix in route definitions\n            // define an \"absolute\" url by excluding \"/\"\n            route.group = {};\n\n            if (route.route.substring(0, 1) !== \"/\") {\n              route.route = `/${route.route}`;\n              route.group.prefix = \"\";\n            }\n\n            routeDefinitions.push(route);\n          }\n        }\n      } // end package loop\n\n      // Uniq-ify routes\n      // Take all route definitions in the order that were received, and reverse it.\n      // Routes defined later, like in the case of custom routes will then have a\n      // higher precedence. Any duplicates after the first instance will be removed.\n      //\n      // TODO: In the future, sort by priority\n      // TODO: Allow duplicated routes with a prefix / suffix / flag\n      const uniqRoutes = uniqBy(routeDefinitions.reverse(), \"route\");\n      const reactRouterRoutes = uniqRoutes.map((route, index) => (\n        <Route\n          key={`${route.name}-${index}`}\n          path={route.route}\n          exact={true}\n          render={route.options.component}\n        />\n      ));\n\n      // Last route, if no other route is matched, this one will be the not-found view\n      // Note: This is last becuase all other routes must at-least attempt a match\n      // before falling back to this not-found route.\n      reactRouterRoutes.push((\n        <Route\n          key=\"not-found\"\n          render={notFoundLayout.component}\n        />\n      ));\n\n      // Finish initialization\n      Router._initialized = true;\n      Router.reactComponents = reactRouterRoutes;\n      Router._routes = uniqRoutes;\n\n      // Trigger a reactive refresh to re-render routes\n      routerReadyDependency.changed();\n    }\n  });\n};\n\n\nexport default Router;\n"]},"sourceType":"script","hash":"7350c90d0d0dbc5636b1001706e1ca781bf3f4a8"}
