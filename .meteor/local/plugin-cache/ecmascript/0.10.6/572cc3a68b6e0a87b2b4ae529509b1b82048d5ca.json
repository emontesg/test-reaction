{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$1$2","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"ast":true,"babelrc":false,"sourceFileName":"imports/plugins/included/shipping-shippo/server/methods/shippo.js","filename":"imports/plugins/included/shipping-shippo/server/methods/shippo.js","sourceMaps":true,"envName":"development","cwd":"/Users/estebandev/test-knowledge","passPerPreset":false,"presets":[],"parserOpts":{"sourceType":"module","sourceFileName":"imports/plugins/included/shipping-shippo/server/methods/shippo.js","plugins":["jsx","jsx","flow","flow","objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties"]},"generatorOpts":{"filename":"imports/plugins/included/shipping-shippo/server/methods/shippo.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"imports/plugins/included/shipping-shippo/server/methods/shippo.js"}},"code":"module.export({\n  methods: () => methods\n});\n\nlet _difference;\n\nmodule.watch(require(\"lodash/difference\"), {\n  default(v) {\n    _difference = v;\n  }\n\n}, 0);\nlet Meteor;\nmodule.watch(require(\"meteor/meteor\"), {\n  Meteor(v) {\n    Meteor = v;\n  }\n\n}, 1);\nlet check, Match;\nmodule.watch(require(\"meteor/check\"), {\n  check(v) {\n    check = v;\n  },\n\n  Match(v) {\n    Match = v;\n  }\n\n}, 2);\nlet Roles;\nmodule.watch(require(\"meteor/alanning:roles\"), {\n  Roles(v) {\n    Roles = v;\n  }\n\n}, 3);\nlet Reaction, Hooks;\nmodule.watch(require(\"../../../../../../server/api\"), {\n  Reaction(v) {\n    Reaction = v;\n  },\n\n  Hooks(v) {\n    Hooks = v;\n  }\n\n}, 4);\nlet Packages, Accounts, Shops, Shipping, Cart, Orders;\nmodule.watch(require(\"../../../../../../lib/collections\"), {\n  Packages(v) {\n    Packages = v;\n  },\n\n  Accounts(v) {\n    Accounts = v;\n  },\n\n  Shops(v) {\n    Shops = v;\n  },\n\n  Shipping(v) {\n    Shipping = v;\n  },\n\n  Cart(v) {\n    Cart = v;\n  },\n\n  Orders(v) {\n    Orders = v;\n  }\n\n}, 5);\nlet ShippoPackageConfig;\nmodule.watch(require(\"../../lib/collections/schemas\"), {\n  ShippoPackageConfig(v) {\n    ShippoPackageConfig = v;\n  }\n\n}, 6);\nlet shippingRoles;\nmodule.watch(require(\"../lib/roles\"), {\n  shippingRoles(v) {\n    shippingRoles = v;\n  }\n\n}, 7);\nlet ShippoApi;\nmodule.watch(require(\"./shippoapi\"), {\n  ShippoApi(v) {\n    ShippoApi = v;\n  }\n\n}, 8);\n\n// Creates an address (for sender or recipient) suitable for Shippo Api Calls given\n// a reaction address an email and a purpose(\"QUOTE\"|\"PURCHASE\")\nfunction createShippoAddress(reactionAddress, email, purpose) {\n  const shippoAddress = {\n    object_purpose: purpose,\n    name: reactionAddress.fullName,\n    street1: reactionAddress.address1,\n    street2: reactionAddress.address2 || \"\",\n    // \"\" in order to be cleaned later by SimpleSchema.clean\n    city: reactionAddress.city,\n    company: reactionAddress.company || \"\",\n    state: reactionAddress.region,\n    zip: reactionAddress.postal,\n    country: reactionAddress.country,\n    phone: reactionAddress.phone,\n    email,\n    is_residential: !reactionAddress.isCommercial\n  };\n  return shippoAddress;\n} // Creates a parcel object suitable for Shippo Api Calls given\n// a reaction product's parcel and units of measure for mass and distance\n\n\nfunction createShippoParcel(reactionParcel, cartWeight, reactionMassUnit, reactionDistanceUnit) {\n  const shippoParcel = {\n    width: reactionParcel.width || 1,\n    length: reactionParcel.length || 1,\n    height: reactionParcel.height || 1,\n    weight: cartWeight,\n    distance_unit: reactionDistanceUnit,\n    mass_unit: reactionMassUnit\n  };\n  return shippoParcel;\n}\n\nfunction getTotalCartweight(cart) {\n  const totalWeight = cart.items.reduce((sum, cartItem) => {\n    const itemWeight = cartItem.quantity * cartItem.parcel.weight;\n    return sum + itemWeight;\n  }, 0);\n  return totalWeight;\n} // converts the Rates List fetched from the Shippo Api to Reaction Shipping Rates form\n\n\nfunction ratesParser(shippoRates, shippoDocs) {\n  return shippoRates.map(rate => {\n    const rateAmount = parseFloat(rate.amount);\n    const reactionRate = {\n      carrier: rate.provider,\n      method: {\n        carrier: rate.provider,\n        enabled: true,\n        handling: 0,\n        label: rate.servicelevel_name,\n        rate: rateAmount,\n        settings: {\n          // carrierAccount: rate.carrier_account,\n          rateId: rate.object_id,\n          serviceLevelToken: rate.servicelevel_token\n        }\n      },\n      rate: rateAmount,\n      shopId: shippoDocs[rate.carrier_account].shopId\n    };\n    return reactionRate;\n  });\n} // Filters the carrier list and gets and parses only the ones that are activated in the Shippo Account\n\n\nfunction filterActiveCarriers(carrierList) {\n  const activeCarriers = [];\n\n  if (carrierList.results && carrierList.count) {\n    carrierList.results.forEach(carrier => {\n      if (carrier.active) {\n        activeCarriers.push({\n          carrier: carrier.carrier,\n          // this is a property of the returned result with value the name of the carrier\n          carrierAccountId: carrier.object_id\n        });\n      }\n    });\n    return activeCarriers;\n  }\n} // usps_express to USPS EXPRESS .We need a better approach - use a suitable static map object\n\n\nfunction formatCarrierLabel(carrierName) {\n  return carrierName.replace(/_/g, \" \").toUpperCase();\n} // get Shippo's Api Key from the Shippo package with the supplied shopId or alternatively of the current shop's Id\n\n\nfunction getApiKey(shopId = Reaction.getShopId()) {\n  const {\n    settings\n  } = Packages.findOne({\n    name: \"reaction-shippo\",\n    shopId\n  });\n  return settings.apiKey;\n} // Adds Shippo carriers in Shipping Collection (one doc per carrier) for the current Shop\n\n\nfunction addShippoProviders(carriers, shopId = Reaction.getShopId()) {\n  let result = true;\n  carriers.forEach(carrier => {\n    const carrierName = carrier.carrier;\n    const carrierLabel = formatCarrierLabel(carrierName);\n    const currentResult = Shipping.insert({\n      name: `${carrierLabel}`,\n      // check it later for a better name\n      methods: [],\n      provider: {\n        name: carrierName,\n        label: carrierLabel,\n        enabled: true,\n        shippoProvider: {\n          carrierAccountId: carrier.carrierAccountId\n        }\n      },\n      shopId\n    });\n    result = result && currentResult;\n  });\n  return result;\n} // Remove from Shipping Collection shop's Shippo Providers with carrier account Id in carriersIds\n// or all of them (if carriersIds is set to false)\n\n\nfunction removeShippoProviders(carriersIds, shopId = Reaction.getShopId()) {\n  if (carriersIds) {\n    return Shipping.remove({\n      shopId,\n      \"provider.shippoProvider.carrierAccountId\": {\n        $in: carriersIds\n      }\n    });\n  }\n\n  return Shipping.remove({\n    shopId,\n    \"provider.shippoProvider\": {\n      $exists: true\n    }\n  });\n} // After getting the current active Carriers of the Shippo Account removes\n// from the Shipping Collection the Shippo providers that are deactivated(don't exist in active carriers)\n// and inserts the newly active carriers in Shipping Collection as shippo providers.\n\n\nfunction updateShippoProviders(activeCarriers, shopId = Reaction.getShopId()) {\n  const currentShippoProviders = Shipping.find({\n    shopId,\n    \"provider.shippoProvider\": {\n      $exists: true\n    }\n  }, {\n    fields: {\n      \"provider.shippoProvider.carrierAccountId\": 1\n    }\n  }); // Ids of Shippo Carriers that exist currently as docs in Shipping Collection\n\n  const currentCarriersIds = currentShippoProviders.map(doc => doc.provider.shippoProvider.carrierAccountId);\n  const newActiveCarriers = [];\n  const unchangedActiveCarriersIds = [];\n  activeCarriers.forEach(carrier => {\n    const carrierId = carrier.carrierAccountId;\n\n    if (!currentCarriersIds.includes(carrierId)) {\n      newActiveCarriers.push(carrier);\n    } else {\n      unchangedActiveCarriersIds.push(carrierId);\n    }\n  });\n\n  const deactivatedCarriersIds = _difference(currentCarriersIds, unchangedActiveCarriersIds);\n\n  if (deactivatedCarriersIds.length) {\n    removeShippoProviders(deactivatedCarriersIds, shopId);\n  }\n\n  if (newActiveCarriers.length) {\n    addShippoProviders(newActiveCarriers, shopId);\n  }\n\n  return true;\n}\n\nconst methods = {\n  /**\n   * Updates the Api key(Live/Test Token) used for connection with the Shippo account.\n   * Also inserts(and deletes if already exist) docs in the Shipping collection each of the\n   * activated Carriers of the Shippo account.\n   * This method is intended to be used mainly by Autoform.\n   * @param  {Object} details An object with _id and modifier props\n   * @param  {String} [docId] DEPRECATED. The _id, if details is the modifier.\n   * @return {Object|Boolean} result - The object returned.\n   * @return {String} {string(\"update\"|\"delete\")} result.type - The type of updating happened.\n   */\n  \"shippo/updateApiKey\"(details, docId) {\n    check(details, Object); // Backward compatibility\n\n    check(docId, Match.Optional(String));\n    const id = docId || details._id;\n    const modifier = docId ? details : details.modifier; // Important server-side checks for security and data integrity\n\n    check(id, String);\n    ShippoPackageConfig.validate(modifier, {\n      modifier: true\n    }); // Make sure user has proper rights to this package\n\n    const {\n      shopId\n    } = Packages.findOne({\n      _id: id\n    }, {\n      field: {\n        shopId: 1\n      }\n    });\n\n    if (shopId && Roles.userIsInRole(this.userId, shippingRoles, shopId)) {\n      // If user wants to delete existing key\n      if ({}.hasOwnProperty.call(modifier, \"$unset\")) {\n        const customModifier = {\n          $set: {\n            \"settings.apiKey\": null\n          }\n        };\n        Packages.update(id, customModifier); // remove shop's existing Shippo Providers from Shipping Collection\n\n        removeShippoProviders(false, shopId);\n        return {\n          type: \"delete\"\n        };\n      }\n\n      const apiKey = modifier.$set[\"settings.apiKey\"]; // Tries to use the apiKey by fetching a list of the addresses of Shippo Account\n      // if not possible throws a relative Meteor Error (eg invalid_credentials)\n\n      ShippoApi.methods.getAddressList.call({\n        apiKey\n      }); // if everything is ok proceed with the api key update\n\n      Packages.update(id, modifier); // remove shop's existing Shippo Providers from Shipping Collection\n\n      removeShippoProviders(false, shopId);\n      const activeCarriers = filterActiveCarriers(ShippoApi.methods.getCarrierAccountsList.call({\n        apiKey\n      }));\n\n      if (activeCarriers.length) {\n        addShippoProviders(activeCarriers, shopId);\n      }\n\n      return {\n        type: \"update\"\n      };\n    }\n\n    return false;\n  },\n\n  /**\n   * Fetches the current active Shippo Carriers from the Shippo Account and updates the\n   * Shipping Collection by keeping only these as Shippo Providers of the shop.\n   * @return {Boolean} result - if the updating happened successfully or not.\n   * */\n  \"shippo/fetchProviders\"() {\n    const shopId = Reaction.getShopId();\n\n    if (Roles.userIsInRole(this.userId, shippingRoles, shopId)) {\n      const apiKey = getApiKey(shopId);\n\n      if (!apiKey) {\n        return false;\n      }\n\n      const activeCarriers = filterActiveCarriers(ShippoApi.methods.getCarrierAccountsList.call({\n        apiKey\n      }));\n      return updateShippoProviders(activeCarriers, shopId);\n    }\n\n    return false;\n  },\n\n  /**\n   * Fetches the tracking status of shipped orders from Shippo and updates the\n   * relevant orders' properties\n   * @param {String} orderId - optional orderId to get status of just one order.\n   * @return {Boolean} result - if the updating happened successfully or not.\n   * */\n  \"shippo/fetchTrackingStatusForOrders\"(orderId) {\n    check(orderId, Match.Optional(String));\n    const shopId = Reaction.getShopId();\n    let shippoOrders;\n    const apiKey = getApiKey(shopId);\n\n    if (!apiKey) {\n      return false;\n    }\n\n    if (orderId) {\n      // return a specific order\n      shippoOrders = Orders.find({\n        shopId,\n        orderId\n      });\n    } else {\n      // Find the orders of the shop that have shippo provider, tracking number, that are shipped\n      // but they are not yet delivered;\n      shippoOrders = Orders.find({\n        shopId,\n        \"shipping.0.shippo.transactionId\": {\n          $exists: true\n        },\n        \"shipping.0.tracking\": {\n          $exists: true\n        },\n        \"shipping.0.shipped\": true,\n        \"shipping.0.delivered\": {\n          $ne: true // For now we don' t have logic for returned products\n\n        }\n      });\n    } // no orders to update\n\n\n    if (!shippoOrders.count()) {\n      return true;\n    } // For each order get from Shippo the transaction item ,check the tracking and if it has been updated\n\n\n    let updatingResult = true;\n    shippoOrders.forEach(order => {\n      const orderShipment = order.shipping[0];\n      const {\n        transactionId\n      } = orderShipment.shippo;\n      const transaction = ShippoApi.methods.getTransaction.call({\n        apiKey,\n        transactionId\n      }); // For Testing:\n      // Comment First line of code, and uncomment following block to mock the updating of tracking status\n      // as Shippo's tracking status for test Shipments isn't getting updated.\n\n      const trackingStatus = transaction.tracking_status; // const trackingStatus = {};\n      // if (transaction.object_state === \"VALID\") {\n      //   trackingStatus.status_date = (new Date).toString();\n      //   trackingStatus.status = (!orderShipment.shippo.trackingStatusStatus ? \"TRANSIT\" : \"DELIVERED\");\n      // }\n\n      if (trackingStatus && trackingStatus.status_date !== orderShipment.shippo.trackingStatusDate) {\n        //  Shippo's tracking_status.status enum Indicates the high level status of the shipment:\n        // 'UNKNOWN', 'DELIVERED', 'TRANSIT', 'FAILURE', 'RETURNED'.\n        if (trackingStatus.status === \"DELIVERED\") {\n          Meteor.call(\"orders/shipmentDelivered\", order);\n        } // A batch update might be better option. Unfortunately Reaction.importer doesn't support\n        // .. Orders currently\n\n\n        const orderUpdating = Orders.update({\n          _id: order._id\n        }, {\n          $set: {\n            \"shipping.0.shippo.trackingStatusDate\": trackingStatus.status_date,\n            \"shipping.0.shippo.trackingStatusStatus\": trackingStatus.status\n          }\n        });\n        updatingResult = updatingResult && orderUpdating;\n      }\n    });\n    return updatingResult;\n  },\n\n  /**\n   * Returns the available Shippo Methods/Rates for a selected cart,\n   * in the same form shipping/getShippingRates returns them.\n   * @param {String} cartId - The id of the cart that rates are to be supplied.\n   * @param {Object} shippoDocs - Contains all the enabled shipping objects with\n   * provider.shippoProvider property. Each property has as key the Shippo's\n   * carrierAccountId and as value the corresponding document of shipping\n   * collection.\n   * @param {Array} retrialTargets - An array with the details of which\n   * methods for getting shipping methods failed in the most recent\n   * query of Shippo's API.\n   * @return {Array} errorDetailsAndRetryInfo - Details of any error that\n   * occurred while querying Shippo's API, and info about this package so\n   * as to know if this specific query is to be retried.\n   * @return {Array} rates - The rates of the enabled and available\n   * Shippo carriers, and an empty array.\n   */\n  \"shippo/getShippingRatesForCart\"(cartId, shippoDocs, retrialTargets) {\n    check(cartId, String);\n    check(shippoDocs, Object);\n    check(retrialTargets, Array);\n    const currentMethodInfo = {\n      packageName: \"shippo\",\n      fileName: \"shippo.js\"\n    };\n    const errorDetails = {\n      requestStatus: \"error\",\n      shippingProvider: \"shippo\"\n    };\n    let isRetry;\n\n    if (retrialTargets.length > 0) {\n      const isNotAmongFailedRequests = retrialTargets.every(target => target.packageName !== currentMethodInfo.packageName && target.fileName !== currentMethodInfo.fileName);\n\n      if (isNotAmongFailedRequests) {\n        return [[], retrialTargets];\n      }\n\n      isRetry = true;\n    }\n\n    const cart = Cart.findOne(cartId);\n\n    if (cart && cart.userId === this.userId) {\n      // confirm user has the right\n      let shippoAddressTo;\n      let shippoParcel;\n      const purpose = \"PURCHASE\";\n      const shop = Shops.findOne({\n        _id: cart.shopId\n      }, {\n        field: {\n          addressBook: 1,\n          emails: 1,\n          unitsOfMeasure: {\n            $elemMatch: {\n              default: true\n            }\n          }\n        }\n      });\n      const apiKey = getApiKey(cart.shopId); // If for a weird reason Shop hasn't a Shippo Api key anymore return no-rates.\n\n      if (!apiKey) {\n        // In this case, and some similar ones below, there's no need\n        // for a retry.\n        errorDetails.message = \"No Shippo API key was found in this cart.\";\n        return [[errorDetails], []];\n      } // TODO create a shipping address book record for shop.\n\n\n      const shippoAddressFrom = createShippoAddress(shop.addressBook[0], shop.emails[0].address, purpose); // product in the cart has to have parcel property with the dimensions\n\n      if (cart.items && cart.items[0] && cart.items[0].parcel) {\n        const unitOfMeasure = shop && shop.baseUOM || \"kg\";\n        const unitOfLength = shop && shop.baseUOL || \"cm\";\n        const cartWeight = getTotalCartweight(cart);\n        shippoParcel = createShippoParcel(cart.items[0].parcel, cartWeight, unitOfMeasure, unitOfLength);\n      } else {\n        errorDetails.message = \"This cart has no items, or the first item has no 'parcel' property.\";\n        return [[errorDetails], []];\n      }\n\n      const buyer = Accounts.findOne({\n        _id: this.userId\n      }, {\n        field: {\n          emails: 1\n        }\n      }); // check that there is address available in cart\n\n      if (cart.shipping && cart.shipping[0] && cart.shipping[0].address) {\n        // TODO take a more elegant approach to guest checkout -> no email address\n        // add Logger.trace if this smells\n        let email = shop.emails[0].address || \"noreply@localhost\";\n\n        if (buyer.emails.length > 0) {\n          if (buyer.emails[0].address) {\n            email = buyer.emails[0].address;\n          }\n        }\n\n        shippoAddressTo = createShippoAddress(cart.shipping[0].address, email, purpose);\n      } else {\n        errorDetails.message = \"The 'shipping' property of this cart is either missing or incomplete.\";\n        return [[errorDetails], []];\n      }\n\n      const carrierAccounts = Object.keys(shippoDocs);\n      let shippoShipment;\n\n      try {\n        shippoShipment = ShippoApi.methods.createShipment.call({\n          shippoAddressFrom,\n          shippoAddressTo,\n          shippoParcel,\n          purpose,\n          carrierAccounts,\n          apiKey\n        });\n      } catch (error) {\n        const errorData = {\n          requestStatus: \"error\",\n          shippingProvider: \"shippo\",\n          message: error.message\n        };\n\n        if (isRetry) {\n          errorDetails.message = \"The Shippo API call has failed again.\";\n          return [[errorDetails], []];\n        }\n\n        return [[errorData], [currentMethodInfo]];\n      }\n\n      const shippoRates = shippoShipment.rates_list;\n\n      if (!shippoRates || shippoRates.length === 0) {\n        const noShippingMethods = {\n          requestStatus: \"error\",\n          shippingProvider: \"shippo\",\n          message: \"Couldn't find any shipping methods. Try using another address.\"\n        };\n\n        if (isRetry) {\n          errorDetails.message = \"Didn't get any shipping methods. The Shippo API call has failed again.\";\n          return [[errorDetails], []];\n        }\n\n        return [[noShippingMethods], [currentMethodInfo]];\n      }\n\n      const reactionRates = ratesParser(shippoRates, shippoDocs);\n      return [reactionRates, []];\n    }\n\n    errorDetails.message = \"Error. Your cart is either undefined or has the wrong userId.\";\n    return [[errorDetails], []];\n  },\n\n  /**\n   * Confirms Shippo order based on buyer's choice at the time of purchase\n   * and supplies the order doc with the tracking and label infos\n   * @param {String} orderId - The id of the ordered that labels are purchased for\n   * @return {Boolean} result - True if procedure completed succesfully,otherwise false\n   */\n  \"shippo/confirmShippingMethodForOrder\"(orderId) {\n    check(orderId, String);\n    const order = Orders.findOne(orderId); // Make sure user has permissions in the shop's order\n\n    if (Roles.userIsInRole(this.userId, shippingRoles, order.shopId)) {\n      const orderShipment = order.shipping[0]; // Here we done it for the first/unique Shipment only . in the near future it will be done for multiple ones\n\n      if (orderShipment && orderShipment.shipmentMethod && orderShipment.shipmentMethod.settings && orderShipment.shipmentMethod.settings.rateId) {\n        const apiKey = getApiKey(order.shopId); // If for a weird reason Shop hasn't a Shippo Api key anymore you have to throw an error\n        // cause the Shippo label purchasing is not gonna happen.\n\n        if (!apiKey) {\n          throw new Meteor.Error(\"access-denied\", \"Invalid Shippo Credentials\");\n        }\n\n        const {\n          rateId\n        } = orderShipment.shipmentMethod.settings; // make the actual purchase\n\n        const transaction = ShippoApi.methods.createTransaction.call({\n          rateId,\n          apiKey\n        });\n\n        if (transaction) {\n          return Orders.update({\n            _id: orderId\n          }, {\n            $set: {\n              \"shipping.0.shippingLabelUrl\": transaction.label_url,\n              \"shipping.0.tracking\": transaction.tracking_number,\n              \"shipping.0.shippo.transactionId\": transaction.object_id,\n              \"shipping.0.shippo.trackingStatusDate\": null,\n              \"shipping.0.shippo.trackingStatusStatus\": null\n            }\n          });\n        }\n      }\n    }\n\n    return false;\n  }\n\n};\nMeteor.methods(methods);\nHooks.Events.add(\"onOrderPaymentCaptured\", orderId => {\n  Meteor.call(\"shippo/confirmShippingMethodForOrder\", orderId);\n  return orderId;\n});","map":{"version":3,"sources":["imports/plugins/included/shipping-shippo/server/methods/shippo.js"],"names":["module","export","methods","_difference","watch","require","default","v","Meteor","check","Match","Roles","Reaction","Hooks","Packages","Accounts","Shops","Shipping","Cart","Orders","ShippoPackageConfig","shippingRoles","ShippoApi","createShippoAddress","reactionAddress","email","purpose","shippoAddress","object_purpose","name","fullName","street1","address1","street2","address2","city","company","state","region","zip","postal","country","phone","is_residential","isCommercial","createShippoParcel","reactionParcel","cartWeight","reactionMassUnit","reactionDistanceUnit","shippoParcel","width","length","height","weight","distance_unit","mass_unit","getTotalCartweight","cart","totalWeight","items","reduce","sum","cartItem","itemWeight","quantity","parcel","ratesParser","shippoRates","shippoDocs","map","rate","rateAmount","parseFloat","amount","reactionRate","carrier","provider","method","enabled","handling","label","servicelevel_name","settings","rateId","object_id","serviceLevelToken","servicelevel_token","shopId","carrier_account","filterActiveCarriers","carrierList","activeCarriers","results","count","forEach","active","push","carrierAccountId","formatCarrierLabel","carrierName","replace","toUpperCase","getApiKey","getShopId","findOne","apiKey","addShippoProviders","carriers","result","carrierLabel","currentResult","insert","shippoProvider","removeShippoProviders","carriersIds","remove","$in","$exists","updateShippoProviders","currentShippoProviders","find","fields","currentCarriersIds","doc","newActiveCarriers","unchangedActiveCarriersIds","carrierId","includes","deactivatedCarriersIds","details","docId","Object","Optional","String","id","_id","modifier","validate","field","userIsInRole","userId","hasOwnProperty","call","customModifier","$set","update","type","getAddressList","getCarrierAccountsList","orderId","shippoOrders","$ne","updatingResult","order","orderShipment","shipping","transactionId","shippo","transaction","getTransaction","trackingStatus","tracking_status","status_date","trackingStatusDate","status","orderUpdating","cartId","retrialTargets","Array","currentMethodInfo","packageName","fileName","errorDetails","requestStatus","shippingProvider","isRetry","isNotAmongFailedRequests","every","target","shippoAddressTo","shop","addressBook","emails","unitsOfMeasure","$elemMatch","message","shippoAddressFrom","address","unitOfMeasure","baseUOM","unitOfLength","baseUOL","buyer","carrierAccounts","keys","shippoShipment","createShipment","error","errorData","rates_list","noShippingMethods","reactionRates","shipmentMethod","Error","createTransaction","label_url","tracking_number","Events","add"],"mappings":"AAAAA,OAAOC,MAAP,CAAc;AAACC,WAAQ,MAAIA;AAAb,CAAd;;AAAqC,IAAIC,WAAJ;;AAAgBH,OAAOI,KAAP,CAAaC,QAAQ,mBAAR,CAAb,EAA0C;AAACC,UAAQC,CAAR,EAAU;AAACJ,kBAAYI,CAAZ;AAAc;;AAA1B,CAA1C,EAAsE,CAAtE;AAAyE,IAAIC,MAAJ;AAAWR,OAAOI,KAAP,CAAaC,QAAQ,eAAR,CAAb,EAAsC;AAACG,SAAOD,CAAP,EAAS;AAACC,aAAOD,CAAP;AAAS;;AAApB,CAAtC,EAA4D,CAA5D;AAA+D,IAAIE,KAAJ,EAAUC,KAAV;AAAgBV,OAAOI,KAAP,CAAaC,QAAQ,cAAR,CAAb,EAAqC;AAACI,QAAMF,CAAN,EAAQ;AAACE,YAAMF,CAAN;AAAQ,GAAlB;;AAAmBG,QAAMH,CAAN,EAAQ;AAACG,YAAMH,CAAN;AAAQ;;AAApC,CAArC,EAA2E,CAA3E;AAA8E,IAAII,KAAJ;AAAUX,OAAOI,KAAP,CAAaC,QAAQ,uBAAR,CAAb,EAA8C;AAACM,QAAMJ,CAAN,EAAQ;AAACI,YAAMJ,CAAN;AAAQ;;AAAlB,CAA9C,EAAkE,CAAlE;AAAqE,IAAIK,QAAJ,EAAaC,KAAb;AAAmBb,OAAOI,KAAP,CAAaC,QAAQ,8BAAR,CAAb,EAAqD;AAACO,WAASL,CAAT,EAAW;AAACK,eAASL,CAAT;AAAW,GAAxB;;AAAyBM,QAAMN,CAAN,EAAQ;AAACM,YAAMN,CAAN;AAAQ;;AAA1C,CAArD,EAAiG,CAAjG;AAAoG,IAAIO,QAAJ,EAAaC,QAAb,EAAsBC,KAAtB,EAA4BC,QAA5B,EAAqCC,IAArC,EAA0CC,MAA1C;AAAiDnB,OAAOI,KAAP,CAAaC,QAAQ,mCAAR,CAAb,EAA0D;AAACS,WAASP,CAAT,EAAW;AAACO,eAASP,CAAT;AAAW,GAAxB;;AAAyBQ,WAASR,CAAT,EAAW;AAACQ,eAASR,CAAT;AAAW,GAAhD;;AAAiDS,QAAMT,CAAN,EAAQ;AAACS,YAAMT,CAAN;AAAQ,GAAlE;;AAAmEU,WAASV,CAAT,EAAW;AAACU,eAASV,CAAT;AAAW,GAA1F;;AAA2FW,OAAKX,CAAL,EAAO;AAACW,WAAKX,CAAL;AAAO,GAA1G;;AAA2GY,SAAOZ,CAAP,EAAS;AAACY,aAAOZ,CAAP;AAAS;;AAA9H,CAA1D,EAA0L,CAA1L;AAA6L,IAAIa,mBAAJ;AAAwBpB,OAAOI,KAAP,CAAaC,QAAQ,+BAAR,CAAb,EAAsD;AAACe,sBAAoBb,CAApB,EAAsB;AAACa,0BAAoBb,CAApB;AAAsB;;AAA9C,CAAtD,EAAsG,CAAtG;AAAyG,IAAIc,aAAJ;AAAkBrB,OAAOI,KAAP,CAAaC,QAAQ,cAAR,CAAb,EAAqC;AAACgB,gBAAcd,CAAd,EAAgB;AAACc,oBAAcd,CAAd;AAAgB;;AAAlC,CAArC,EAAyE,CAAzE;AAA4E,IAAIe,SAAJ;AAActB,OAAOI,KAAP,CAAaC,QAAQ,aAAR,CAAb,EAAoC;AAACiB,YAAUf,CAAV,EAAY;AAACe,gBAAUf,CAAV;AAAY;;AAA1B,CAApC,EAAgE,CAAhE;;AAWv8B;AACA;AACA,SAASgB,mBAAT,CAA6BC,eAA7B,EAA8CC,KAA9C,EAAqDC,OAArD,EAA8D;AAC5D,QAAMC,gBAAgB;AACpBC,oBAAgBF,OADI;AAEpBG,UAAML,gBAAgBM,QAFF;AAGpBC,aAASP,gBAAgBQ,QAHL;AAIpBC,aAAST,gBAAgBU,QAAhB,IAA4B,EAJjB;AAIqB;AACzCC,UAAMX,gBAAgBW,IALF;AAMpBC,aAASZ,gBAAgBY,OAAhB,IAA2B,EANhB;AAOpBC,WAAOb,gBAAgBc,MAPH;AAQpBC,SAAKf,gBAAgBgB,MARD;AASpBC,aAASjB,gBAAgBiB,OATL;AAUpBC,WAAOlB,gBAAgBkB,KAVH;AAWpBjB,SAXoB;AAYpBkB,oBAAgB,CAACnB,gBAAgBoB;AAZb,GAAtB;AAeA,SAAOjB,aAAP;AACD,C,CAED;AACA;;;AACA,SAASkB,kBAAT,CAA4BC,cAA5B,EAA4CC,UAA5C,EAAwDC,gBAAxD,EAA0EC,oBAA1E,EAAgG;AAC9F,QAAMC,eAAe;AACnBC,WAAOL,eAAeK,KAAf,IAAwB,CADZ;AAEnBC,YAAQN,eAAeM,MAAf,IAAyB,CAFd;AAGnBC,YAAQP,eAAeO,MAAf,IAAyB,CAHd;AAInBC,YAAQP,UAJW;AAKnBQ,mBAAeN,oBALI;AAMnBO,eAAWR;AANQ,GAArB;AASA,SAAOE,YAAP;AACD;;AAED,SAASO,kBAAT,CAA4BC,IAA5B,EAAkC;AAChC,QAAMC,cAAcD,KAAKE,KAAL,CAAWC,MAAX,CAAkB,CAACC,GAAD,EAAMC,QAAN,KAAmB;AACvD,UAAMC,aAAaD,SAASE,QAAT,GAAoBF,SAASG,MAAT,CAAgBZ,MAAvD;AACA,WAAOQ,MAAME,UAAb;AACD,GAHmB,EAGjB,CAHiB,CAApB;AAIA,SAAOL,WAAP;AACD,C,CAED;;;AACA,SAASQ,WAAT,CAAqBC,WAArB,EAAkCC,UAAlC,EAA8C;AAC5C,SAAOD,YAAYE,GAAZ,CAAiBC,IAAD,IAAU;AAC/B,UAAMC,aAAaC,WAAWF,KAAKG,MAAhB,CAAnB;AACA,UAAMC,eAAe;AACnBC,eAASL,KAAKM,QADK;AAEnBC,cAAQ;AACNF,iBAASL,KAAKM,QADR;AAENE,iBAAS,IAFH;AAGNC,kBAAU,CAHJ;AAINC,eAAOV,KAAKW,iBAJN;AAKNX,cAAMC,UALA;AAMNW,kBAAU;AACR;AACAC,kBAAQb,KAAKc,SAFL;AAGRC,6BAAmBf,KAAKgB;AAHhB;AANJ,OAFW;AAcnBhB,YAAMC,UAda;AAenBgB,cAAQnB,WAAWE,KAAKkB,eAAhB,EAAiCD;AAftB,KAArB;AAkBA,WAAOb,YAAP;AACD,GArBM,CAAP;AAsBD,C,CAED;;;AACA,SAASe,oBAAT,CAA8BC,WAA9B,EAA2C;AACzC,QAAMC,iBAAiB,EAAvB;;AACA,MAAID,YAAYE,OAAZ,IAAuBF,YAAYG,KAAvC,EAA8C;AAC5CH,gBAAYE,OAAZ,CAAoBE,OAApB,CAA6BnB,OAAD,IAAa;AACvC,UAAIA,QAAQoB,MAAZ,EAAoB;AAClBJ,uBAAeK,IAAf,CAAoB;AAClBrB,mBAASA,QAAQA,OADC;AACQ;AAC1BsB,4BAAkBtB,QAAQS;AAFR,SAApB;AAID;AACF,KAPD;AASA,WAAOO,cAAP;AACD;AACF,C,CAED;;;AACA,SAASO,kBAAT,CAA4BC,WAA5B,EAAyC;AACvC,SAAOA,YAAYC,OAAZ,CAAoB,IAApB,EAA0B,GAA1B,EAA+BC,WAA/B,EAAP;AACD,C,CAED;;;AACA,SAASC,SAAT,CAAmBf,SAAS5E,SAAS4F,SAAT,EAA5B,EAAkD;AAChD,QAAM;AAAErB;AAAF,MAAerE,SAAS2F,OAAT,CAAiB;AACpC5E,UAAM,iBAD8B;AAEpC2D;AAFoC,GAAjB,CAArB;AAKA,SAAOL,SAASuB,MAAhB;AACD,C,CAED;;;AACA,SAASC,kBAAT,CAA4BC,QAA5B,EAAsCpB,SAAS5E,SAAS4F,SAAT,EAA/C,EAAqE;AACnE,MAAIK,SAAS,IAAb;AACAD,WAASb,OAAT,CAAkBnB,OAAD,IAAa;AAC5B,UAAMwB,cAAcxB,QAAQA,OAA5B;AACA,UAAMkC,eAAeX,mBAAmBC,WAAnB,CAArB;AACA,UAAMW,gBAAgB9F,SAAS+F,MAAT,CAAgB;AACpCnF,YAAO,GAAEiF,YAAa,EADc;AACX;AACzB5G,eAAS,EAF2B;AAGpC2E,gBAAU;AACRhD,cAAMuE,WADE;AAERnB,eAAO6B,YAFC;AAGR/B,iBAAS,IAHD;AAIRkC,wBAAgB;AACdf,4BAAkBtB,QAAQsB;AADZ;AAJR,OAH0B;AAWpCV;AAXoC,KAAhB,CAAtB;AAaAqB,aAASA,UAAUE,aAAnB;AACD,GAjBD;AAmBA,SAAOF,MAAP;AACD,C,CAED;AACA;;;AACA,SAASK,qBAAT,CAA+BC,WAA/B,EAA4C3B,SAAS5E,SAAS4F,SAAT,EAArD,EAA2E;AACzE,MAAIW,WAAJ,EAAiB;AACf,WAAOlG,SAASmG,MAAT,CAAgB;AACrB5B,YADqB;AAErB,kDAA4C;AAAE6B,aAAKF;AAAP;AAFvB,KAAhB,CAAP;AAID;;AAED,SAAOlG,SAASmG,MAAT,CAAgB;AACrB5B,UADqB;AAErB,+BAA2B;AAAE8B,eAAS;AAAX;AAFN,GAAhB,CAAP;AAID,C,CAED;AACA;AACA;;;AAEA,SAASC,qBAAT,CAA+B3B,cAA/B,EAA+CJ,SAAS5E,SAAS4F,SAAT,EAAxD,EAA8E;AAC5E,QAAMgB,yBAAyBvG,SAASwG,IAAT,CAAc;AAC3CjC,UAD2C;AAE3C,+BAA2B;AAAE8B,eAAS;AAAX;AAFgB,GAAd,EAG5B;AACDI,YAAQ;AAAE,kDAA4C;AAA9C;AADP,GAH4B,CAA/B,CAD4E,CAQ5E;;AACA,QAAMC,qBAAqBH,uBAAuBlD,GAAvB,CAA4BsD,GAAD,IAASA,IAAI/C,QAAJ,CAAaoC,cAAb,CAA4Bf,gBAAhE,CAA3B;AAEA,QAAM2B,oBAAoB,EAA1B;AACA,QAAMC,6BAA6B,EAAnC;AACAlC,iBAAeG,OAAf,CAAwBnB,OAAD,IAAa;AAClC,UAAMmD,YAAYnD,QAAQsB,gBAA1B;;AACA,QAAI,CAACyB,mBAAmBK,QAAnB,CAA4BD,SAA5B,CAAL,EAA6C;AAC3CF,wBAAkB5B,IAAlB,CAAuBrB,OAAvB;AACD,KAFD,MAEO;AACLkD,iCAA2B7B,IAA3B,CAAgC8B,SAAhC;AACD;AACF,GAPD;;AASA,QAAME,yBAAyB,YAAaN,kBAAb,EAAiCG,0BAAjC,CAA/B;;AACA,MAAIG,uBAAuB7E,MAA3B,EAAmC;AACjC8D,0BAAsBe,sBAAtB,EAA8CzC,MAA9C;AACD;;AACD,MAAIqC,kBAAkBzE,MAAtB,EAA8B;AAC5BuD,uBAAmBkB,iBAAnB,EAAsCrC,MAAtC;AACD;;AAED,SAAO,IAAP;AACD;;AAEM,MAAMtF,UAAU;AACrB;;;;;;;;;;AAUA,wBAAsBgI,OAAtB,EAA+BC,KAA/B,EAAsC;AACpC1H,UAAMyH,OAAN,EAAeE,MAAf,EADoC,CAGpC;;AACA3H,UAAM0H,KAAN,EAAazH,MAAM2H,QAAN,CAAeC,MAAf,CAAb;AACA,UAAMC,KAAKJ,SAASD,QAAQM,GAA5B;AACA,UAAMC,WAAWN,QAAQD,OAAR,GAAkBA,QAAQO,QAA3C,CANoC,CAQpC;;AACAhI,UAAM8H,EAAN,EAAUD,MAAV;AACAlH,wBAAoBsH,QAApB,CAA6BD,QAA7B,EAAuC;AAAEA,gBAAU;AAAZ,KAAvC,EAVoC,CAYpC;;AACA,UAAM;AAAEjD;AAAF,QAAa1E,SAAS2F,OAAT,CAAiB;AAAE+B,WAAKD;AAAP,KAAjB,EAA8B;AAAEI,aAAO;AAAEnD,gBAAQ;AAAV;AAAT,KAA9B,CAAnB;;AACA,QAAIA,UAAU7E,MAAMiI,YAAN,CAAmB,KAAKC,MAAxB,EAAgCxH,aAAhC,EAA+CmE,MAA/C,CAAd,EAAsE;AACpE;AACA,UAAI,GAAGsD,cAAH,CAAkBC,IAAlB,CAAuBN,QAAvB,EAAiC,QAAjC,CAAJ,EAAgD;AAC9C,cAAMO,iBAAiB;AAAEC,gBAAM;AAAE,+BAAmB;AAArB;AAAR,SAAvB;AACAnI,iBAASoI,MAAT,CAAgBX,EAAhB,EAAoBS,cAApB,EAF8C,CAG9C;;AACA9B,8BAAsB,KAAtB,EAA6B1B,MAA7B;AAEA,eAAO;AAAE2D,gBAAM;AAAR,SAAP;AACD;;AAED,YAAMzC,SAAS+B,SAASQ,IAAT,CAAc,iBAAd,CAAf,CAXoE,CAapE;AACA;;AACA3H,gBAAUpB,OAAV,CAAkBkJ,cAAlB,CAAiCL,IAAjC,CAAsC;AAAErC;AAAF,OAAtC,EAfoE,CAgBpE;;AACA5F,eAASoI,MAAT,CAAgBX,EAAhB,EAAoBE,QAApB,EAjBoE,CAkBpE;;AACAvB,4BAAsB,KAAtB,EAA6B1B,MAA7B;AAEA,YAAMI,iBAAiBF,qBAAqBpE,UAAUpB,OAAV,CAAkBmJ,sBAAlB,CAAyCN,IAAzC,CAA8C;AAAErC;AAAF,OAA9C,CAArB,CAAvB;;AACA,UAAId,eAAexC,MAAnB,EAA2B;AACzBuD,2BAAmBf,cAAnB,EAAmCJ,MAAnC;AACD;;AAED,aAAO;AAAE2D,cAAM;AAAR,OAAP;AACD;;AAED,WAAO,KAAP;AACD,GAvDoB;;AAyDrB;;;;;AAMA,4BAA0B;AACxB,UAAM3D,SAAS5E,SAAS4F,SAAT,EAAf;;AAEA,QAAI7F,MAAMiI,YAAN,CAAmB,KAAKC,MAAxB,EAAgCxH,aAAhC,EAA+CmE,MAA/C,CAAJ,EAA4D;AAC1D,YAAMkB,SAASH,UAAUf,MAAV,CAAf;;AACA,UAAI,CAACkB,MAAL,EAAa;AACX,eAAO,KAAP;AACD;;AAED,YAAMd,iBAAiBF,qBAAqBpE,UAAUpB,OAAV,CAAkBmJ,sBAAlB,CAAyCN,IAAzC,CAA8C;AAAErC;AAAF,OAA9C,CAArB,CAAvB;AACA,aAAOa,sBAAsB3B,cAAtB,EAAsCJ,MAAtC,CAAP;AACD;;AAED,WAAO,KAAP;AACD,GA7EoB;;AA+ErB;;;;;;AAMA,wCAAsC8D,OAAtC,EAA+C;AAC7C7I,UAAM6I,OAAN,EAAe5I,MAAM2H,QAAN,CAAeC,MAAf,CAAf;AACA,UAAM9C,SAAS5E,SAAS4F,SAAT,EAAf;AACA,QAAI+C,YAAJ;AACA,UAAM7C,SAASH,UAAUf,MAAV,CAAf;;AACA,QAAI,CAACkB,MAAL,EAAa;AACX,aAAO,KAAP;AACD;;AAED,QAAI4C,OAAJ,EAAa;AACX;AACAC,qBAAepI,OAAOsG,IAAP,CAAY;AACzBjC,cADyB;AAEzB8D;AAFyB,OAAZ,CAAf;AAID,KAND,MAMO;AACL;AACA;AACAC,qBAAepI,OAAOsG,IAAP,CAAY;AACzBjC,cADyB;AAEzB,2CAAmC;AAAE8B,mBAAS;AAAX,SAFV;AAGzB,+BAAuB;AAAEA,mBAAS;AAAX,SAHE;AAIzB,8BAAsB,IAJG;AAKzB,gCAAwB;AAAEkC,eAAK,IAAP,CACxB;;AADwB;AALC,OAAZ,CAAf;AAQD,KA1B4C,CA6B7C;;;AACA,QAAI,CAACD,aAAazD,KAAb,EAAL,EAA2B;AACzB,aAAO,IAAP;AACD,KAhC4C,CAkC7C;;;AACA,QAAI2D,iBAAiB,IAArB;AACAF,iBAAaxD,OAAb,CAAsB2D,KAAD,IAAW;AAC9B,YAAMC,gBAAgBD,MAAME,QAAN,CAAe,CAAf,CAAtB;AACA,YAAM;AAAEC;AAAF,UAAoBF,cAAcG,MAAxC;AACA,YAAMC,cAAczI,UAAUpB,OAAV,CAAkB8J,cAAlB,CAAiCjB,IAAjC,CAAsC;AAAErC,cAAF;AAAUmD;AAAV,OAAtC,CAApB,CAH8B,CAK9B;AACA;AACA;;AACA,YAAMI,iBAAiBF,YAAYG,eAAnC,CAR8B,CAS9B;AACA;AACA;AACA;AACA;;AAEA,UAAID,kBACFA,eAAeE,WAAf,KAA+BR,cAAcG,MAAd,CAAqBM,kBADtD,EAC0E;AACxE;AACA;AACA,YAAIH,eAAeI,MAAf,KAA0B,WAA9B,EAA2C;AACzC7J,iBAAOuI,IAAP,CAAY,0BAAZ,EAAwCW,KAAxC;AACD,SALuE,CAOxE;AACA;;;AACA,cAAMY,gBAAgBnJ,OAAO+H,MAAP,CAAc;AAClCV,eAAKkB,MAAMlB;AADuB,SAAd,EAEnB;AACDS,gBAAM;AACJ,oDAAwCgB,eAAeE,WADnD;AAEJ,sDAA0CF,eAAeI;AAFrD;AADL,SAFmB,CAAtB;AAQAZ,yBAAiBA,kBAAkBa,aAAnC;AACD;AACF,KAnCD;AAqCA,WAAOb,cAAP;AACD,GA/JoB;;AAiKrB;;;;;;;;;;;;;;;;;AAiBA,mCAAiCc,MAAjC,EAAyClG,UAAzC,EAAqDmG,cAArD,EAAqE;AACnE/J,UAAM8J,MAAN,EAAcjC,MAAd;AACA7H,UAAM4D,UAAN,EAAkB+D,MAAlB;AACA3H,UAAM+J,cAAN,EAAsBC,KAAtB;AAEA,UAAMC,oBAAoB;AACxBC,mBAAa,QADW;AAExBC,gBAAU;AAFc,KAA1B;AAIA,UAAMC,eAAe;AACnBC,qBAAe,OADI;AAEnBC,wBAAkB;AAFC,KAArB;AAKA,QAAIC,OAAJ;;AACA,QAAIR,eAAepH,MAAf,GAAwB,CAA5B,EAA+B;AAC7B,YAAM6H,2BAA2BT,eAAeU,KAAf,CAAsBC,MAAD,IACpDA,OAAOR,WAAP,KAAuBD,kBAAkBC,WAAzC,IACAQ,OAAOP,QAAP,KAAoBF,kBAAkBE,QAFP,CAAjC;;AAGA,UAAIK,wBAAJ,EAA8B;AAC5B,eAAO,CAAC,EAAD,EAAKT,cAAL,CAAP;AACD;;AAEDQ,gBAAU,IAAV;AACD;;AAED,UAAMtH,OAAOxC,KAAKuF,OAAL,CAAa8D,MAAb,CAAb;;AACA,QAAI7G,QAAQA,KAAKmF,MAAL,KAAgB,KAAKA,MAAjC,EAAyC;AAAE;AACzC,UAAIuC,eAAJ;AACA,UAAIlI,YAAJ;AACA,YAAMxB,UAAU,UAAhB;AAEA,YAAM2J,OAAOrK,MAAMyF,OAAN,CAAc;AACzB+B,aAAK9E,KAAK8B;AADe,OAAd,EAEV;AACDmD,eAAO;AACL2C,uBAAa,CADR;AAELC,kBAAQ,CAFH;AAGLC,0BAAgB;AAAEC,wBAAY;AAAEnL,uBAAS;AAAX;AAAd;AAHX;AADN,OAFU,CAAb;AAUA,YAAMoG,SAASH,UAAU7C,KAAK8B,MAAf,CAAf,CAfuC,CAgBvC;;AACA,UAAI,CAACkB,MAAL,EAAa;AACX;AACA;AACAmE,qBAAaa,OAAb,GAAuB,2CAAvB;AACA,eAAO,CAAC,CAACb,YAAD,CAAD,EAAiB,EAAjB,CAAP;AACD,OAtBsC,CAuBvC;;;AACA,YAAMc,oBAAoBpK,oBAAoB8J,KAAKC,WAAL,CAAiB,CAAjB,CAApB,EAAyCD,KAAKE,MAAL,CAAY,CAAZ,EAAeK,OAAxD,EAAiElK,OAAjE,CAA1B,CAxBuC,CAyBvC;;AACA,UAAIgC,KAAKE,KAAL,IAAcF,KAAKE,KAAL,CAAW,CAAX,CAAd,IAA+BF,KAAKE,KAAL,CAAW,CAAX,EAAcM,MAAjD,EAAyD;AACvD,cAAM2H,gBAAiBR,QAAQA,KAAKS,OAAd,IAA0B,IAAhD;AACA,cAAMC,eAAgBV,QAAQA,KAAKW,OAAd,IAA0B,IAA/C;AACA,cAAMjJ,aAAaU,mBAAmBC,IAAnB,CAAnB;AACAR,uBAAeL,mBAAmBa,KAAKE,KAAL,CAAW,CAAX,EAAcM,MAAjC,EAAyCnB,UAAzC,EAAqD8I,aAArD,EAAoEE,YAApE,CAAf;AACD,OALD,MAKO;AACLlB,qBAAaa,OAAb,GAAuB,qEAAvB;AACA,eAAO,CAAC,CAACb,YAAD,CAAD,EAAiB,EAAjB,CAAP;AACD;;AAED,YAAMoB,QAAQlL,SAAS0F,OAAT,CAAiB;AAC7B+B,aAAK,KAAKK;AADmB,OAAjB,EAEX;AACDF,eAAO;AAAE4C,kBAAQ;AAAV;AADN,OAFW,CAAd,CApCuC,CAyCvC;;AACA,UAAI7H,KAAKkG,QAAL,IAAiBlG,KAAKkG,QAAL,CAAc,CAAd,CAAjB,IAAqClG,KAAKkG,QAAL,CAAc,CAAd,EAAiBgC,OAA1D,EAAmE;AACjE;AACA;AACA,YAAInK,QAAQ4J,KAAKE,MAAL,CAAY,CAAZ,EAAeK,OAAf,IAA0B,mBAAtC;;AACA,YAAIK,MAAMV,MAAN,CAAanI,MAAb,GAAsB,CAA1B,EAA6B;AAC3B,cAAI6I,MAAMV,MAAN,CAAa,CAAb,EAAgBK,OAApB,EAA6B;AAC3BnK,oBAAQwK,MAAMV,MAAN,CAAa,CAAb,EAAgBK,OAAxB;AACD;AACF;;AACDR,0BAAkB7J,oBAAoBmC,KAAKkG,QAAL,CAAc,CAAd,EAAiBgC,OAArC,EAA8CnK,KAA9C,EAAqDC,OAArD,CAAlB;AACD,OAVD,MAUO;AACLmJ,qBAAaa,OAAb,GAAuB,uEAAvB;AACA,eAAO,CAAC,CAACb,YAAD,CAAD,EAAiB,EAAjB,CAAP;AACD;;AAED,YAAMqB,kBAAkB9D,OAAO+D,IAAP,CAAY9H,UAAZ,CAAxB;AACA,UAAI+H,cAAJ;;AACA,UAAI;AACFA,yBAAiB9K,UAAUpB,OAAV,CAAkBmM,cAAlB,CAAiCtD,IAAjC,CAAsC;AACrD4C,2BADqD;AAErDP,yBAFqD;AAGrDlI,sBAHqD;AAIrDxB,iBAJqD;AAKrDwK,yBALqD;AAMrDxF;AANqD,SAAtC,CAAjB;AAQD,OATD,CASE,OAAO4F,KAAP,EAAc;AACd,cAAMC,YAAY;AAChBzB,yBAAe,OADC;AAEhBC,4BAAkB,QAFF;AAGhBW,mBAASY,MAAMZ;AAHC,SAAlB;;AAMA,YAAIV,OAAJ,EAAa;AACXH,uBAAaa,OAAb,GAAuB,uCAAvB;AACA,iBAAO,CAAC,CAACb,YAAD,CAAD,EAAiB,EAAjB,CAAP;AACD;;AAED,eAAO,CAAC,CAAC0B,SAAD,CAAD,EAAc,CAAC7B,iBAAD,CAAd,CAAP;AACD;;AAED,YAAMtG,cAAcgI,eAAeI,UAAnC;;AACA,UAAI,CAACpI,WAAD,IAAgBA,YAAYhB,MAAZ,KAAuB,CAA3C,EAA8C;AAC5C,cAAMqJ,oBAAoB;AACxB3B,yBAAe,OADS;AAExBC,4BAAkB,QAFM;AAGxBW,mBAAS;AAHe,SAA1B;;AAMA,YAAIV,OAAJ,EAAa;AACXH,uBAAaa,OAAb,GAAuB,wEAAvB;AACA,iBAAO,CAAC,CAACb,YAAD,CAAD,EAAiB,EAAjB,CAAP;AACD;;AAED,eAAO,CAAC,CAAC4B,iBAAD,CAAD,EAAsB,CAAC/B,iBAAD,CAAtB,CAAP;AACD;;AAED,YAAMgC,gBAAgBvI,YAAYC,WAAZ,EAAyBC,UAAzB,CAAtB;AACA,aAAO,CAACqI,aAAD,EAAgB,EAAhB,CAAP;AACD;;AAED7B,iBAAaa,OAAb,GAAuB,+DAAvB;AACA,WAAO,CAAC,CAACb,YAAD,CAAD,EAAiB,EAAjB,CAAP;AACD,GAtToB;;AAwTrB;;;;;;AAMA,yCAAuCvB,OAAvC,EAAgD;AAC9C7I,UAAM6I,OAAN,EAAehB,MAAf;AACA,UAAMoB,QAAQvI,OAAOsF,OAAP,CAAe6C,OAAf,CAAd,CAF8C,CAG9C;;AACA,QAAI3I,MAAMiI,YAAN,CAAmB,KAAKC,MAAxB,EAAgCxH,aAAhC,EAA+CqI,MAAMlE,MAArD,CAAJ,EAAkE;AAChE,YAAMmE,gBAAgBD,MAAME,QAAN,CAAe,CAAf,CAAtB,CADgE,CAEhE;;AACA,UAAID,iBAAiBA,cAAcgD,cAA/B,IAAiDhD,cAAcgD,cAAd,CAA6BxH,QAA9E,IAA0FwE,cAAcgD,cAAd,CAA6BxH,QAA7B,CAAsCC,MAApI,EAA4I;AAC1I,cAAMsB,SAASH,UAAUmD,MAAMlE,MAAhB,CAAf,CAD0I,CAE1I;AACA;;AACA,YAAI,CAACkB,MAAL,EAAa;AACX,gBAAM,IAAIlG,OAAOoM,KAAX,CAAiB,eAAjB,EAAkC,4BAAlC,CAAN;AACD;;AACD,cAAM;AAAExH;AAAF,YAAauE,cAAcgD,cAAd,CAA6BxH,QAAhD,CAP0I,CAQ1I;;AACA,cAAM4E,cAAczI,UAAUpB,OAAV,CAAkB2M,iBAAlB,CAAoC9D,IAApC,CAAyC;AAAE3D,gBAAF;AAAUsB;AAAV,SAAzC,CAApB;;AACA,YAAIqD,WAAJ,EAAiB;AACf,iBAAO5I,OAAO+H,MAAP,CAAc;AACnBV,iBAAKc;AADc,WAAd,EAEJ;AACDL,kBAAM;AACJ,6CAA+Bc,YAAY+C,SADvC;AAEJ,qCAAuB/C,YAAYgD,eAF/B;AAGJ,iDAAmChD,YAAY1E,SAH3C;AAIJ,sDAAwC,IAJpC;AAKJ,wDAA0C;AALtC;AADL,WAFI,CAAP;AAWD;AACF;AACF;;AACD,WAAO,KAAP;AACD;;AA/VoB,CAAhB;AAkWP7E,OAAON,OAAP,CAAeA,OAAf;AAEAW,MAAMmM,MAAN,CAAaC,GAAb,CAAiB,wBAAjB,EAA4C3D,OAAD,IAAa;AACtD9I,SAAOuI,IAAP,CAAY,sCAAZ,EAAoDO,OAApD;AACA,SAAOA,OAAP;AACD,CAHD","sourcesContent":["/* eslint camelcase: 0 */\nimport _ from \"lodash\";\nimport { Meteor } from \"meteor/meteor\";\nimport { check, Match } from \"meteor/check\";\nimport { Roles } from \"meteor/alanning:roles\";\nimport { Reaction, Hooks } from \"/server/api\";\nimport { Packages, Accounts, Shops, Shipping, Cart, Orders } from \"/lib/collections\";\nimport { ShippoPackageConfig } from \"../../lib/collections/schemas\";\nimport { shippingRoles } from \"../lib/roles\";\nimport { ShippoApi } from \"./shippoapi\";\n\n// Creates an address (for sender or recipient) suitable for Shippo Api Calls given\n// a reaction address an email and a purpose(\"QUOTE\"|\"PURCHASE\")\nfunction createShippoAddress(reactionAddress, email, purpose) {\n  const shippoAddress = {\n    object_purpose: purpose,\n    name: reactionAddress.fullName,\n    street1: reactionAddress.address1,\n    street2: reactionAddress.address2 || \"\", // \"\" in order to be cleaned later by SimpleSchema.clean\n    city: reactionAddress.city,\n    company: reactionAddress.company || \"\",\n    state: reactionAddress.region,\n    zip: reactionAddress.postal,\n    country: reactionAddress.country,\n    phone: reactionAddress.phone,\n    email,\n    is_residential: !reactionAddress.isCommercial\n  };\n\n  return shippoAddress;\n}\n\n// Creates a parcel object suitable for Shippo Api Calls given\n// a reaction product's parcel and units of measure for mass and distance\nfunction createShippoParcel(reactionParcel, cartWeight, reactionMassUnit, reactionDistanceUnit) {\n  const shippoParcel = {\n    width: reactionParcel.width || 1,\n    length: reactionParcel.length || 1,\n    height: reactionParcel.height || 1,\n    weight: cartWeight,\n    distance_unit: reactionDistanceUnit,\n    mass_unit: reactionMassUnit\n  };\n\n  return shippoParcel;\n}\n\nfunction getTotalCartweight(cart) {\n  const totalWeight = cart.items.reduce((sum, cartItem) => {\n    const itemWeight = cartItem.quantity * cartItem.parcel.weight;\n    return sum + itemWeight;\n  }, 0);\n  return totalWeight;\n}\n\n// converts the Rates List fetched from the Shippo Api to Reaction Shipping Rates form\nfunction ratesParser(shippoRates, shippoDocs) {\n  return shippoRates.map((rate) => {\n    const rateAmount = parseFloat(rate.amount);\n    const reactionRate = {\n      carrier: rate.provider,\n      method: {\n        carrier: rate.provider,\n        enabled: true,\n        handling: 0,\n        label: rate.servicelevel_name,\n        rate: rateAmount,\n        settings: {\n          // carrierAccount: rate.carrier_account,\n          rateId: rate.object_id,\n          serviceLevelToken: rate.servicelevel_token\n        }\n      },\n      rate: rateAmount,\n      shopId: shippoDocs[rate.carrier_account].shopId\n    };\n\n    return reactionRate;\n  });\n}\n\n// Filters the carrier list and gets and parses only the ones that are activated in the Shippo Account\nfunction filterActiveCarriers(carrierList) {\n  const activeCarriers = [];\n  if (carrierList.results && carrierList.count) {\n    carrierList.results.forEach((carrier) => {\n      if (carrier.active) {\n        activeCarriers.push({\n          carrier: carrier.carrier, // this is a property of the returned result with value the name of the carrier\n          carrierAccountId: carrier.object_id\n        });\n      }\n    });\n\n    return activeCarriers;\n  }\n}\n\n// usps_express to USPS EXPRESS .We need a better approach - use a suitable static map object\nfunction formatCarrierLabel(carrierName) {\n  return carrierName.replace(/_/g, \" \").toUpperCase();\n}\n\n// get Shippo's Api Key from the Shippo package with the supplied shopId or alternatively of the current shop's Id\nfunction getApiKey(shopId = Reaction.getShopId()) {\n  const { settings } = Packages.findOne({\n    name: \"reaction-shippo\",\n    shopId\n  });\n\n  return settings.apiKey;\n}\n\n// Adds Shippo carriers in Shipping Collection (one doc per carrier) for the current Shop\nfunction addShippoProviders(carriers, shopId = Reaction.getShopId()) {\n  let result = true;\n  carriers.forEach((carrier) => {\n    const carrierName = carrier.carrier;\n    const carrierLabel = formatCarrierLabel(carrierName);\n    const currentResult = Shipping.insert({\n      name: `${carrierLabel}`, // check it later for a better name\n      methods: [],\n      provider: {\n        name: carrierName,\n        label: carrierLabel,\n        enabled: true,\n        shippoProvider: {\n          carrierAccountId: carrier.carrierAccountId\n        }\n      },\n      shopId\n    });\n    result = result && currentResult;\n  });\n\n  return result;\n}\n\n// Remove from Shipping Collection shop's Shippo Providers with carrier account Id in carriersIds\n// or all of them (if carriersIds is set to false)\nfunction removeShippoProviders(carriersIds, shopId = Reaction.getShopId()) {\n  if (carriersIds) {\n    return Shipping.remove({\n      shopId,\n      \"provider.shippoProvider.carrierAccountId\": { $in: carriersIds }\n    });\n  }\n\n  return Shipping.remove({\n    shopId,\n    \"provider.shippoProvider\": { $exists: true }\n  });\n}\n\n// After getting the current active Carriers of the Shippo Account removes\n// from the Shipping Collection the Shippo providers that are deactivated(don't exist in active carriers)\n// and inserts the newly active carriers in Shipping Collection as shippo providers.\n\nfunction updateShippoProviders(activeCarriers, shopId = Reaction.getShopId()) {\n  const currentShippoProviders = Shipping.find({\n    shopId,\n    \"provider.shippoProvider\": { $exists: true }\n  }, {\n    fields: { \"provider.shippoProvider.carrierAccountId\": 1 }\n  });\n\n  // Ids of Shippo Carriers that exist currently as docs in Shipping Collection\n  const currentCarriersIds = currentShippoProviders.map((doc) => doc.provider.shippoProvider.carrierAccountId);\n\n  const newActiveCarriers = [];\n  const unchangedActiveCarriersIds = [];\n  activeCarriers.forEach((carrier) => {\n    const carrierId = carrier.carrierAccountId;\n    if (!currentCarriersIds.includes(carrierId)) {\n      newActiveCarriers.push(carrier);\n    } else {\n      unchangedActiveCarriersIds.push(carrierId);\n    }\n  });\n\n  const deactivatedCarriersIds = _.difference(currentCarriersIds, unchangedActiveCarriersIds);\n  if (deactivatedCarriersIds.length) {\n    removeShippoProviders(deactivatedCarriersIds, shopId);\n  }\n  if (newActiveCarriers.length) {\n    addShippoProviders(newActiveCarriers, shopId);\n  }\n\n  return true;\n}\n\nexport const methods = {\n  /**\n   * Updates the Api key(Live/Test Token) used for connection with the Shippo account.\n   * Also inserts(and deletes if already exist) docs in the Shipping collection each of the\n   * activated Carriers of the Shippo account.\n   * This method is intended to be used mainly by Autoform.\n   * @param  {Object} details An object with _id and modifier props\n   * @param  {String} [docId] DEPRECATED. The _id, if details is the modifier.\n   * @return {Object|Boolean} result - The object returned.\n   * @return {String} {string(\"update\"|\"delete\")} result.type - The type of updating happened.\n   */\n  \"shippo/updateApiKey\"(details, docId) {\n    check(details, Object);\n\n    // Backward compatibility\n    check(docId, Match.Optional(String));\n    const id = docId || details._id;\n    const modifier = docId ? details : details.modifier;\n\n    // Important server-side checks for security and data integrity\n    check(id, String);\n    ShippoPackageConfig.validate(modifier, { modifier: true });\n\n    // Make sure user has proper rights to this package\n    const { shopId } = Packages.findOne({ _id: id }, { field: { shopId: 1 } });\n    if (shopId && Roles.userIsInRole(this.userId, shippingRoles, shopId)) {\n      // If user wants to delete existing key\n      if ({}.hasOwnProperty.call(modifier, \"$unset\")) {\n        const customModifier = { $set: { \"settings.apiKey\": null } };\n        Packages.update(id, customModifier);\n        // remove shop's existing Shippo Providers from Shipping Collection\n        removeShippoProviders(false, shopId);\n\n        return { type: \"delete\" };\n      }\n\n      const apiKey = modifier.$set[\"settings.apiKey\"];\n\n      // Tries to use the apiKey by fetching a list of the addresses of Shippo Account\n      // if not possible throws a relative Meteor Error (eg invalid_credentials)\n      ShippoApi.methods.getAddressList.call({ apiKey });\n      // if everything is ok proceed with the api key update\n      Packages.update(id, modifier);\n      // remove shop's existing Shippo Providers from Shipping Collection\n      removeShippoProviders(false, shopId);\n\n      const activeCarriers = filterActiveCarriers(ShippoApi.methods.getCarrierAccountsList.call({ apiKey }));\n      if (activeCarriers.length) {\n        addShippoProviders(activeCarriers, shopId);\n      }\n\n      return { type: \"update\" };\n    }\n\n    return false;\n  },\n\n  /**\n   * Fetches the current active Shippo Carriers from the Shippo Account and updates the\n   * Shipping Collection by keeping only these as Shippo Providers of the shop.\n   * @return {Boolean} result - if the updating happened successfully or not.\n   * */\n\n  \"shippo/fetchProviders\"() {\n    const shopId = Reaction.getShopId();\n\n    if (Roles.userIsInRole(this.userId, shippingRoles, shopId)) {\n      const apiKey = getApiKey(shopId);\n      if (!apiKey) {\n        return false;\n      }\n\n      const activeCarriers = filterActiveCarriers(ShippoApi.methods.getCarrierAccountsList.call({ apiKey }));\n      return updateShippoProviders(activeCarriers, shopId);\n    }\n\n    return false;\n  },\n\n  /**\n   * Fetches the tracking status of shipped orders from Shippo and updates the\n   * relevant orders' properties\n   * @param {String} orderId - optional orderId to get status of just one order.\n   * @return {Boolean} result - if the updating happened successfully or not.\n   * */\n  \"shippo/fetchTrackingStatusForOrders\"(orderId) {\n    check(orderId, Match.Optional(String));\n    const shopId = Reaction.getShopId();\n    let shippoOrders;\n    const apiKey = getApiKey(shopId);\n    if (!apiKey) {\n      return false;\n    }\n\n    if (orderId) {\n      // return a specific order\n      shippoOrders = Orders.find({\n        shopId,\n        orderId\n      });\n    } else {\n      // Find the orders of the shop that have shippo provider, tracking number, that are shipped\n      // but they are not yet delivered;\n      shippoOrders = Orders.find({\n        shopId,\n        \"shipping.0.shippo.transactionId\": { $exists: true },\n        \"shipping.0.tracking\": { $exists: true },\n        \"shipping.0.shipped\": true,\n        \"shipping.0.delivered\": { $ne: true }\n        // For now we don' t have logic for returned products\n      });\n    }\n\n\n    // no orders to update\n    if (!shippoOrders.count()) {\n      return true;\n    }\n\n    // For each order get from Shippo the transaction item ,check the tracking and if it has been updated\n    let updatingResult = true;\n    shippoOrders.forEach((order) => {\n      const orderShipment = order.shipping[0];\n      const { transactionId } = orderShipment.shippo;\n      const transaction = ShippoApi.methods.getTransaction.call({ apiKey, transactionId });\n\n      // For Testing:\n      // Comment First line of code, and uncomment following block to mock the updating of tracking status\n      // as Shippo's tracking status for test Shipments isn't getting updated.\n      const trackingStatus = transaction.tracking_status;\n      // const trackingStatus = {};\n      // if (transaction.object_state === \"VALID\") {\n      //   trackingStatus.status_date = (new Date).toString();\n      //   trackingStatus.status = (!orderShipment.shippo.trackingStatusStatus ? \"TRANSIT\" : \"DELIVERED\");\n      // }\n\n      if (trackingStatus &&\n        trackingStatus.status_date !== orderShipment.shippo.trackingStatusDate) {\n        //  Shippo's tracking_status.status enum Indicates the high level status of the shipment:\n        // 'UNKNOWN', 'DELIVERED', 'TRANSIT', 'FAILURE', 'RETURNED'.\n        if (trackingStatus.status === \"DELIVERED\") {\n          Meteor.call(\"orders/shipmentDelivered\", order);\n        }\n\n        // A batch update might be better option. Unfortunately Reaction.importer doesn't support\n        // .. Orders currently\n        const orderUpdating = Orders.update({\n          _id: order._id\n        }, {\n          $set: {\n            \"shipping.0.shippo.trackingStatusDate\": trackingStatus.status_date,\n            \"shipping.0.shippo.trackingStatusStatus\": trackingStatus.status\n          }\n        });\n        updatingResult = updatingResult && orderUpdating;\n      }\n    });\n\n    return updatingResult;\n  },\n\n  /**\n   * Returns the available Shippo Methods/Rates for a selected cart,\n   * in the same form shipping/getShippingRates returns them.\n   * @param {String} cartId - The id of the cart that rates are to be supplied.\n   * @param {Object} shippoDocs - Contains all the enabled shipping objects with\n   * provider.shippoProvider property. Each property has as key the Shippo's\n   * carrierAccountId and as value the corresponding document of shipping\n   * collection.\n   * @param {Array} retrialTargets - An array with the details of which\n   * methods for getting shipping methods failed in the most recent\n   * query of Shippo's API.\n   * @return {Array} errorDetailsAndRetryInfo - Details of any error that\n   * occurred while querying Shippo's API, and info about this package so\n   * as to know if this specific query is to be retried.\n   * @return {Array} rates - The rates of the enabled and available\n   * Shippo carriers, and an empty array.\n   */\n  \"shippo/getShippingRatesForCart\"(cartId, shippoDocs, retrialTargets) {\n    check(cartId, String);\n    check(shippoDocs, Object);\n    check(retrialTargets, Array);\n\n    const currentMethodInfo = {\n      packageName: \"shippo\",\n      fileName: \"shippo.js\"\n    };\n    const errorDetails = {\n      requestStatus: \"error\",\n      shippingProvider: \"shippo\"\n    };\n\n    let isRetry;\n    if (retrialTargets.length > 0) {\n      const isNotAmongFailedRequests = retrialTargets.every((target) =>\n        target.packageName !== currentMethodInfo.packageName &&\n        target.fileName !== currentMethodInfo.fileName);\n      if (isNotAmongFailedRequests) {\n        return [[], retrialTargets];\n      }\n\n      isRetry = true;\n    }\n\n    const cart = Cart.findOne(cartId);\n    if (cart && cart.userId === this.userId) { // confirm user has the right\n      let shippoAddressTo;\n      let shippoParcel;\n      const purpose = \"PURCHASE\";\n\n      const shop = Shops.findOne({\n        _id: cart.shopId\n      }, {\n        field: {\n          addressBook: 1,\n          emails: 1,\n          unitsOfMeasure: { $elemMatch: { default: true } }\n        }\n      });\n\n      const apiKey = getApiKey(cart.shopId);\n      // If for a weird reason Shop hasn't a Shippo Api key anymore return no-rates.\n      if (!apiKey) {\n        // In this case, and some similar ones below, there's no need\n        // for a retry.\n        errorDetails.message = \"No Shippo API key was found in this cart.\";\n        return [[errorDetails], []];\n      }\n      // TODO create a shipping address book record for shop.\n      const shippoAddressFrom = createShippoAddress(shop.addressBook[0], shop.emails[0].address, purpose);\n      // product in the cart has to have parcel property with the dimensions\n      if (cart.items && cart.items[0] && cart.items[0].parcel) {\n        const unitOfMeasure = (shop && shop.baseUOM) || \"kg\";\n        const unitOfLength = (shop && shop.baseUOL) || \"cm\";\n        const cartWeight = getTotalCartweight(cart);\n        shippoParcel = createShippoParcel(cart.items[0].parcel, cartWeight, unitOfMeasure, unitOfLength);\n      } else {\n        errorDetails.message = \"This cart has no items, or the first item has no 'parcel' property.\";\n        return [[errorDetails], []];\n      }\n\n      const buyer = Accounts.findOne({\n        _id: this.userId\n      }, {\n        field: { emails: 1 }\n      });\n      // check that there is address available in cart\n      if (cart.shipping && cart.shipping[0] && cart.shipping[0].address) {\n        // TODO take a more elegant approach to guest checkout -> no email address\n        // add Logger.trace if this smells\n        let email = shop.emails[0].address || \"noreply@localhost\";\n        if (buyer.emails.length > 0) {\n          if (buyer.emails[0].address) {\n            email = buyer.emails[0].address;\n          }\n        }\n        shippoAddressTo = createShippoAddress(cart.shipping[0].address, email, purpose);\n      } else {\n        errorDetails.message = \"The 'shipping' property of this cart is either missing or incomplete.\";\n        return [[errorDetails], []];\n      }\n\n      const carrierAccounts = Object.keys(shippoDocs);\n      let shippoShipment;\n      try {\n        shippoShipment = ShippoApi.methods.createShipment.call({\n          shippoAddressFrom,\n          shippoAddressTo,\n          shippoParcel,\n          purpose,\n          carrierAccounts,\n          apiKey\n        });\n      } catch (error) {\n        const errorData = {\n          requestStatus: \"error\",\n          shippingProvider: \"shippo\",\n          message: error.message\n        };\n\n        if (isRetry) {\n          errorDetails.message = \"The Shippo API call has failed again.\";\n          return [[errorDetails], []];\n        }\n\n        return [[errorData], [currentMethodInfo]];\n      }\n\n      const shippoRates = shippoShipment.rates_list;\n      if (!shippoRates || shippoRates.length === 0) {\n        const noShippingMethods = {\n          requestStatus: \"error\",\n          shippingProvider: \"shippo\",\n          message: \"Couldn't find any shipping methods. Try using another address.\"\n        };\n\n        if (isRetry) {\n          errorDetails.message = \"Didn't get any shipping methods. The Shippo API call has failed again.\";\n          return [[errorDetails], []];\n        }\n\n        return [[noShippingMethods], [currentMethodInfo]];\n      }\n\n      const reactionRates = ratesParser(shippoRates, shippoDocs);\n      return [reactionRates, []];\n    }\n\n    errorDetails.message = \"Error. Your cart is either undefined or has the wrong userId.\";\n    return [[errorDetails], []];\n  },\n\n  /**\n   * Confirms Shippo order based on buyer's choice at the time of purchase\n   * and supplies the order doc with the tracking and label infos\n   * @param {String} orderId - The id of the ordered that labels are purchased for\n   * @return {Boolean} result - True if procedure completed succesfully,otherwise false\n   */\n  \"shippo/confirmShippingMethodForOrder\"(orderId) {\n    check(orderId, String);\n    const order = Orders.findOne(orderId);\n    // Make sure user has permissions in the shop's order\n    if (Roles.userIsInRole(this.userId, shippingRoles, order.shopId)) {\n      const orderShipment = order.shipping[0];\n      // Here we done it for the first/unique Shipment only . in the near future it will be done for multiple ones\n      if (orderShipment && orderShipment.shipmentMethod && orderShipment.shipmentMethod.settings && orderShipment.shipmentMethod.settings.rateId) {\n        const apiKey = getApiKey(order.shopId);\n        // If for a weird reason Shop hasn't a Shippo Api key anymore you have to throw an error\n        // cause the Shippo label purchasing is not gonna happen.\n        if (!apiKey) {\n          throw new Meteor.Error(\"access-denied\", \"Invalid Shippo Credentials\");\n        }\n        const { rateId } = orderShipment.shipmentMethod.settings;\n        // make the actual purchase\n        const transaction = ShippoApi.methods.createTransaction.call({ rateId, apiKey });\n        if (transaction) {\n          return Orders.update({\n            _id: orderId\n          }, {\n            $set: {\n              \"shipping.0.shippingLabelUrl\": transaction.label_url,\n              \"shipping.0.tracking\": transaction.tracking_number,\n              \"shipping.0.shippo.transactionId\": transaction.object_id,\n              \"shipping.0.shippo.trackingStatusDate\": null,\n              \"shipping.0.shippo.trackingStatusStatus\": null\n            }\n          });\n        }\n      }\n    }\n    return false;\n  }\n};\n\nMeteor.methods(methods);\n\nHooks.Events.add(\"onOrderPaymentCaptured\", (orderId) => {\n  Meteor.call(\"shippo/confirmShippingMethodForOrder\", orderId);\n  return orderId;\n});\n"]},"sourceType":"script","hash":"572cc3a68b6e0a87b2b4ae529509b1b82048d5ca"}
