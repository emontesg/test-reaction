{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$1$2","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"ast":true,"babelrc":false,"sourceFileName":"server/methods/core/groups.js","filename":"server/methods/core/groups.js","sourceMaps":true,"envName":"development","cwd":"/Users/estebandev/test-knowledge","passPerPreset":false,"presets":[],"parserOpts":{"sourceType":"module","sourceFileName":"server/methods/core/groups.js","plugins":["jsx","jsx","flow","flow","objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties"]},"generatorOpts":{"filename":"server/methods/core/groups.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"server/methods/core/groups.js"}},"code":"let _uniq;\n\nmodule.watch(require(\"lodash/uniq\"), {\n  default(v) {\n    _uniq = v;\n  }\n\n}, 0);\nlet Meteor;\nmodule.watch(require(\"meteor/meteor\"), {\n  Meteor(v) {\n    Meteor = v;\n  }\n\n}, 1);\nlet check, Match;\nmodule.watch(require(\"meteor/check\"), {\n  check(v) {\n    check = v;\n  },\n\n  Match(v) {\n    Match = v;\n  }\n\n}, 2);\nlet Roles;\nmodule.watch(require(\"meteor/alanning:roles\"), {\n  Roles(v) {\n    Roles = v;\n  }\n\n}, 3);\nlet Reaction, Logger, Hooks;\nmodule.watch(require(\"../../api\"), {\n  Reaction(v) {\n    Reaction = v;\n  },\n\n  Logger(v) {\n    Logger = v;\n  },\n\n  Hooks(v) {\n    Hooks = v;\n  }\n\n}, 4);\nlet Accounts, Groups;\nmodule.watch(require(\"../../../lib/collections\"), {\n  Accounts(v) {\n    Accounts = v;\n  },\n\n  Groups(v) {\n    Groups = v;\n  }\n\n}, 5);\nlet getSlug;\nmodule.watch(require(\"../../../lib/api\"), {\n  getSlug(v) {\n    getSlug = v;\n  }\n\n}, 6);\n\n/**\n * @file Methods for creating and managing admin user permission groups.\n * Run these methods using `Meteor.call()`.\n * @example Meteor.call(\"group/createGroup\", sampleCustomerGroup, shop._id)\n * @namespace Methods/Group\n*/\nMeteor.methods({\n  /**\n   * @name group/createGroup\n   * @method\n   * @memberof Methods/Group\n   * @summary Creates a new permission group for a shop\n   * It creates permission group for a given shop with passed in roles\n   * @param {Object} groupData - info about group to create\n   * @param {String} groupData.name - name of the group to be created\n   * @param {String} groupData.description - Optional description of the group to be created\n   * @param {Array} groupData.permissions - permissions to assign to the group being created\n   * @param {String} shopId - id of the shop the group belongs to\n   * @return {Object} - `object.status` of 200 on success or Error object on failure\n   */\n  \"group/createGroup\"(groupData, shopId) {\n    check(groupData, Object);\n    check(groupData.name, String);\n    check(groupData.description, Match.Optional(String));\n    check(groupData.permissions, Match.Optional([String]));\n    check(shopId, String);\n\n    let _id; // we are limiting group method actions to only users with admin roles\n    // this also include shop owners, since they have the `admin` role in their Roles.GLOBAL_GROUP\n\n\n    if (!Reaction.hasPermission(\"admin\", Meteor.userId(), shopId)) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    const defaultCustomerGroupForShop = Groups.findOne({\n      slug: \"customer\",\n      shopId\n    }) || {};\n    const defaultAdminPermissions = (defaultCustomerGroupForShop.permissions || []).concat(\"dashboard\");\n    const newGroupData = Object.assign({}, groupData, {\n      slug: getSlug(groupData.name),\n      shopId\n    });\n\n    if (!newGroupData.permissions) {\n      newGroupData.permissions = [];\n    }\n\n    newGroupData.permissions = _uniq([...newGroupData.permissions, ...defaultAdminPermissions]); // ensure one group type per shop\n\n    const groupExists = Groups.findOne({\n      slug: newGroupData.slug,\n      shopId\n    });\n\n    if (groupExists) {\n      throw new Meteor.Error(\"conflict\", \"Group already exist for this shop\");\n    }\n\n    try {\n      _id = Groups.insert(newGroupData);\n    } catch (error) {\n      Logger.error(error);\n      throw new Meteor.Error(\"invalid-parameter\", \"Bad request\");\n    }\n\n    return {\n      status: 200,\n      group: Groups.findOne({\n        _id\n      })\n    };\n  },\n\n  /**\n   * @name group/updateGroup\n   * @method\n   * @memberof Methods/Group\n   * @summary Updates a permission group for a shop.\n   * Change the details of a group (name, desc, permissions etc) to the values passed in.\n   * It also goes into affected user data to modify both the groupName (using Accounts schema)\n   * and group permissions (using \"accounts/removeUserPermissions\")\n   * @param {Object} groupId - group to be updated\n   * @param {Object} newGroupData - updated group info (similar to current group data)\n   * slug remains untouched; used as key in querying\n   * @param {String} shopId - id of the shop the group belongs to\n   * @return {Object} - `object.status` of 200 on success or Error object on failure\n   */\n  \"group/updateGroup\"(groupId, newGroupData, shopId) {\n    check(groupId, String);\n    check(newGroupData, Object);\n    check(shopId, String); // we are limiting group method actions to only users with admin roles\n    // this also include shop owners, since they have the `admin` role in their Roles.GLOBAL_GROUP\n\n    if (!Reaction.hasPermission(\"admin\", Meteor.userId(), shopId)) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    } // 1. Update the group data\n\n\n    const update = newGroupData;\n    delete update.slug; // slug remains constant because it's used as key in querying. So we remove it if it was passed\n\n    const group = Groups.findOne({\n      _id: groupId\n    }) || {}; // prevent edits on owner. Owner groups is the default containing all roles, and as such should be untouched\n\n    if (group.slug === \"owner\") {\n      throw new Meteor.Error(\"invalid-parameter\", \"Bad request\");\n    }\n\n    Groups.update({\n      _id: groupId,\n      shopId\n    }, {\n      $set: update\n    }); // 2. Check & Modify users in the group that changed\n\n    const users = Accounts.find({\n      groups: {\n        $in: [groupId]\n      }\n    }).fetch();\n    let error;\n\n    if (newGroupData.permissions && newGroupData.permissions.length) {\n      error = setUserPermissions(users, newGroupData.permissions, shopId);\n    } // 3. Return response\n\n\n    if (!error) {\n      return {\n        status: 200,\n        group: Groups.findOne({\n          _id: groupId\n        })\n      };\n    }\n\n    Logger.error(error);\n    throw new Meteor.Error(\"server-error\", \"Update not successful\");\n  },\n\n  /**\n   * @name group/addUser\n   * @method\n   * @memberof Methods/Group\n   * @summary Adds a user to a permission group\n   * Updates the user's list of permissions/roles with the defined the list defined for the group\n   * (NB: At this time, a user only belongs to only one group per shop)\n   * @param {String} userId - The account ID to add to the group\n   * @param {String} groupId - ID of the group\n   * @return {Object} - The modified group object\n   */\n  \"group/addUser\"(userId, groupId) {\n    check(userId, String);\n    check(groupId, String);\n    const group = Groups.findOne({\n      _id: groupId\n    }) || {};\n    const {\n      permissions,\n      shopId,\n      slug\n    } = group;\n    const loggedInUserId = Meteor.userId();\n    const canInvite = Reaction.canInviteToGroup({\n      group\n    }); // we are limiting group method actions to only users with admin roles\n    // this also include shop owners, since they have the `admin` role in their Roles.GLOBAL_GROUP\n\n    if (!Reaction.hasPermission(\"admin\", loggedInUserId, shopId)) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    } // Users with `owner` and/or `admin` roles can invite to any group\n    // Also a user with `admin` can invite to only groups they have permissions that are a superset of\n    // See details of canInvite method in core (i.e Reaction.canInviteToGroup)\n\n\n    if (!canInvite) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    if (slug === \"owner\") {\n      // if adding a user to the owner group, check that the request is done by current owner\n      if (!Reaction.hasPermission(\"owner\", Meteor.userId(), shopId)) {\n        throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n      }\n    } // make sure user only belongs to one group per shop\n\n\n    const allGroupsInShop = Groups.find({\n      shopId\n    }).fetch().map(grp => grp._id);\n    const user = Accounts.findOne({\n      _id: userId\n    }) || {};\n    const currentUserGroups = user.groups || [];\n    let newGroups = [];\n    let currentUserGrpInShop;\n    currentUserGroups.forEach(grp => {\n      if (allGroupsInShop.indexOf(grp) < 0) {\n        newGroups.push(grp);\n      } else {\n        currentUserGrpInShop = grp;\n      }\n    });\n    newGroups = newGroups.concat(groupId);\n\n    try {\n      setUserPermissions({\n        _id: userId\n      }, permissions, shopId);\n      Accounts.update({\n        _id: userId\n      }, {\n        $set: {\n          groups: newGroups\n        }\n      });\n      Hooks.Events.run(\"afterAccountsUpdate\", loggedInUserId, {\n        accountId: userId,\n        updatedFields: [\"groups\"]\n      });\n\n      if (slug === \"owner\") {\n        if (shopId === Reaction.getPrimaryShopId()) {\n          changeMarketplaceOwner({\n            userId,\n            permissions\n          });\n        } // remove current shop owner after setting another admin as the new owner\n\n\n        Meteor.call(\"group/addUser\", Meteor.userId(), currentUserGrpInShop);\n      } // Return the group the account as added to\n\n\n      return Groups.findOne({\n        _id: groupId\n      });\n    } catch (error) {\n      Logger.error(error);\n      throw new Meteor.Error(\"server-error\", \"Could not add user\");\n    }\n  },\n\n  /**\n   * @name group/removeUser\n   * @method\n   * @memberof Methods/Group\n   * @summary Removes a user from a group for a shop, and adds them to the default customer group.\n   * Updates the user's permission list to reflect.\n   * (NB: At this time, a user only belongs to only one group per shop)\n   * @param {String} userId - The account ID to remove from the group\n   * @param {String} groupId - ID of the group\n   * @return {Object} - The modified group object\n   */\n  \"group/removeUser\"(userId, groupId) {\n    check(userId, String);\n    check(groupId, String);\n    const user = Accounts.findOne({\n      _id: userId\n    });\n    const {\n      shopId\n    } = Groups.findOne({\n      _id: groupId\n    }) || {};\n    const defaultCustomerGroupForShop = Groups.findOne({\n      slug: \"customer\",\n      shopId\n    }) || {}; // we are limiting group method actions to only users with admin roles\n    // this also include shop owners, since they have the `admin` role in their Roles.GLOBAL_GROUP\n\n    if (!Reaction.hasPermission(\"admin\", Meteor.userId(), shopId)) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    if (!user) {\n      throw new Meteor.Error(\"invalid-parameter\", \"Could not find user\");\n    }\n\n    try {\n      setUserPermissions(user, defaultCustomerGroupForShop.permissions, shopId);\n      Accounts.update({\n        _id: userId,\n        groups: groupId\n      }, {\n        $set: {\n          \"groups.$\": defaultCustomerGroupForShop._id\n        }\n      }); // replace the old id with new id\n\n      Hooks.Events.run(\"afterAccountsUpdate\", Meteor.userId(), {\n        accountId: userId,\n        updatedFields: [\"groups\"]\n      });\n      return defaultCustomerGroupForShop;\n    } catch (error) {\n      Logger.error(error);\n      throw new Meteor.Error(\"server-error\", \"Could not add user\");\n    }\n  }\n\n});\n/**\n * changeMarketplaceOwner\n * @private\n * @summary Checks if the user making the request is allowed to make invitation to that group\n * @param {Object} options -\n * @param {String} options.userId - userID\n * @param {String} options.permissions - permissions\n * @return {null} -\n */\n\nfunction changeMarketplaceOwner({\n  userId,\n  permissions\n}) {\n  // give global marketplace role to new owner\n  Roles.setUserRoles(userId, permissions, Roles.GLOBAL_GROUP); // remove global from previous owner\n\n  Meteor.users.update({\n    _id: Meteor.userId()\n  }, {\n    $unset: {\n      [`roles.${Roles.GLOBAL_GROUP}`]: \"\"\n    }\n  });\n}\n/**\n * setUserPermissions\n * @private\n * @summary Set user permissions\n * @param {Object} users -\n * @param {String} permissions -\n * @param {String} shopId -\n * @return {null} -\n */\n\n\nfunction setUserPermissions(users, permissions, shopId) {\n  let affectedUsers = users;\n\n  if (!Array.isArray(users)) {\n    affectedUsers = [users];\n  }\n\n  return affectedUsers.forEach(user => Roles.setUserRoles(user._id, permissions, shopId));\n} // set default admin user's account as \"owner\"\n\n\nHooks.Events.add(\"afterCreateDefaultAdminUser\", user => {\n  const group = Groups.findOne({\n    slug: \"owner\",\n    shopId: Reaction.getShopId()\n  });\n  Accounts.update({\n    _id: user._id\n  }, {\n    $set: {\n      groups: [group._id]\n    }\n  });\n  Hooks.Events.run(\"afterAccountsUpdate\", null, {\n    accountId: user._id,\n    updatedFields: [\"groups\"]\n  });\n});","map":{"version":3,"sources":["server/methods/core/groups.js"],"names":["_uniq","module","watch","require","default","v","Meteor","check","Match","Roles","Reaction","Logger","Hooks","Accounts","Groups","getSlug","methods","groupData","shopId","Object","name","String","description","Optional","permissions","_id","hasPermission","userId","Error","defaultCustomerGroupForShop","findOne","slug","defaultAdminPermissions","concat","newGroupData","assign","groupExists","insert","error","status","group","groupId","update","$set","users","find","groups","$in","fetch","length","setUserPermissions","loggedInUserId","canInvite","canInviteToGroup","allGroupsInShop","map","grp","user","currentUserGroups","newGroups","currentUserGrpInShop","forEach","indexOf","push","Events","run","accountId","updatedFields","getPrimaryShopId","changeMarketplaceOwner","call","setUserRoles","GLOBAL_GROUP","$unset","affectedUsers","Array","isArray","add","getShopId"],"mappings":"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","sourcesContent":["import { Meteor } from \"meteor/meteor\";\nimport { check, Match } from \"meteor/check\";\nimport _ from \"lodash\";\nimport { Roles } from \"meteor/alanning:roles\";\nimport { Reaction, Logger, Hooks } from \"/server/api\";\nimport { Accounts, Groups } from \"/lib/collections\";\nimport { getSlug } from \"/lib/api\";\n\n/**\n * @file Methods for creating and managing admin user permission groups.\n * Run these methods using `Meteor.call()`.\n * @example Meteor.call(\"group/createGroup\", sampleCustomerGroup, shop._id)\n * @namespace Methods/Group\n*/\nMeteor.methods({\n  /**\n   * @name group/createGroup\n   * @method\n   * @memberof Methods/Group\n   * @summary Creates a new permission group for a shop\n   * It creates permission group for a given shop with passed in roles\n   * @param {Object} groupData - info about group to create\n   * @param {String} groupData.name - name of the group to be created\n   * @param {String} groupData.description - Optional description of the group to be created\n   * @param {Array} groupData.permissions - permissions to assign to the group being created\n   * @param {String} shopId - id of the shop the group belongs to\n   * @return {Object} - `object.status` of 200 on success or Error object on failure\n   */\n  \"group/createGroup\"(groupData, shopId) {\n    check(groupData, Object);\n    check(groupData.name, String);\n    check(groupData.description, Match.Optional(String));\n    check(groupData.permissions, Match.Optional([String]));\n    check(shopId, String);\n    let _id;\n\n    // we are limiting group method actions to only users with admin roles\n    // this also include shop owners, since they have the `admin` role in their Roles.GLOBAL_GROUP\n    if (!Reaction.hasPermission(\"admin\", Meteor.userId(), shopId)) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    const defaultCustomerGroupForShop = Groups.findOne({ slug: \"customer\", shopId }) || {};\n    const defaultAdminPermissions = (defaultCustomerGroupForShop.permissions || []).concat(\"dashboard\");\n    const newGroupData = Object.assign({}, groupData, {\n      slug: getSlug(groupData.name), shopId\n    });\n\n    if (!newGroupData.permissions) {\n      newGroupData.permissions = [];\n    }\n\n    newGroupData.permissions = _.uniq([...newGroupData.permissions, ...defaultAdminPermissions]);\n\n    // ensure one group type per shop\n    const groupExists = Groups.findOne({ slug: newGroupData.slug, shopId });\n    if (groupExists) {\n      throw new Meteor.Error(\"conflict\", \"Group already exist for this shop\");\n    }\n    try {\n      _id = Groups.insert(newGroupData);\n    } catch (error) {\n      Logger.error(error);\n      throw new Meteor.Error(\"invalid-parameter\", \"Bad request\");\n    }\n\n    return { status: 200, group: Groups.findOne({ _id }) };\n  },\n\n  /**\n   * @name group/updateGroup\n   * @method\n   * @memberof Methods/Group\n   * @summary Updates a permission group for a shop.\n   * Change the details of a group (name, desc, permissions etc) to the values passed in.\n   * It also goes into affected user data to modify both the groupName (using Accounts schema)\n   * and group permissions (using \"accounts/removeUserPermissions\")\n   * @param {Object} groupId - group to be updated\n   * @param {Object} newGroupData - updated group info (similar to current group data)\n   * slug remains untouched; used as key in querying\n   * @param {String} shopId - id of the shop the group belongs to\n   * @return {Object} - `object.status` of 200 on success or Error object on failure\n   */\n  \"group/updateGroup\"(groupId, newGroupData, shopId) {\n    check(groupId, String);\n    check(newGroupData, Object);\n    check(shopId, String);\n\n    // we are limiting group method actions to only users with admin roles\n    // this also include shop owners, since they have the `admin` role in their Roles.GLOBAL_GROUP\n    if (!Reaction.hasPermission(\"admin\", Meteor.userId(), shopId)) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    // 1. Update the group data\n    const update = newGroupData;\n    delete update.slug; // slug remains constant because it's used as key in querying. So we remove it if it was passed\n\n    const group = Groups.findOne({ _id: groupId }) || {};\n\n    // prevent edits on owner. Owner groups is the default containing all roles, and as such should be untouched\n    if (group.slug === \"owner\") {\n      throw new Meteor.Error(\"invalid-parameter\", \"Bad request\");\n    }\n\n    Groups.update({ _id: groupId, shopId }, { $set: update });\n\n    // 2. Check & Modify users in the group that changed\n    const users = Accounts.find({ groups: { $in: [groupId] } }).fetch();\n    let error;\n\n    if (newGroupData.permissions && newGroupData.permissions.length) {\n      error = setUserPermissions(users, newGroupData.permissions, shopId);\n    }\n\n    // 3. Return response\n    if (!error) {\n      return { status: 200, group: Groups.findOne({ _id: groupId }) };\n    }\n    Logger.error(error);\n    throw new Meteor.Error(\"server-error\", \"Update not successful\");\n  },\n\n  /**\n   * @name group/addUser\n   * @method\n   * @memberof Methods/Group\n   * @summary Adds a user to a permission group\n   * Updates the user's list of permissions/roles with the defined the list defined for the group\n   * (NB: At this time, a user only belongs to only one group per shop)\n   * @param {String} userId - The account ID to add to the group\n   * @param {String} groupId - ID of the group\n   * @return {Object} - The modified group object\n   */\n  \"group/addUser\"(userId, groupId) {\n    check(userId, String);\n    check(groupId, String);\n    const group = Groups.findOne({ _id: groupId }) || {};\n    const { permissions, shopId, slug } = group;\n    const loggedInUserId = Meteor.userId();\n    const canInvite = Reaction.canInviteToGroup({ group });\n\n    // we are limiting group method actions to only users with admin roles\n    // this also include shop owners, since they have the `admin` role in their Roles.GLOBAL_GROUP\n    if (!Reaction.hasPermission(\"admin\", loggedInUserId, shopId)) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    // Users with `owner` and/or `admin` roles can invite to any group\n    // Also a user with `admin` can invite to only groups they have permissions that are a superset of\n    // See details of canInvite method in core (i.e Reaction.canInviteToGroup)\n    if (!canInvite) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    if (slug === \"owner\") {\n      // if adding a user to the owner group, check that the request is done by current owner\n      if (!Reaction.hasPermission(\"owner\", Meteor.userId(), shopId)) {\n        throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n      }\n    }\n\n    // make sure user only belongs to one group per shop\n    const allGroupsInShop = Groups.find({ shopId }).fetch().map((grp) => grp._id);\n    const user = Accounts.findOne({ _id: userId }) || {};\n    const currentUserGroups = user.groups || [];\n    let newGroups = [];\n    let currentUserGrpInShop;\n    currentUserGroups.forEach((grp) => {\n      if (allGroupsInShop.indexOf(grp) < 0) {\n        newGroups.push(grp);\n      } else {\n        currentUserGrpInShop = grp;\n      }\n    });\n    newGroups = newGroups.concat(groupId);\n\n    try {\n      setUserPermissions({ _id: userId }, permissions, shopId);\n      Accounts.update({ _id: userId }, { $set: { groups: newGroups } });\n      Hooks.Events.run(\"afterAccountsUpdate\", loggedInUserId, {\n        accountId: userId,\n        updatedFields: [\"groups\"]\n      });\n      if (slug === \"owner\") {\n        if (shopId === Reaction.getPrimaryShopId()) {\n          changeMarketplaceOwner({ userId, permissions });\n        }\n        // remove current shop owner after setting another admin as the new owner\n        Meteor.call(\"group/addUser\", Meteor.userId(), currentUserGrpInShop);\n      }\n\n      // Return the group the account as added to\n      return Groups.findOne({ _id: groupId });\n    } catch (error) {\n      Logger.error(error);\n      throw new Meteor.Error(\"server-error\", \"Could not add user\");\n    }\n  },\n\n  /**\n   * @name group/removeUser\n   * @method\n   * @memberof Methods/Group\n   * @summary Removes a user from a group for a shop, and adds them to the default customer group.\n   * Updates the user's permission list to reflect.\n   * (NB: At this time, a user only belongs to only one group per shop)\n   * @param {String} userId - The account ID to remove from the group\n   * @param {String} groupId - ID of the group\n   * @return {Object} - The modified group object\n   */\n  \"group/removeUser\"(userId, groupId) {\n    check(userId, String);\n    check(groupId, String);\n\n    const user = Accounts.findOne({ _id: userId });\n    const { shopId } = Groups.findOne({ _id: groupId }) || {};\n    const defaultCustomerGroupForShop = Groups.findOne({ slug: \"customer\", shopId }) || {};\n\n    // we are limiting group method actions to only users with admin roles\n    // this also include shop owners, since they have the `admin` role in their Roles.GLOBAL_GROUP\n    if (!Reaction.hasPermission(\"admin\", Meteor.userId(), shopId)) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    if (!user) {\n      throw new Meteor.Error(\"invalid-parameter\", \"Could not find user\");\n    }\n\n    try {\n      setUserPermissions(user, defaultCustomerGroupForShop.permissions, shopId);\n      Accounts.update({ _id: userId, groups: groupId }, { $set: { \"groups.$\": defaultCustomerGroupForShop._id } }); // replace the old id with new id\n      Hooks.Events.run(\"afterAccountsUpdate\", Meteor.userId(), {\n        accountId: userId,\n        updatedFields: [\"groups\"]\n      });\n      return defaultCustomerGroupForShop;\n    } catch (error) {\n      Logger.error(error);\n      throw new Meteor.Error(\"server-error\", \"Could not add user\");\n    }\n  }\n});\n\n/**\n * changeMarketplaceOwner\n * @private\n * @summary Checks if the user making the request is allowed to make invitation to that group\n * @param {Object} options -\n * @param {String} options.userId - userID\n * @param {String} options.permissions - permissions\n * @return {null} -\n */\nfunction changeMarketplaceOwner({ userId, permissions }) {\n  // give global marketplace role to new owner\n  Roles.setUserRoles(userId, permissions, Roles.GLOBAL_GROUP);\n  // remove global from previous owner\n  Meteor.users.update({ _id: Meteor.userId() }, { $unset: { [`roles.${Roles.GLOBAL_GROUP}`]: \"\" } });\n}\n\n/**\n * setUserPermissions\n * @private\n * @summary Set user permissions\n * @param {Object} users -\n * @param {String} permissions -\n * @param {String} shopId -\n * @return {null} -\n */\nfunction setUserPermissions(users, permissions, shopId) {\n  let affectedUsers = users;\n  if (!Array.isArray(users)) {\n    affectedUsers = [users];\n  }\n\n  return affectedUsers.forEach((user) => Roles.setUserRoles(user._id, permissions, shopId));\n}\n\n// set default admin user's account as \"owner\"\nHooks.Events.add(\"afterCreateDefaultAdminUser\", (user) => {\n  const group = Groups.findOne({ slug: \"owner\", shopId: Reaction.getShopId() });\n  Accounts.update({ _id: user._id }, { $set: { groups: [group._id] } });\n  Hooks.Events.run(\"afterAccountsUpdate\", null, {\n    accountId: user._id,\n    updatedFields: [\"groups\"]\n  });\n});\n"]},"sourceType":"script","hash":"a8e32a0b8a649a9d53792355326b37a1c64e4f67"}
