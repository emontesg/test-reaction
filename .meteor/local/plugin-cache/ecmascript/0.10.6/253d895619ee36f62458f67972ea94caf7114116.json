{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$1$2","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"ast":true,"babelrc":false,"sourceFileName":"imports/plugins/included/inventory/server/methods/statusChanges.js","filename":"imports/plugins/included/inventory/server/methods/statusChanges.js","sourceMaps":true,"envName":"development","cwd":"/Users/estebandev/test-knowledge","passPerPreset":false,"presets":[],"parserOpts":{"sourceType":"module","sourceFileName":"imports/plugins/included/inventory/server/methods/statusChanges.js","plugins":["jsx","jsx","flow","flow","objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties"]},"generatorOpts":{"filename":"imports/plugins/included/inventory/server/methods/statusChanges.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"imports/plugins/included/inventory/server/methods/statusChanges.js"}},"code":"let Meteor;\nmodule.watch(require(\"meteor/meteor\"), {\n  Meteor(v) {\n    Meteor = v;\n  }\n\n}, 0);\nlet check, Match;\nmodule.watch(require(\"meteor/check\"), {\n  check(v) {\n    check = v;\n  },\n\n  Match(v) {\n    Match = v;\n  }\n\n}, 1);\nlet Inventory;\nmodule.watch(require(\"../../../../../../lib/collections\"), {\n  Inventory(v) {\n    Inventory = v;\n  }\n\n}, 2);\nlet Schemas;\nmodule.watch(require(\"../../../../../../lib/collections/schemas\"), {\n  \"*\"(v) {\n    Schemas = v;\n  }\n\n}, 3);\nlet Logger, Reaction;\nmodule.watch(require(\"../../../../../../server/api\"), {\n  Logger(v) {\n    Logger = v;\n  },\n\n  Reaction(v) {\n    Reaction = v;\n  }\n\n}, 4);\n// TODO statusChanges DDP limiting Disabled for now, needs more testing.\n// // Define a rate limiting rule that matches update attempts by non-admin users\n// const addReserveRule = {\n//   userId: function (userId) {\n//     return Roles.userIsInRole(userId, \"createProduct\", Reaction.getShopId());\n//   },\n//   type: \"subscription\",\n//   method: \"Inventory\"\n// };\n//\n// // Define a rate limiting rule that matches backorder attempts by non-admin users\n// const addBackorderRule = {\n//   userId: function (userId) {\n//     return Roles.userIsInRole(userId, \"createProduct\", Reaction.getShopId());\n//   },\n//   type: \"method\",\n//   method: \"inventory/backorder\"\n// };\n//\n// // Add the rule, allowing up to 5 messages every 1000 milliseconds.\n// DDPRateLimiter.addRule(addReserveRule, 5, 1000);\n// DDPRateLimiter.addRule(addBackorderRule, 5, 1000);\n\n/**\n * @file Methods for Inventory. Run these methods using `Meteor.call()`\n *\n *\n * @namespace Methods/Inventory\n*/\nMeteor.methods({\n  /**\n   * @name inventory/setStatus\n   * @method\n   * @memberof Methods/Inventory\n   * @summary Sets status from one status to a new status. Defaults to `new` to `reserved`\n   * @example Meteor.call(\"inventory/backorder\", reservation, backOrderQty);\n   * @param  {Array} cartItems array of objects of type Schemas.CartItems\n   * @param  {String} status optional - sets the inventory workflow status, defaults to `reserved`\n   * @param  {String} currentStatus - what is the current status to change `from`\n   * @param  {String} notFoundStatus - what to use if the status is not found\n   * @todo move this to bulkOp\n   * @return {Number} returns reservationCount\n   */\n  \"inventory/setStatus\"(cartItems, status, currentStatus, notFoundStatus) {\n    Schemas.CartItem.validate(cartItems);\n    check(status, Match.Optional(String));\n    check(currentStatus, Match.Optional(String));\n    check(notFoundStatus, Match.Optional(String));\n    this.unblock(); // check basic user permissions\n    // if (!Reaction.hasPermission([\"guest\", \"anonymous\"])) {\n    //   throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    // }\n    // set defaults\n\n    const reservationStatus = status || \"reserved\"; // change status to options object\n\n    const defaultStatus = currentStatus || \"new\"; // default to the \"new\" status\n\n    const backorderStatus = notFoundStatus || \"backorder\"; // change status to options object\n\n    let reservationCount;\n    Logger.debug(`Moving Inventory items from ${defaultStatus} to ${reservationStatus}`); // update inventory status for cartItems\n\n    for (const item of cartItems) {\n      // check of existing reserved inventory for this cart\n      const existingReservations = Inventory.find({\n        productId: item.productId,\n        variantId: item.variants._id,\n        shopId: item.shopId,\n        orderItemId: item._id\n      }); // define a new reservation\n\n      const availableInventory = Inventory.find({\n        \"productId\": item.productId,\n        \"variantId\": item.variants._id,\n        \"shopId\": item.shopId,\n        \"workflow.status\": defaultStatus\n      });\n      const totalRequiredQty = item.quantity;\n      const availableInventoryQty = availableInventory.count();\n      let existingReservationQty = existingReservations.count();\n      Logger.debug(\"totalRequiredQty\", totalRequiredQty);\n      Logger.debug(\"availableInventoryQty\", availableInventoryQty); // if we don't have existing inventory we create backorders\n\n      if (totalRequiredQty > availableInventoryQty) {\n        // TODO put in a dashboard setting to allow backorder or altenate handler to be used\n        const backOrderQty = Number(totalRequiredQty - availableInventoryQty - existingReservationQty);\n        Logger.debug(`no inventory found, create ${backOrderQty} ${backorderStatus}`); // define a new reservation\n\n        const reservation = {\n          productId: item.productId,\n          variantId: item.variants._id,\n          shopId: item.shopId,\n          orderItemId: item._id,\n          workflow: {\n            status: backorderStatus\n          }\n        };\n        Meteor.call(\"inventory/backorder\", reservation, backOrderQty);\n        existingReservationQty = backOrderQty;\n      } // if we have inventory available, only create additional required reservations\n\n\n      Logger.debug(\"existingReservationQty\", existingReservationQty);\n      reservationCount = existingReservationQty;\n      let newReservedQty;\n\n      if (reservationStatus === \"reserved\" && defaultStatus === \"new\") {\n        newReservedQty = totalRequiredQty - existingReservationQty + 1;\n      } else {\n        // when moving from one \"reserved\" type status, we don't need to deal with existingReservationQty\n        newReservedQty = totalRequiredQty + 1;\n      }\n\n      let i = 1;\n\n      while (i < newReservedQty) {\n        // updated existing new inventory to be reserved\n        Logger.debug(`updating reservation status ${i} of ${newReservedQty - 1}/${totalRequiredQty} items.`); // we should be updating existing inventory here.\n        // backorder process created additional backorder inventory if there\n        // wasn't enough.\n\n        Inventory.update({\n          \"productId\": item.productId,\n          \"variantId\": item.variants._id,\n          \"shopId\": item.shopId,\n          \"workflow.status\": defaultStatus\n        }, {\n          $set: {\n            \"orderItemId\": item._id,\n            \"workflow.status\": reservationStatus\n          }\n        });\n        reservationCount += 1;\n        i += 1;\n      }\n    }\n\n    Logger.debug(`finished creating ${reservationCount} new ${reservationStatus} reservations`);\n    return reservationCount;\n  },\n\n  /**\n   * @name inventory/clearStatus\n   * @method\n   * @memberof Methods/Inventory\n   * @summary Used to reset status on inventory item (defaults to `new`)\n   * @param  {Array} cartItems array of objects Schemas.CartItem\n   * @param  {Array} status optional reset workflow.status, defaults to `new`\n   * @param  {Array} currentStatus optional matching workflow.status, defaults to `reserved`\n   * @return {undefined} undefined\n   */\n  \"inventory/clearStatus\"(cartItems, status, currentStatus) {\n    Schemas.CartItem.validate(cartItems);\n    check(status, Match.Optional(String)); // workflow status\n\n    check(currentStatus, Match.Optional(String));\n    this.unblock(); // // check basic user permissions\n    // if (!Reaction.hasPermission([\"guest\", \"anonymous\"])) {\n    //   throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    // }\n    // optional workflow status or default to \"new\"\n\n    const newStatus = status || \"new\";\n    const oldStatus = currentStatus || \"reserved\"; // remove each cart item in inventory\n\n    for (const item of cartItems) {\n      // check of existing reserved inventory for this cart\n      const existingReservations = Inventory.find({\n        \"productId\": item.productId,\n        \"variantId\": item.variants._id,\n        \"shopId\": item.shopId,\n        \"orderItemId\": item._id,\n        \"workflow.status\": oldStatus\n      });\n      const reservationsCount = existingReservations.count();\n      let clearCount = item.quantity; // reset existing cartItem reservations\n\n      while (clearCount && reservationsCount) {\n        Inventory.update({\n          \"productId\": item.productId,\n          \"variantId\": item.variants._id,\n          \"shopId\": item.shopId,\n          \"orderItemId\": item._id,\n          \"workflow.status\": oldStatus\n        }, {\n          $set: {\n            \"orderItemId\": \"\",\n            // clear order/cart\n            \"workflow.status\": newStatus // reset status\n\n          }\n        });\n        clearCount -= 1;\n      }\n    }\n\n    Logger.debug(\"inventory/clearReserve\", newStatus);\n  },\n\n  /**\n   * @name inventory/clearReserve\n   * @method\n   * @memberof Methods/Inventory\n   * @example Meteor.call(\"inventory/clearReserve\", cart.items)\n   * @summary Resets `reserved` items to `new`\n   * @param  {Array} cartItems array of objects Schemas.CartItem\n   * @return {undefined}\n   */\n  \"inventory/clearReserve\"(cartItems) {\n    Schemas.CartItem.validate(cartItems);\n    return Meteor.call(\"inventory/clearStatus\", cartItems);\n  },\n\n  /**\n   * @name inventory/addReserve\n   * @summary Converts new items to reserved, or backorders\n   * @method\n   * @example Meteor.call(\"inventory/addReserve\", cart.items)\n   * @memberof Methods/Inventory\n   * @param  {Array} cartItems array of objects Schemas.CartItem\n   * @return {undefined}\n   */\n  \"inventory/addReserve\"(cartItems) {\n    Schemas.CartItem.validate(cartItems);\n    return Meteor.call(\"inventory/setStatus\", cartItems);\n  },\n\n  /**\n   * @name inventory/backorder\n   * @summary Used by the cart process to create a new Inventory backorder item,\n   * but this could be used for inserting any custom inventory.\n   * @method\n   * A note on DDP Limits: As these are wide open we defined some {@link http://docs.meteor.com/#/full/ddpratelimiter ddp limiting rules}\n   * @memberof Methods/Inventory\n   * @param {Object} reservation Schemas.Inventory\n   * @param {Number} backOrderQty number of backorder items to create\n   * @returns {Number} number of inserted backorder documents\n   */\n  \"inventory/backorder\"(reservation, backOrderQty) {\n    Schemas.Inventory.validate(reservation);\n    check(backOrderQty, Number);\n    this.unblock(); // this use case could happen when mergeCart is fired. We don't add anything\n    // or remove, just item owner changed. We need to add this check here\n    // because of bulk operation. It throws exception if nothing to operate.\n\n    if (backOrderQty === 0) {\n      return 0;\n    } // TODO inventory/backorder need to look carefully and understand is it possible ho have a\n    // negative `backOrderQty` value here?\n    // check basic user permissions\n    // if (!Reaction.hasPermission([\"guest\",\"anonymous\"])) {\n    //   throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    // }\n    // set defaults\n\n\n    const newReservation = reservation;\n\n    if (!newReservation.workflow) {\n      newReservation.workflow = {\n        status: \"backorder\"\n      };\n    } // insert backorder\n\n\n    let i = 0;\n    const batch = Inventory.rawCollection().initializeUnorderedBulkOp();\n\n    if (batch) {\n      while (i < backOrderQty) {\n        const id = Inventory._makeNewID();\n\n        batch.insert(Object.assign({\n          _id: id\n        }, newReservation));\n        i += 1;\n      }\n\n      const execute = Meteor.wrapAsync(batch.execute, batch);\n\n      if (batch.length) {\n        const inventoryBackorder = execute();\n        const inserted = inventoryBackorder.nInserted;\n        Logger.debug(`created ${inserted} backorder records for product ${newReservation.productId}, variant ${newReservation.variantId}`);\n        return inserted;\n      }\n    } //\n    // TODO implement a backup inventory/backorder method if bulk operations fail.\n    //\n\n\n    Logger.error(\"skipped bulk operations backorder updates.\");\n    return null;\n  },\n\n  /**\n   * @name inventory/lowStock\n   * @summary Send low stock warnings\n   * @method\n   * @memberof Methods/Inventory\n   * @param  {Object} product object type Product\n   * @return {undefined}\n   * @todo implement inventory/lowstock calculations\n   */\n  \"inventory/lowStock\"(product) {\n    Schemas.Product.validate(product); // placeholder is here to give plugins a place to hook into\n\n    Logger.debug(\"inventory/lowStock\");\n  },\n\n  /**\n   * @name inventory/remove\n   * @summary Delete an inventory item permanently\n   * @method\n   * @memberof Methods/Inventory\n   * @param  {Object} inventoryItem object type Schemas.Inventory\n   * @return {String} return remove result\n   */\n  \"inventory/remove\"(inventoryItem) {\n    Schemas.Inventory.validate(inventoryItem); // user needs createProduct permission to adjust inventory\n    // REVIEW: Should this be checking against shop permissions instead?\n    // calledByServer is only true if this method was triggered by the server, such as from a webhook.\n    // there will be a null connection and no userId.\n\n    const calledByServer = this.connection === null && !Meteor.userId();\n\n    if (!calledByServer && !Reaction.hasPermission(\"createProduct\", this.userId, inventoryItem.shopId)) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    } // this.unblock();\n    // TODO: add bulkOp here\n\n\n    Logger.debug(\"inventory/remove\", inventoryItem);\n    return Inventory.remove(inventoryItem);\n  },\n\n  /**\n   * @name inventory/shipped\n   * @method\n   * @memberof Methods/Inventory\n   * @summary Mark inventory as shipped\n   * @param  {Array} cartItems array of objects Schemas.CartItem\n   * @return {undefined}\n   */\n  \"inventory/shipped\"(cartItems) {\n    Schemas.CartItem.validate(cartItems);\n    return Meteor.call(\"inventory/setStatus\", cartItems, \"shipped\", \"sold\");\n  },\n\n  /**\n   * @name inventory/sold\n   * @method\n   * @memberof Methods/Inventory\n   * @summary Mark inventory as sold\n   * @param  {Array} cartItems array of objects Schemas.CartItem\n   * @return {undefined}\n   */\n  \"inventory/sold\"(cartItems) {\n    Schemas.CartItem.validate(cartItems);\n    return Meteor.call(\"inventory/setStatus\", cartItems, \"sold\", \"reserved\");\n  },\n\n  /**\n   * @name inventory/return\n   * @method\n   * @memberof Methods/Inventory\n   * @summary Mark inventory as returned\n   * @param  {Array} cartItems array of objects Schemas.CartItem\n   * @return {undefined}\n   */\n  \"inventory/return\"(cartItems) {\n    Schemas.CartItem.validate(cartItems);\n    return Meteor.call(\"inventory/setStatus\", cartItems, \"return\");\n  },\n\n  /**\n   * @name inventory/returnToStock\n   * @method\n   * @memberof Methods/Inventory\n   * @summary Mark inventory as return and available for sale\n   * @param  {Array} cartItems array of objects Schemas.CartItem\n   * @return {undefined}\n   */\n  \"inventory/returnToStock\"(cartItems) {\n    Schemas.CartItem.validate(cartItems);\n    return Meteor.call(\"inventory/clearStatus\", cartItems, \"new\", \"return\");\n  }\n\n});","map":{"version":3,"sources":["imports/plugins/included/inventory/server/methods/statusChanges.js"],"names":["Meteor","module","watch","require","v","check","Match","Inventory","Schemas","Logger","Reaction","methods","cartItems","status","currentStatus","notFoundStatus","CartItem","validate","Optional","String","unblock","reservationStatus","defaultStatus","backorderStatus","reservationCount","debug","item","existingReservations","find","productId","variantId","variants","_id","shopId","orderItemId","availableInventory","totalRequiredQty","quantity","availableInventoryQty","count","existingReservationQty","backOrderQty","Number","reservation","workflow","call","newReservedQty","i","update","$set","newStatus","oldStatus","reservationsCount","clearCount","newReservation","batch","rawCollection","initializeUnorderedBulkOp","id","_makeNewID","insert","Object","assign","execute","wrapAsync","length","inventoryBackorder","inserted","nInserted","error","product","Product","inventoryItem","calledByServer","connection","userId","hasPermission","Error","remove"],"mappings":"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","sourcesContent":["import { Meteor } from \"meteor/meteor\";\nimport { check, Match } from \"meteor/check\";\nimport { Inventory } from \"/lib/collections\";\nimport * as Schemas from \"/lib/collections/schemas\";\nimport { Logger, Reaction } from \"/server/api\";\n\n// TODO statusChanges DDP limiting Disabled for now, needs more testing.\n\n// // Define a rate limiting rule that matches update attempts by non-admin users\n// const addReserveRule = {\n//   userId: function (userId) {\n//     return Roles.userIsInRole(userId, \"createProduct\", Reaction.getShopId());\n//   },\n//   type: \"subscription\",\n//   method: \"Inventory\"\n// };\n//\n// // Define a rate limiting rule that matches backorder attempts by non-admin users\n// const addBackorderRule = {\n//   userId: function (userId) {\n//     return Roles.userIsInRole(userId, \"createProduct\", Reaction.getShopId());\n//   },\n//   type: \"method\",\n//   method: \"inventory/backorder\"\n// };\n//\n// // Add the rule, allowing up to 5 messages every 1000 milliseconds.\n// DDPRateLimiter.addRule(addReserveRule, 5, 1000);\n// DDPRateLimiter.addRule(addBackorderRule, 5, 1000);\n\n/**\n * @file Methods for Inventory. Run these methods using `Meteor.call()`\n *\n *\n * @namespace Methods/Inventory\n*/\nMeteor.methods({\n  /**\n   * @name inventory/setStatus\n   * @method\n   * @memberof Methods/Inventory\n   * @summary Sets status from one status to a new status. Defaults to `new` to `reserved`\n   * @example Meteor.call(\"inventory/backorder\", reservation, backOrderQty);\n   * @param  {Array} cartItems array of objects of type Schemas.CartItems\n   * @param  {String} status optional - sets the inventory workflow status, defaults to `reserved`\n   * @param  {String} currentStatus - what is the current status to change `from`\n   * @param  {String} notFoundStatus - what to use if the status is not found\n   * @todo move this to bulkOp\n   * @return {Number} returns reservationCount\n   */\n  \"inventory/setStatus\"(cartItems, status, currentStatus, notFoundStatus) {\n    Schemas.CartItem.validate(cartItems);\n    check(status, Match.Optional(String));\n    check(currentStatus, Match.Optional(String));\n    check(notFoundStatus, Match.Optional(String));\n    this.unblock();\n\n    // check basic user permissions\n    // if (!Reaction.hasPermission([\"guest\", \"anonymous\"])) {\n    //   throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    // }\n\n    // set defaults\n    const reservationStatus = status || \"reserved\"; // change status to options object\n    const defaultStatus = currentStatus || \"new\"; // default to the \"new\" status\n    const backorderStatus = notFoundStatus || \"backorder\"; // change status to options object\n    let reservationCount;\n    Logger.debug(`Moving Inventory items from ${defaultStatus} to ${reservationStatus}`);\n\n    // update inventory status for cartItems\n    for (const item of cartItems) {\n      // check of existing reserved inventory for this cart\n      const existingReservations = Inventory.find({\n        productId: item.productId,\n        variantId: item.variants._id,\n        shopId: item.shopId,\n        orderItemId: item._id\n      });\n\n      // define a new reservation\n      const availableInventory = Inventory.find({\n        \"productId\": item.productId,\n        \"variantId\": item.variants._id,\n        \"shopId\": item.shopId,\n        \"workflow.status\": defaultStatus\n      });\n\n      const totalRequiredQty = item.quantity;\n      const availableInventoryQty = availableInventory.count();\n      let existingReservationQty = existingReservations.count();\n\n      Logger.debug(\"totalRequiredQty\", totalRequiredQty);\n      Logger.debug(\"availableInventoryQty\", availableInventoryQty);\n\n      // if we don't have existing inventory we create backorders\n      if (totalRequiredQty > availableInventoryQty) {\n        // TODO put in a dashboard setting to allow backorder or altenate handler to be used\n        const backOrderQty = Number(totalRequiredQty - availableInventoryQty - existingReservationQty);\n        Logger.debug(`no inventory found, create ${backOrderQty} ${backorderStatus}`);\n        // define a new reservation\n        const reservation = {\n          productId: item.productId,\n          variantId: item.variants._id,\n          shopId: item.shopId,\n          orderItemId: item._id,\n          workflow: {\n            status: backorderStatus\n          }\n        };\n\n        Meteor.call(\"inventory/backorder\", reservation, backOrderQty);\n        existingReservationQty = backOrderQty;\n      }\n      // if we have inventory available, only create additional required reservations\n      Logger.debug(\"existingReservationQty\", existingReservationQty);\n      reservationCount = existingReservationQty;\n      let newReservedQty;\n      if (reservationStatus === \"reserved\" && defaultStatus === \"new\") {\n        newReservedQty = totalRequiredQty - existingReservationQty + 1;\n      } else {\n        // when moving from one \"reserved\" type status, we don't need to deal with existingReservationQty\n        newReservedQty = totalRequiredQty + 1;\n      }\n\n      let i = 1;\n      while (i < newReservedQty) {\n        // updated existing new inventory to be reserved\n        Logger.debug(`updating reservation status ${i} of ${newReservedQty - 1}/${totalRequiredQty} items.`);\n        // we should be updating existing inventory here.\n        // backorder process created additional backorder inventory if there\n        // wasn't enough.\n        Inventory.update({\n          \"productId\": item.productId,\n          \"variantId\": item.variants._id,\n          \"shopId\": item.shopId,\n          \"workflow.status\": defaultStatus\n        }, {\n          $set: {\n            \"orderItemId\": item._id,\n            \"workflow.status\": reservationStatus\n          }\n        });\n        reservationCount += 1;\n        i += 1;\n      }\n    }\n    Logger.debug(`finished creating ${reservationCount} new ${reservationStatus} reservations`);\n    return reservationCount;\n  },\n\n  /**\n   * @name inventory/clearStatus\n   * @method\n   * @memberof Methods/Inventory\n   * @summary Used to reset status on inventory item (defaults to `new`)\n   * @param  {Array} cartItems array of objects Schemas.CartItem\n   * @param  {Array} status optional reset workflow.status, defaults to `new`\n   * @param  {Array} currentStatus optional matching workflow.status, defaults to `reserved`\n   * @return {undefined} undefined\n   */\n  \"inventory/clearStatus\"(cartItems, status, currentStatus) {\n    Schemas.CartItem.validate(cartItems);\n    check(status, Match.Optional(String)); // workflow status\n    check(currentStatus, Match.Optional(String));\n    this.unblock();\n\n    // // check basic user permissions\n    // if (!Reaction.hasPermission([\"guest\", \"anonymous\"])) {\n    //   throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    // }\n\n    // optional workflow status or default to \"new\"\n    const newStatus = status || \"new\";\n    const oldStatus = currentStatus || \"reserved\";\n\n    // remove each cart item in inventory\n    for (const item of cartItems) {\n      // check of existing reserved inventory for this cart\n      const existingReservations = Inventory.find({\n        \"productId\": item.productId,\n        \"variantId\": item.variants._id,\n        \"shopId\": item.shopId,\n        \"orderItemId\": item._id,\n        \"workflow.status\": oldStatus\n      });\n      const reservationsCount = existingReservations.count();\n      let clearCount = item.quantity;\n      // reset existing cartItem reservations\n      while (clearCount && reservationsCount) {\n        Inventory.update({\n          \"productId\": item.productId,\n          \"variantId\": item.variants._id,\n          \"shopId\": item.shopId,\n          \"orderItemId\": item._id,\n          \"workflow.status\": oldStatus\n        }, {\n          $set: {\n            \"orderItemId\": \"\", // clear order/cart\n            \"workflow.status\": newStatus // reset status\n          }\n        });\n\n        clearCount -= 1;\n      }\n    }\n    Logger.debug(\"inventory/clearReserve\", newStatus);\n  },\n\n  /**\n   * @name inventory/clearReserve\n   * @method\n   * @memberof Methods/Inventory\n   * @example Meteor.call(\"inventory/clearReserve\", cart.items)\n   * @summary Resets `reserved` items to `new`\n   * @param  {Array} cartItems array of objects Schemas.CartItem\n   * @return {undefined}\n   */\n  \"inventory/clearReserve\"(cartItems) {\n    Schemas.CartItem.validate(cartItems);\n    return Meteor.call(\"inventory/clearStatus\", cartItems);\n  },\n\n  /**\n   * @name inventory/addReserve\n   * @summary Converts new items to reserved, or backorders\n   * @method\n   * @example Meteor.call(\"inventory/addReserve\", cart.items)\n   * @memberof Methods/Inventory\n   * @param  {Array} cartItems array of objects Schemas.CartItem\n   * @return {undefined}\n   */\n  \"inventory/addReserve\"(cartItems) {\n    Schemas.CartItem.validate(cartItems);\n    return Meteor.call(\"inventory/setStatus\", cartItems);\n  },\n\n  /**\n   * @name inventory/backorder\n   * @summary Used by the cart process to create a new Inventory backorder item,\n   * but this could be used for inserting any custom inventory.\n   * @method\n   * A note on DDP Limits: As these are wide open we defined some {@link http://docs.meteor.com/#/full/ddpratelimiter ddp limiting rules}\n   * @memberof Methods/Inventory\n   * @param {Object} reservation Schemas.Inventory\n   * @param {Number} backOrderQty number of backorder items to create\n   * @returns {Number} number of inserted backorder documents\n   */\n  \"inventory/backorder\"(reservation, backOrderQty) {\n    Schemas.Inventory.validate(reservation);\n    check(backOrderQty, Number);\n    this.unblock();\n\n    // this use case could happen when mergeCart is fired. We don't add anything\n    // or remove, just item owner changed. We need to add this check here\n    // because of bulk operation. It throws exception if nothing to operate.\n    if (backOrderQty === 0) {\n      return 0;\n    }\n\n    // TODO inventory/backorder need to look carefully and understand is it possible ho have a\n    // negative `backOrderQty` value here?\n\n    // check basic user permissions\n    // if (!Reaction.hasPermission([\"guest\",\"anonymous\"])) {\n    //   throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    // }\n\n    // set defaults\n    const newReservation = reservation;\n    if (!newReservation.workflow) {\n      newReservation.workflow = {\n        status: \"backorder\"\n      };\n    }\n\n    // insert backorder\n    let i = 0;\n    const batch = Inventory.rawCollection().initializeUnorderedBulkOp();\n    if (batch) {\n      while (i < backOrderQty) {\n        const id = Inventory._makeNewID();\n        batch.insert(Object.assign({ _id: id }, newReservation));\n        i += 1;\n      }\n\n      const execute = Meteor.wrapAsync(batch.execute, batch);\n      if (batch.length) {\n        const inventoryBackorder = execute();\n        const inserted = inventoryBackorder.nInserted;\n        Logger.debug(`created ${inserted} backorder records for product ${newReservation.productId}, variant ${newReservation.variantId}`);\n        return inserted;\n      }\n    }\n    //\n    // TODO implement a backup inventory/backorder method if bulk operations fail.\n    //\n    Logger.error(\"skipped bulk operations backorder updates.\");\n    return null;\n  },\n\n  /**\n   * @name inventory/lowStock\n   * @summary Send low stock warnings\n   * @method\n   * @memberof Methods/Inventory\n   * @param  {Object} product object type Product\n   * @return {undefined}\n   * @todo implement inventory/lowstock calculations\n   */\n  \"inventory/lowStock\"(product) {\n    Schemas.Product.validate(product);\n    // placeholder is here to give plugins a place to hook into\n    Logger.debug(\"inventory/lowStock\");\n  },\n\n  /**\n   * @name inventory/remove\n   * @summary Delete an inventory item permanently\n   * @method\n   * @memberof Methods/Inventory\n   * @param  {Object} inventoryItem object type Schemas.Inventory\n   * @return {String} return remove result\n   */\n  \"inventory/remove\"(inventoryItem) {\n    Schemas.Inventory.validate(inventoryItem);\n    // user needs createProduct permission to adjust inventory\n    // REVIEW: Should this be checking against shop permissions instead?\n\n    // calledByServer is only true if this method was triggered by the server, such as from a webhook.\n    // there will be a null connection and no userId.\n    const calledByServer = (this.connection === null && !Meteor.userId());\n\n    if (!calledByServer && !Reaction.hasPermission(\"createProduct\", this.userId, inventoryItem.shopId)) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n    // this.unblock();\n    // TODO: add bulkOp here\n\n    Logger.debug(\"inventory/remove\", inventoryItem);\n    return Inventory.remove(inventoryItem);\n  },\n\n  /**\n   * @name inventory/shipped\n   * @method\n   * @memberof Methods/Inventory\n   * @summary Mark inventory as shipped\n   * @param  {Array} cartItems array of objects Schemas.CartItem\n   * @return {undefined}\n   */\n  \"inventory/shipped\"(cartItems) {\n    Schemas.CartItem.validate(cartItems);\n    return Meteor.call(\"inventory/setStatus\", cartItems, \"shipped\", \"sold\");\n  },\n\n  /**\n   * @name inventory/sold\n   * @method\n   * @memberof Methods/Inventory\n   * @summary Mark inventory as sold\n   * @param  {Array} cartItems array of objects Schemas.CartItem\n   * @return {undefined}\n   */\n  \"inventory/sold\"(cartItems) {\n    Schemas.CartItem.validate(cartItems);\n    return Meteor.call(\"inventory/setStatus\", cartItems, \"sold\", \"reserved\");\n  },\n\n  /**\n   * @name inventory/return\n   * @method\n   * @memberof Methods/Inventory\n   * @summary Mark inventory as returned\n   * @param  {Array} cartItems array of objects Schemas.CartItem\n   * @return {undefined}\n   */\n  \"inventory/return\"(cartItems) {\n    Schemas.CartItem.validate(cartItems);\n    return Meteor.call(\"inventory/setStatus\", cartItems, \"return\");\n  },\n\n  /**\n   * @name inventory/returnToStock\n   * @method\n   * @memberof Methods/Inventory\n   * @summary Mark inventory as return and available for sale\n   * @param  {Array} cartItems array of objects Schemas.CartItem\n   * @return {undefined}\n   */\n  \"inventory/returnToStock\"(cartItems) {\n    Schemas.CartItem.validate(cartItems);\n    return Meteor.call(\"inventory/clearStatus\", cartItems, \"new\", \"return\");\n  }\n});\n"]},"sourceType":"script","hash":"253d895619ee36f62458f67972ea94caf7114116"}
