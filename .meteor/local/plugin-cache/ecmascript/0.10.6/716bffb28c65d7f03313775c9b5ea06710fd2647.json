{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$1$2","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"ast":true,"babelrc":false,"sourceFileName":"imports/plugins/included/payments-authnet/server/methods/authnet.js","filename":"imports/plugins/included/payments-authnet/server/methods/authnet.js","sourceMaps":true,"envName":"development","cwd":"/Users/estebandev/test-knowledge","passPerPreset":false,"presets":[],"parserOpts":{"sourceType":"module","sourceFileName":"imports/plugins/included/payments-authnet/server/methods/authnet.js","plugins":["jsx","jsx","flow","flow","objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties"]},"generatorOpts":{"filename":"imports/plugins/included/payments-authnet/server/methods/authnet.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"imports/plugins/included/payments-authnet/server/methods/authnet.js"}},"code":"let accounting;\nmodule.watch(require(\"accounting-js\"), {\n  default(v) {\n    accounting = v;\n  }\n\n}, 0);\nlet Meteor;\nmodule.watch(require(\"meteor/meteor\"), {\n  Meteor(v) {\n    Meteor = v;\n  }\n\n}, 1);\nlet check, Match;\nmodule.watch(require(\"meteor/check\"), {\n  check(v) {\n    check = v;\n  },\n\n  Match(v) {\n    Match = v;\n  }\n\n}, 2);\nlet Promise;\nmodule.watch(require(\"meteor/promise\"), {\n  Promise(v) {\n    Promise = v;\n  }\n\n}, 3);\nlet AuthNetAPI;\nmodule.watch(require(\"authorize-net\"), {\n  default(v) {\n    AuthNetAPI = v;\n  }\n\n}, 4);\nlet Reaction, Logger;\nmodule.watch(require(\"../../../../../../server/api\"), {\n  Reaction(v) {\n    Reaction = v;\n  },\n\n  Logger(v) {\n    Logger = v;\n  }\n\n}, 5);\nlet Packages;\nmodule.watch(require(\"../../../../../../lib/collections\"), {\n  Packages(v) {\n    Packages = v;\n  }\n\n}, 6);\nlet ValidCardNumber, ValidExpireMonth, ValidExpireYear, ValidCVV;\nmodule.watch(require(\"../../../../../../lib/api\"), {\n  ValidCardNumber(v) {\n    ValidCardNumber = v;\n  },\n\n  ValidExpireMonth(v) {\n    ValidExpireMonth = v;\n  },\n\n  ValidExpireYear(v) {\n    ValidExpireYear = v;\n  },\n\n  ValidCVV(v) {\n    ValidCVV = v;\n  }\n\n}, 7);\nlet PaymentMethodArgument;\nmodule.watch(require(\"../../../../../../lib/collections/schemas\"), {\n  PaymentMethodArgument(v) {\n    PaymentMethodArgument = v;\n  }\n\n}, 8);\n\nfunction getAccountOptions(isPayment) {\n  const queryConditions = {\n    name: \"reaction-auth-net\",\n    shopId: Reaction.getShopId()\n  };\n\n  if (isPayment) {\n    queryConditions.enabled = true;\n  }\n\n  const packageData = Packages.findOne(queryConditions);\n  const {\n    settings\n  } = packageData;\n  const ref = Meteor.settings.authnet;\n  const options = {\n    login: getSettings(settings, ref, \"api_id\"),\n    tran_key: getSettings(settings, ref, \"transaction_key\")\n  };\n\n  if (!options.login) {\n    throw new Meteor.Error(\"invalid-credentials\", \"Invalid Authnet Credentials\");\n  }\n\n  return options;\n}\n\nfunction getSettings(settings, ref, valueName) {\n  if (settings !== null) {\n    return settings[valueName];\n  } else if (ref !== null) {\n    return ref[valueName];\n  }\n\n  return undefined;\n}\n\nMeteor.methods({\n  authnetSubmit(transactionType = \"authorizeTransaction\", cardInfo, paymentInfo) {\n    check(transactionType, String);\n\n    try {\n      check(cardInfo, {\n        cardNumber: ValidCardNumber,\n        expirationYear: ValidExpireYear,\n        expirationMonth: ValidExpireMonth,\n        cvv2: ValidCVV\n      });\n    } catch (error) {\n      throw new Meteor.Error(\"invalid-card-details\", \"Invalid card details\");\n    }\n\n    check(paymentInfo, {\n      total: String,\n      currency: String\n    });\n    const order = {\n      amount: paymentInfo.total\n    };\n    const creditCard = {\n      creditCardNumber: cardInfo.cardNumber,\n      cvv2: cardInfo.cvv2,\n      expirationYear: cardInfo.expirationYear,\n      expirationMonth: cardInfo.expirationMonth\n    };\n    const isPayment = true;\n    const authnetService = getAuthnetService(getAccountOptions(isPayment));\n    const authnetTransactionFunc = authnetService[transactionType];\n    let authResult;\n\n    if (authnetTransactionFunc) {\n      try {\n        authResult = authnetTransactionFunc.call(authnetService, order, creditCard);\n      } catch (error) {\n        Logger.fatal(error);\n      }\n    } else {\n      throw new Meteor.Error(\"invalid-transaction-type\", \"Invalid Transaction Type\");\n    }\n\n    try {\n      const result = Promise.await(authResult);\n      return result;\n    } catch (error) {\n      throw new Meteor.Error(\"auth-failed\", error.message);\n    }\n  },\n\n  \"authnet/payment/capture\"(paymentMethod) {\n    // Call both check and validate because by calling `clean`, the audit pkg\n    // thinks that we haven't checked paymentMethod arg\n    check(paymentMethod, Object);\n    PaymentMethodArgument.validate(PaymentMethodArgument.clean(paymentMethod));\n    const {\n      transactionId,\n      amount\n    } = paymentMethod;\n    const authnetService = getAuthnetService(getAccountOptions());\n    const roundedAmount = parseFloat(amount.toFixed(2));\n    const capturedAmount = accounting.toFixed(amount, 2);\n    let result;\n\n    if (capturedAmount === accounting.toFixed(0, 2)) {\n      try {\n        const captureResult = voidTransaction(transactionId, authnetService);\n\n        if (captureResult.responseCode[0] === \"1\") {\n          result = {\n            saved: true,\n            response: captureResult\n          };\n        } else {\n          result = {\n            saved: false,\n            error: captureResult\n          };\n        }\n      } catch (error) {\n        Logger.fatal(error);\n        result = {\n          saved: false,\n          error\n        };\n      }\n\n      return result;\n    }\n\n    try {\n      const captureResult = priorAuthCaptureTransaction(transactionId, roundedAmount, authnetService);\n\n      if (captureResult.responseCode[0] === \"1\") {\n        result = {\n          saved: true,\n          response: captureResult\n        };\n      } else {\n        result = {\n          saved: false,\n          error: captureResult\n        };\n      }\n    } catch (error) {\n      Logger.fatal(error);\n      result = {\n        saved: false,\n        error\n      };\n    }\n\n    return result;\n  },\n\n  \"authnet/refund/create\"(paymentMethod, amount) {\n    check(amount, Number); // Call both check and validate because by calling `clean`, the audit pkg\n    // thinks that we haven't checked paymentMethod arg\n\n    check(paymentMethod, Object);\n    PaymentMethodArgument.validate(PaymentMethodArgument.clean(paymentMethod));\n    const result = {\n      saved: false,\n      error: \"Reaction does not yet support direct refund processing from Authorize.net. \" + \"Please visit their web portal to perform this action. https://account.authorize.net/\"\n    };\n    return result;\n  },\n\n  \"authnet/refund/list\"(...args) {\n    check(args, [Match.Any]);\n    Meteor.Error(\"not-implemented\", \"Authorize.net does not yet support retrieving a list of refunds.\");\n    return [];\n  }\n\n});\n\nfunction getAuthnetService(accountOptions) {\n  const {\n    login,\n    tran_key,\n    mode\n  } = accountOptions;\n  return new AuthNetAPI({\n    API_LOGIN_ID: login,\n    TRANSACTION_KEY: tran_key,\n    testMode: !mode\n  });\n}\n\nfunction priorAuthCaptureTransaction(transId, amount, service) {\n  const body = {\n    transactionType: \"priorAuthCaptureTransaction\",\n    amount,\n    refTransId: transId\n  }; // This call returns a Promise to the cb so we need to use Promise.await\n\n  const transactionRequest = service.sendTransactionRequest.call(service, body, trans => trans);\n  return Promise.await(transactionRequest);\n}\n\nfunction voidTransaction(transId, service) {\n  const body = {\n    transactionType: \"voidTransaction\",\n    refTransId: transId\n  }; // This call returns a Promise to the cb so we need to use Promise.await\n\n  const transactionRequest = service.sendTransactionRequest.call(service, body, trans => trans);\n  return Promise.await(transactionRequest);\n}","map":{"version":3,"sources":["imports/plugins/included/payments-authnet/server/methods/authnet.js"],"names":["accounting","module","watch","require","default","v","Meteor","check","Match","Promise","AuthNetAPI","Reaction","Logger","Packages","ValidCardNumber","ValidExpireMonth","ValidExpireYear","ValidCVV","PaymentMethodArgument","getAccountOptions","isPayment","queryConditions","name","shopId","getShopId","enabled","packageData","findOne","settings","ref","authnet","options","login","getSettings","tran_key","Error","valueName","undefined","methods","authnetSubmit","transactionType","cardInfo","paymentInfo","String","cardNumber","expirationYear","expirationMonth","cvv2","error","total","currency","order","amount","creditCard","creditCardNumber","authnetService","getAuthnetService","authnetTransactionFunc","authResult","call","fatal","result","await","message","paymentMethod","Object","validate","clean","transactionId","roundedAmount","parseFloat","toFixed","capturedAmount","captureResult","voidTransaction","responseCode","saved","response","priorAuthCaptureTransaction","Number","args","Any","accountOptions","mode","API_LOGIN_ID","TRANSACTION_KEY","testMode","transId","service","body","refTransId","transactionRequest","sendTransactionRequest","trans"],"mappings":"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","sourcesContent":["/* eslint camelcase: 0 */\n/* eslint quote-props: 0 */\n// meteor modules\nimport accounting from \"accounting-js\";\nimport { Meteor } from \"meteor/meteor\";\nimport { check, Match } from \"meteor/check\";\nimport { Promise } from \"meteor/promise\";\n\nimport AuthNetAPI from \"authorize-net\";\nimport { Reaction, Logger } from \"/server/api\";\nimport { Packages } from \"/lib/collections\";\nimport { ValidCardNumber, ValidExpireMonth, ValidExpireYear, ValidCVV } from \"/lib/api\";\nimport { PaymentMethodArgument } from \"/lib/collections/schemas\";\n\nfunction getAccountOptions(isPayment) {\n  const queryConditions = {\n    name: \"reaction-auth-net\",\n    shopId: Reaction.getShopId()\n  };\n  if (isPayment) {\n    queryConditions.enabled = true;\n  }\n\n  const packageData = Packages.findOne(queryConditions);\n  const { settings } = packageData;\n  const ref = Meteor.settings.authnet;\n  const options = {\n    login: getSettings(settings, ref, \"api_id\"),\n    tran_key: getSettings(settings, ref, \"transaction_key\")\n  };\n\n  if (!options.login) {\n    throw new Meteor.Error(\"invalid-credentials\", \"Invalid Authnet Credentials\");\n  }\n  return options;\n}\n\nfunction getSettings(settings, ref, valueName) {\n  if (settings !== null) {\n    return settings[valueName];\n  } else if (ref !== null) {\n    return ref[valueName];\n  }\n  return undefined;\n}\n\nMeteor.methods({\n  authnetSubmit(transactionType = \"authorizeTransaction\", cardInfo, paymentInfo) {\n    check(transactionType, String);\n    try {\n      check(cardInfo, {\n        cardNumber: ValidCardNumber,\n        expirationYear: ValidExpireYear,\n        expirationMonth: ValidExpireMonth,\n        cvv2: ValidCVV\n      });\n    } catch (error) {\n      throw new Meteor.Error(\"invalid-card-details\", \"Invalid card details\");\n    }\n    check(paymentInfo, {\n      total: String,\n      currency: String\n    });\n\n    const order = {\n      amount: paymentInfo.total\n    };\n    const creditCard = {\n      creditCardNumber: cardInfo.cardNumber,\n      cvv2: cardInfo.cvv2,\n      expirationYear: cardInfo.expirationYear,\n      expirationMonth: cardInfo.expirationMonth\n    };\n    const isPayment = true;\n    const authnetService = getAuthnetService(getAccountOptions(isPayment));\n    const authnetTransactionFunc = authnetService[transactionType];\n    let authResult;\n    if (authnetTransactionFunc) {\n      try {\n        authResult = authnetTransactionFunc.call(\n          authnetService,\n          order,\n          creditCard\n        );\n      } catch (error) {\n        Logger.fatal(error);\n      }\n    } else {\n      throw new Meteor.Error(\"invalid-transaction-type\", \"Invalid Transaction Type\");\n    }\n    try {\n      const result = Promise.await(authResult);\n      return result;\n    } catch (error) {\n      throw new Meteor.Error(\"auth-failed\", error.message);\n    }\n  },\n\n  \"authnet/payment/capture\"(paymentMethod) {\n    // Call both check and validate because by calling `clean`, the audit pkg\n    // thinks that we haven't checked paymentMethod arg\n    check(paymentMethod, Object);\n    PaymentMethodArgument.validate(PaymentMethodArgument.clean(paymentMethod));\n\n    const {\n      transactionId,\n      amount\n    } = paymentMethod;\n\n    const authnetService = getAuthnetService(getAccountOptions());\n    const roundedAmount = parseFloat(amount.toFixed(2));\n    const capturedAmount = accounting.toFixed(amount, 2);\n    let result;\n    if (capturedAmount === accounting.toFixed(0, 2)) {\n      try {\n        const captureResult = voidTransaction(\n          transactionId,\n          authnetService\n        );\n        if (captureResult.responseCode[0] === \"1\") {\n          result = {\n            saved: true,\n            response: captureResult\n          };\n        } else {\n          result = {\n            saved: false,\n            error: captureResult\n          };\n        }\n      } catch (error) {\n        Logger.fatal(error);\n        result = {\n          saved: false,\n          error\n        };\n      }\n      return result;\n    }\n    try {\n      const captureResult = priorAuthCaptureTransaction(\n        transactionId,\n        roundedAmount,\n        authnetService\n      );\n      if (captureResult.responseCode[0] === \"1\") {\n        result = {\n          saved: true,\n          response: captureResult\n        };\n      } else {\n        result = {\n          saved: false,\n          error: captureResult\n        };\n      }\n    } catch (error) {\n      Logger.fatal(error);\n      result = {\n        saved: false,\n        error\n      };\n    }\n    return result;\n  },\n\n  \"authnet/refund/create\"(paymentMethod, amount) {\n    check(amount, Number);\n\n    // Call both check and validate because by calling `clean`, the audit pkg\n    // thinks that we haven't checked paymentMethod arg\n    check(paymentMethod, Object);\n    PaymentMethodArgument.validate(PaymentMethodArgument.clean(paymentMethod));\n\n    const result = {\n      saved: false,\n      error: \"Reaction does not yet support direct refund processing from Authorize.net. \" +\n      \"Please visit their web portal to perform this action. https://account.authorize.net/\"\n    };\n\n    return result;\n  },\n  \"authnet/refund/list\"(...args) {\n    check(args, [Match.Any]);\n    Meteor.Error(\"not-implemented\", \"Authorize.net does not yet support retrieving a list of refunds.\");\n    return [];\n  }\n});\n\nfunction getAuthnetService(accountOptions) {\n  const {\n    login,\n    tran_key,\n    mode\n  } = accountOptions;\n\n  return new AuthNetAPI({\n    API_LOGIN_ID: login,\n    TRANSACTION_KEY: tran_key,\n    testMode: !mode\n  });\n}\n\nfunction priorAuthCaptureTransaction(transId, amount, service) {\n  const body = {\n    transactionType: \"priorAuthCaptureTransaction\",\n    amount,\n    refTransId: transId\n  };\n  // This call returns a Promise to the cb so we need to use Promise.await\n  const transactionRequest = service.sendTransactionRequest.call(service, body, (trans) => trans);\n  return Promise.await(transactionRequest);\n}\n\nfunction voidTransaction(transId, service) {\n  const body = {\n    transactionType: \"voidTransaction\",\n    refTransId: transId\n  };\n  // This call returns a Promise to the cb so we need to use Promise.await\n  const transactionRequest = service.sendTransactionRequest.call(service, body, (trans) => trans);\n  return Promise.await(transactionRequest);\n}\n"]},"sourceType":"script","hash":"716bffb28c65d7f03313775c9b5ea06710fd2647"}
