{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$1$2","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"ast":true,"babelrc":false,"sourceFileName":"server/methods/core/orders.js","filename":"server/methods/core/orders.js","sourceMaps":true,"envName":"development","cwd":"/Users/estebandev/test-knowledge","passPerPreset":false,"presets":[],"parserOpts":{"sourceType":"module","sourceFileName":"server/methods/core/orders.js","plugins":["jsx","jsx","flow","flow","objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties"]},"generatorOpts":{"filename":"server/methods/core/orders.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"server/methods/core/orders.js"}},"code":"var _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/builtin/objectSpread\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nmodule.export({\n  orderCreditMethod: () => orderCreditMethod,\n  orderDebitMethod: () => orderDebitMethod,\n  ordersInventoryAdjust: () => ordersInventoryAdjust,\n  ordersInventoryAdjustByShop: () => ordersInventoryAdjustByShop,\n  orderQuantityAdjust: () => orderQuantityAdjust,\n  methods: () => methods\n});\n\nlet _get;\n\nmodule.watch(require(\"lodash/get\"), {\n  default(v) {\n    _get = v;\n  }\n\n}, 0);\n\nlet _omit;\n\nmodule.watch(require(\"lodash/omit\"), {\n  default(v) {\n    _omit = v;\n  }\n\n}, 1);\nlet accounting;\nmodule.watch(require(\"accounting-js\"), {\n  default(v) {\n    accounting = v;\n  }\n\n}, 2);\nlet Future;\nmodule.watch(require(\"fibers/future\"), {\n  default(v) {\n    Future = v;\n  }\n\n}, 3);\nlet Meteor;\nmodule.watch(require(\"meteor/meteor\"), {\n  Meteor(v) {\n    Meteor = v;\n  }\n\n}, 4);\nlet check, Match;\nmodule.watch(require(\"meteor/check\"), {\n  check(v) {\n    check = v;\n  },\n\n  Match(v) {\n    Match = v;\n  }\n\n}, 5);\nlet SSR;\nmodule.watch(require(\"meteor/meteorhacks:ssr\"), {\n  SSR(v) {\n    SSR = v;\n  }\n\n}, 6);\nlet Orders, Products, Shops, Packages;\nmodule.watch(require(\"../../../lib/collections\"), {\n  Orders(v) {\n    Orders = v;\n  },\n\n  Products(v) {\n    Products = v;\n  },\n\n  Shops(v) {\n    Shops = v;\n  },\n\n  Packages(v) {\n    Packages = v;\n  }\n\n}, 7);\nlet PaymentMethodArgument;\nmodule.watch(require(\"../../../lib/collections/schemas\"), {\n  PaymentMethodArgument(v) {\n    PaymentMethodArgument = v;\n  }\n\n}, 8);\nlet Logger, Hooks, Reaction;\nmodule.watch(require(\"../../api\"), {\n  Logger(v) {\n    Logger = v;\n  },\n\n  Hooks(v) {\n    Hooks = v;\n  },\n\n  Reaction(v) {\n    Reaction = v;\n  }\n\n}, 9);\nlet Media;\nmodule.watch(require(\"../../../imports/plugins/core/files/server\"), {\n  Media(v) {\n    Media = v;\n  }\n\n}, 10);\nlet publishProductInventoryAdjustments;\nmodule.watch(require(\"../../../imports/plugins/core/catalog/server/methods/catalog\"), {\n  publishProductInventoryAdjustments(v) {\n    publishProductInventoryAdjustments = v;\n  }\n\n}, 11);\n\n/**\n * @name getPrimaryMediaForItem\n * @summary Gets the FileRecord for the primary media item associated with the variant or product\n *   for the given item. This is similar to a function in /lib/api/helpers, but that one uses\n *   Media.findOneLocal, which is only for browser code.\n * @param {Object} item Must have `productId` and/or `variantId` set to get back a result.\n * @return {FileRecord|null}\n */\nfunction getPrimaryMediaForItem({\n  productId,\n  variantId\n} = {}) {\n  return Promise.asyncApply(() => {\n    let result;\n\n    if (variantId) {\n      result = Promise.await(Media.findOne({\n        \"metadata.variantId\": variantId\n      }, {\n        sort: {\n          \"metadata.priority\": 1,\n          \"uploadedAt\": 1\n        }\n      }));\n    }\n\n    if (!result && productId) {\n      result = Promise.await(Media.findOne({\n        \"metadata.productId\": productId\n      }, {\n        sort: {\n          \"metadata.priority\": 1,\n          \"uploadedAt\": 1\n        }\n      }));\n    }\n\n    return result || null;\n  });\n}\n/**\n * @name formatDateForEmail\n * @method\n * @private\n * @summary helper to generate the order date as a string for emails\n * @param {Date} date\n * @return {String} return date formatted as a MM/DD/YYYY string\n */\n\n\nfunction formatDateForEmail(date) {\n  const emailDate = new Date(date); // Clone date\n\n  const year = emailDate.getFullYear(); // get year\n\n  const month = emailDate.getMonth() + 1; // get month number + 1 (js has 0 indexed months)\n\n  const day = emailDate.getDate(); // get day number (js has 1 indexed days)\n\n  const paddedMonth = month > 9 ? `${month}` : `0${month}`; // generate padded month if necessary\n\n  const paddedDay = day > 9 ? `${day}` : `0${day}`; // generate padded days if necessary\n\n  return `${paddedMonth}/${paddedDay}/${year}`; // return MM/DD/YYYY formatted string\n}\n/**\n * @file Methods for Orders.\n *\n *\n * @namespace Methods/Orders\n*/\n\n/**\n * @name orderCreditMethod\n * @method\n * @memberof Methods/Orders\n * @summary Helper to return the order credit object.\n * Credit paymentMethod on the order as per current active shop\n * @param  {Object} order order object\n * @return {Object} returns entire payment method\n */\n\n\nfunction orderCreditMethod(order) {\n  const creditBillingRecords = order.billing.filter(value => value.paymentMethod.method === \"credit\");\n  const billingRecord = creditBillingRecords.find(billing => billing.shopId === Reaction.getShopId());\n  return billingRecord;\n}\n\nfunction orderDebitMethod(order) {\n  const debitBillingRecords = order.billing.filter(value => value.paymentMethod.method === \"debit\");\n  const billingRecord = debitBillingRecords.find(billing => billing.shopId === Reaction.getShopId());\n  return billingRecord;\n}\n\nfunction ordersInventoryAdjust(orderId) {\n  check(orderId, String);\n\n  if (!Reaction.hasPermission(\"orders\")) {\n    throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n  }\n\n  const order = Orders.findOne(orderId);\n  order.items.forEach(item => {\n    Products.update({\n      _id: item.variants._id\n    }, {\n      $inc: {\n        inventoryQuantity: -item.quantity\n      }\n    }, {\n      publish: true,\n      selector: {\n        type: \"variant\"\n      }\n    });\n    Hooks.Events.run(\"afterUpdateCatalogProduct\", item.variant); // Publish inventory updates to the Catalog\n\n    publishProductInventoryAdjustments(item.productId);\n  });\n}\n\nfunction ordersInventoryAdjustByShop(orderId, shopId) {\n  check(orderId, String);\n  check(shopId, String);\n\n  if (!Reaction.hasPermission(\"orders\")) {\n    throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n  }\n\n  const order = Orders.findOne(orderId);\n  order.items.forEach(item => {\n    if (item.shopId === shopId) {\n      Products.update({\n        _id: item.variants._id\n      }, {\n        $inc: {\n          inventoryQuantity: -item.quantity\n        }\n      }, {\n        publish: true,\n        selector: {\n          type: \"variant\"\n        }\n      });\n      Hooks.Events.run(\"afterUpdateCatalogProduct\", item.variants); // Publish inventory updates to the Catalog\n\n      publishProductInventoryAdjustments(item.productId);\n    }\n  });\n}\n\nfunction orderQuantityAdjust(orderId, refundedItem) {\n  check(orderId, String);\n\n  if (!Reaction.hasPermission(\"orders\")) {\n    throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n  }\n\n  const order = Orders.findOne(orderId);\n  order.items.forEach(item => {\n    if (item._id === refundedItem.id) {\n      const itemId = item._id;\n      const newQuantity = item.quantity - refundedItem.refundedQuantity;\n      Orders.update({\n        _id: orderId,\n        items: {\n          $elemMatch: {\n            _id: itemId\n          }\n        }\n      }, {\n        $set: {\n          \"items.$.quantity\": newQuantity\n        }\n      });\n    }\n  });\n}\n\nconst methods = {\n  /**\n   * @name orders/shipmentPicked\n   * @method\n   * @memberof Methods/Orders\n   * @summary update picking status\n   * @param {Object} order - order object\n   * @param {Object} shipment - shipment object\n   * @return {Object} return workflow result\n   */\n  \"orders/shipmentPicked\"(order, shipment) {\n    check(order, Object);\n    check(shipment, Object);\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    } // Set the status of the items as picked\n\n\n    const itemIds = shipment.items.map(item => item._id);\n    const result = Meteor.call(\"workflow/pushItemWorkflow\", \"coreOrderItemWorkflow/picked\", order, itemIds);\n\n    if (result === 1) {\n      return Orders.update({\n        \"_id\": order._id,\n        \"shipping._id\": shipment._id\n      }, {\n        $set: {\n          \"shipping.$.workflow.status\": \"coreOrderWorkflow/picked\"\n        },\n        $push: {\n          \"shipping.$.workflow.workflow\": \"coreOrderWorkflow/picked\"\n        }\n      }, {\n        bypassCollection2: true\n      });\n    }\n\n    return result;\n  },\n\n  /**\n   * @name orders/shipmentPacked\n   * @method\n   * @memberof Methods/Orders\n   * @summary update packing status\n   * @param {Object} order - order object\n   * @param {Object} shipment - shipment object\n   * @return {Object} return workflow result\n   */\n  \"orders/shipmentPacked\"(order, shipment) {\n    check(order, Object);\n    check(shipment, Object); // REVIEW: who should have permission to do this in a marketplace setting?\n    // Do we need to update the order schema to reflect multiple packers / shipments?\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    } // Set the status of the items as packed\n\n\n    const itemIds = shipment.items.map(item => item._id);\n    const result = Meteor.call(\"workflow/pushItemWorkflow\", \"coreOrderItemWorkflow/packed\", order, itemIds);\n\n    if (result === 1) {\n      return Orders.update({\n        \"_id\": order._id,\n        \"shipping._id\": shipment._id\n      }, {\n        $set: {\n          \"shipping.$.workflow.status\": \"coreOrderWorkflow/packed\"\n        },\n        $push: {\n          \"shipping.$.workflow.workflow\": \"coreOrderWorkflow/packed\"\n        }\n      }, {\n        bypassCollection2: true\n      });\n    }\n\n    return result;\n  },\n\n  /**\n   * @name orders/shipmentLabeled\n   * @method\n   * @memberof Methods/Orders\n   * @summary update labeling status\n   * @param {Object} order - order object\n   * @param {Object} shipment - shipment object\n   * @return {Object} return workflow result\n   */\n  \"orders/shipmentLabeled\"(order, shipment) {\n    check(order, Object);\n    check(shipment, Object);\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    } // Set the status of the items as labeled\n\n\n    const itemIds = shipment.items.map(item => item._id);\n    const result = Meteor.call(\"workflow/pushItemWorkflow\", \"coreOrderItemWorkflow/labeled\", order, itemIds);\n\n    if (result === 1) {\n      return Orders.update({\n        \"_id\": order._id,\n        \"shipping._id\": shipment._id\n      }, {\n        $set: {\n          \"shipping.$.workflow.status\": \"coreOrderWorkflow/labeled\"\n        },\n        $push: {\n          \"shipping.$.workflow.workflow\": \"coreOrderWorkflow/labeled\"\n        }\n      }, {\n        bypassCollection2: true\n      });\n    }\n\n    return result;\n  },\n\n  /**\n   * @name orders/makeAdjustmentsToInvoice\n   * @method\n   * @memberof Methods/Orders\n   * @summary Update the status of an invoice to allow adjustments to be made\n   * @param {Object} order - order object\n   * @return {Object} Mongo update\n   */\n  \"orders/makeAdjustmentsToInvoice\"(order) {\n    check(order, Object);\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    this.unblock(); // REVIEW: Why unblock here?\n\n    return Orders.update({\n      \"_id\": order._id,\n      \"billing.shopId\": Reaction.getShopId(),\n      \"billing.paymentMethod.method\": \"credit\"\n    }, {\n      $set: {\n        \"billing.$.paymentMethod.status\": \"adjustments\"\n      }\n    });\n  },\n\n  /**\n   * @name orders/approvePayment\n   * @method\n   * @memberof Methods/Orders\n   * @summary Approve payment and apply any adjustments\n   * @param {Object} order - order object\n   * @return {Object} return this.processPayment result\n   */\n  \"orders/approvePayment\"(order) {\n    check(order, Object);\n    const {\n      invoice\n    } = orderCreditMethod(order); // REVIEW: Who should have access to do this for a marketplace?\n    // Do we have/need a shopId on each order?\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    this.unblock(); // REVIEW: why unblock here?\n    // this is server side check to verify\n    // that the math all still adds up.\n\n    const shopId = Reaction.getShopId();\n    const {\n      discounts,\n      shipping,\n      subtotal,\n      taxes\n    } = invoice;\n    const discountTotal = Math.max(0, subtotal - discounts); // ensure no discounting below 0.\n\n    const total = accounting.toFixed(Number(discountTotal) + Number(shipping) + Number(taxes), 2); // Updates flattened inventory count on variants in Products collection\n\n    ordersInventoryAdjustByShop(order._id, shopId);\n    const result = Orders.update({\n      \"_id\": order._id,\n      \"billing.shopId\": shopId,\n      \"billing.paymentMethod.method\": \"credit\"\n    }, {\n      $set: {\n        \"billing.$.paymentMethod.amount\": total,\n        \"billing.$.paymentMethod.status\": \"approved\",\n        \"billing.$.paymentMethod.mode\": \"capture\",\n        \"billing.$.invoice.discounts\": discounts,\n        \"billing.$.invoice.total\": Number(total)\n      }\n    }); // Update search record\n\n    Hooks.Events.run(\"afterUpdateOrderUpdateSearchRecord\", order);\n    return result;\n  },\n\n  /**\n   * @name orders/cancelOrder\n   * @method\n   * @memberof Methods/Orders\n   * @summary Start the cancel order process\n   * @param {Object} order - order object\n   * @param {Boolean} returnToStock - condition to return product to stock\n   * @return {Object} ret\n   */\n  \"orders/cancelOrder\"(order, returnToStock) {\n    check(order, Object);\n    check(returnToStock, Boolean); // REVIEW: Only marketplace admins should be able to cancel entire order?\n    // Unless order is entirely contained in a single shop? Do we need a switch on marketplace owner dashboard?\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    } // Inventory is removed from stock only once an order has been approved\n    // This is indicated by order.billing.$.paymentMethod.status being anything other than `created`\n    // We need to check to make sure the inventory has been removed before we return it to stock\n\n\n    const orderIsApproved = order.billing.find(status => status.paymentMethod.status !== \"created\");\n\n    if (returnToStock && orderIsApproved) {\n      // Run this Product update inline instead of using ordersInventoryAdjust because the collection hooks fail\n      // in some instances which causes the order not to cancel\n      order.items.forEach(item => {\n        if (Reaction.hasPermission(\"orders\", Meteor.userId(), item.shopId)) {\n          Products.update({\n            _id: item.variants._id,\n            shopId: item.shopId\n          }, {\n            $inc: {\n              inventoryQuantity: +item.quantity\n            }\n          }, {\n            bypassCollection2: true,\n            publish: true\n          });\n          Hooks.Events.run(\"afterUpdateCatalogProduct\", item.variants); // Publish inventory updates to the Catalog\n\n          publishProductInventoryAdjustments(item.productId);\n        }\n      });\n    }\n\n    const billingRecord = order.billing.find(billing => billing.shopId === Reaction.getShopId());\n    const shippingRecord = order.shipping.find(shipping => shipping.shopId === Reaction.getShopId());\n    let {\n      paymentMethod\n    } = orderCreditMethod(order);\n    paymentMethod = Object.assign(paymentMethod, {\n      amount: Number(paymentMethod.amount)\n    });\n    const invoiceTotal = billingRecord.invoice.total;\n    const shipment = shippingRecord;\n    const itemIds = shipment.items.map(item => item._id); // refund payment to customer\n\n    const paymentMethodId = paymentMethod && paymentMethod.paymentPackageId;\n    const paymentMethodName = paymentMethod && paymentMethod.paymentSettingsKey;\n    const getPaymentMethod = Packages.findOne({\n      _id: paymentMethodId\n    });\n    const isRefundable = getPaymentMethod && getPaymentMethod.settings && getPaymentMethod.settings[paymentMethodName] && getPaymentMethod.settings[paymentMethodName].support.includes(\"Refund\");\n\n    if (isRefundable) {\n      Meteor.call(\"orders/refunds/create\", order._id, paymentMethod, Number(invoiceTotal));\n    } // send notification to user\n\n\n    const prefix = Reaction.getShopPrefix();\n    const url = `${prefix}/notifications`;\n    const sms = true;\n    Meteor.call(\"notification/send\", order.userId, \"orderCanceled\", url, sms, err => {\n      if (err) Logger.error(err);\n    }); // update item workflow\n\n    Meteor.call(\"workflow/pushItemWorkflow\", \"coreOrderItemWorkflow/canceled\", order, itemIds);\n    return Orders.update({\n      \"_id\": order._id,\n      \"billing.shopId\": Reaction.getShopId(),\n      \"billing.paymentMethod.method\": \"credit\"\n    }, {\n      $set: {\n        \"workflow.status\": \"coreOrderWorkflow/canceled\",\n        \"billing.$.paymentMethod.mode\": \"cancel\"\n      },\n      $push: {\n        \"workflow.workflow\": \"coreOrderWorkflow/canceled\"\n      }\n    });\n  },\n\n  /**\n   * @name orders/processPayment\n   * @method\n   * @memberof Methods/Orders\n   * @summary trigger processPayment and workflow update\n   * @param {Object} order - order object\n   * @return {Object} return this.processPayment result\n   */\n  \"orders/processPayment\"(order) {\n    check(order, Object); // REVIEW: Who should have access to process payment in marketplace?\n    // Probably just the shop owner for now?\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    this.unblock();\n    return Meteor.call(\"orders/processPayments\", order._id, function (error, result) {\n      if (result) {\n        Meteor.call(\"workflow/pushOrderWorkflow\", \"coreOrderWorkflow\", \"coreProcessPayment\", order._id);\n        const shippingRecord = order.shipping.find(shipping => shipping.shopId === Reaction.getShopId()); // Set the status of the items as shipped\n\n        const itemIds = shippingRecord.items.map(item => item._id);\n        Meteor.call(\"workflow/pushItemWorkflow\", \"coreOrderItemWorkflow/captured\", order, itemIds);\n        return this.processPayment(order);\n      }\n\n      return false;\n    });\n  },\n\n  /**\n   * @name orders/shipmentShipped\n   * @method\n   * @memberof Methods/Orders\n   * @summary trigger shipmentShipped status and workflow update\n   * @param {Object} order - order object\n   * @param {Object} shipment - shipment object\n   * @return {Object} return results of several operations\n   */\n  \"orders/shipmentShipped\"(order, shipment) {\n    check(order, Object);\n    check(shipment, Object); // TODO: Who should have access to ship shipments in a marketplace setting\n    // Should be anyone who has product in an order.\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      Logger.error(\"User does not have 'orders' permissions\");\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    this.unblock();\n    let completedItemsResult;\n    let completedOrderResult;\n    const itemIds = shipment.items.map(item => item._id); // TODO: In the future, this could be handled by shipping delivery status\n    // REVIEW: This hook seems to run before the shipment has been marked as shipped\n\n    Hooks.Events.run(\"onOrderShipmentShipped\", order, itemIds);\n    const workflowResult = Meteor.call(\"workflow/pushItemWorkflow\", \"coreOrderItemWorkflow/shipped\", order, itemIds);\n\n    if (workflowResult === 1) {\n      // Move to completed status for items\n      completedItemsResult = Meteor.call(\"workflow/pushItemWorkflow\", \"coreOrderItemWorkflow/completed\", order, itemIds);\n\n      if (completedItemsResult === 1) {\n        // Then try to mark order as completed.\n        completedOrderResult = Meteor.call(\"workflow/pushOrderWorkflow\", \"coreOrderWorkflow\", \"completed\", order);\n      }\n    }\n\n    if (order.email) {\n      Meteor.call(\"orders/sendNotification\", order, \"shipped\");\n    } else {\n      // TODO: add to order history that no email was sent\n      Logger.warn(\"No order email found. No notification sent.\");\n    }\n\n    Orders.update({\n      \"_id\": order._id,\n      \"shipping._id\": shipment._id\n    }, {\n      $set: {\n        \"shipping.$.workflow.status\": \"coreOrderWorkflow/shipped\"\n      },\n      $push: {\n        \"shipping.$.workflow.workflow\": \"coreOrderWorkflow/shipped\"\n      }\n    }, {\n      bypassCollection2: true\n    });\n    return {\n      workflowResult,\n      completedItems: completedItemsResult,\n      completedOrder: completedOrderResult\n    };\n  },\n\n  /**\n   * @name orders/shipmentDelivered\n   * @method\n   * @memberof Methods/Orders\n   * @summary trigger shipmentShipped status and workflow update\n   * @param {Object} order - order object\n   * @return {Object} return workflow result\n   */\n  \"orders/shipmentDelivered\"(order) {\n    check(order, Object); // REVIEW: this should be callable from the server via callback from Shippo or other webhook\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    this.unblock();\n    const shipment = order.shipping.find(shipping => shipping.shopId === Reaction.getShopId());\n\n    if (order.email) {\n      Meteor.call(\"orders/sendNotification\", order, err => {\n        if (err) {\n          Logger.error(err, \"orders/shipmentDelivered: Failed to send notification\");\n        }\n      });\n    } else {\n      Logger.warn(\"No order email found. No notification sent.\");\n    }\n\n    const itemIds = shipment.items.map(item => item._id);\n    Meteor.call(\"workflow/pushItemWorkflow\", \"coreOrderItemWorkflow/delivered\", order, itemIds);\n    Meteor.call(\"workflow/pushItemWorkflow\", \"coreOrderItemWorkflow/completed\", order, itemIds);\n    const isCompleted = order.items.every(item => item.workflow.workflow && item.workflow.workflow.includes(\"coreOrderItemWorkflow/completed\"));\n    Orders.update({\n      \"_id\": order._id,\n      \"shipping._id\": shipment._id\n    }, {\n      $set: {\n        \"shipping.$.workflow.status\": \"coreOrderWorkflow/delivered\"\n      },\n      $push: {\n        \"shipping.$.workflow.workflow\": \"coreOrderWorkflow/delivered\"\n      }\n    }, {\n      bypassCollection2: true\n    });\n\n    if (isCompleted === true) {\n      Hooks.Events.run(\"onOrderShipmentDelivered\", order._id);\n      Meteor.call(\"workflow/pushOrderWorkflow\", \"coreOrderWorkflow\", \"completed\", order);\n      return true;\n    }\n\n    Meteor.call(\"workflow/pushOrderWorkflow\", \"coreOrderWorkflow\", \"processing\", order);\n    return false;\n  },\n\n  /**\n   * @name orders/sendNotification\n   * @method\n   * @memberof Methods/Orders\n   * @summary send order notification email\n   * @param {Object} order - order object\n   * @param {Object} action - send notification action\n   * @return {Boolean} email sent or not\n   */\n  \"orders/sendNotification\"(order, action) {\n    check(order, Object);\n    check(action, Match.OneOf(String, undefined)); // TODO: REVIEW: SECURITY this only checks to see if a userId exists\n\n    if (!this.userId) {\n      Logger.error(\"orders/sendNotification: Access denied\");\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    this.unblock(); // Get Shop information\n\n    const shop = Shops.findOne(order.shopId); // TODO need to make this fully support multi-shop. Now it's just collapsing into one\n    // Get shop logo, if available\n\n    const emailLogo = Reaction.Email.getShopLogo(shop);\n    let subtotal = 0;\n    let shippingCost = 0;\n    let taxes = 0;\n    let discounts = 0;\n    let amount = 0;\n    let address = {};\n    let paymentMethod = {};\n    let shippingAddress = {};\n    let tracking;\n    let carrier = \"\";\n\n    for (const billingRecord of order.billing) {\n      subtotal += Number.parseFloat(billingRecord.invoice.subtotal);\n      taxes += Number.parseFloat(billingRecord.invoice.taxes);\n      discounts += Number.parseFloat(billingRecord.invoice.discounts);\n      amount += billingRecord.paymentMethod.amount;\n      ({\n        address\n      } = billingRecord);\n      ({\n        paymentMethod\n      } = billingRecord);\n    }\n\n    for (const shippingRecord of order.shipping) {\n      shippingAddress = shippingRecord.address;\n      ({\n        tracking\n      } = shippingRecord);\n      const {\n        shipmentMethod\n      } = shippingRecord;\n      ({\n        carrier\n      } = shipmentMethod || {});\n      const {\n        rate\n      } = shipmentMethod || {};\n      shippingCost += rate || 0;\n    }\n\n    const refundResult = Meteor.call(\"orders/refunds/list\", order);\n    const refundTotal = Array.isArray(refundResult) && refundResult.reduce((acc, refund) => acc + refund.amount, 0); // Get user currency formatting from shops collection, remove saved rate\n    // using billing[0] here to get the currency and exchange rate used because\n    // in multishop mode, the currency object is different across shops\n    // and it's inconsistent, i.e. sometimes there's no exchangeRate field in the secondary\n    // shop's currency array.\n    // TODO: Remove billing[0] and properly aquire userCurrency and exchange rate\n\n    const userCurrencyFormatting = _omit(shop.currencies[order.billing[0].currency.userCurrency], [\"enabled\", \"rate\"]); // Get user currency exchange rate at time of transaction\n\n\n    const userCurrencyExchangeRate = order.billing[0].currency.exchangeRate; // Combine same products into single \"product\" for display purposes\n\n    const combinedItems = [];\n\n    if (order) {\n      // Loop through all items in the order. The items are split into indivital items\n      for (const orderItem of order.items) {\n        // Find an exising item in the combinedItems array\n        const foundItem = combinedItems.find(combinedItem => {\n          // If and item variant exists, then we return true\n          if (combinedItem.variants) {\n            return combinedItem.variants._id === orderItem.variants._id;\n          }\n\n          return false;\n        }); // Increment the quantity count for the duplicate product variants\n\n        if (foundItem) {\n          foundItem.quantity += 1;\n        } else {\n          // Otherwise push the unique item into the combinedItems array\n          // Add displayPrice to match user currency settings\n          orderItem.variants.displayPrice = accounting.formatMoney(orderItem.variants.price * userCurrencyExchangeRate, userCurrencyFormatting);\n          combinedItems.push(orderItem); // Placeholder image if there is no product image\n\n          orderItem.placeholderImage = `${Meteor.absoluteUrl()}resources/placeholder.gif`; // variant image\n\n          const variantImage = Promise.await(getPrimaryMediaForItem({\n            productId: orderItem.productId,\n            variantId: orderItem.variants && orderItem.variants._id\n          }));\n\n          if (variantImage) {\n            orderItem.variantImage = variantImage.url({\n              absolute: true,\n              store: \"large\"\n            });\n          } // find a default image\n\n\n          const productImage = Promise.await(getPrimaryMediaForItem({\n            productId: orderItem.productId\n          }));\n\n          if (productImage) {\n            orderItem.productImage = productImage.url({\n              absolute: true,\n              store: \"large\"\n            });\n          }\n        }\n      }\n\n      const copyrightDate = new Date().getFullYear(); // Merge data into single object to pass to email template\n\n      const dataForEmail = {\n        // Shop Data\n        shop,\n        contactEmail: shop.emails[0].address,\n        homepage: Meteor.absoluteUrl(),\n        emailLogo,\n        copyrightDate,\n        legalName: _get(shop, \"addressBook[0].company\"),\n        physicalAddress: {\n          address: `${_get(shop, \"addressBook[0].address1\")} ${_get(shop, \"addressBook[0].address2\")}`,\n          city: _get(shop, \"addressBook[0].city\"),\n          region: _get(shop, \"addressBook[0].region\"),\n          postal: _get(shop, \"addressBook[0].postal\")\n        },\n        shopName: shop.name,\n        socialLinks: {\n          display: true,\n          facebook: {\n            display: true,\n            icon: `${Meteor.absoluteUrl()}resources/email-templates/facebook-icon.png`,\n            link: \"https://www.facebook.com\"\n          },\n          googlePlus: {\n            display: true,\n            icon: `${Meteor.absoluteUrl()}resources/email-templates/google-plus-icon.png`,\n            link: \"https://plus.google.com\"\n          },\n          twitter: {\n            display: true,\n            icon: `${Meteor.absoluteUrl()}resources/email-templates/twitter-icon.png`,\n            link: \"https://www.twitter.com\"\n          }\n        },\n        // Order Data\n        order,\n        billing: {\n          address: {\n            address: `${address.address1}${address.address2 ? ` ${address.address2}` : \"\"}`,\n            city: address.city,\n            region: address.region,\n            postal: address.postal\n          },\n          paymentMethod: paymentMethod.storedCard || paymentMethod.processor,\n          subtotal: accounting.formatMoney(subtotal * userCurrencyExchangeRate, userCurrencyFormatting),\n          shipping: accounting.formatMoney(shippingCost * userCurrencyExchangeRate, userCurrencyFormatting),\n          taxes: accounting.formatMoney(taxes * userCurrencyExchangeRate, userCurrencyFormatting),\n          discounts: accounting.formatMoney(discounts * userCurrencyExchangeRate, userCurrencyFormatting),\n          refunds: accounting.formatMoney(refundTotal * userCurrencyExchangeRate, userCurrencyFormatting),\n          total: accounting.formatMoney((subtotal + shippingCost + taxes - discounts) * userCurrencyExchangeRate, userCurrencyFormatting),\n          adjustedTotal: accounting.formatMoney((amount - refundTotal) * userCurrencyExchangeRate, userCurrencyFormatting)\n        },\n        combinedItems,\n        orderDate: formatDateForEmail(order.createdAt),\n        orderUrl: `cart/completed?_id=${order.cartId}`,\n        shipping: {\n          tracking,\n          carrier,\n          address: {\n            address: `${shippingAddress.address1}${shippingAddress.address2 ? ` ${shippingAddress.address2}` : \"\"}`,\n            city: shippingAddress.city,\n            region: shippingAddress.region,\n            postal: shippingAddress.postal\n          }\n        }\n      };\n      Logger.debug(`orders/sendNotification status: ${order.workflow.status}`); // handle missing root shop email\n\n      if (!shop.emails[0].address) {\n        shop.emails[0].address = \"no-reply@reactioncommerce.com\";\n        Logger.warn(\"No shop email configured. Using no-reply to send mail\");\n      } // anonymous users without emails.\n\n\n      if (!order.email) {\n        const msg = \"No order email found. No notification sent.\";\n        Logger.warn(msg);\n        throw new Meteor.Error(\"email-error\", msg);\n      } // Compile Email with SSR\n\n\n      let subject;\n      let tpl;\n\n      if (action === \"shipped\") {\n        tpl = \"orders/shipped\";\n        subject = \"orders/shipped/subject\";\n      } else if (action === \"refunded\") {\n        tpl = \"orders/refunded\";\n        subject = \"orders/refunded/subject\";\n      } else if (action === \"itemRefund\") {\n        tpl = \"orders/itemRefund\";\n        subject = \"orders/itemRefund/subject\";\n      } else {\n        tpl = `orders/${order.workflow.status}`;\n        subject = `orders/${order.workflow.status}/subject`;\n      }\n\n      SSR.compileTemplate(tpl, Reaction.Email.getTemplate(tpl));\n      SSR.compileTemplate(subject, Reaction.Email.getSubject(tpl));\n      Reaction.Email.send({\n        to: order.email,\n        from: `${shop.name} <${shop.emails[0].address}>`,\n        subject: SSR.render(subject, dataForEmail),\n        html: SSR.render(tpl, dataForEmail)\n      });\n      return true;\n    }\n\n    return false;\n  },\n\n  /**\n   * @name orders/updateShipmentTracking\n   * @summary Adds tracking information to order without workflow update.\n   * Call after any tracking code is generated\n   * @method\n   * @memberof Methods/Orders\n   * @param {Object} order - An Order object\n   * @param {Object} shipment - A Shipment object\n   * @param {String} tracking - tracking id\n   * @return {String} returns order update result\n   */\n  \"orders/updateShipmentTracking\"(order, shipment, tracking) {\n    check(order, Object);\n    check(shipment, Object);\n    check(tracking, String); // REVIEW: This method should be callable from a webhook (e.g. Shippo)\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    return Orders.update({\n      \"_id\": order._id,\n      \"shipping._id\": shipment._id\n    }, {\n      $set: {\n        \"shipping.$.tracking\": tracking\n      }\n    });\n  },\n\n  /**\n   * @name orders/addOrderEmail\n   * @method\n   * @memberof Methods/Orders\n   * @summary Adds email to order, used for guest users\n   * @param {String} cartId - add tracking to orderId\n   * @param {String} email - valid email address\n   * @return {String} returns order update result\n   */\n  \"orders/addOrderEmail\"(cartId, email) {\n    check(cartId, String);\n    check(email, String);\n    /**\n    *Instead of checking the Orders permission, we should check if user is\n    *connected.This is only needed for guest where email is\n    *provided for tracking order progress.\n    */\n\n    if (!Meteor.userId()) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied. You are not connected.\");\n    }\n\n    return Orders.update({\n      cartId\n    }, {\n      $set: {\n        email\n      }\n    });\n  },\n\n  /**\n   * @name orders/updateHistory\n   * @method\n   * @memberof Methods/Orders\n   * @summary adds order history item for tracking and logging order updates\n   * @param {String} orderId - add tracking to orderId\n   * @param {String} event - workflow event\n   * @param {String} value - event value\n   * @return {String} returns order update result\n   */\n  \"orders/updateHistory\"(orderId, event, value) {\n    check(orderId, String);\n    check(event, String);\n    check(value, Match.Optional(String)); // REVIEW: For marketplace implementations\n    // This should be possible for anyone with permission to act on the order\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    return Orders.update(orderId, {\n      $addToSet: {\n        history: {\n          event,\n          value,\n          userId: Meteor.userId(),\n          updatedAt: new Date()\n        }\n      }\n    });\n  },\n\n  /**\n   * @name orders/capturePayments\n   * @summary Finalize any payment where mode is \"authorize\"\n   * and status is \"approved\", reprocess as \"capture\"\n   * @method\n   * @memberof Methods/Orders\n   * @param {String} orderId - add tracking to orderId\n   * @return {null} no return value\n   */\n  \"orders/capturePayments\": orderId => {\n    check(orderId, String); // REVIEW: For marketplace implmentations who should be able to capture payments?\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    const shopId = Reaction.getShopId(); // the shopId of the current user, i.e. merchant\n\n    const order = Orders.findOne(orderId); // find the appropriate shipping record by shop\n\n    const shippingRecord = order.shipping.find(sRecord => sRecord.shopId === shopId);\n    const itemIds = shippingRecord.items.map(item => item._id);\n    Meteor.call(\"workflow/pushItemWorkflow\", \"coreOrderItemWorkflow/captured\", order, itemIds);\n\n    if (order.workflow.status === \"new\") {\n      Meteor.call(\"workflow/pushOrderWorkflow\", \"coreOrderWorkflow\", \"processing\", order);\n    } // process order..payment.paymentMethod\n    // find the billing record based on shopId\n\n\n    const bilingRecord = order.billing.find(bRecord => bRecord.shopId === shopId);\n    const {\n      paymentMethod\n    } = bilingRecord;\n    const {\n      transactionId\n    } = paymentMethod;\n\n    if (paymentMethod.mode === \"capture\" && paymentMethod.status === \"approved\" && paymentMethod.processor) {\n      // Grab the amount from the shipment, otherwise use the original amount\n      const processor = paymentMethod.processor.toLowerCase();\n      let result;\n      let error;\n\n      try {\n        result = Meteor.call(`${processor}/payment/capture`, paymentMethod);\n      } catch (e) {\n        error = e;\n      }\n\n      if (result && result.saved === true) {\n        const metadata = Object.assign(bilingRecord.paymentMethod.metadata || {}, result.metadata || {});\n        Orders.update({\n          \"_id\": orderId,\n          \"billing.paymentMethod.transactionId\": transactionId\n        }, {\n          $set: {\n            \"billing.$.paymentMethod.mode\": \"capture\",\n            \"billing.$.paymentMethod.status\": \"completed\",\n            \"billing.$.paymentMethod.metadata\": metadata\n          },\n          $push: {\n            \"billing.$.paymentMethod.transactions\": result\n          }\n        }); // event onOrderPaymentCaptured used for confirmation hooks\n        // ie: confirmShippingMethodForOrder is triggered here\n\n        Hooks.Events.run(\"onOrderPaymentCaptured\", orderId);\n        return {\n          error,\n          result\n        };\n      }\n\n      if (result && result.error) {\n        Logger.fatal(\"Failed to capture transaction.\", order, paymentMethod.transactionId, result.error);\n      } else {\n        Logger.fatal(\"Failed to capture transaction.\", order, paymentMethod.transactionId, error);\n      }\n\n      Orders.update({\n        \"_id\": orderId,\n        \"billing.paymentMethod.transactionId\": transactionId\n      }, {\n        $set: {\n          \"billing.$.paymentMethod.mode\": \"capture\",\n          \"billing.$.paymentMethod.status\": \"error\"\n        },\n        $push: {\n          \"billing.$.paymentMethod.transactions\": result\n        }\n      });\n      return {\n        error: \"orders/capturePayments: Failed to capture transaction\"\n      };\n    }\n  },\n\n  /**\n   * @name orders/refund/list\n   * @summary loop through order's payments and find existing refunds.\n   * Get a list of refunds for a particular payment method.\n   * @method\n   * @memberof Methods/Orders\n   * @param {Object} order - order object\n   * @return {Array} Array contains refund records\n   */\n  \"orders/refunds/list\"(order) {\n    check(order, Object);\n\n    if (!this.userId === order.userId && !Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    const refunds = [];\n\n    for (const billingRecord of order.billing) {\n      const {\n        paymentMethod\n      } = billingRecord;\n      const processor = paymentMethod.processor.toLowerCase();\n      const shopRefunds = Meteor.call(`${processor}/refund/list`, paymentMethod);\n      refunds.push(...shopRefunds);\n    }\n\n    return refunds;\n  },\n\n  /**\n   * @name orders/refund/create\n   * @method\n   * @memberof Methods/Orders\n   * @summary Apply a refund to an already captured order\n   * @param {String} orderId - order object\n   * @param {Object} paymentMethod - paymentMethod object\n   * @param {Number} amount - Amount of the refund, as a positive number\n   * @param {Bool} sendEmail - Send email confirmation\n   * @return {null} no return value\n   */\n  \"orders/refunds/create\"(orderId, paymentMethod, amount, sendEmail = true) {\n    check(orderId, String);\n    check(amount, Number);\n    check(sendEmail, Match.Optional(Boolean)); // Call both check and validate because by calling `clean`, the audit pkg\n    // thinks that we haven't checked paymentMethod arg\n\n    check(paymentMethod, Object);\n    PaymentMethodArgument.validate(PaymentMethodArgument.clean(paymentMethod)); // REVIEW: For marketplace implementations, who can refund? Just the marketplace?\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    const processor = paymentMethod.processor.toLowerCase();\n    const order = Orders.findOne(orderId);\n    const {\n      transactionId\n    } = paymentMethod;\n    const packageId = paymentMethod.paymentPackageId;\n    const settingsKey = paymentMethod.paymentSettingsKey; // check if payment provider supports de-authorize\n\n    const checkSupportedMethods = Packages.findOne({\n      _id: packageId\n    }).settings[settingsKey].support;\n    const orderMode = paymentMethod.mode;\n    let result;\n    let query = {};\n\n    if (checkSupportedMethods.includes(\"De-authorize\")) {\n      result = Meteor.call(`${processor}/payment/deAuthorize`, paymentMethod, amount);\n      query = {\n        $push: {\n          \"billing.$.paymentMethod.transactions\": result\n        }\n      };\n\n      if (result.saved === false) {\n        Logger.fatal(\"Attempt for de-authorize transaction failed\", order._id, paymentMethod.transactionId, result.error);\n        throw new Meteor.Error(\"Attempt to de-authorize transaction failed\", result.error);\n      }\n    } else if (orderMode === \"capture\") {\n      result = Meteor.call(`${processor}/refund/create`, paymentMethod, amount);\n      query = {\n        $push: {\n          \"billing.$.paymentMethod.transactions\": result\n        }\n      };\n\n      if (result.saved === false) {\n        Logger.fatal(\"Attempt for refund transaction failed\", order._id, paymentMethod.transactionId, result.error);\n        throw new Meteor.Error(\"Attempt to refund transaction failed\", result.error);\n      }\n    }\n\n    Orders.update({\n      \"_id\": orderId,\n      \"billing.shopId\": Reaction.getShopId(),\n      \"billing.paymentMethod.transactionId\": transactionId\n    }, (0, _objectSpread2.default)({\n      $set: {\n        \"billing.$.paymentMethod.status\": \"refunded\"\n      }\n    }, query));\n    Hooks.Events.run(\"onOrderRefundCreated\", orderId); // Send email to notify customer of a refund\n\n    if (checkSupportedMethods.includes(\"De-authorize\")) {\n      Meteor.call(\"orders/sendNotification\", order);\n    } else if (orderMode === \"capture\" && sendEmail) {\n      Meteor.call(\"orders/sendNotification\", order, \"refunded\");\n    }\n  },\n\n  /**\n   * @name orders/refunds/refundItems\n   * @method\n   * @memberof Methods/Orders\n   * @summary Apply a refund to line items\n   * @param {String} orderId - order object\n   * @param {Object} paymentMethod - paymentMethod object\n   * @param {Object} refundItemsInfo - info about refund items\n   * @return {Object} refund boolean and result/error value\n   */\n  \"orders/refunds/refundItems\"(orderId, paymentMethod, refundItemsInfo) {\n    check(orderId, String);\n    check(refundItemsInfo, Object); // Call both check and validate because by calling `clean`, the audit pkg\n    // thinks that we haven't checked paymentMethod arg\n\n    check(paymentMethod, Object);\n    PaymentMethodArgument.validate(PaymentMethodArgument.clean(paymentMethod)); // REVIEW: For marketplace implementations, who can refund? Just the marketplace?\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    const fut = new Future();\n    const order = Orders.findOne(orderId);\n    const {\n      transactionId\n    } = paymentMethod;\n    const amount = refundItemsInfo.total;\n    const {\n      quantity\n    } = refundItemsInfo;\n    const refundItems = refundItemsInfo.items;\n    const originalQuantity = order.items.reduce((acc, item) => acc + item.quantity, 0); // refund payment to customer\n\n    Meteor.call(\"orders/refunds/create\", order._id, paymentMethod, Number(amount), false, (error, result) => {\n      if (error) {\n        Logger.fatal(\"Attempt for refund transaction failed\", order._id, paymentMethod.transactionId, error);\n        fut.return({\n          refund: false,\n          error\n        });\n      }\n\n      if (result) {\n        refundItems.forEach(refundItem => {\n          orderQuantityAdjust(orderId, refundItem);\n        });\n        let refundedStatus = \"refunded\";\n\n        if (quantity < originalQuantity) {\n          refundedStatus = \"partialRefund\";\n        }\n\n        Orders.update({\n          \"_id\": orderId,\n          \"billing.shopId\": Reaction.getShopId(),\n          \"billing.paymentMethod.transactionId\": transactionId\n        }, {\n          $set: {\n            \"billing.$.paymentMethod.status\": refundedStatus\n          }\n        });\n        Meteor.call(\"orders/sendNotification\", order, \"itemRefund\");\n        fut.return({\n          refund: true,\n          result\n        });\n      }\n    });\n    return fut.wait();\n  }\n\n};\nMeteor.methods(methods);","map":{"version":3,"sources":["server/methods/core/orders.js"],"names":["module","export","orderCreditMethod","orderDebitMethod","ordersInventoryAdjust","ordersInventoryAdjustByShop","orderQuantityAdjust","methods","_get","watch","require","default","v","_omit","accounting","Future","Meteor","check","Match","SSR","Orders","Products","Shops","Packages","PaymentMethodArgument","Logger","Hooks","Reaction","Media","publishProductInventoryAdjustments","getPrimaryMediaForItem","productId","variantId","result","findOne","sort","formatDateForEmail","date","emailDate","Date","year","getFullYear","month","getMonth","day","getDate","paddedMonth","paddedDay","order","creditBillingRecords","billing","filter","value","paymentMethod","method","billingRecord","find","shopId","getShopId","debitBillingRecords","orderId","String","hasPermission","Error","items","forEach","item","update","_id","variants","$inc","inventoryQuantity","quantity","publish","selector","type","Events","run","variant","refundedItem","id","itemId","newQuantity","refundedQuantity","$elemMatch","$set","shipment","Object","itemIds","map","call","$push","bypassCollection2","unblock","invoice","discounts","shipping","subtotal","taxes","discountTotal","Math","max","total","toFixed","Number","returnToStock","Boolean","orderIsApproved","status","userId","shippingRecord","assign","amount","invoiceTotal","paymentMethodId","paymentPackageId","paymentMethodName","paymentSettingsKey","getPaymentMethod","isRefundable","settings","support","includes","prefix","getShopPrefix","url","sms","err","error","processPayment","completedItemsResult","completedOrderResult","workflowResult","email","warn","completedItems","completedOrder","isCompleted","every","workflow","action","OneOf","undefined","shop","emailLogo","Email","getShopLogo","shippingCost","address","shippingAddress","tracking","carrier","parseFloat","shipmentMethod","rate","refundResult","refundTotal","Array","isArray","reduce","acc","refund","userCurrencyFormatting","currencies","currency","userCurrency","userCurrencyExchangeRate","exchangeRate","combinedItems","orderItem","foundItem","combinedItem","displayPrice","formatMoney","price","push","placeholderImage","absoluteUrl","variantImage","Promise","await","absolute","store","productImage","copyrightDate","dataForEmail","contactEmail","emails","homepage","legalName","physicalAddress","city","region","postal","shopName","name","socialLinks","display","facebook","icon","link","googlePlus","twitter","address1","address2","storedCard","processor","refunds","adjustedTotal","orderDate","createdAt","orderUrl","cartId","debug","msg","subject","tpl","compileTemplate","getTemplate","getSubject","send","to","from","render","html","event","Optional","$addToSet","history","updatedAt","sRecord","bilingRecord","bRecord","transactionId","mode","toLowerCase","e","saved","metadata","fatal","shopRefunds","sendEmail","validate","clean","packageId","settingsKey","checkSupportedMethods","orderMode","query","refundItemsInfo","fut","refundItems","originalQuantity","return","refundItem","refundedStatus","wait"],"mappings":"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","sourcesContent":["import _ from \"lodash\";\nimport accounting from \"accounting-js\";\nimport Future from \"fibers/future\";\nimport { Meteor } from \"meteor/meteor\";\nimport { check, Match } from \"meteor/check\";\nimport { SSR } from \"meteor/meteorhacks:ssr\";\nimport { Orders, Products, Shops, Packages } from \"/lib/collections\";\nimport { PaymentMethodArgument } from \"/lib/collections/schemas\";\nimport { Logger, Hooks, Reaction } from \"/server/api\";\nimport { Media } from \"/imports/plugins/core/files/server\";\nimport { publishProductInventoryAdjustments } from \"/imports/plugins/core/catalog/server/methods/catalog\";\n\n/**\n * @name getPrimaryMediaForItem\n * @summary Gets the FileRecord for the primary media item associated with the variant or product\n *   for the given item. This is similar to a function in /lib/api/helpers, but that one uses\n *   Media.findOneLocal, which is only for browser code.\n * @param {Object} item Must have `productId` and/or `variantId` set to get back a result.\n * @return {FileRecord|null}\n */\nasync function getPrimaryMediaForItem({ productId, variantId } = {}) {\n  let result;\n\n  if (variantId) {\n    result = await Media.findOne({\n      \"metadata.variantId\": variantId\n    }, { sort: { \"metadata.priority\": 1, \"uploadedAt\": 1 } });\n  }\n\n  if (!result && productId) {\n    result = await Media.findOne({\n      \"metadata.productId\": productId\n    }, { sort: { \"metadata.priority\": 1, \"uploadedAt\": 1 } });\n  }\n\n  return result || null;\n}\n\n/**\n * @name formatDateForEmail\n * @method\n * @private\n * @summary helper to generate the order date as a string for emails\n * @param {Date} date\n * @return {String} return date formatted as a MM/DD/YYYY string\n */\nfunction formatDateForEmail(date) {\n  const emailDate = new Date(date); // Clone date\n  const year = emailDate.getFullYear(); // get year\n  const month = emailDate.getMonth() + 1; // get month number + 1 (js has 0 indexed months)\n  const day = emailDate.getDate(); // get day number (js has 1 indexed days)\n\n  const paddedMonth = month > 9 ? `${month}` : `0${month}`; // generate padded month if necessary\n  const paddedDay = day > 9 ? `${day}` : `0${day}`; // generate padded days if necessary\n\n  return `${paddedMonth}/${paddedDay}/${year}`; // return MM/DD/YYYY formatted string\n}\n\n\n/**\n * @file Methods for Orders.\n *\n *\n * @namespace Methods/Orders\n*/\n\n/**\n * @name orderCreditMethod\n * @method\n * @memberof Methods/Orders\n * @summary Helper to return the order credit object.\n * Credit paymentMethod on the order as per current active shop\n * @param  {Object} order order object\n * @return {Object} returns entire payment method\n */\nexport function orderCreditMethod(order) {\n  const creditBillingRecords = order.billing.filter((value) => value.paymentMethod.method === \"credit\");\n  const billingRecord = creditBillingRecords.find((billing) => billing.shopId === Reaction.getShopId());\n  return billingRecord;\n}\n\n/**\n * @name orderDebitMethod\n * @method\n * @memberof Methods/Orders\n * @summary Helper to return the order debit object\n * @param  {Object} order order object\n * @return {Object} returns entire payment method\n */\nexport function orderDebitMethod(order) {\n  const debitBillingRecords = order.billing.filter((value) => value.paymentMethod.method === \"debit\");\n  const billingRecord = debitBillingRecords.find((billing) => billing.shopId === Reaction.getShopId());\n  return billingRecord;\n}\n\n/**\n * @name ordersInventoryAdjust\n * @method\n * @memberof Methods/Orders\n * @summary Adjust inventory when an order is placed\n * @param {String} orderId - Add tracking to orderId\n * @todo Why are we waiting until someone with orders permissions does something to reduce quantity of\n * ordered items seems like this could cause over ordered items and messed up order quantities pretty easily.\n * @return {null} no return value\n */\nexport function ordersInventoryAdjust(orderId) {\n  check(orderId, String);\n\n  if (!Reaction.hasPermission(\"orders\")) {\n    throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n  }\n\n  const order = Orders.findOne(orderId);\n  order.items.forEach((item) => {\n    Products.update({\n      _id: item.variants._id\n    }, {\n      $inc: {\n        inventoryQuantity: -item.quantity\n      }\n    }, {\n      publish: true,\n      selector: {\n        type: \"variant\"\n      }\n    });\n\n    Hooks.Events.run(\"afterUpdateCatalogProduct\", item.variant);\n\n    // Publish inventory updates to the Catalog\n    publishProductInventoryAdjustments(item.productId);\n  });\n}\n\n/**\n * @name ordersInventoryAdjustByShop\n * @method\n * @memberof Methods/Orders\n * @summary Adjust inventory for a particular shop when an order is approved\n * @todo Marketplace: Is there a reason to do this any other way? Can admins reduce for more than one shop?\n * @param {String} orderId - orderId\n * @param {String} shopId - the id of the shop approving the order\n * @return {null} no return value\n */\nexport function ordersInventoryAdjustByShop(orderId, shopId) {\n  check(orderId, String);\n  check(shopId, String);\n\n  if (!Reaction.hasPermission(\"orders\")) {\n    throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n  }\n\n  const order = Orders.findOne(orderId);\n  order.items.forEach((item) => {\n    if (item.shopId === shopId) {\n      Products.update({\n        _id: item.variants._id\n      }, {\n        $inc: {\n          inventoryQuantity: -item.quantity\n        }\n      }, {\n        publish: true,\n        selector: {\n          type: \"variant\"\n        }\n      });\n\n      Hooks.Events.run(\"afterUpdateCatalogProduct\", item.variants);\n\n      // Publish inventory updates to the Catalog\n      publishProductInventoryAdjustments(item.productId);\n    }\n  });\n}\n\n/**\n * @name orderQuantityAdjust\n * @method\n * @memberof Methods/Orders\n * @param  {String} orderId      orderId\n * @param  {Object} refundedItem refunded item\n * @return {null} no return value\n */\nexport function orderQuantityAdjust(orderId, refundedItem) {\n  check(orderId, String);\n\n  if (!Reaction.hasPermission(\"orders\")) {\n    throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n  }\n\n  const order = Orders.findOne(orderId);\n  order.items.forEach((item) => {\n    if (item._id === refundedItem.id) {\n      const itemId = item._id;\n      const newQuantity = item.quantity - refundedItem.refundedQuantity;\n\n      Orders.update({\n        _id: orderId,\n        items: { $elemMatch: { _id: itemId } }\n      }, {\n        $set: { \"items.$.quantity\": newQuantity }\n      });\n    }\n  });\n}\n\nexport const methods = {\n  /**\n   * @name orders/shipmentPicked\n   * @method\n   * @memberof Methods/Orders\n   * @summary update picking status\n   * @param {Object} order - order object\n   * @param {Object} shipment - shipment object\n   * @return {Object} return workflow result\n   */\n  \"orders/shipmentPicked\"(order, shipment) {\n    check(order, Object);\n    check(shipment, Object);\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    // Set the status of the items as picked\n    const itemIds = shipment.items.map((item) => item._id);\n\n    const result = Meteor.call(\"workflow/pushItemWorkflow\", \"coreOrderItemWorkflow/picked\", order, itemIds);\n    if (result === 1) {\n      return Orders.update({\n        \"_id\": order._id,\n        \"shipping._id\": shipment._id\n      }, {\n        $set: {\n          \"shipping.$.workflow.status\": \"coreOrderWorkflow/picked\"\n        },\n        $push: {\n          \"shipping.$.workflow.workflow\": \"coreOrderWorkflow/picked\"\n        }\n      }, { bypassCollection2: true });\n    }\n    return result;\n  },\n\n  /**\n   * @name orders/shipmentPacked\n   * @method\n   * @memberof Methods/Orders\n   * @summary update packing status\n   * @param {Object} order - order object\n   * @param {Object} shipment - shipment object\n   * @return {Object} return workflow result\n   */\n  \"orders/shipmentPacked\"(order, shipment) {\n    check(order, Object);\n    check(shipment, Object);\n\n    // REVIEW: who should have permission to do this in a marketplace setting?\n    // Do we need to update the order schema to reflect multiple packers / shipments?\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    // Set the status of the items as packed\n    const itemIds = shipment.items.map((item) => item._id);\n\n    const result = Meteor.call(\"workflow/pushItemWorkflow\", \"coreOrderItemWorkflow/packed\", order, itemIds);\n    if (result === 1) {\n      return Orders.update({\n        \"_id\": order._id,\n        \"shipping._id\": shipment._id\n      }, {\n        $set: {\n          \"shipping.$.workflow.status\": \"coreOrderWorkflow/packed\"\n        },\n        $push: {\n          \"shipping.$.workflow.workflow\": \"coreOrderWorkflow/packed\"\n        }\n      }, { bypassCollection2: true });\n    }\n    return result;\n  },\n\n  /**\n   * @name orders/shipmentLabeled\n   * @method\n   * @memberof Methods/Orders\n   * @summary update labeling status\n   * @param {Object} order - order object\n   * @param {Object} shipment - shipment object\n   * @return {Object} return workflow result\n   */\n  \"orders/shipmentLabeled\"(order, shipment) {\n    check(order, Object);\n    check(shipment, Object);\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    // Set the status of the items as labeled\n    const itemIds = shipment.items.map((item) => item._id);\n\n    const result = Meteor.call(\"workflow/pushItemWorkflow\", \"coreOrderItemWorkflow/labeled\", order, itemIds);\n    if (result === 1) {\n      return Orders.update({\n        \"_id\": order._id,\n        \"shipping._id\": shipment._id\n      }, {\n        $set: {\n          \"shipping.$.workflow.status\": \"coreOrderWorkflow/labeled\"\n        },\n        $push: {\n          \"shipping.$.workflow.workflow\": \"coreOrderWorkflow/labeled\"\n        }\n      }, { bypassCollection2: true });\n    }\n    return result;\n  },\n\n  /**\n   * @name orders/makeAdjustmentsToInvoice\n   * @method\n   * @memberof Methods/Orders\n   * @summary Update the status of an invoice to allow adjustments to be made\n   * @param {Object} order - order object\n   * @return {Object} Mongo update\n   */\n  \"orders/makeAdjustmentsToInvoice\"(order) {\n    check(order, Object);\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    this.unblock(); // REVIEW: Why unblock here?\n\n    return Orders.update({\n      \"_id\": order._id,\n      \"billing.shopId\": Reaction.getShopId(),\n      \"billing.paymentMethod.method\": \"credit\"\n    }, {\n      $set: {\n        \"billing.$.paymentMethod.status\": \"adjustments\"\n      }\n    });\n  },\n\n  /**\n   * @name orders/approvePayment\n   * @method\n   * @memberof Methods/Orders\n   * @summary Approve payment and apply any adjustments\n   * @param {Object} order - order object\n   * @return {Object} return this.processPayment result\n   */\n  \"orders/approvePayment\"(order) {\n    check(order, Object);\n    const { invoice } = orderCreditMethod(order);\n\n    // REVIEW: Who should have access to do this for a marketplace?\n    // Do we have/need a shopId on each order?\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    this.unblock(); // REVIEW: why unblock here?\n\n    // this is server side check to verify\n    // that the math all still adds up.\n    const shopId = Reaction.getShopId();\n    const { discounts, shipping, subtotal, taxes } = invoice;\n    const discountTotal = Math.max(0, subtotal - discounts); // ensure no discounting below 0.\n    const total = accounting.toFixed(Number(discountTotal) + Number(shipping) + Number(taxes), 2);\n\n    // Updates flattened inventory count on variants in Products collection\n    ordersInventoryAdjustByShop(order._id, shopId);\n\n    const result = Orders.update({\n      \"_id\": order._id,\n      \"billing.shopId\": shopId,\n      \"billing.paymentMethod.method\": \"credit\"\n    }, {\n      $set: {\n        \"billing.$.paymentMethod.amount\": total,\n        \"billing.$.paymentMethod.status\": \"approved\",\n        \"billing.$.paymentMethod.mode\": \"capture\",\n        \"billing.$.invoice.discounts\": discounts,\n        \"billing.$.invoice.total\": Number(total)\n      }\n    });\n\n    // Update search record\n    Hooks.Events.run(\"afterUpdateOrderUpdateSearchRecord\", order);\n\n    return result;\n  },\n\n  /**\n   * @name orders/cancelOrder\n   * @method\n   * @memberof Methods/Orders\n   * @summary Start the cancel order process\n   * @param {Object} order - order object\n   * @param {Boolean} returnToStock - condition to return product to stock\n   * @return {Object} ret\n   */\n  \"orders/cancelOrder\"(order, returnToStock) {\n    check(order, Object);\n    check(returnToStock, Boolean);\n\n    // REVIEW: Only marketplace admins should be able to cancel entire order?\n    // Unless order is entirely contained in a single shop? Do we need a switch on marketplace owner dashboard?\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    // Inventory is removed from stock only once an order has been approved\n    // This is indicated by order.billing.$.paymentMethod.status being anything other than `created`\n    // We need to check to make sure the inventory has been removed before we return it to stock\n    const orderIsApproved = order.billing.find((status) => status.paymentMethod.status !== \"created\");\n\n    if (returnToStock && orderIsApproved) {\n      // Run this Product update inline instead of using ordersInventoryAdjust because the collection hooks fail\n      // in some instances which causes the order not to cancel\n      order.items.forEach((item) => {\n        if (Reaction.hasPermission(\"orders\", Meteor.userId(), item.shopId)) {\n          Products.update({\n            _id: item.variants._id,\n            shopId: item.shopId\n          }, {\n            $inc: {\n              inventoryQuantity: +item.quantity\n            }\n          }, {\n            bypassCollection2: true,\n            publish: true\n          });\n\n          Hooks.Events.run(\"afterUpdateCatalogProduct\", item.variants);\n\n          // Publish inventory updates to the Catalog\n          publishProductInventoryAdjustments(item.productId);\n        }\n      });\n    }\n\n    const billingRecord = order.billing.find((billing) => billing.shopId === Reaction.getShopId());\n    const shippingRecord = order.shipping.find((shipping) => shipping.shopId === Reaction.getShopId());\n\n    let { paymentMethod } = orderCreditMethod(order);\n    paymentMethod = Object.assign(paymentMethod, { amount: Number(paymentMethod.amount) });\n    const invoiceTotal = billingRecord.invoice.total;\n    const shipment = shippingRecord;\n    const itemIds = shipment.items.map((item) => item._id);\n\n    // refund payment to customer\n    const paymentMethodId = paymentMethod && paymentMethod.paymentPackageId;\n    const paymentMethodName = paymentMethod && paymentMethod.paymentSettingsKey;\n    const getPaymentMethod = Packages.findOne({ _id: paymentMethodId });\n    const isRefundable = getPaymentMethod && getPaymentMethod.settings && getPaymentMethod.settings[paymentMethodName]\n      && getPaymentMethod.settings[paymentMethodName].support.includes(\"Refund\");\n\n    if (isRefundable) {\n      Meteor.call(\"orders/refunds/create\", order._id, paymentMethod, Number(invoiceTotal));\n    }\n\n    // send notification to user\n    const prefix = Reaction.getShopPrefix();\n    const url = `${prefix}/notifications`;\n    const sms = true;\n    Meteor.call(\"notification/send\", order.userId, \"orderCanceled\", url, sms, (err) => {\n      if (err) Logger.error(err);\n    });\n\n    // update item workflow\n    Meteor.call(\"workflow/pushItemWorkflow\", \"coreOrderItemWorkflow/canceled\", order, itemIds);\n\n    return Orders.update({\n      \"_id\": order._id,\n      \"billing.shopId\": Reaction.getShopId(),\n      \"billing.paymentMethod.method\": \"credit\"\n    }, {\n      $set: {\n        \"workflow.status\": \"coreOrderWorkflow/canceled\",\n        \"billing.$.paymentMethod.mode\": \"cancel\"\n      },\n      $push: {\n        \"workflow.workflow\": \"coreOrderWorkflow/canceled\"\n      }\n    });\n  },\n\n  /**\n   * @name orders/processPayment\n   * @method\n   * @memberof Methods/Orders\n   * @summary trigger processPayment and workflow update\n   * @param {Object} order - order object\n   * @return {Object} return this.processPayment result\n   */\n  \"orders/processPayment\"(order) {\n    check(order, Object);\n\n    // REVIEW: Who should have access to process payment in marketplace?\n    // Probably just the shop owner for now?\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    this.unblock();\n\n    return Meteor.call(\"orders/processPayments\", order._id, function (error, result) {\n      if (result) {\n        Meteor.call(\"workflow/pushOrderWorkflow\", \"coreOrderWorkflow\", \"coreProcessPayment\", order._id);\n\n        const shippingRecord = order.shipping.find((shipping) => shipping.shopId === Reaction.getShopId());\n        // Set the status of the items as shipped\n        const itemIds = shippingRecord.items.map((item) => item._id);\n\n        Meteor.call(\"workflow/pushItemWorkflow\", \"coreOrderItemWorkflow/captured\", order, itemIds);\n\n        return this.processPayment(order);\n      }\n      return false;\n    });\n  },\n\n  /**\n   * @name orders/shipmentShipped\n   * @method\n   * @memberof Methods/Orders\n   * @summary trigger shipmentShipped status and workflow update\n   * @param {Object} order - order object\n   * @param {Object} shipment - shipment object\n   * @return {Object} return results of several operations\n   */\n  \"orders/shipmentShipped\"(order, shipment) {\n    check(order, Object);\n    check(shipment, Object);\n\n    // TODO: Who should have access to ship shipments in a marketplace setting\n    // Should be anyone who has product in an order.\n    if (!Reaction.hasPermission(\"orders\")) {\n      Logger.error(\"User does not have 'orders' permissions\");\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    this.unblock();\n\n    let completedItemsResult;\n    let completedOrderResult;\n\n    const itemIds = shipment.items.map((item) => item._id);\n\n    // TODO: In the future, this could be handled by shipping delivery status\n    // REVIEW: This hook seems to run before the shipment has been marked as shipped\n    Hooks.Events.run(\"onOrderShipmentShipped\", order, itemIds);\n    const workflowResult = Meteor.call(\"workflow/pushItemWorkflow\", \"coreOrderItemWorkflow/shipped\", order, itemIds);\n\n    if (workflowResult === 1) {\n      // Move to completed status for items\n      completedItemsResult = Meteor.call(\"workflow/pushItemWorkflow\", \"coreOrderItemWorkflow/completed\", order, itemIds);\n\n      if (completedItemsResult === 1) {\n        // Then try to mark order as completed.\n        completedOrderResult = Meteor.call(\"workflow/pushOrderWorkflow\", \"coreOrderWorkflow\", \"completed\", order);\n      }\n    }\n\n    if (order.email) {\n      Meteor.call(\"orders/sendNotification\", order, \"shipped\");\n    } else {\n      // TODO: add to order history that no email was sent\n      Logger.warn(\"No order email found. No notification sent.\");\n    }\n\n    Orders.update({\n      \"_id\": order._id,\n      \"shipping._id\": shipment._id\n    }, {\n      $set: {\n        \"shipping.$.workflow.status\": \"coreOrderWorkflow/shipped\"\n      },\n      $push: {\n        \"shipping.$.workflow.workflow\": \"coreOrderWorkflow/shipped\"\n      }\n    }, { bypassCollection2: true });\n\n    return {\n      workflowResult,\n      completedItems: completedItemsResult,\n      completedOrder: completedOrderResult\n    };\n  },\n\n  /**\n   * @name orders/shipmentDelivered\n   * @method\n   * @memberof Methods/Orders\n   * @summary trigger shipmentShipped status and workflow update\n   * @param {Object} order - order object\n   * @return {Object} return workflow result\n   */\n  \"orders/shipmentDelivered\"(order) {\n    check(order, Object);\n\n    // REVIEW: this should be callable from the server via callback from Shippo or other webhook\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    this.unblock();\n\n    const shipment = order.shipping.find((shipping) => shipping.shopId === Reaction.getShopId());\n\n    if (order.email) {\n      Meteor.call(\"orders/sendNotification\", order, (err) => {\n        if (err) {\n          Logger.error(err, \"orders/shipmentDelivered: Failed to send notification\");\n        }\n      });\n    } else {\n      Logger.warn(\"No order email found. No notification sent.\");\n    }\n\n    const itemIds = shipment.items.map((item) => item._id);\n\n    Meteor.call(\"workflow/pushItemWorkflow\", \"coreOrderItemWorkflow/delivered\", order, itemIds);\n    Meteor.call(\"workflow/pushItemWorkflow\", \"coreOrderItemWorkflow/completed\", order, itemIds);\n\n    const isCompleted = order.items.every((item) => item.workflow.workflow && item.workflow.workflow.includes(\"coreOrderItemWorkflow/completed\"));\n\n    Orders.update({\n      \"_id\": order._id,\n      \"shipping._id\": shipment._id\n    }, {\n      $set: {\n        \"shipping.$.workflow.status\": \"coreOrderWorkflow/delivered\"\n      },\n      $push: {\n        \"shipping.$.workflow.workflow\": \"coreOrderWorkflow/delivered\"\n      }\n    }, { bypassCollection2: true });\n\n    if (isCompleted === true) {\n      Hooks.Events.run(\"onOrderShipmentDelivered\", order._id);\n      Meteor.call(\"workflow/pushOrderWorkflow\", \"coreOrderWorkflow\", \"completed\", order);\n      return true;\n    }\n\n    Meteor.call(\"workflow/pushOrderWorkflow\", \"coreOrderWorkflow\", \"processing\", order);\n\n    return false;\n  },\n\n  /**\n   * @name orders/sendNotification\n   * @method\n   * @memberof Methods/Orders\n   * @summary send order notification email\n   * @param {Object} order - order object\n   * @param {Object} action - send notification action\n   * @return {Boolean} email sent or not\n   */\n  \"orders/sendNotification\"(order, action) {\n    check(order, Object);\n    check(action, Match.OneOf(String, undefined));\n\n    // TODO: REVIEW: SECURITY this only checks to see if a userId exists\n    if (!this.userId) {\n      Logger.error(\"orders/sendNotification: Access denied\");\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    this.unblock();\n\n    // Get Shop information\n    const shop = Shops.findOne(order.shopId);\n    // TODO need to make this fully support multi-shop. Now it's just collapsing into one\n    // Get shop logo, if available\n    const emailLogo = Reaction.Email.getShopLogo(shop);\n\n    let subtotal = 0;\n    let shippingCost = 0;\n    let taxes = 0;\n    let discounts = 0;\n    let amount = 0;\n    let address = {};\n    let paymentMethod = {};\n    let shippingAddress = {};\n    let tracking;\n    let carrier = \"\";\n\n    for (const billingRecord of order.billing) {\n      subtotal += Number.parseFloat(billingRecord.invoice.subtotal);\n      taxes += Number.parseFloat(billingRecord.invoice.taxes);\n      discounts += Number.parseFloat(billingRecord.invoice.discounts);\n      amount += billingRecord.paymentMethod.amount;\n      ({ address } = billingRecord);\n      ({ paymentMethod } = billingRecord);\n    }\n\n    for (const shippingRecord of order.shipping) {\n      shippingAddress = shippingRecord.address;\n      ({ tracking } = shippingRecord);\n      const { shipmentMethod } = shippingRecord;\n      ({ carrier } = shipmentMethod || {});\n      const { rate } = shipmentMethod || {};\n      shippingCost += rate || 0;\n    }\n\n    const refundResult = Meteor.call(\"orders/refunds/list\", order);\n    const refundTotal = Array.isArray(refundResult) && refundResult.reduce((acc, refund) => acc + refund.amount, 0);\n\n    // Get user currency formatting from shops collection, remove saved rate\n    // using billing[0] here to get the currency and exchange rate used because\n    // in multishop mode, the currency object is different across shops\n    // and it's inconsistent, i.e. sometimes there's no exchangeRate field in the secondary\n    // shop's currency array.\n    // TODO: Remove billing[0] and properly aquire userCurrency and exchange rate\n    const userCurrencyFormatting = _.omit(shop.currencies[order.billing[0].currency.userCurrency], [\"enabled\", \"rate\"]);\n\n    // Get user currency exchange rate at time of transaction\n    const userCurrencyExchangeRate = order.billing[0].currency.exchangeRate;\n\n    // Combine same products into single \"product\" for display purposes\n    const combinedItems = [];\n    if (order) {\n      // Loop through all items in the order. The items are split into indivital items\n      for (const orderItem of order.items) {\n        // Find an exising item in the combinedItems array\n        const foundItem = combinedItems.find((combinedItem) => {\n          // If and item variant exists, then we return true\n          if (combinedItem.variants) {\n            return combinedItem.variants._id === orderItem.variants._id;\n          }\n\n          return false;\n        });\n\n        // Increment the quantity count for the duplicate product variants\n        if (foundItem) {\n          foundItem.quantity += 1;\n        } else {\n          // Otherwise push the unique item into the combinedItems array\n\n          // Add displayPrice to match user currency settings\n          orderItem.variants.displayPrice = accounting.formatMoney(orderItem.variants.price * userCurrencyExchangeRate, userCurrencyFormatting);\n\n          combinedItems.push(orderItem);\n\n          // Placeholder image if there is no product image\n          orderItem.placeholderImage = `${Meteor.absoluteUrl()}resources/placeholder.gif`;\n\n          // variant image\n          const variantImage = Promise.await(getPrimaryMediaForItem({\n            productId: orderItem.productId,\n            variantId: orderItem.variants && orderItem.variants._id\n          }));\n          if (variantImage) {\n            orderItem.variantImage = variantImage.url({ absolute: true, store: \"large\" });\n          }\n\n          // find a default image\n          const productImage = Promise.await(getPrimaryMediaForItem({ productId: orderItem.productId }));\n          if (productImage) {\n            orderItem.productImage = productImage.url({ absolute: true, store: \"large\" });\n          }\n        }\n      }\n\n      const copyrightDate = new Date().getFullYear();\n\n      // Merge data into single object to pass to email template\n      const dataForEmail = {\n        // Shop Data\n        shop,\n        contactEmail: shop.emails[0].address,\n        homepage: Meteor.absoluteUrl(),\n        emailLogo,\n        copyrightDate,\n        legalName: _.get(shop, \"addressBook[0].company\"),\n        physicalAddress: {\n          address: `${_.get(shop, \"addressBook[0].address1\")} ${_.get(shop, \"addressBook[0].address2\")}`,\n          city: _.get(shop, \"addressBook[0].city\"),\n          region: _.get(shop, \"addressBook[0].region\"),\n          postal: _.get(shop, \"addressBook[0].postal\")\n        },\n        shopName: shop.name,\n        socialLinks: {\n          display: true,\n          facebook: {\n            display: true,\n            icon: `${Meteor.absoluteUrl()}resources/email-templates/facebook-icon.png`,\n            link: \"https://www.facebook.com\"\n          },\n          googlePlus: {\n            display: true,\n            icon: `${Meteor.absoluteUrl()}resources/email-templates/google-plus-icon.png`,\n            link: \"https://plus.google.com\"\n          },\n          twitter: {\n            display: true,\n            icon: `${Meteor.absoluteUrl()}resources/email-templates/twitter-icon.png`,\n            link: \"https://www.twitter.com\"\n          }\n        },\n        // Order Data\n        order,\n        billing: {\n          address: {\n            address: `${address.address1}${address.address2 ? ` ${address.address2}` : \"\"}`,\n            city: address.city,\n            region: address.region,\n            postal: address.postal\n          },\n          paymentMethod: paymentMethod.storedCard || paymentMethod.processor,\n          subtotal: accounting.formatMoney(subtotal * userCurrencyExchangeRate, userCurrencyFormatting),\n          shipping: accounting.formatMoney(shippingCost * userCurrencyExchangeRate, userCurrencyFormatting),\n          taxes: accounting.formatMoney(taxes * userCurrencyExchangeRate, userCurrencyFormatting),\n          discounts: accounting.formatMoney(discounts * userCurrencyExchangeRate, userCurrencyFormatting),\n          refunds: accounting.formatMoney(refundTotal * userCurrencyExchangeRate, userCurrencyFormatting),\n          total: accounting.formatMoney((subtotal + shippingCost + taxes - discounts) * userCurrencyExchangeRate, userCurrencyFormatting),\n          adjustedTotal: accounting.formatMoney((amount - refundTotal) * userCurrencyExchangeRate, userCurrencyFormatting)\n        },\n        combinedItems,\n        orderDate: formatDateForEmail(order.createdAt),\n        orderUrl: `cart/completed?_id=${order.cartId}`,\n        shipping: {\n          tracking,\n          carrier,\n          address: {\n            address: `${shippingAddress.address1}${shippingAddress.address2 ? ` ${shippingAddress.address2}` : \"\"}`,\n            city: shippingAddress.city,\n            region: shippingAddress.region,\n            postal: shippingAddress.postal\n          }\n        }\n      };\n\n      Logger.debug(`orders/sendNotification status: ${order.workflow.status}`);\n\n\n      // handle missing root shop email\n      if (!shop.emails[0].address) {\n        shop.emails[0].address = \"no-reply@reactioncommerce.com\";\n        Logger.warn(\"No shop email configured. Using no-reply to send mail\");\n      }\n\n      // anonymous users without emails.\n      if (!order.email) {\n        const msg = \"No order email found. No notification sent.\";\n        Logger.warn(msg);\n        throw new Meteor.Error(\"email-error\", msg);\n      }\n\n      // Compile Email with SSR\n      let subject;\n      let tpl;\n\n      if (action === \"shipped\") {\n        tpl = \"orders/shipped\";\n        subject = \"orders/shipped/subject\";\n      } else if (action === \"refunded\") {\n        tpl = \"orders/refunded\";\n        subject = \"orders/refunded/subject\";\n      } else if (action === \"itemRefund\") {\n        tpl = \"orders/itemRefund\";\n        subject = \"orders/itemRefund/subject\";\n      } else {\n        tpl = `orders/${order.workflow.status}`;\n        subject = `orders/${order.workflow.status}/subject`;\n      }\n\n      SSR.compileTemplate(tpl, Reaction.Email.getTemplate(tpl));\n      SSR.compileTemplate(subject, Reaction.Email.getSubject(tpl));\n\n      Reaction.Email.send({\n        to: order.email,\n        from: `${shop.name} <${shop.emails[0].address}>`,\n        subject: SSR.render(subject, dataForEmail),\n        html: SSR.render(tpl, dataForEmail)\n      });\n\n      return true;\n    }\n    return false;\n  },\n\n  /**\n   * @name orders/updateShipmentTracking\n   * @summary Adds tracking information to order without workflow update.\n   * Call after any tracking code is generated\n   * @method\n   * @memberof Methods/Orders\n   * @param {Object} order - An Order object\n   * @param {Object} shipment - A Shipment object\n   * @param {String} tracking - tracking id\n   * @return {String} returns order update result\n   */\n  \"orders/updateShipmentTracking\"(order, shipment, tracking) {\n    check(order, Object);\n    check(shipment, Object);\n    check(tracking, String);\n\n    // REVIEW: This method should be callable from a webhook (e.g. Shippo)\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    return Orders.update({\n      \"_id\": order._id,\n      \"shipping._id\": shipment._id\n    }, {\n      $set: {\n        \"shipping.$.tracking\": tracking\n      }\n    });\n  },\n\n  /**\n   * @name orders/addOrderEmail\n   * @method\n   * @memberof Methods/Orders\n   * @summary Adds email to order, used for guest users\n   * @param {String} cartId - add tracking to orderId\n   * @param {String} email - valid email address\n   * @return {String} returns order update result\n   */\n  \"orders/addOrderEmail\"(cartId, email) {\n    check(cartId, String);\n    check(email, String);\n    /**\n    *Instead of checking the Orders permission, we should check if user is\n    *connected.This is only needed for guest where email is\n    *provided for tracking order progress.\n    */\n\n    if (!Meteor.userId()) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied. You are not connected.\");\n    }\n\n    return Orders.update({ cartId }, { $set: { email } });\n  },\n\n  /**\n   * @name orders/updateHistory\n   * @method\n   * @memberof Methods/Orders\n   * @summary adds order history item for tracking and logging order updates\n   * @param {String} orderId - add tracking to orderId\n   * @param {String} event - workflow event\n   * @param {String} value - event value\n   * @return {String} returns order update result\n   */\n  \"orders/updateHistory\"(orderId, event, value) {\n    check(orderId, String);\n    check(event, String);\n    check(value, Match.Optional(String));\n\n    // REVIEW: For marketplace implementations\n    // This should be possible for anyone with permission to act on the order\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    return Orders.update(orderId, {\n      $addToSet: {\n        history: {\n          event,\n          value,\n          userId: Meteor.userId(),\n          updatedAt: new Date()\n        }\n      }\n    });\n  },\n\n  /**\n   * @name orders/capturePayments\n   * @summary Finalize any payment where mode is \"authorize\"\n   * and status is \"approved\", reprocess as \"capture\"\n   * @method\n   * @memberof Methods/Orders\n   * @param {String} orderId - add tracking to orderId\n   * @return {null} no return value\n   */\n  \"orders/capturePayments\": (orderId) => {\n    check(orderId, String);\n    // REVIEW: For marketplace implmentations who should be able to capture payments?\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n    const shopId = Reaction.getShopId(); // the shopId of the current user, i.e. merchant\n    const order = Orders.findOne(orderId);\n    // find the appropriate shipping record by shop\n    const shippingRecord = order.shipping.find((sRecord) => sRecord.shopId === shopId);\n    const itemIds = shippingRecord.items.map((item) => item._id);\n\n    Meteor.call(\"workflow/pushItemWorkflow\", \"coreOrderItemWorkflow/captured\", order, itemIds);\n\n    if (order.workflow.status === \"new\") {\n      Meteor.call(\"workflow/pushOrderWorkflow\", \"coreOrderWorkflow\", \"processing\", order);\n    }\n\n    // process order..payment.paymentMethod\n    // find the billing record based on shopId\n    const bilingRecord = order.billing.find((bRecord) => bRecord.shopId === shopId);\n\n    const { paymentMethod } = bilingRecord;\n    const { transactionId } = paymentMethod;\n\n    if (paymentMethod.mode === \"capture\" && paymentMethod.status === \"approved\" && paymentMethod.processor) {\n      // Grab the amount from the shipment, otherwise use the original amount\n      const processor = paymentMethod.processor.toLowerCase();\n\n      let result;\n      let error;\n      try {\n        result = Meteor.call(`${processor}/payment/capture`, paymentMethod);\n      } catch (e) {\n        error = e;\n      }\n\n      if (result && result.saved === true) {\n        const metadata = Object.assign(bilingRecord.paymentMethod.metadata || {}, result.metadata || {});\n\n        Orders.update({\n          \"_id\": orderId,\n          \"billing.paymentMethod.transactionId\": transactionId\n        }, {\n          $set: {\n            \"billing.$.paymentMethod.mode\": \"capture\",\n            \"billing.$.paymentMethod.status\": \"completed\",\n            \"billing.$.paymentMethod.metadata\": metadata\n          },\n          $push: {\n            \"billing.$.paymentMethod.transactions\": result\n          }\n        });\n\n        // event onOrderPaymentCaptured used for confirmation hooks\n        // ie: confirmShippingMethodForOrder is triggered here\n        Hooks.Events.run(\"onOrderPaymentCaptured\", orderId);\n        return { error, result };\n      }\n\n      if (result && result.error) {\n        Logger.fatal(\"Failed to capture transaction.\", order, paymentMethod.transactionId, result.error);\n      } else {\n        Logger.fatal(\"Failed to capture transaction.\", order, paymentMethod.transactionId, error);\n      }\n\n      Orders.update({\n        \"_id\": orderId,\n        \"billing.paymentMethod.transactionId\": transactionId\n      }, {\n        $set: {\n          \"billing.$.paymentMethod.mode\": \"capture\",\n          \"billing.$.paymentMethod.status\": \"error\"\n        },\n        $push: {\n          \"billing.$.paymentMethod.transactions\": result\n        }\n      });\n\n      return { error: \"orders/capturePayments: Failed to capture transaction\" };\n    }\n  },\n\n  /**\n   * @name orders/refund/list\n   * @summary loop through order's payments and find existing refunds.\n   * Get a list of refunds for a particular payment method.\n   * @method\n   * @memberof Methods/Orders\n   * @param {Object} order - order object\n   * @return {Array} Array contains refund records\n   */\n  \"orders/refunds/list\"(order) {\n    check(order, Object);\n\n    if (!this.userId === order.userId && !Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    const refunds = [];\n    for (const billingRecord of order.billing) {\n      const { paymentMethod } = billingRecord;\n      const processor = paymentMethod.processor.toLowerCase();\n      const shopRefunds = Meteor.call(`${processor}/refund/list`, paymentMethod);\n      refunds.push(...shopRefunds);\n    }\n    return refunds;\n  },\n\n  /**\n   * @name orders/refund/create\n   * @method\n   * @memberof Methods/Orders\n   * @summary Apply a refund to an already captured order\n   * @param {String} orderId - order object\n   * @param {Object} paymentMethod - paymentMethod object\n   * @param {Number} amount - Amount of the refund, as a positive number\n   * @param {Bool} sendEmail - Send email confirmation\n   * @return {null} no return value\n   */\n  \"orders/refunds/create\"(orderId, paymentMethod, amount, sendEmail = true) {\n    check(orderId, String);\n    check(amount, Number);\n    check(sendEmail, Match.Optional(Boolean));\n\n    // Call both check and validate because by calling `clean`, the audit pkg\n    // thinks that we haven't checked paymentMethod arg\n    check(paymentMethod, Object);\n    PaymentMethodArgument.validate(PaymentMethodArgument.clean(paymentMethod));\n\n    // REVIEW: For marketplace implementations, who can refund? Just the marketplace?\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n    const processor = paymentMethod.processor.toLowerCase();\n    const order = Orders.findOne(orderId);\n    const { transactionId } = paymentMethod;\n\n    const packageId = paymentMethod.paymentPackageId;\n    const settingsKey = paymentMethod.paymentSettingsKey;\n    // check if payment provider supports de-authorize\n    const checkSupportedMethods = Packages.findOne({\n      _id: packageId\n    }).settings[settingsKey].support;\n\n    const orderMode = paymentMethod.mode;\n\n    let result;\n    let query = {};\n    if (checkSupportedMethods.includes(\"De-authorize\")) {\n      result = Meteor.call(`${processor}/payment/deAuthorize`, paymentMethod, amount);\n      query = {\n        $push: {\n          \"billing.$.paymentMethod.transactions\": result\n        }\n      };\n\n      if (result.saved === false) {\n        Logger.fatal(\"Attempt for de-authorize transaction failed\", order._id, paymentMethod.transactionId, result.error);\n        throw new Meteor.Error(\"Attempt to de-authorize transaction failed\", result.error);\n      }\n    } else if (orderMode === \"capture\") {\n      result = Meteor.call(`${processor}/refund/create`, paymentMethod, amount);\n      query = {\n        $push: {\n          \"billing.$.paymentMethod.transactions\": result\n        }\n      };\n\n      if (result.saved === false) {\n        Logger.fatal(\"Attempt for refund transaction failed\", order._id, paymentMethod.transactionId, result.error);\n        throw new Meteor.Error(\"Attempt to refund transaction failed\", result.error);\n      }\n    }\n\n    Orders.update({\n      \"_id\": orderId,\n      \"billing.shopId\": Reaction.getShopId(),\n      \"billing.paymentMethod.transactionId\": transactionId\n    }, {\n      $set: {\n        \"billing.$.paymentMethod.status\": \"refunded\"\n      },\n      ...query\n    });\n\n    Hooks.Events.run(\"onOrderRefundCreated\", orderId);\n\n    // Send email to notify customer of a refund\n    if (checkSupportedMethods.includes(\"De-authorize\")) {\n      Meteor.call(\"orders/sendNotification\", order);\n    } else if (orderMode === \"capture\" && sendEmail) {\n      Meteor.call(\"orders/sendNotification\", order, \"refunded\");\n    }\n  },\n\n  /**\n   * @name orders/refunds/refundItems\n   * @method\n   * @memberof Methods/Orders\n   * @summary Apply a refund to line items\n   * @param {String} orderId - order object\n   * @param {Object} paymentMethod - paymentMethod object\n   * @param {Object} refundItemsInfo - info about refund items\n   * @return {Object} refund boolean and result/error value\n   */\n  \"orders/refunds/refundItems\"(orderId, paymentMethod, refundItemsInfo) {\n    check(orderId, String);\n    check(refundItemsInfo, Object);\n\n    // Call both check and validate because by calling `clean`, the audit pkg\n    // thinks that we haven't checked paymentMethod arg\n    check(paymentMethod, Object);\n    PaymentMethodArgument.validate(PaymentMethodArgument.clean(paymentMethod));\n\n    // REVIEW: For marketplace implementations, who can refund? Just the marketplace?\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    const fut = new Future();\n    const order = Orders.findOne(orderId);\n    const { transactionId } = paymentMethod;\n    const amount = refundItemsInfo.total;\n    const { quantity } = refundItemsInfo;\n    const refundItems = refundItemsInfo.items;\n    const originalQuantity = order.items.reduce((acc, item) => acc + item.quantity, 0);\n\n    // refund payment to customer\n    Meteor.call(\"orders/refunds/create\", order._id, paymentMethod, Number(amount), false, (error, result) => {\n      if (error) {\n        Logger.fatal(\"Attempt for refund transaction failed\", order._id, paymentMethod.transactionId, error);\n        fut.return({\n          refund: false,\n          error\n        });\n      }\n      if (result) {\n        refundItems.forEach((refundItem) => {\n          orderQuantityAdjust(orderId, refundItem);\n        });\n\n        let refundedStatus = \"refunded\";\n\n        if (quantity < originalQuantity) {\n          refundedStatus = \"partialRefund\";\n        }\n\n        Orders.update({\n          \"_id\": orderId,\n          \"billing.shopId\": Reaction.getShopId(),\n          \"billing.paymentMethod.transactionId\": transactionId\n        }, {\n          $set: {\n            \"billing.$.paymentMethod.status\": refundedStatus\n          }\n        });\n\n        Meteor.call(\"orders/sendNotification\", order, \"itemRefund\");\n\n        fut.return({\n          refund: true,\n          result\n        });\n      }\n    });\n    return fut.wait();\n  }\n};\n\nMeteor.methods(methods);\n"]},"sourceType":"script","hash":"b9575f4239d5bcf9df01d140228029a04bf14009"}
