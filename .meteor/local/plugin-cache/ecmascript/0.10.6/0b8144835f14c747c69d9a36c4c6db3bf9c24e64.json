{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$1$2","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"ast":true,"babelrc":false,"sourceFileName":"imports/plugins/included/discount-codes/server/methods/methods.js","filename":"imports/plugins/included/discount-codes/server/methods/methods.js","sourceMaps":true,"envName":"development","cwd":"/Users/estebandev/test-knowledge","passPerPreset":false,"presets":[],"parserOpts":{"sourceType":"module","sourceFileName":"imports/plugins/included/discount-codes/server/methods/methods.js","plugins":["jsx","jsx","flow","flow","objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties"]},"generatorOpts":{"filename":"imports/plugins/included/discount-codes/server/methods/methods.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"imports/plugins/included/discount-codes/server/methods/methods.js"}},"code":"module.export({\n  methods: () => methods\n});\nlet Meteor;\nmodule.watch(require(\"meteor/meteor\"), {\n  Meteor(v) {\n    Meteor = v;\n  }\n\n}, 0);\nlet Match, check;\nmodule.watch(require(\"meteor/check\"), {\n  Match(v) {\n    Match = v;\n  },\n\n  check(v) {\n    check = v;\n  }\n\n}, 1);\nlet Random;\nmodule.watch(require(\"meteor/random\"), {\n  Random(v) {\n    Random = v;\n  }\n\n}, 2);\nlet Reaction, Hooks;\nmodule.watch(require(\"../../../../../../server/api\"), {\n  Reaction(v) {\n    Reaction = v;\n  },\n\n  Hooks(v) {\n    Hooks = v;\n  }\n\n}, 3);\nlet Cart;\nmodule.watch(require(\"../../../../../../lib/collections\"), {\n  Cart(v) {\n    Cart = v;\n  }\n\n}, 4);\nlet Discounts;\nmodule.watch(require(\"../../../../core/discounts/lib/collections\"), {\n  Discounts(v) {\n    Discounts = v;\n  }\n\n}, 5);\nlet DiscountSchema;\nmodule.watch(require(\"../../lib/collections/schemas\"), {\n  DiscountCodes(v) {\n    DiscountSchema = v;\n  }\n\n}, 6);\n// attach discount code specific schema\nDiscounts.attachSchema(DiscountSchema, {\n  selector: {\n    discountMethod: \"code\"\n  }\n}); //\n// make all discount methods available\n//\n\nconst methods = {\n  /**\n   * discounts/codes/discount\n   * calculates percentage off discount rates\n   * we intentionally passed ids, instead\n   * of the cart,discount Object\n   * for a smaller request providing an\n   * additional level of validation.\n   * @param  {String} cartId cartId\n   * @param  {String} discountId discountId\n   * @return {Number} returns discount total\n   */\n  \"discounts/codes/discount\"(cartId, discountId) {\n    check(cartId, String);\n    check(discountId, String);\n    let discount = 0;\n    const discountMethod = Discounts.findOne(discountId);\n    const cart = Cart.findOne(cartId);\n\n    for (const item of cart.items) {\n      const preDiscount = item.quantity * item.variants.price;\n      discount += preDiscount * discountMethod.discount / 100;\n    }\n\n    return discount;\n  },\n\n  /**\n   * TODO discounts/codes/credit\n   * calculates a credit off cart\n   * for discount codes\n   * @param  {String} cartId cartId\n   * @param  {String} discountId discountId\n   * @return {Number} returns discount total\n   */\n  \"discounts/codes/credit\"(cartId, discountId) {\n    check(cartId, String);\n    check(discountId, String);\n    let discount = 0;\n    const discountMethod = Discounts.findOne(discountId);\n    ({\n      discount\n    } = discountMethod);\n    return discount;\n  },\n\n  /**\n   * TODO discounts/codes/sale\n   * calculates a new price for an item\n   * @param  {String} cartId cartId\n   * @param  {String} discountId discountId\n   * @return {Number} returns discount total\n   */\n  \"discounts/codes/sale\"(cartId, discountId) {\n    check(cartId, String);\n    check(discountId, String);\n    let discount = 0;\n    const discountMethod = Discounts.findOne(discountId);\n    const cart = Cart.findOne(cartId); // TODO add item specific conditions to sale calculations.\n\n    for (const item of cart.items) {\n      const preDiscountItemTotal = item.quantity * item.variants.price;\n      const salePriceItemTotal = item.quantity * discountMethod.discount; // we if the sale is below 0, we won't discount at all. that's invalid.\n\n      discount += Math.max(0, preDiscountItemTotal - salePriceItemTotal);\n    }\n\n    return discount;\n  },\n\n  /**\n   * TODO discounts/codes/shipping\n   * calculates a discount based on the value\n   * of a calculated shipping rate in the cart.\n   * @param  {String} cartId cartId\n   * @param  {String} discountId discountId\n   * @return {Number} returns discount total\n   */\n  \"discounts/codes/shipping\"(cartId, discountId) {\n    check(cartId, String);\n    check(discountId, String);\n    let discount = 0;\n    const discountMethod = Discounts.findOne(discountId);\n    const cart = Cart.findOne(cartId);\n\n    if (cart.shipping && cart.shipping.length) {\n      for (const shipping of cart.shipping) {\n        if (shipping.shipmentMethod && shipping.shipmentMethod.name.toUpperCase() === discountMethod.discount.toUpperCase()) {\n          discount += Math.max(0, shipping.shipmentMethod.rate);\n        }\n      }\n    }\n\n    return discount;\n  },\n\n  /**\n   * @name discounts/addCode\n   * @method\n   * @param  {Object} doc A Discounts document to be inserted\n   * @param  {String} [docId] DEPRECATED. Existing ID to trigger an update. Use discounts/editCode method instead.\n   * @return {String} Insert result\n   */\n  \"discounts/addCode\"(doc, docId) {\n    check(doc, Object); // actual schema validation happens during insert below\n    // Backward compatibility\n\n    check(docId, Match.Optional(String));\n    if (docId) return Meteor.call(\"discounts/editCode\", {\n      _id: docId,\n      modifier: doc\n    });\n    if (!Reaction.hasPermission(\"discount-codes\")) throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    return Discounts.insert(doc);\n  },\n\n  /**\n   * @name discounts/editCode\n   * @method\n   * @param  {Object} details An object with _id and modifier props\n   * @return {String} Update result\n   */\n  \"discounts/editCode\"(details) {\n    check(details, {\n      _id: String,\n      modifier: Object // actual schema validation happens during update below\n\n    });\n    if (!Reaction.hasPermission(\"discount-codes\")) throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    const {\n      _id,\n      modifier\n    } = details;\n    return Discounts.update(_id, modifier);\n  },\n\n  /**\n   * discounts/codes/remove\n   * removes discounts that have been previously applied\n   * to a cart.\n   * @param  {String} id cart id of which to remove a code\n   * @param  {String} codeId discount Id from cart.billing\n   * @param  {String} collection collection (either Orders or Cart)\n   * @return {String} returns update/insert result\n   */\n  \"discounts/codes/remove\"(id, codeId, collection = \"Cart\") {\n    check(id, String);\n    check(codeId, String);\n    check(collection, String);\n    const Collection = Reaction.Collections[collection]; //\n    // delete code from cart\n    //\n\n    const cart = Collection.findOne(id);\n    let hasInvoice = false;\n    let currentDiscount = 0;\n\n    for (const billing of cart.billing) {\n      if (billing.paymentMethod && billing.paymentMethod.processor === \"code\" && billing._id !== codeId) {\n        currentDiscount += parseFloat(billing.paymentMethod.amount);\n      }\n\n      if (billing.paymentMethod && billing.invoice) {\n        hasInvoice = true;\n      }\n    } // only if this is an order\n\n\n    if (hasInvoice) {\n      const selector = {\n        \"_id\": id,\n        \"billing._id\": cart.billing[0]._id\n      };\n      const update = {\n        $set: {\n          \"billing.$.invoice.discounts\": currentDiscount\n        }\n      };\n      Collection.update(selector, update);\n    } // TODO: update a history record of transaction\n\n\n    const result = Collection.update({\n      _id: id\n    }, {\n      $set: {\n        discount: currentDiscount\n      },\n      $pull: {\n        billing: {\n          _id: codeId\n        }\n      }\n    }, {\n      multi: true\n    }); // calculate discounts\n\n    Hooks.Events.run(\"afterCartUpdateCalculateDiscount\", id);\n    return result;\n  },\n\n  /**\n   * discounts/codes/apply\n   * checks validity of code conditions and then\n   * applies a discount as a paymentMethod to cart\n   * @param  {String} id cart/order id of which to remove a code\n   * @param  {String} code valid discount code\n   * @param  {String} collection collection (either Orders or Cart)\n   * @return {Boolean} returns true if successfully applied\n   */\n  \"discounts/codes/apply\"(id, code, collection = \"Cart\") {\n    check(id, String);\n    check(code, String);\n    check(collection, String);\n    let userCount = 0;\n    let orderCount = 0; // TODO: further expand to meet all condition rules\n    // const conditions = {\n    //   enabled: true\n    // };\n    // check to ensure discounts can only apply to single shop carts\n    // TODO: Remove this check after implementation of shop-by-shop discounts\n\n    const Collection = Reaction.Collections[collection];\n    const objectToApplyDiscount = Collection.findOne({\n      _id: id\n    });\n    const items = objectToApplyDiscount && objectToApplyDiscount.items; // loop through all items and filter down to unique shops (in order to get participating shops in the order/cart)\n\n    const uniqueShopObj = items.reduce((shopObj, item) => {\n      if (!shopObj[item.shopId]) {\n        shopObj[item.shopId] = true;\n      }\n\n      return shopObj;\n    }, {});\n    const participatingShops = Object.keys(uniqueShopObj);\n\n    if (participatingShops.length > 1) {\n      throw new Meteor.Error(\"not-implemented\", \"discounts.multiShopError\", \"Discounts cannot be applied to a multi-shop cart or order\");\n    } // TODO: add  conditions: conditions\n\n\n    const discount = Discounts.findOne({\n      code\n    }); // TODO: check usage limit\n    // don't apply if cart has exceeded usage limit\n    // will also need to check all time usage.\n    // which means storing the use data with the Discounts\n    // or searching all user's order history\n    // and if a user cancels an order,\n    // is the discount now re-activated\n\n    if (discount) {\n      const {\n        conditions\n      } = discount;\n      let accountLimitExceeded = false;\n      let discountLimitExceeded = false; // existing usage count\n\n      if (discount.transactions) {\n        const users = Array.from(discount.transactions, t => t.userId);\n        const transactionCount = new Map([...new Set(users)].map(x => [x, users.filter(y => y === x).length]));\n        const orders = Array.from(discount.transactions, t => t.cartId);\n        userCount = transactionCount.get(Meteor.userId());\n        orderCount = orders.length;\n      } // check limits\n\n\n      if (conditions) {\n        if (conditions.accountLimit) accountLimitExceeded = conditions.accountLimit <= userCount;\n        if (conditions.redemptionLimit) discountLimitExceeded = conditions.redemptionLimit <= orderCount;\n      } // validate basic limit handling\n\n\n      if (accountLimitExceeded === true || discountLimitExceeded === true) {\n        return {\n          i18nKeyLabel: \"Code is expired\",\n          i18nKey: \"discounts.codeIsExpired\"\n        };\n      } // save to payment methods\n      // and update status in Discounts\n      // payment methods can be debit or credit.\n\n\n      const paymentMethod = {\n        id: discount._id,\n        processor: discount.discountMethod,\n        method: discount.calculation.method,\n        code: discount.code,\n        transactionId: Random.id(),\n        amount: discount.discount,\n        // pre-process to amount.\n        status: \"created\"\n      };\n      return Meteor.call(\"payments/apply\", id, paymentMethod, collection);\n    }\n  }\n\n};\n// export methods to Meteor\nMeteor.methods(methods);","map":{"version":3,"sources":["imports/plugins/included/discount-codes/server/methods/methods.js"],"names":["module","export","methods","Meteor","watch","require","v","Match","check","Random","Reaction","Hooks","Cart","Discounts","DiscountSchema","DiscountCodes","attachSchema","selector","discountMethod","cartId","discountId","String","discount","findOne","cart","item","items","preDiscount","quantity","variants","price","preDiscountItemTotal","salePriceItemTotal","Math","max","shipping","length","shipmentMethod","name","toUpperCase","rate","doc","docId","Object","Optional","call","_id","modifier","hasPermission","Error","insert","details","update","id","codeId","collection","Collection","Collections","hasInvoice","currentDiscount","billing","paymentMethod","processor","parseFloat","amount","invoice","$set","result","$pull","multi","Events","run","code","userCount","orderCount","objectToApplyDiscount","uniqueShopObj","reduce","shopObj","shopId","participatingShops","keys","conditions","accountLimitExceeded","discountLimitExceeded","transactions","users","Array","from","t","userId","transactionCount","Map","Set","map","x","filter","y","orders","get","accountLimit","redemptionLimit","i18nKeyLabel","i18nKey","method","calculation","transactionId","status"],"mappings":"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","sourcesContent":["import { Meteor } from \"meteor/meteor\";\nimport { Match, check } from \"meteor/check\";\nimport { Random } from \"meteor/random\";\nimport { Reaction, Hooks } from \"/server/api\";\nimport { Cart } from \"/lib/collections\";\nimport { Discounts } from \"/imports/plugins/core/discounts/lib/collections\";\nimport { DiscountCodes as DiscountSchema } from \"../../lib/collections/schemas\";\n\n// attach discount code specific schema\nDiscounts.attachSchema(DiscountSchema, { selector: { discountMethod: \"code\" } });\n\n//\n// make all discount methods available\n//\nexport const methods = {\n  /**\n   * discounts/codes/discount\n   * calculates percentage off discount rates\n   * we intentionally passed ids, instead\n   * of the cart,discount Object\n   * for a smaller request providing an\n   * additional level of validation.\n   * @param  {String} cartId cartId\n   * @param  {String} discountId discountId\n   * @return {Number} returns discount total\n   */\n  \"discounts/codes/discount\"(cartId, discountId) {\n    check(cartId, String);\n    check(discountId, String);\n    let discount = 0;\n    const discountMethod = Discounts.findOne(discountId);\n    const cart = Cart.findOne(cartId);\n\n    for (const item of cart.items) {\n      const preDiscount = item.quantity * item.variants.price;\n      discount += preDiscount * discountMethod.discount / 100;\n    }\n\n    return discount;\n  },\n  /**\n   * TODO discounts/codes/credit\n   * calculates a credit off cart\n   * for discount codes\n   * @param  {String} cartId cartId\n   * @param  {String} discountId discountId\n   * @return {Number} returns discount total\n   */\n  \"discounts/codes/credit\"(cartId, discountId) {\n    check(cartId, String);\n    check(discountId, String);\n    let discount = 0;\n    const discountMethod = Discounts.findOne(discountId);\n    ({ discount } = discountMethod);\n    return discount;\n  },\n  /**\n   * TODO discounts/codes/sale\n   * calculates a new price for an item\n   * @param  {String} cartId cartId\n   * @param  {String} discountId discountId\n   * @return {Number} returns discount total\n   */\n  \"discounts/codes/sale\"(cartId, discountId) {\n    check(cartId, String);\n    check(discountId, String);\n    let discount = 0;\n    const discountMethod = Discounts.findOne(discountId);\n    const cart = Cart.findOne(cartId);\n\n    // TODO add item specific conditions to sale calculations.\n    for (const item of cart.items) {\n      const preDiscountItemTotal = item.quantity * item.variants.price;\n      const salePriceItemTotal = item.quantity * discountMethod.discount;\n      // we if the sale is below 0, we won't discount at all. that's invalid.\n      discount += Math.max(0, preDiscountItemTotal - salePriceItemTotal);\n    }\n\n    return discount;\n  },\n  /**\n   * TODO discounts/codes/shipping\n   * calculates a discount based on the value\n   * of a calculated shipping rate in the cart.\n   * @param  {String} cartId cartId\n   * @param  {String} discountId discountId\n   * @return {Number} returns discount total\n   */\n  \"discounts/codes/shipping\"(cartId, discountId) {\n    check(cartId, String);\n    check(discountId, String);\n    let discount = 0;\n    const discountMethod = Discounts.findOne(discountId);\n    const cart = Cart.findOne(cartId);\n    if (cart.shipping && cart.shipping.length) {\n      for (const shipping of cart.shipping) {\n        if (shipping.shipmentMethod && shipping.shipmentMethod.name.toUpperCase() === discountMethod.discount.toUpperCase()) {\n          discount += Math.max(0, shipping.shipmentMethod.rate);\n        }\n      }\n    }\n    return discount;\n  },\n\n  /**\n   * @name discounts/addCode\n   * @method\n   * @param  {Object} doc A Discounts document to be inserted\n   * @param  {String} [docId] DEPRECATED. Existing ID to trigger an update. Use discounts/editCode method instead.\n   * @return {String} Insert result\n   */\n  \"discounts/addCode\"(doc, docId) {\n    check(doc, Object); // actual schema validation happens during insert below\n\n    // Backward compatibility\n    check(docId, Match.Optional(String));\n    if (docId) return Meteor.call(\"discounts/editCode\", { _id: docId, modifier: doc });\n\n    if (!Reaction.hasPermission(\"discount-codes\")) throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    return Discounts.insert(doc);\n  },\n\n  /**\n   * @name discounts/editCode\n   * @method\n   * @param  {Object} details An object with _id and modifier props\n   * @return {String} Update result\n   */\n  \"discounts/editCode\"(details) {\n    check(details, {\n      _id: String,\n      modifier: Object // actual schema validation happens during update below\n    });\n    if (!Reaction.hasPermission(\"discount-codes\")) throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    const { _id, modifier } = details;\n    return Discounts.update(_id, modifier);\n  },\n\n  /**\n   * discounts/codes/remove\n   * removes discounts that have been previously applied\n   * to a cart.\n   * @param  {String} id cart id of which to remove a code\n   * @param  {String} codeId discount Id from cart.billing\n   * @param  {String} collection collection (either Orders or Cart)\n   * @return {String} returns update/insert result\n   */\n  \"discounts/codes/remove\"(id, codeId, collection = \"Cart\") {\n    check(id, String);\n    check(codeId, String);\n    check(collection, String);\n    const Collection = Reaction.Collections[collection];\n    //\n    // delete code from cart\n    //\n    const cart = Collection.findOne(id);\n    let hasInvoice = false;\n    let currentDiscount = 0;\n    for (const billing of cart.billing) {\n      if (billing.paymentMethod && billing.paymentMethod.processor === \"code\" && billing._id !== codeId) {\n        currentDiscount += parseFloat(billing.paymentMethod.amount);\n      }\n      if (billing.paymentMethod && billing.invoice) {\n        hasInvoice = true;\n      }\n    }\n    // only if this is an order\n    if (hasInvoice) {\n      const selector = {\n        \"_id\": id,\n        \"billing._id\": cart.billing[0]._id\n      };\n      const update = {\n        $set: {\n          \"billing.$.invoice.discounts\": currentDiscount\n        }\n      };\n      Collection.update(selector, update);\n    }\n    // TODO: update a history record of transaction\n    const result = Collection.update(\n      { _id: id },\n      { $set: { discount: currentDiscount }, $pull: { billing: { _id: codeId } } },\n      { multi: true }\n    );\n\n    // calculate discounts\n    Hooks.Events.run(\"afterCartUpdateCalculateDiscount\", id);\n\n    return result;\n  },\n  /**\n   * discounts/codes/apply\n   * checks validity of code conditions and then\n   * applies a discount as a paymentMethod to cart\n   * @param  {String} id cart/order id of which to remove a code\n   * @param  {String} code valid discount code\n   * @param  {String} collection collection (either Orders or Cart)\n   * @return {Boolean} returns true if successfully applied\n   */\n  \"discounts/codes/apply\"(id, code, collection = \"Cart\") {\n    check(id, String);\n    check(code, String);\n    check(collection, String);\n    let userCount = 0;\n    let orderCount = 0;\n\n    // TODO: further expand to meet all condition rules\n    // const conditions = {\n    //   enabled: true\n    // };\n\n    // check to ensure discounts can only apply to single shop carts\n    // TODO: Remove this check after implementation of shop-by-shop discounts\n    const Collection = Reaction.Collections[collection];\n    const objectToApplyDiscount = Collection.findOne({ _id: id });\n    const items = objectToApplyDiscount && objectToApplyDiscount.items;\n    // loop through all items and filter down to unique shops (in order to get participating shops in the order/cart)\n    const uniqueShopObj = items.reduce((shopObj, item) => {\n      if (!shopObj[item.shopId]) {\n        shopObj[item.shopId] = true;\n      }\n      return shopObj;\n    }, {});\n    const participatingShops = Object.keys(uniqueShopObj);\n\n    if (participatingShops.length > 1) {\n      throw new Meteor.Error(\"not-implemented\", \"discounts.multiShopError\", \"Discounts cannot be applied to a multi-shop cart or order\");\n    }\n\n    // TODO: add  conditions: conditions\n    const discount = Discounts.findOne({ code });\n\n    // TODO: check usage limit\n    // don't apply if cart has exceeded usage limit\n    // will also need to check all time usage.\n    // which means storing the use data with the Discounts\n    // or searching all user's order history\n    // and if a user cancels an order,\n    // is the discount now re-activated\n\n    if (discount) {\n      const { conditions } = discount;\n      let accountLimitExceeded = false;\n      let discountLimitExceeded = false;\n\n      // existing usage count\n      if (discount.transactions) {\n        const users = Array.from(discount.transactions, (t) => t.userId);\n        const transactionCount = new Map([...new Set(users)].map((x) => [x, users.filter((y) => y === x).length]));\n        const orders = Array.from(discount.transactions, (t) => t.cartId);\n        userCount = transactionCount.get(Meteor.userId());\n        orderCount = orders.length;\n      }\n      // check limits\n      if (conditions) {\n        if (conditions.accountLimit) accountLimitExceeded = conditions.accountLimit <= userCount;\n        if (conditions.redemptionLimit) discountLimitExceeded = conditions.redemptionLimit <= orderCount;\n      }\n\n      // validate basic limit handling\n      if (accountLimitExceeded === true || discountLimitExceeded === true) {\n        return { i18nKeyLabel: \"Code is expired\", i18nKey: \"discounts.codeIsExpired\" };\n      }\n\n      // save to payment methods\n      // and update status in Discounts\n      // payment methods can be debit or credit.\n      const paymentMethod = {\n        id: discount._id,\n        processor: discount.discountMethod,\n        method: discount.calculation.method,\n        code: discount.code,\n        transactionId: Random.id(),\n        amount: discount.discount, // pre-process to amount.\n        status: \"created\"\n      };\n      return Meteor.call(\"payments/apply\", id, paymentMethod, collection);\n    }\n  }\n};\n\n// export methods to Meteor\nMeteor.methods(methods);\n"]},"sourceType":"script","hash":"0b8144835f14c747c69d9a36c4c6db3bf9c24e64"}
