{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$1$2","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"ast":true,"babelrc":false,"sourceFileName":"imports/plugins/core/taxes/server/methods/methods.js","filename":"imports/plugins/core/taxes/server/methods/methods.js","sourceMaps":true,"envName":"development","cwd":"/Users/estebandev/test-knowledge","passPerPreset":false,"presets":[],"parserOpts":{"sourceType":"module","sourceFileName":"imports/plugins/core/taxes/server/methods/methods.js","plugins":["jsx","jsx","flow","flow","objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties"]},"generatorOpts":{"filename":"imports/plugins/core/taxes/server/methods/methods.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"imports/plugins/core/taxes/server/methods/methods.js"}},"code":"module.export({\n  methods: () => methods\n});\nlet Meteor;\nmodule.watch(require(\"meteor/meteor\"), {\n  Meteor(v) {\n    Meteor = v;\n  }\n\n}, 0);\nlet Match, check;\nmodule.watch(require(\"meteor/check\"), {\n  Match(v) {\n    Match = v;\n  },\n\n  check(v) {\n    check = v;\n  }\n\n}, 1);\nlet Cart, Packages;\nmodule.watch(require(\"../../../../../../lib/collections\"), {\n  Cart(v) {\n    Cart = v;\n  },\n\n  Packages(v) {\n    Packages = v;\n  }\n\n}, 2);\nlet Taxes;\nmodule.watch(require(\"../../lib/collections\"), {\n  Taxes(v) {\n    Taxes = v;\n  }\n\n}, 3);\nlet Reaction;\nmodule.watch(require(\"../api\"), {\n  default(v) {\n    Reaction = v;\n  }\n\n}, 4);\nlet Logger;\nmodule.watch(require(\"../../../../../../server/api\"), {\n  Logger(v) {\n    Logger = v;\n  }\n\n}, 5);\nconst methods = {\n  /**\n   * @name taxes/deleteRate\n   * @method\n   * @memberof Methods/Taxes\n   * @param  {String} taxId tax taxId to delete\n   * @return {String} returns update/insert result\n   */\n  \"taxes/deleteRate\"(taxId) {\n    check(taxId, String); // check permissions to delete\n\n    if (!Reaction.hasPermission(\"taxes\")) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    return Taxes.remove(taxId);\n  },\n\n  /**\n   * @name taxes/addRate\n   * @method\n   * @memberof Methods/Taxes\n   * @param  {Object} doc A Taxes document to be inserted\n   * @param  {String} [docId] DEPRECATED. Existing ID to trigger an update. Use taxes/editRate method instead.\n   * @return {String} Insert result\n   */\n  \"taxes/addRate\"(doc, docId) {\n    check(doc, Object); // actual schema validation happens during insert below\n    // Backward compatibility\n\n    check(docId, Match.Optional(String));\n    if (docId) return Meteor.call(\"taxes/editRate\", {\n      _id: docId,\n      modifier: doc\n    });\n    if (!Reaction.hasPermission(\"taxes\")) throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    return Taxes.insert(doc);\n  },\n\n  /**\n   * @name taxes/editRate\n   * @method\n   * @memberof Methods/Taxes\n   * @param  {Object} details An object with _id and modifier props\n   * @return {String} Update result\n   */\n  \"taxes/editRate\"(details) {\n    check(details, {\n      _id: String,\n      modifier: Object // actual schema validation happens during update below\n\n    });\n    if (!Reaction.hasPermission(\"taxes\")) throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    const {\n      _id,\n      modifier\n    } = details;\n    return Taxes.update(_id, modifier);\n  },\n\n  /**\n   * @name taxes/setRate\n   * @summary Update the cart without hooks\n   * @method\n   * @memberof Methods/Taxes\n   * @param  {String} cartId cartId\n   * @param  {Number} taxRate taxRate\n   * @param  {Object} taxes taxes\n   * @return {Number} returns update result\n   */\n  \"taxes/setRate\"(cartId, taxRate, taxes) {\n    check(cartId, String);\n    check(taxRate, Number);\n    check(taxes, Match.Optional(Array));\n    return Cart.update(cartId, {\n      $set: {\n        taxes,\n        tax: taxRate\n      }\n    });\n  },\n\n  /**\n   * @name taxes/setRateByShopAndItem\n   * @method\n   * @memberof Methods/Taxes\n   * @summary Update the cart without hooks\n   * @param  {String} cartId cartId\n   * @param  {Object} options - Options object\n   * @param  {Object} options.taxRatesByShop - Object shopIds: taxRates\n   * @param  {Array}  options.itemsWithTax - Items array with computed tax details\n   * @param  {Object} options.cartTaxRate - Tax rate for shop associated with cart.shopId\n   * @param  {Object} options.cartTaxData - Tax data for shop associated with cart.shopId\n   * @return {Number} returns update result\n   */\n  \"taxes/setRateByShopAndItem\"(cartId, options) {\n    check(cartId, String);\n    check(options, {\n      taxRatesByShop: Object,\n      itemsWithTax: [Object],\n      cartTaxRate: Number,\n      cartTaxData: Match.OneOf([Object], undefined, null)\n    });\n    const {\n      cartTaxData,\n      cartTaxRate,\n      itemsWithTax,\n      taxRatesByShop\n    } = options;\n    return Cart.update(cartId, {\n      $set: {\n        taxes: cartTaxData,\n        tax: cartTaxRate,\n        items: itemsWithTax,\n        taxRatesByShop\n      }\n    });\n  },\n\n  /**\n   * @name taxes/calculate\n   * @method\n   * @memberof Methods/Taxes\n   * @param  {String} cartId cartId\n   * @return {Object}  returns tax object\n   */\n  \"taxes/calculate\"(cartId) {\n    check(cartId, String);\n    const cartToCalc = Cart.findOne(cartId);\n    const cartShopId = cartToCalc.shopId;\n    let cartTaxRate = 0; // TODO: Calculate shipping taxes for regions that require it\n\n    const pkg = Packages.findOne({\n      shopId: cartShopId,\n      name: \"reaction-taxes\"\n    }); //\n    // custom rates\n    // TODO Determine calculation method (row, total, shipping)\n    // TODO method for order tax updates\n    // additional logic will be needed for refunds\n    // or tax adjustments\n    //\n    // check if plugin is enabled and this calculation method is enabled\n\n    if (pkg && pkg.enabled === true && pkg.settings.rates.enabled === true) {\n      Logger.debug(\"Calculating custom tax rates\");\n\n      if (typeof cartToCalc.shipping !== \"undefined\" && typeof cartToCalc.items !== \"undefined\") {\n        const shippingAddress = cartToCalc.shipping[0].address;\n        let totalTax = 0; // custom rates that match shipping info\n        // high chance this needs more review as\n        // it's unlikely this matches all potential\n        // here we just sort by postal, so if it's an exact\n        // match we're taking the first record, where the most\n        // likely tax scenario is a postal code falling\n        // back to a regional tax.\n\n        if (shippingAddress) {\n          // Get tax rates by shop\n          const taxDataByShop = cartToCalc.items.reduce((uniqueShopTaxRates, item) => {\n            // lookup custom tax rate for each shop once\n            if (!uniqueShopTaxRates[item.shopId]) {\n              uniqueShopTaxRates[item.shopId] = Taxes.findOne({\n                $and: [{\n                  $or: [{\n                    postal: shippingAddress.postal\n                  }, {\n                    postal: {\n                      $exists: false\n                    },\n                    region: shippingAddress.region,\n                    country: shippingAddress.country\n                  }, {\n                    postal: {\n                      $exists: false\n                    },\n                    region: {\n                      $exists: false\n                    },\n                    country: shippingAddress.country\n                  }]\n                }, {\n                  shopId: item.shopId\n                }]\n              }, {\n                sort: {\n                  postal: -1\n                }\n              });\n            }\n\n            return uniqueShopTaxRates;\n          }, {});\n          const taxRatesByShop = Object.keys(taxDataByShop).reduce((ratesByShop, shopId) => {\n            if (taxDataByShop[shopId]) {\n              ratesByShop[shopId] = taxDataByShop[shopId].rate / 100;\n            }\n\n            return ratesByShop;\n          }, {}); // calculate line item taxes\n\n          const itemsWithTax = cartToCalc.items.map(item => {\n            // init rate to 0\n            item.taxRate = 0;\n            item.taxData = undefined;\n            const shopTaxData = taxDataByShop[item.shopId]; // only process taxble products and skip if there is no shopTaxData\n\n            if (shopTaxData && item.variants.taxable === true) {\n              const shopTaxRate = shopTaxData.rate / 100; // If we have tax rates for this shop\n\n              if (shopTaxData && shopTaxRate) {\n                item.taxData = shopTaxData;\n                item.taxRate = shopTaxRate;\n                item.subtotal = item.variants.price * item.quantity;\n                item.tax = item.subtotal * item.taxRate;\n              }\n\n              totalTax += item.tax;\n            } // add the item to our new array\n\n\n            return item;\n          });\n\n          if (totalTax > 0) {\n            cartTaxRate = totalTax / cartToCalc.getSubTotal();\n          } // Marketplace Compatible\n\n\n          Meteor.call(\"taxes/setRateByShopAndItem\", cartToCalc._id, {\n            taxRatesByShop,\n            itemsWithTax,\n            cartTaxRate,\n            cartTaxData: undefined // not setting cartTaxData here to disguise actual tax rate from client\n\n          });\n        } // end custom rates\n\n      } // end shippingAddress calculation\n\n    } else {\n      // we are here because the custom rate package is disabled.\n      // we're going to set an inital rate of 0\n      // all methods that trigger when taxes/calculate will\n      // recalculate this rate as needed.\n      Meteor.call(\"taxes/setRate\", cartToCalc._id, cartTaxRate);\n    }\n  } // end taxes/calculate\n\n\n};\nMeteor.methods(methods);","map":{"version":3,"sources":["imports/plugins/core/taxes/server/methods/methods.js"],"names":["module","export","methods","Meteor","watch","require","v","Match","check","Cart","Packages","Taxes","Reaction","default","Logger","taxId","String","hasPermission","Error","remove","doc","docId","Object","Optional","call","_id","modifier","insert","details","update","cartId","taxRate","taxes","Number","Array","$set","tax","options","taxRatesByShop","itemsWithTax","cartTaxRate","cartTaxData","OneOf","undefined","items","cartToCalc","findOne","cartShopId","shopId","pkg","name","enabled","settings","rates","debug","shipping","shippingAddress","address","totalTax","taxDataByShop","reduce","uniqueShopTaxRates","item","$and","$or","postal","$exists","region","country","sort","keys","ratesByShop","rate","map","taxData","shopTaxData","variants","taxable","shopTaxRate","subtotal","price","quantity","getSubTotal"],"mappings":"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","sourcesContent":["import { Meteor } from \"meteor/meteor\";\nimport { Match, check } from \"meteor/check\";\nimport { Cart, Packages } from \"/lib/collections\";\nimport { Taxes } from \"../../lib/collections\";\nimport Reaction from \"../api\";\nimport { Logger } from \"/server/api\";\n\n/**\n * @file Methods for Taxes. Run these methods using `Meteor.call()`.\n *\n *\n * @namespace Methods/Taxes\n*/\n\nexport const methods = {\n  /**\n   * @name taxes/deleteRate\n   * @method\n   * @memberof Methods/Taxes\n   * @param  {String} taxId tax taxId to delete\n   * @return {String} returns update/insert result\n   */\n  \"taxes/deleteRate\"(taxId) {\n    check(taxId, String);\n\n    // check permissions to delete\n    if (!Reaction.hasPermission(\"taxes\")) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    return Taxes.remove(taxId);\n  },\n\n  /**\n   * @name taxes/addRate\n   * @method\n   * @memberof Methods/Taxes\n   * @param  {Object} doc A Taxes document to be inserted\n   * @param  {String} [docId] DEPRECATED. Existing ID to trigger an update. Use taxes/editRate method instead.\n   * @return {String} Insert result\n   */\n  \"taxes/addRate\"(doc, docId) {\n    check(doc, Object); // actual schema validation happens during insert below\n\n    // Backward compatibility\n    check(docId, Match.Optional(String));\n    if (docId) return Meteor.call(\"taxes/editRate\", { _id: docId, modifier: doc });\n\n    if (!Reaction.hasPermission(\"taxes\")) throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    return Taxes.insert(doc);\n  },\n\n  /**\n   * @name taxes/editRate\n   * @method\n   * @memberof Methods/Taxes\n   * @param  {Object} details An object with _id and modifier props\n   * @return {String} Update result\n   */\n  \"taxes/editRate\"(details) {\n    check(details, {\n      _id: String,\n      modifier: Object // actual schema validation happens during update below\n    });\n    if (!Reaction.hasPermission(\"taxes\")) throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    const { _id, modifier } = details;\n    return Taxes.update(_id, modifier);\n  },\n\n  /**\n   * @name taxes/setRate\n   * @summary Update the cart without hooks\n   * @method\n   * @memberof Methods/Taxes\n   * @param  {String} cartId cartId\n   * @param  {Number} taxRate taxRate\n   * @param  {Object} taxes taxes\n   * @return {Number} returns update result\n   */\n  \"taxes/setRate\"(cartId, taxRate, taxes) {\n    check(cartId, String);\n    check(taxRate, Number);\n    check(taxes, Match.Optional(Array));\n\n    return Cart.update(cartId, {\n      $set: {\n        taxes,\n        tax: taxRate\n      }\n    });\n  },\n\n  /**\n   * @name taxes/setRateByShopAndItem\n   * @method\n   * @memberof Methods/Taxes\n   * @summary Update the cart without hooks\n   * @param  {String} cartId cartId\n   * @param  {Object} options - Options object\n   * @param  {Object} options.taxRatesByShop - Object shopIds: taxRates\n   * @param  {Array}  options.itemsWithTax - Items array with computed tax details\n   * @param  {Object} options.cartTaxRate - Tax rate for shop associated with cart.shopId\n   * @param  {Object} options.cartTaxData - Tax data for shop associated with cart.shopId\n   * @return {Number} returns update result\n   */\n  \"taxes/setRateByShopAndItem\"(cartId, options) {\n    check(cartId, String);\n    check(options, {\n      taxRatesByShop: Object,\n      itemsWithTax: [Object],\n      cartTaxRate: Number,\n      cartTaxData: Match.OneOf([Object], undefined, null)\n    });\n\n    const { cartTaxData, cartTaxRate, itemsWithTax, taxRatesByShop } = options;\n\n    return Cart.update(cartId, {\n      $set: {\n        taxes: cartTaxData,\n        tax: cartTaxRate,\n        items: itemsWithTax,\n        taxRatesByShop\n      }\n    });\n  },\n\n  /**\n   * @name taxes/calculate\n   * @method\n   * @memberof Methods/Taxes\n   * @param  {String} cartId cartId\n   * @return {Object}  returns tax object\n   */\n  \"taxes/calculate\"(cartId) {\n    check(cartId, String);\n    const cartToCalc = Cart.findOne(cartId);\n    const cartShopId = cartToCalc.shopId;\n    let cartTaxRate = 0;\n\n    // TODO: Calculate shipping taxes for regions that require it\n    const pkg = Packages.findOne({\n      shopId: cartShopId,\n      name: \"reaction-taxes\"\n    });\n    //\n    // custom rates\n    // TODO Determine calculation method (row, total, shipping)\n    // TODO method for order tax updates\n    // additional logic will be needed for refunds\n    // or tax adjustments\n    //\n    // check if plugin is enabled and this calculation method is enabled\n    if (pkg && pkg.enabled === true && pkg.settings.rates.enabled === true) {\n      Logger.debug(\"Calculating custom tax rates\");\n\n      if (typeof cartToCalc.shipping !== \"undefined\" && typeof cartToCalc.items !== \"undefined\") {\n        const shippingAddress = cartToCalc.shipping[0].address;\n        let totalTax = 0;\n\n        // custom rates that match shipping info\n        // high chance this needs more review as\n        // it's unlikely this matches all potential\n        // here we just sort by postal, so if it's an exact\n        // match we're taking the first record, where the most\n        // likely tax scenario is a postal code falling\n        // back to a regional tax.\n        if (shippingAddress) {\n          // Get tax rates by shop\n          const taxDataByShop = cartToCalc.items.reduce((uniqueShopTaxRates, item) => {\n            // lookup custom tax rate for each shop once\n            if (!uniqueShopTaxRates[item.shopId]) {\n              uniqueShopTaxRates[item.shopId] = Taxes.findOne({\n                $and: [{\n                  $or: [{\n                    postal: shippingAddress.postal\n                  }, {\n                    postal: { $exists: false },\n                    region: shippingAddress.region,\n                    country: shippingAddress.country\n                  }, {\n                    postal: { $exists: false },\n                    region: { $exists: false },\n                    country: shippingAddress.country\n                  }]\n                }, {\n                  shopId: item.shopId\n                }]\n              }, { sort: { postal: -1 } });\n            }\n\n            return uniqueShopTaxRates;\n          }, {});\n\n          const taxRatesByShop = Object.keys(taxDataByShop).reduce((ratesByShop, shopId) => {\n            if (taxDataByShop[shopId]) {\n              ratesByShop[shopId] = taxDataByShop[shopId].rate / 100;\n            }\n            return ratesByShop;\n          }, {});\n\n          // calculate line item taxes\n          const itemsWithTax = cartToCalc.items.map((item) => {\n            // init rate to 0\n            item.taxRate = 0;\n            item.taxData = undefined;\n            const shopTaxData = taxDataByShop[item.shopId];\n\n            // only process taxble products and skip if there is no shopTaxData\n            if (shopTaxData && item.variants.taxable === true) {\n              const shopTaxRate = shopTaxData.rate / 100;\n\n              // If we have tax rates for this shop\n              if (shopTaxData && shopTaxRate) {\n                item.taxData = shopTaxData;\n                item.taxRate = shopTaxRate;\n                item.subtotal = item.variants.price * item.quantity;\n                item.tax = item.subtotal * item.taxRate;\n              }\n              totalTax += item.tax;\n            }\n\n            // add the item to our new array\n            return item;\n          });\n\n          if (totalTax > 0) {\n            cartTaxRate = totalTax / cartToCalc.getSubTotal();\n          }\n\n          // Marketplace Compatible\n          Meteor.call(\"taxes/setRateByShopAndItem\", cartToCalc._id, {\n            taxRatesByShop,\n            itemsWithTax,\n            cartTaxRate,\n            cartTaxData: undefined\n            // not setting cartTaxData here to disguise actual tax rate from client\n          });\n        } // end custom rates\n      } // end shippingAddress calculation\n    } else {\n      // we are here because the custom rate package is disabled.\n      // we're going to set an inital rate of 0\n      // all methods that trigger when taxes/calculate will\n      // recalculate this rate as needed.\n      Meteor.call(\"taxes/setRate\", cartToCalc._id, cartTaxRate);\n    }\n  } // end taxes/calculate\n};\n\nMeteor.methods(methods);\n"]},"sourceType":"script","hash":"9f1618671a577a6edd79dddfba9acf690e3f6d69"}
