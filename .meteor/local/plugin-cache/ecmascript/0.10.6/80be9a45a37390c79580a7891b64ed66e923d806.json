{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$1$2","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"ast":true,"babelrc":false,"sourceFileName":"server/startup/i18n.js","filename":"server/startup/i18n.js","sourceMaps":true,"envName":"development","cwd":"/Users/estebandev/test-knowledge","passPerPreset":false,"presets":[],"parserOpts":{"sourceType":"module","sourceFileName":"server/startup/i18n.js","plugins":["jsx","jsx","flow","flow","objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties"]},"generatorOpts":{"filename":"server/startup/i18n.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"server/startup/i18n.js"}},"code":"module.export({\n  loadTranslation: () => loadTranslation,\n  loadTranslations: () => loadTranslations,\n  flushTranslationLoad: () => flushTranslationLoad,\n  loadCoreTranslations: () => loadCoreTranslations,\n  reloadAllTranslations: () => reloadAllTranslations,\n  reloadTranslationsForShop: () => reloadTranslationsForShop,\n  importAllTranslations: () => importAllTranslations\n});\nlet fsModule;\nmodule.watch(require(\"fs\"), {\n  default(v) {\n    fsModule = v;\n  }\n\n}, 0);\nlet path;\nmodule.watch(require(\"path\"), {\n  default(v) {\n    path = v;\n  }\n\n}, 1);\nlet util;\nmodule.watch(require(\"util\"), {\n  default(v) {\n    util = v;\n  }\n\n}, 2);\nlet Assets, Translations;\nmodule.watch(require(\"../../lib/collections\"), {\n  Assets(v) {\n    Assets = v;\n  },\n\n  Translations(v) {\n    Translations = v;\n  }\n\n}, 3);\nlet Logger, Reaction;\nmodule.watch(require(\"../api\"), {\n  Logger(v) {\n    Logger = v;\n  },\n\n  Reaction(v) {\n    Reaction = v;\n  }\n\n}, 4);\nconst fs = {\n  readdir: util.promisify(fsModule.readdir),\n  readFile: util.promisify(fsModule.readFile),\n  realpath: util.promisify(fsModule.realpath),\n  stat: util.promisify(fsModule.stat)\n};\nconst translationSources = [];\nconst rawAssetsCollection = Assets.rawCollection();\nlet bulkAssetOp;\n\nfunction directoryExists(dirPath) {\n  return Promise.asyncApply(() => {\n    let info;\n\n    try {\n      info = Promise.await(fs.stat(dirPath));\n    } catch (error) {\n      return false;\n    }\n\n    return info.isDirectory();\n  });\n}\n/**\n * @method loadTranslation\n * @memberof i18n\n * @summary Server method: Load a single translation object as an Asset\n * loadTranslation should generally be used\n * before startup, to ensure that Assets load.\n * @param  {Object} source a json i18next object\n * @return {Boolean} false if assets weren't loaded\n */\n\n\nfunction loadTranslation(source) {\n  try {\n    if (!bulkAssetOp) bulkAssetOp = rawAssetsCollection.initializeUnorderedBulkOp();\n    const content = typeof source === \"string\" ? JSON.parse(source) : source;\n    const json = typeof source === \"object\" ? JSON.stringify(source) : source;\n    const {\n      i18n,\n      ns\n    } = content[0]; // Keep a record of all available translations for import later at a later time if using the\n    // reload translations icon button from the Internationalization settings panel\n\n    translationSources.push(source);\n    bulkAssetOp.find({\n      type: \"i18n\",\n      name: i18n,\n      ns\n    }).upsert().update({\n      $set: {\n        content: json\n      }\n    });\n    Logger.debug(\"Translation assets bulk update prepared for \", ns);\n  } catch (error) {\n    Logger.error(\"Failed to prepare bulk upsert for translation assets\", error);\n  }\n}\n\nfunction loadTranslations(sources) {\n  sources.forEach(loadTranslation);\n}\n\nfunction flushTranslationLoad() {\n  return Promise.asyncApply(() => {\n    if (!bulkAssetOp) return Promise.resolve();\n\n    try {\n      Promise.await(bulkAssetOp.execute());\n      bulkAssetOp = null;\n    } catch (error) {\n      Logger.error(\"Error flushing the translation asset upserts\");\n    }\n  });\n}\n\nfunction loadCoreTranslations() {\n  return Promise.asyncApply(() => {\n    const meteorPath = Promise.await(fs.realpath(`${process.cwd()}/../`));\n    const i18nFolder = `${meteorPath}/server/assets/app/data/i18n/`;\n\n    if (Promise.await(directoryExists(i18nFolder))) {\n      let files;\n\n      try {\n        files = Promise.await(fs.readdir(i18nFolder));\n      } catch (error) {\n        throw new Error(`No translations found in ${i18nFolder} for import`, error);\n      }\n\n      const promises = files.filter(file => file.endsWith(\".json\")).map(file => {\n        Logger.debug(`Importing Translations from ${file}`);\n        return fs.readFile(path.join(i18nFolder, file), \"utf8\");\n      });\n      let fileContents = [];\n\n      try {\n        fileContents = Promise.await(Promise.all(promises));\n      } catch (error) {\n        Logger.error(\"Failed to load translations from files\", error.message);\n      }\n\n      fileContents.forEach(loadTranslation);\n    }\n  });\n}\n\nfunction reloadAllTranslations() {\n  // Clear assets for i18n\n  Assets.remove({\n    type: \"i18n\"\n  }); // Remove translations for all shops\n\n  Translations.remove(); // Load translations from translation sources and prepare bulk op\n\n  loadTranslations(translationSources); // Load translations\n\n  importAllTranslations();\n}\n\nfunction reloadTranslationsForShop(shopId) {\n  // Clear assets for i18n\n  Assets.remove({\n    type: \"i18n\"\n  }); // Remove translations for the current shop\n\n  Translations.remove({\n    shopId\n  }); // Load translations from translation sources and prepare bulk op\n\n  loadTranslations(translationSources); // Load translations\n\n  importAllTranslations();\n}\n\nfunction importAllTranslations() {\n  // Get count of all i18n assets\n  const i18nAssetCount = Assets.find({\n    type: \"i18n\"\n  }).count(); // If we have no assets, then this is either a fresh start or\n  // the i18n assets were cleared. In either case, allow i18n translations\n  // to be loaded into Assets collection and subsequently into the Translation collection\n\n  if (i18nAssetCount === 0) {\n    // Import core translations\n    Promise.await(loadCoreTranslations()); // Flush all the bulk Assets upserts created by calls to loadTranslations\n\n    Promise.await(flushTranslationLoad());\n    Logger.debug(\"All translation assets updated\"); // Then loop through those I18N assets and import them\n\n    Assets.find({\n      type: \"i18n\"\n    }).forEach(t => {\n      Logger.debug(`Importing ${t.name} translation for \"${t.ns}\"`);\n\n      if (t.content) {\n        Reaction.Importer.process(t.content, [\"i18n\"], Reaction.Importer.translation);\n      } else {\n        Logger.debug(`No translation content found for ${t.name} - ${t.ns} asset`);\n      }\n    });\n    Reaction.Importer.flush();\n    Logger.debug(\"All translation imported into translations collection from Assets.\");\n  } else {\n    bulkAssetOp = null;\n    Logger.debug(\"Cancel translation update. Translations have a already been imported.\");\n  }\n}","map":{"version":3,"sources":["server/startup/i18n.js"],"names":["module","export","loadTranslation","loadTranslations","flushTranslationLoad","loadCoreTranslations","reloadAllTranslations","reloadTranslationsForShop","importAllTranslations","fsModule","watch","require","default","v","path","util","Assets","Translations","Logger","Reaction","fs","readdir","promisify","readFile","realpath","stat","translationSources","rawAssetsCollection","rawCollection","bulkAssetOp","directoryExists","dirPath","info","error","isDirectory","source","initializeUnorderedBulkOp","content","JSON","parse","json","stringify","i18n","ns","push","find","type","name","upsert","update","$set","debug","sources","forEach","Promise","resolve","execute","meteorPath","process","cwd","i18nFolder","files","Error","promises","filter","file","endsWith","map","join","fileContents","all","message","remove","shopId","i18nAssetCount","count","await","t","Importer","translation","flush"],"mappings":"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","sourcesContent":["import fsModule from \"fs\";\nimport path from \"path\";\nimport util from \"util\";\nimport { Assets, Translations } from \"/lib/collections\";\nimport { Logger, Reaction } from \"/server/api\";\n\nconst fs = {\n  readdir: util.promisify(fsModule.readdir),\n  readFile: util.promisify(fsModule.readFile),\n  realpath: util.promisify(fsModule.realpath),\n  stat: util.promisify(fsModule.stat)\n};\n\nconst translationSources = [];\nconst rawAssetsCollection = Assets.rawCollection();\nlet bulkAssetOp;\n\nasync function directoryExists(dirPath) {\n  let info;\n\n  try {\n    info = await fs.stat(dirPath);\n  } catch (error) {\n    return false;\n  }\n\n  return info.isDirectory();\n}\n\n/**\n * @method loadTranslation\n * @memberof i18n\n * @summary Server method: Load a single translation object as an Asset\n * loadTranslation should generally be used\n * before startup, to ensure that Assets load.\n * @param  {Object} source a json i18next object\n * @return {Boolean} false if assets weren't loaded\n */\nexport function loadTranslation(source) {\n  try {\n    if (!bulkAssetOp) bulkAssetOp = rawAssetsCollection.initializeUnorderedBulkOp();\n    const content = typeof source === \"string\" ? JSON.parse(source) : source;\n    const json = typeof source === \"object\" ? JSON.stringify(source) : source;\n    const { i18n, ns } = content[0];\n\n    // Keep a record of all available translations for import later at a later time if using the\n    // reload translations icon button from the Internationalization settings panel\n    translationSources.push(source);\n\n    bulkAssetOp\n      .find({ type: \"i18n\", name: i18n, ns })\n      .upsert()\n      .update({ $set: { content: json } });\n\n    Logger.debug(\"Translation assets bulk update prepared for \", ns);\n  } catch (error) {\n    Logger.error(\"Failed to prepare bulk upsert for translation assets\", error);\n  }\n}\n\n/**\n * @method loadTranslations\n * @summary Load an array of translation objects\n * and import using loadTranslation\n * @param  {Object} sources array of i18next translations\n * @return {Boolean} false if assets weren't loaded\n */\nexport function loadTranslations(sources) {\n  sources.forEach(loadTranslation);\n}\n\nexport async function flushTranslationLoad() {\n  if (!bulkAssetOp) return Promise.resolve();\n\n  try {\n    await bulkAssetOp.execute();\n    bulkAssetOp = null;\n  } catch (error) {\n    Logger.error(\"Error flushing the translation asset upserts\");\n  }\n}\n\n/**\n * @method loadCoreTranslations\n * @memberof i18n\n * @summary imports i18n json files from private/data/i18n into the Assets collection\n * Assets collection is processed with Reaction.Import\n * after all assets have been loaded.\n * @async\n */\nexport async function loadCoreTranslations() {\n  const meteorPath = await fs.realpath(`${process.cwd()}/../`);\n  const i18nFolder = `${meteorPath}/server/assets/app/data/i18n/`;\n\n  if (await directoryExists(i18nFolder)) {\n    let files;\n    try {\n      files = await fs.readdir(i18nFolder);\n    } catch (error) {\n      throw new Error(`No translations found in ${i18nFolder} for import`, error);\n    }\n\n    const promises = files.filter((file) => file.endsWith(\".json\")).map((file) => {\n      Logger.debug(`Importing Translations from ${file}`);\n      return fs.readFile(path.join(i18nFolder, file), \"utf8\");\n    });\n\n    let fileContents = [];\n    try {\n      fileContents = await Promise.all(promises);\n    } catch (error) {\n      Logger.error(\"Failed to load translations from files\", error.message);\n    }\n\n    fileContents.forEach(loadTranslation);\n  }\n}\n\n/**\n * @method reloadAllTranslations\n * @memberof i18n\n * @summary Reload translations for all shops\n * @return {undefined}\n*/\nexport function reloadAllTranslations() {\n  // Clear assets for i18n\n  Assets.remove({ type: \"i18n\" });\n\n  // Remove translations for all shops\n  Translations.remove();\n\n  // Load translations from translation sources and prepare bulk op\n  loadTranslations(translationSources);\n\n  // Load translations\n  importAllTranslations();\n}\n\n/**\n * @method reloadTranslationsForShop\n * @memberof i18n\n * @summary Reload translations for specified shop\n * @param {string} shopId - Shop Id to reset translations for\n * @return {undefined}\n*/\nexport function reloadTranslationsForShop(shopId) {\n  // Clear assets for i18n\n  Assets.remove({ type: \"i18n\" });\n\n  // Remove translations for the current shop\n  Translations.remove({ shopId });\n\n  // Load translations from translation sources and prepare bulk op\n  loadTranslations(translationSources);\n\n  // Load translations\n  importAllTranslations();\n}\n\n/**\n * @method importAllTranslations\n * @memberof i18n\n * @summary Imports all translations into Assets collection and Translation collection\n * @return {undefined}\n */\nexport function importAllTranslations() {\n  // Get count of all i18n assets\n  const i18nAssetCount = Assets.find({ type: \"i18n\" }).count();\n\n  // If we have no assets, then this is either a fresh start or\n  // the i18n assets were cleared. In either case, allow i18n translations\n  // to be loaded into Assets collection and subsequently into the Translation collection\n  if (i18nAssetCount === 0) {\n    // Import core translations\n    Promise.await(loadCoreTranslations());\n\n    // Flush all the bulk Assets upserts created by calls to loadTranslations\n    Promise.await(flushTranslationLoad());\n\n    Logger.debug(\"All translation assets updated\");\n\n    // Then loop through those I18N assets and import them\n    Assets.find({ type: \"i18n\" }).forEach((t) => {\n      Logger.debug(`Importing ${t.name} translation for \"${t.ns}\"`);\n      if (t.content) {\n        Reaction.Importer.process(t.content, [\"i18n\"], Reaction.Importer.translation);\n      } else {\n        Logger.debug(`No translation content found for ${t.name} - ${t.ns} asset`);\n      }\n    });\n    Reaction.Importer.flush();\n\n    Logger.debug(\"All translation imported into translations collection from Assets.\");\n  } else {\n    bulkAssetOp = null;\n    Logger.debug(\"Cancel translation update. Translations have a already been imported.\");\n  }\n}\n"]},"sourceType":"script","hash":"80be9a45a37390c79580a7891b64ed66e923d806"}
