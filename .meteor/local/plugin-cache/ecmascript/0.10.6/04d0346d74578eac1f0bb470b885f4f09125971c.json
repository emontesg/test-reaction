{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$1$2","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"ast":true,"babelrc":false,"sourceFileName":"imports/plugins/custom/knowledge-payments/server/methods/example.js","filename":"imports/plugins/custom/knowledge-payments/server/methods/example.js","sourceMaps":true,"envName":"development","cwd":"/Users/estebandev/test-knowledge","passPerPreset":false,"presets":[],"parserOpts":{"sourceType":"module","sourceFileName":"imports/plugins/custom/knowledge-payments/server/methods/example.js","plugins":["jsx","jsx","flow","flow","objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties"]},"generatorOpts":{"filename":"imports/plugins/custom/knowledge-payments/server/methods/example.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"imports/plugins/custom/knowledge-payments/server/methods/example.js"}},"code":"let Meteor;\nmodule.watch(require(\"meteor/meteor\"), {\n  Meteor(v) {\n    Meteor = v;\n  }\n\n}, 0);\nlet check, Match;\nmodule.watch(require(\"meteor/check\"), {\n  check(v) {\n    check = v;\n  },\n\n  Match(v) {\n    Match = v;\n  }\n\n}, 1);\nlet Reaction, Logger;\nmodule.watch(require(\"../../../../../../server/api\"), {\n  Reaction(v) {\n    Reaction = v;\n  },\n\n  Logger(v) {\n    Logger = v;\n  }\n\n}, 2);\nlet ExampleApi;\nmodule.watch(require(\"./exampleapi\"), {\n  ExampleApi(v) {\n    ExampleApi = v;\n  }\n\n}, 3);\n\nfunction luhnValid(x) {\n  return [...x].reverse().reduce((sum, c, i) => {\n    let d = parseInt(c, 10);\n\n    if (i % 2 !== 0) {\n      d *= 2;\n    }\n\n    if (d > 9) {\n      d -= 9;\n    }\n\n    return sum + d;\n  }, 0) % 10 === 0;\n}\n\nconst ValidCardNumber = Match.Where(x => /^[0-9]{13,16}$/.test(x) && luhnValid(x));\nconst ValidExpireMonth = Match.Where(x => /^[0-9]{1,2}$/.test(x));\nconst ValidExpireYear = Match.Where(x => /^[0-9]{4}$/.test(x));\nconst ValidCVV = Match.Where(x => /^[0-9]{3,4}$/.test(x)); // function chargeObj() {\n//   return {\n//     amount: \"\",\n//     currency: \"\",\n//     card: {},\n//     capture: true\n//   };\n// }\n// function parseCardData(data) {\n//   return {\n//     number: data.number,\n//     name: data.name,\n//     cvc: data.cvv2,\n//     expireMonth: data.expire_month,\n//     expireYear: data.expire_year\n//   };\n// }\n\nMeteor.methods({\n  /**\n   * Submit a card for Authorization\n   * @param  {Object} transactionType authorize or capture\n   * @param  {Object} cardData card Details\n   * @param  {Object} paymentData The details of the Payment Needed\n   * @return {Object} results normalized\n   */\n  \"exampleSubmit\"(transactionType, cardData, paymentData) {\n    check(transactionType, String);\n    check(cardData, {\n      name: String,\n      number: ValidCardNumber,\n      expireMonth: ValidExpireMonth,\n      expireYear: ValidExpireYear,\n      cvv2: ValidCVV,\n      type: String\n    });\n    check(paymentData, {\n      total: String,\n      currency: String\n    });\n    const total = parseFloat(paymentData.total);\n    let result;\n\n    try {\n      const transaction = ExampleApi.methods.authorize.call({\n        transactionType,\n        cardData,\n        paymentData\n      });\n      result = {\n        saved: true,\n        status: \"created\",\n        currency: paymentData.currency,\n        amount: total,\n        riskLevel: normalizeRiskLevel(transaction),\n        transactionId: transaction.id,\n        response: {\n          amount: total,\n          transactionId: transaction.id,\n          currency: paymentData.currency\n        }\n      };\n    } catch (error) {\n      Logger.warn(error);\n      result = {\n        saved: false,\n        error\n      };\n    }\n\n    return result;\n  },\n\n  /**\n   * Capture a Charge\n   * @param {Object} paymentData Object containing data about the transaction to capture\n   * @return {Object} results normalized\n   */\n  \"example/payment/capture\"(paymentData) {\n    check(paymentData, Reaction.Schemas.PaymentMethod);\n    const authorizationId = paymentData.transactionId;\n    const {\n      amount\n    } = paymentData;\n    const response = ExampleApi.methods.capture.call({\n      authorizationId,\n      amount\n    });\n    const result = {\n      saved: true,\n      response\n    };\n    return result;\n  },\n\n  /**\n   * Create a refund\n   * @param  {Object} paymentMethod object\n   * @param  {Number} amount The amount to be refunded\n   * @return {Object} result\n   */\n  \"knowledge/refund/create\"(paymentMethod, amount) {\n    check(paymentMethod, Reaction.Schemas.PaymentMethod);\n    check(amount, Number);\n    const {\n      transactionId\n    } = paymentMethod;\n    const response = ExampleApi.methods.refund.call({\n      transactionId,\n      amount\n    });\n    const results = {\n      saved: true,\n      response\n    };\n    return results;\n  },\n\n  /**\n   * List refunds\n   * @param  {Object} paymentMethod Object containing the pertinant data\n   * @return {Object} result\n   */\n  \"knowledge/refund/list\"(paymentMethod) {\n    check(paymentMethod, Reaction.Schemas.PaymentMethod);\n    const {\n      transactionId\n    } = paymentMethod;\n    const response = ExampleApi.methods.refunds.call({\n      transactionId\n    });\n    const result = [];\n\n    for (const refund of response.refunds) {\n      result.push(refund);\n    } // The results retured from the GenericAPI just so happen to look like exactly what the dashboard\n    // wants. The return package should ba an array of objects that look like this\n    // {\n    //   type: \"refund\",\n    //   amount: Number,\n    //   created: Number: Epoch Time,\n    //   currency: String,\n    //   raw: Object\n    // }\n\n\n    const emptyResult = [];\n    return emptyResult;\n  }\n\n});\n/**\n * @method normalizeRiskLevel\n * @private\n * @summary Normalizes the risk level response of a transaction to the values defined in paymentMethod schema\n * @param  {object} transaction - The transaction that we need to normalize\n * @return {string} normalized status string - either elevated, high, or normal\n */\n\nfunction normalizeRiskLevel(transaction) {\n  // the values to be checked against will depend on the return codes/values from the payment API\n  if (transaction.riskStatus === \"low_risk_level\") {\n    return \"elevated\";\n  }\n\n  if (transaction.riskStatus === \"highest_risk_level\") {\n    return \"high\";\n  } // default to normal if no other flagged\n\n\n  return \"normal\";\n}","map":{"version":3,"sources":["imports/plugins/custom/knowledge-payments/server/methods/example.js"],"names":["Meteor","module","watch","require","v","check","Match","Reaction","Logger","ExampleApi","luhnValid","x","reverse","reduce","sum","c","i","d","parseInt","ValidCardNumber","Where","test","ValidExpireMonth","ValidExpireYear","ValidCVV","methods","transactionType","cardData","paymentData","String","name","number","expireMonth","expireYear","cvv2","type","total","currency","parseFloat","result","transaction","authorize","call","saved","status","amount","riskLevel","normalizeRiskLevel","transactionId","id","response","error","warn","Schemas","PaymentMethod","authorizationId","capture","paymentMethod","Number","refund","results","refunds","push","emptyResult","riskStatus"],"mappings":"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","sourcesContent":["/* eslint camelcase: 0 */\n// meteor modules\nimport { Meteor } from \"meteor/meteor\";\nimport { check, Match } from \"meteor/check\";\n// reaction modules\nimport { Reaction, Logger } from \"/server/api\";\nimport { ExampleApi } from \"./exampleapi\";\n\nfunction luhnValid(x) {\n  return [...x].reverse().reduce((sum, c, i) => {\n    let d = parseInt(c, 10);\n    if (i % 2 !== 0) { d *= 2; }\n    if (d > 9) { d -= 9; }\n    return sum + d;\n  }, 0) % 10 === 0;\n}\n\nconst ValidCardNumber = Match.Where((x) => /^[0-9]{13,16}$/.test(x) && luhnValid(x));\n\nconst ValidExpireMonth = Match.Where((x) => /^[0-9]{1,2}$/.test(x));\n\nconst ValidExpireYear = Match.Where((x) => /^[0-9]{4}$/.test(x));\n\nconst ValidCVV = Match.Where((x) => /^[0-9]{3,4}$/.test(x));\n\n// function chargeObj() {\n//   return {\n//     amount: \"\",\n//     currency: \"\",\n//     card: {},\n//     capture: true\n//   };\n// }\n\n// function parseCardData(data) {\n//   return {\n//     number: data.number,\n//     name: data.name,\n//     cvc: data.cvv2,\n//     expireMonth: data.expire_month,\n//     expireYear: data.expire_year\n//   };\n// }\n\n\nMeteor.methods({\n  /**\n   * Submit a card for Authorization\n   * @param  {Object} transactionType authorize or capture\n   * @param  {Object} cardData card Details\n   * @param  {Object} paymentData The details of the Payment Needed\n   * @return {Object} results normalized\n   */\n  \"exampleSubmit\"(transactionType, cardData, paymentData) {\n    check(transactionType, String);\n    check(cardData, {\n      name: String,\n      number: ValidCardNumber,\n      expireMonth: ValidExpireMonth,\n      expireYear: ValidExpireYear,\n      cvv2: ValidCVV,\n      type: String\n    });\n\n    check(paymentData, {\n      total: String,\n      currency: String\n    });\n    const total = parseFloat(paymentData.total);\n    let result;\n    try {\n      const transaction = ExampleApi.methods.authorize.call({\n        transactionType,\n        cardData,\n        paymentData\n      });\n\n      result = {\n        saved: true,\n        status: \"created\",\n        currency: paymentData.currency,\n        amount: total,\n        riskLevel: normalizeRiskLevel(transaction),\n        transactionId: transaction.id,\n        response: {\n          amount: total,\n          transactionId: transaction.id,\n          currency: paymentData.currency\n        }\n      };\n    } catch (error) {\n      Logger.warn(error);\n      result = {\n        saved: false,\n        error\n      };\n    }\n    return result;\n  },\n\n  /**\n   * Capture a Charge\n   * @param {Object} paymentData Object containing data about the transaction to capture\n   * @return {Object} results normalized\n   */\n  \"example/payment/capture\"(paymentData) {\n    check(paymentData, Reaction.Schemas.PaymentMethod);\n    const authorizationId = paymentData.transactionId;\n    const { amount } = paymentData;\n    const response = ExampleApi.methods.capture.call({\n      authorizationId,\n      amount\n    });\n    const result = {\n      saved: true,\n      response\n    };\n    return result;\n  },\n\n  /**\n   * Create a refund\n   * @param  {Object} paymentMethod object\n   * @param  {Number} amount The amount to be refunded\n   * @return {Object} result\n   */\n  \"knowledge/refund/create\"(paymentMethod, amount) {\n    check(paymentMethod, Reaction.Schemas.PaymentMethod);\n    check(amount, Number);\n    const { transactionId } = paymentMethod;\n    const response = ExampleApi.methods.refund.call({\n      transactionId,\n      amount\n    });\n    const results = {\n      saved: true,\n      response\n    };\n    return results;\n  },\n\n  /**\n   * List refunds\n   * @param  {Object} paymentMethod Object containing the pertinant data\n   * @return {Object} result\n   */\n  \"knowledge/refund/list\"(paymentMethod) {\n    check(paymentMethod, Reaction.Schemas.PaymentMethod);\n    const { transactionId } = paymentMethod;\n    const response = ExampleApi.methods.refunds.call({\n      transactionId\n    });\n    const result = [];\n    for (const refund of response.refunds) {\n      result.push(refund);\n    }\n\n    // The results retured from the GenericAPI just so happen to look like exactly what the dashboard\n    // wants. The return package should ba an array of objects that look like this\n    // {\n    //   type: \"refund\",\n    //   amount: Number,\n    //   created: Number: Epoch Time,\n    //   currency: String,\n    //   raw: Object\n    // }\n    const emptyResult = [];\n    return emptyResult;\n  }\n});\n\n/**\n * @method normalizeRiskLevel\n * @private\n * @summary Normalizes the risk level response of a transaction to the values defined in paymentMethod schema\n * @param  {object} transaction - The transaction that we need to normalize\n * @return {string} normalized status string - either elevated, high, or normal\n */\nfunction normalizeRiskLevel(transaction) {\n  // the values to be checked against will depend on the return codes/values from the payment API\n  if (transaction.riskStatus === \"low_risk_level\") {\n    return \"elevated\";\n  }\n\n  if (transaction.riskStatus === \"highest_risk_level\") {\n    return \"high\";\n  }\n\n  // default to normal if no other flagged\n  return \"normal\";\n}\n"]},"sourceType":"script","hash":"04d0346d74578eac1f0bb470b885f4f09125971c"}
