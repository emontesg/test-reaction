{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$1$2","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"ast":true,"babelrc":false,"sourceFileName":"imports/plugins/core/files/server/methods.js","filename":"imports/plugins/core/files/server/methods.js","sourceMaps":true,"envName":"development","cwd":"/Users/estebandev/test-knowledge","passPerPreset":false,"presets":[],"parserOpts":{"sourceType":"module","sourceFileName":"imports/plugins/core/files/server/methods.js","plugins":["jsx","jsx","flow","flow","objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties"]},"generatorOpts":{"filename":"imports/plugins/core/files/server/methods.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"imports/plugins/core/files/server/methods.js"}},"code":"var _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/builtin/objectSpread\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nmodule.export({\n  updateMediaMetadata: () => updateMediaMetadata,\n  insertMedia: () => insertMedia,\n  removeMedia: () => removeMedia,\n  updateMediaPriorities: () => updateMediaPriorities\n});\nlet Meteor;\nmodule.watch(require(\"meteor/meteor\"), {\n  Meteor(v) {\n    Meteor = v;\n  }\n\n}, 0);\nlet check;\nmodule.watch(require(\"meteor/check\"), {\n  check(v) {\n    check = v;\n  }\n\n}, 1);\nlet Hooks, Reaction;\nmodule.watch(require(\"../../../../../server/api\"), {\n  Hooks(v) {\n    Hooks = v;\n  },\n\n  Reaction(v) {\n    Reaction = v;\n  }\n\n}, 2);\nlet MediaRecords, Revisions;\nmodule.watch(require(\"../../../../../lib/collections\"), {\n  MediaRecords(v) {\n    MediaRecords = v;\n  },\n\n  Revisions(v) {\n    Revisions = v;\n  }\n\n}, 3);\nlet Media;\nmodule.watch(require(\"./index\"), {\n  Media(v) {\n    Media = v;\n  }\n\n}, 4);\nlet RevisionApi;\nmodule.watch(require(\"../../revisions/lib/api\"), {\n  RevisionApi(v) {\n    RevisionApi = v;\n  }\n\n}, 5);\n\nfunction updateMediaMetadata(fileRecordId, metadata) {\n  return Promise.asyncApply(() => {\n    check(fileRecordId, String);\n    check(metadata, Object);\n\n    if (RevisionApi.isRevisionControlEnabled()) {\n      if (metadata.productId) {\n        const existingRevision = Revisions.findOne({\n          \"documentId\": fileRecordId,\n          \"workflow.status\": {\n            $nin: [\"revision/published\"]\n          }\n        });\n\n        if (existingRevision) {\n          const updatedMetadata = Object.assign({}, existingRevision.documentData, metadata); // Special case where if we have both added and reordered images before publishing we don't want to overwrite\n          // the workflow status since it would be \"unpublished\"\n\n          if (existingRevision.documentData.workflow === \"published\" || existingRevision.changeType === \"insert\") {\n            updatedMetadata.workflow = \"published\";\n          }\n\n          Revisions.update({\n            _id: existingRevision._id\n          }, {\n            $set: {\n              documentData: updatedMetadata\n            }\n          });\n          Hooks.Events.run(\"afterRevisionsUpdate\", Meteor.userId(), (0, _objectSpread2.default)({}, existingRevision, {\n            documentData: updatedMetadata\n          }));\n        } else {\n          Revisions.insert({\n            documentId: fileRecordId,\n            documentData: metadata,\n            documentType: \"image\",\n            parentDocument: metadata.productId,\n            changeType: \"update\",\n            workflow: {\n              status: \"revision/update\"\n            }\n          });\n        }\n\n        return false;\n      }\n    } // for non-product images, just ignore and keep on moving\n\n\n    return true;\n  });\n}\n\nfunction insertMedia(fileRecord) {\n  return Promise.asyncApply(() => {\n    check(fileRecord, Object);\n    const mediaRecordId = Promise.await(MediaRecords.insert(fileRecord));\n\n    if (RevisionApi.isRevisionControlEnabled() && fileRecord.metadata.workflow !== \"published\") {\n      if (fileRecord.metadata.productId) {\n        const revisionMetadata = Object.assign({}, fileRecord.metadata);\n        revisionMetadata.workflow = \"published\";\n        Revisions.insert({\n          documentId: mediaRecordId,\n          documentData: revisionMetadata,\n          documentType: \"image\",\n          parentDocument: fileRecord.metadata.productId,\n          changeType: \"insert\",\n          workflow: {\n            status: \"revision/update\"\n          }\n        });\n        MediaRecords.update({\n          _id: mediaRecordId\n        }, {\n          $set: {\n            \"metadata.workflow\": \"unpublished\"\n          }\n        });\n      } else {\n        MediaRecords.update({\n          _id: mediaRecordId\n        }, {\n          $set: {\n            \"metadata.workflow\": \"published\"\n          }\n        });\n      }\n    }\n\n    return mediaRecordId;\n  });\n}\n\nfunction removeMedia(fileRecordId) {\n  return Promise.asyncApply(() => {\n    check(fileRecordId, String);\n    const {\n      metadata\n    } = MediaRecords.findOne({\n      _id: fileRecordId\n    });\n\n    if (RevisionApi.isRevisionControlEnabled() && metadata.workflow && metadata.workflow === \"unpublished\") {\n      Revisions.remove({\n        documentId: fileRecordId\n      });\n      Media.remove(fileRecordId);\n      return true;\n    } else if (metadata.productId) {\n      Revisions.insert({\n        documentId: fileRecordId,\n        documentData: metadata,\n        documentType: \"image\",\n        parentDocument: metadata.productId,\n        changeType: \"remove\",\n        workflow: {\n          status: \"revision/update\"\n        }\n      });\n      return true;\n    }\n\n    return false;\n  });\n}\n\nfunction updateMediaPriorities(sortedMediaIDs) {\n  check(sortedMediaIDs, [String]);\n\n  if (!Reaction.hasPermission(\"createProduct\")) {\n    throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n  } // Check to be sure product linked with each media belongs to the current user's current shop\n\n\n  const shopId = Reaction.getShopId();\n  const sortedMediaRecords = MediaRecords.find({\n    _id: {\n      $in: sortedMediaIDs\n    }\n  }).fetch();\n  sortedMediaRecords.forEach(mediaRecord => {\n    if (!mediaRecord.metadata || mediaRecord.metadata.shopId !== shopId) {\n      throw new Meteor.Error(\"access-denied\", `Access Denied. No access to shop ${mediaRecord.metadata.shopId}`);\n    }\n  });\n\n  if (sortedMediaRecords.length !== sortedMediaIDs.length) {\n    throw new Meteor.Error(\"not-found\", \"At least one ID in sortedMediaIDs does not exist\");\n  }\n\n  sortedMediaIDs.forEach((_id, index) => {\n    MediaRecords.update({\n      _id\n    }, {\n      $set: {\n        \"metadata.priority\": index\n      }\n    });\n    const {\n      metadata\n    } = MediaRecords.findOne({\n      _id\n    });\n    updateMediaMetadata(_id, metadata);\n  });\n  return true;\n}\n\nMeteor.methods({\n  \"media/insert\": insertMedia,\n  \"media/updatePriorities\": updateMediaPriorities,\n  \"media/remove\": removeMedia\n});","map":{"version":3,"sources":["imports/plugins/core/files/server/methods.js"],"names":["module","export","updateMediaMetadata","insertMedia","removeMedia","updateMediaPriorities","Meteor","watch","require","v","check","Hooks","Reaction","MediaRecords","Revisions","Media","RevisionApi","fileRecordId","metadata","String","Object","isRevisionControlEnabled","productId","existingRevision","findOne","$nin","updatedMetadata","assign","documentData","workflow","changeType","update","_id","$set","Events","run","userId","insert","documentId","documentType","parentDocument","status","fileRecord","mediaRecordId","revisionMetadata","remove","sortedMediaIDs","hasPermission","Error","shopId","getShopId","sortedMediaRecords","find","$in","fetch","forEach","mediaRecord","length","index","methods"],"mappings":"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","sourcesContent":["import { Meteor } from \"meteor/meteor\";\nimport { check } from \"meteor/check\";\nimport { Hooks, Reaction } from \"/server/api\";\nimport { MediaRecords, Revisions } from \"/lib/collections\";\nimport { Media } from \"/imports/plugins/core/files/server\";\nimport { RevisionApi } from \"/imports/plugins/core/revisions/lib/api\";\n\n/**\n * @method updateMediaMetadata\n * @memberof media\n * @summary updates media record in revision control.\n * @param {String} fileRecordId - _id of updated file record.\n * @param {Object} metadata - metadata from updated media file.\n * @return {Boolean}\n */\nexport async function updateMediaMetadata(fileRecordId, metadata) {\n  check(fileRecordId, String);\n  check(metadata, Object);\n  if (RevisionApi.isRevisionControlEnabled()) {\n    if (metadata.productId) {\n      const existingRevision = Revisions.findOne({\n        \"documentId\": fileRecordId,\n        \"workflow.status\": {\n          $nin: [\n            \"revision/published\"\n          ]\n        }\n      });\n      if (existingRevision) {\n        const updatedMetadata = Object.assign({}, existingRevision.documentData, metadata);\n        // Special case where if we have both added and reordered images before publishing we don't want to overwrite\n        // the workflow status since it would be \"unpublished\"\n        if (existingRevision.documentData.workflow === \"published\" || existingRevision.changeType === \"insert\") {\n          updatedMetadata.workflow = \"published\";\n        }\n        Revisions.update({ _id: existingRevision._id }, {\n          $set: {\n            documentData: updatedMetadata\n          }\n        });\n        Hooks.Events.run(\"afterRevisionsUpdate\", Meteor.userId(), {\n          ...existingRevision,\n          documentData: updatedMetadata\n        });\n      } else {\n        Revisions.insert({\n          documentId: fileRecordId,\n          documentData: metadata,\n          documentType: \"image\",\n          parentDocument: metadata.productId,\n          changeType: \"update\",\n          workflow: {\n            status: \"revision/update\"\n          }\n        });\n      }\n\n      return false;\n    }\n  }\n  // for non-product images, just ignore and keep on moving\n  return true;\n}\n\n/**\n * @method insertMedia\n * @memberof media\n * @summary insert a new media record and add it to revision control.\n * @param {Object} fileRecord - document from file collection upload.\n * @return {String} - _id of the new inserted media record.\n */\nexport async function insertMedia(fileRecord) {\n  check(fileRecord, Object);\n  const mediaRecordId = await MediaRecords.insert(fileRecord);\n\n  if (RevisionApi.isRevisionControlEnabled() && fileRecord.metadata.workflow !== \"published\") {\n    if (fileRecord.metadata.productId) {\n      const revisionMetadata = Object.assign({}, fileRecord.metadata);\n      revisionMetadata.workflow = \"published\";\n      Revisions.insert({\n        documentId: mediaRecordId,\n        documentData: revisionMetadata,\n        documentType: \"image\",\n        parentDocument: fileRecord.metadata.productId,\n        changeType: \"insert\",\n        workflow: {\n          status: \"revision/update\"\n        }\n      });\n      MediaRecords.update({\n        _id: mediaRecordId\n      }, {\n        $set: {\n          \"metadata.workflow\": \"unpublished\"\n        }\n      });\n    } else {\n      MediaRecords.update({\n        _id: mediaRecordId\n      }, {\n        $set: {\n          \"metadata.workflow\": \"published\"\n        }\n      });\n    }\n  }\n\n  return mediaRecordId;\n}\n\n/**\n * @method removeMedia\n * @memberof media\n * @summary removes media file and updates record in revision control.\n * @param {String} fileRecordId - _id of file record to be deleted.\n * @return {Boolean}\n */\nexport async function removeMedia(fileRecordId) {\n  check(fileRecordId, String);\n  const { metadata } = MediaRecords.findOne({ _id: fileRecordId });\n  if (RevisionApi.isRevisionControlEnabled() && metadata.workflow && metadata.workflow === \"unpublished\") {\n    Revisions.remove({\n      documentId: fileRecordId\n    });\n    Media.remove(fileRecordId);\n    return true;\n  } else if (metadata.productId) {\n    Revisions.insert({\n      documentId: fileRecordId,\n      documentData: metadata,\n      documentType: \"image\",\n      parentDocument: metadata.productId,\n      changeType: \"remove\",\n      workflow: {\n        status: \"revision/update\"\n      }\n    });\n    return true;\n  }\n  return false;\n}\n\n/**\n * updateMediaPriorities\n * @summary sorting media by array indexes\n * @type {Method}\n * @param {String[]} sortedMediaIDs\n * @return {Boolean} true\n */\nexport function updateMediaPriorities(sortedMediaIDs) {\n  check(sortedMediaIDs, [String]);\n\n  if (!Reaction.hasPermission(\"createProduct\")) {\n    throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n  }\n\n  // Check to be sure product linked with each media belongs to the current user's current shop\n  const shopId = Reaction.getShopId();\n\n  const sortedMediaRecords = MediaRecords.find({\n    _id: { $in: sortedMediaIDs }\n  }).fetch();\n\n  sortedMediaRecords.forEach((mediaRecord) => {\n    if (!mediaRecord.metadata || mediaRecord.metadata.shopId !== shopId) {\n      throw new Meteor.Error(\"access-denied\", `Access Denied. No access to shop ${mediaRecord.metadata.shopId}`);\n    }\n  });\n\n  if (sortedMediaRecords.length !== sortedMediaIDs.length) {\n    throw new Meteor.Error(\"not-found\", \"At least one ID in sortedMediaIDs does not exist\");\n  }\n\n  sortedMediaIDs.forEach((_id, index) => {\n    MediaRecords.update({\n      _id\n    }, {\n      $set: {\n        \"metadata.priority\": index\n      }\n    });\n    const { metadata } = MediaRecords.findOne({ _id });\n    updateMediaMetadata(_id, metadata);\n  });\n\n  return true;\n}\n\nMeteor.methods({\n  \"media/insert\": insertMedia,\n  \"media/updatePriorities\": updateMediaPriorities,\n  \"media/remove\": removeMedia\n});\n"]},"sourceType":"script","hash":"cb55d8d30b6f2def47bbf83be6299ce5ef94d343"}
