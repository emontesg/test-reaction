{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$1$2","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"ast":true,"babelrc":false,"sourceFileName":"imports/plugins/core/files/server/fileCollections.js","filename":"imports/plugins/core/files/server/fileCollections.js","sourceMaps":true,"envName":"development","cwd":"/Users/estebandev/test-knowledge","passPerPreset":false,"presets":[],"parserOpts":{"sourceType":"module","sourceFileName":"imports/plugins/core/files/server/fileCollections.js","plugins":["jsx","jsx","flow","flow","objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties"]},"generatorOpts":{"filename":"imports/plugins/core/files/server/fileCollections.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"imports/plugins/core/files/server/fileCollections.js"}},"code":"const module1 = module;\nmodule1.export({\n  Media: () => Media\n});\nlet Meteor;\nmodule1.watch(require(\"meteor/meteor\"), {\n  Meteor(v) {\n    Meteor = v;\n  }\n\n}, 0);\nlet MongoInternals;\nmodule1.watch(require(\"meteor/mongo\"), {\n  MongoInternals(v) {\n    MongoInternals = v;\n  }\n\n}, 1);\nlet WebApp;\nmodule1.watch(require(\"meteor/webapp\"), {\n  WebApp(v) {\n    WebApp = v;\n  }\n\n}, 2);\nlet check;\nmodule1.watch(require(\"meteor/check\"), {\n  check(v) {\n    check = v;\n  }\n\n}, 3);\nlet Security;\nmodule1.watch(require(\"meteor/ongoworks:security\"), {\n  Security(v) {\n    Security = v;\n  }\n\n}, 4);\nlet fetch;\nmodule1.watch(require(\"node-fetch\"), {\n  default(v) {\n    fetch = v;\n  }\n\n}, 5);\nlet FileDownloadManager, FileRecord, MeteorFileCollection, RemoteUrlWorker, TempFileStore, TempFileStoreWorker;\nmodule1.watch(require(\"@reactioncommerce/file-collections\"), {\n  FileDownloadManager(v) {\n    FileDownloadManager = v;\n  },\n\n  FileRecord(v) {\n    FileRecord = v;\n  },\n\n  MeteorFileCollection(v) {\n    MeteorFileCollection = v;\n  },\n\n  RemoteUrlWorker(v) {\n    RemoteUrlWorker = v;\n  },\n\n  TempFileStore(v) {\n    TempFileStore = v;\n  },\n\n  TempFileStoreWorker(v) {\n    TempFileStoreWorker = v;\n  }\n\n}, 6);\nlet GridFSStore;\nmodule1.watch(require(\"@reactioncommerce/file-collections-sa-gridfs\"), {\n  default(v) {\n    GridFSStore = v;\n  }\n\n}, 7);\nlet Logger;\nmodule1.watch(require(\"../../../../../server/api\"), {\n  Logger(v) {\n    Logger = v;\n  }\n\n}, 8);\nlet MediaRecords;\nmodule1.watch(require(\"../../../../../lib/collections\"), {\n  MediaRecords(v) {\n    MediaRecords = v;\n  }\n\n}, 9);\n// lazy loading sharp package\nlet sharp;\n\nfunction lazyLoadSharp() {\n  return Promise.asyncApply(() => {\n    if (sharp) return;\n    sharp = Promise.await(Promise.resolve().then(() => require(\"sharp\")));\n  });\n}\n\nFileRecord.downloadEndpointPrefix = \"/assets/files\";\nFileRecord.absoluteUrlPrefix = Meteor.absoluteUrl(); // 1024*1024*2 is the GridFSStore default chunk size, and 256k is default GridFS chunk size, but performs terribly\n\nconst gridFSStoresChunkSize = 1 * 1024 * 1024;\nconst mongodb = MongoInternals.NpmModules.mongodb.module;\nconst {\n  db\n} = MongoInternals.defaultRemoteCollectionDriver().mongo;\n/**\n * @name imgTransforms\n * @constant {Array}\n * @property {string} name - transform name that will be used as GridFS name\n * @property {object|undefined} transform - object with image transform settings\n * @property {number} size - transform size, only one number needed for both width & height\n * @property {string} mod - transform modifier function call,\n * for example the `large` & `medium` image transforms want to preserve\n * the image's aspect ratio and resize based on the larger width or height\n * so we use the `max` Sharp modifier function.\n * Check out the {@link http://sharp.pixelplumbing.com/en/stable/|Sharp Docs} for more helper functions.\n * {@link http://sharp.pixelplumbing.com/en/stable/api-resize/#max|Sharp max()}\n * {@link http://sharp.pixelplumbing.com/en/stable/api-resize/#crop|Sharp crop()}\n * @property {string} format - output image format\n * @summary Defines all image transforms\n * Image files are resized to 4 different sizes:\n * 1. `large` - 1000px by 1000px - preserves aspect ratio\n * 2. `medium` - 600px by 600px - preserves aspect ratio\n * 3. `small` - 235px by 235px - crops to square - creates png version\n * 4. `thumbnail` - 100px by 100px - crops to square - creates png version\n */\n\nconst imgTransforms = [{\n  name: \"image\",\n  transform: {\n    size: 1600,\n    mod: \"max\",\n    format: \"jpg\",\n    type: \"image/jpeg\"\n  }\n}, {\n  name: \"large\",\n  transform: {\n    size: 1000,\n    mod: \"max\",\n    format: \"jpg\",\n    type: \"image/jpeg\"\n  }\n}, {\n  name: \"medium\",\n  transform: {\n    size: 600,\n    mod: \"max\",\n    format: \"jpg\",\n    type: \"image/jpeg\"\n  }\n}, {\n  name: \"small\",\n  transform: {\n    size: 235,\n    mod: \"crop\",\n    format: \"png\",\n    type: \"image/png\"\n  }\n}, {\n  name: \"thumbnail\",\n  transform: {\n    size: 100,\n    mod: \"crop\",\n    format: \"png\",\n    type: \"image/png\"\n  }\n}];\n/**\n * @function buildGFS\n * @param {object} imgTransform\n * @summary buildGFS returns a fresh GridFSStore instance from provided image transform settings.\n */\n\nconst buildGFS = ({\n  name,\n  transform\n}) => new GridFSStore({\n  chunkSize: gridFSStoresChunkSize,\n  collectionPrefix: \"cfs_gridfs.\",\n  db,\n  mongodb,\n  name,\n\n  transformWrite(fileRecord) {\n    return Promise.asyncApply(() => {\n      if (!transform) return;\n\n      try {\n        Promise.await(lazyLoadSharp());\n      } catch (error) {\n        Logger.warn(\"Problem lazy loading Sharp lib in image transformWrite\", error.message);\n      }\n\n      if (!sharp) {\n        Logger.warn(\"In transformWrite, sharp does not seem to be available\");\n        return;\n      }\n\n      const {\n        size,\n        mod,\n        format,\n        type\n      } = transform; // Need to update the content type and extension of the file info, too.\n      // The new size gets set correctly automatically by FileCollections package.\n\n      fileRecord.type(type, {\n        store: name\n      });\n      fileRecord.extension(format, {\n        store: name\n      }); // resizing image, adding mod, setting output format\n\n      return sharp().resize(size, size)[mod]().toFormat(format);\n    });\n  }\n\n});\n/**\n * @name stores\n * @constant {Array}\n * @summary Defines an array of GridFSStore by mapping the imgTransform settings over the buildGFS function\n */\n\n\nconst stores = imgTransforms.map(buildGFS);\n/**\n * @name tempStore\n * @type TempFileStore\n * @summary Defines the temporary store where chunked uploads from browsers go\n * initially, until the chunks are eventually combined into one complete file\n * which the worker will then store to the permanant stores.\n * @see https://github.com/reactioncommerce/reaction-file-collections\n */\n\nconst tempStore = new TempFileStore({\n  shouldAllowRequest(req) {\n    const {\n      type\n    } = req.uploadMetadata;\n\n    if (typeof type !== \"string\" || !type.startsWith(\"image/\")) {\n      Logger.info(`shouldAllowRequest received request to upload file of type \"${type}\" and denied it`);\n      return false;\n    }\n\n    return true;\n  }\n\n});\nWebApp.connectHandlers.use(\"/assets/uploads\", (req, res) => {\n  req.baseUrl = \"/assets/uploads\"; // tus relies on this being set, which is an Express thing\n\n  tempStore.connectHandler(req, res);\n});\n/**\n * @name Media\n * @type MeteorFileCollection\n * @summary Defines the Media FileCollection\n * To learn how to further manipulate images with Sharp, refer to\n * {@link http://sharp.pixelplumbing.com/en/stable/|Sharp Docs}\n * @see https://github.com/reactioncommerce/reaction-file-collections\n */\n\nconst Media = new MeteorFileCollection(\"Media\", {\n  allowInsert: (userId, doc) => Security.can(userId).insert(doc).for(MediaRecords).check(),\n  allowUpdate: (userId, id, modifier) => Security.can(userId).update(id, modifier).for(MediaRecords).check(),\n  allowRemove: (userId, id) => Security.can(userId).remove(id).for(MediaRecords).check(),\n  check,\n  collection: MediaRecords,\n  DDP: Meteor,\n  allowGet: () => true,\n  // add more security here if the files should not be public\n  stores,\n  tempStore\n});\n// For backward-compatibility with code relying on how CFS did it, we'll put a\n// reference to the backing MongoDB collection on Media.files property as well.\nMedia.files = MediaRecords;\n/**\n * @name downloadManager\n * @type FileDownloadManager\n * @summary Set up a URL for downloading the files\n * @see https://github.com/reactioncommerce/reaction-file-collections\n */\n\nconst downloadManager = new FileDownloadManager({\n  collections: [Media],\n  headers: {\n    get: {\n      \"Cache-Control\": \"public, max-age=31536000\"\n    }\n  }\n});\nWebApp.connectHandlers.use(\"/assets/files\", downloadManager.connectHandler);\n/**\n * @name remoteUrlWorker\n * @type RemoteUrlWorker\n * @summary Start a worker to watch for inserted remote URLs and stream them to all stores\n * @see https://github.com/reactioncommerce/reaction-file-collections\n */\n\nconst remoteUrlWorker = new RemoteUrlWorker({\n  fetch,\n  fileCollections: [Media]\n});\nremoteUrlWorker.start();\n/**\n * @name fileWorker\n * @type TempFileStoreWorker\n * @summary Start a worker to watch for finished uploads, store them permanantly,\n * and then remove the temporary file\n * @see https://github.com/reactioncommerce/reaction-file-collections\n */\n\nconst fileWorker = new TempFileStoreWorker({\n  fileCollections: [Media]\n});\nfileWorker.start();","map":{"version":3,"sources":["imports/plugins/core/files/server/fileCollections.js"],"names":["module1","module","export","Media","Meteor","watch","require","v","MongoInternals","WebApp","check","Security","fetch","default","FileDownloadManager","FileRecord","MeteorFileCollection","RemoteUrlWorker","TempFileStore","TempFileStoreWorker","GridFSStore","Logger","MediaRecords","sharp","lazyLoadSharp","downloadEndpointPrefix","absoluteUrlPrefix","absoluteUrl","gridFSStoresChunkSize","mongodb","NpmModules","db","defaultRemoteCollectionDriver","mongo","imgTransforms","name","transform","size","mod","format","type","buildGFS","chunkSize","collectionPrefix","transformWrite","fileRecord","error","warn","message","store","extension","resize","toFormat","stores","map","tempStore","shouldAllowRequest","req","uploadMetadata","startsWith","info","connectHandlers","use","res","baseUrl","connectHandler","allowInsert","userId","doc","can","insert","for","allowUpdate","id","modifier","update","allowRemove","remove","collection","DDP","allowGet","files","downloadManager","collections","headers","get","remoteUrlWorker","fileCollections","start","fileWorker"],"mappings":"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","sourcesContent":["import { Meteor } from \"meteor/meteor\";\nimport { MongoInternals } from \"meteor/mongo\";\nimport { WebApp } from \"meteor/webapp\";\nimport { check } from \"meteor/check\";\nimport { Security } from \"meteor/ongoworks:security\";\nimport fetch from \"node-fetch\";\nimport {\n  FileDownloadManager,\n  FileRecord,\n  MeteorFileCollection,\n  RemoteUrlWorker,\n  TempFileStore,\n  TempFileStoreWorker\n} from \"@reactioncommerce/file-collections\";\nimport GridFSStore from \"@reactioncommerce/file-collections-sa-gridfs\";\nimport { Logger } from \"/server/api\";\nimport { MediaRecords } from \"/lib/collections\";\n\n// lazy loading sharp package\nlet sharp;\nasync function lazyLoadSharp() {\n  if (sharp) return;\n  sharp = await import(\"sharp\");\n}\n\nFileRecord.downloadEndpointPrefix = \"/assets/files\";\nFileRecord.absoluteUrlPrefix = Meteor.absoluteUrl();\n\n// 1024*1024*2 is the GridFSStore default chunk size, and 256k is default GridFS chunk size, but performs terribly\nconst gridFSStoresChunkSize = 1 * 1024 * 1024;\nconst mongodb = MongoInternals.NpmModules.mongodb.module;\nconst { db } = MongoInternals.defaultRemoteCollectionDriver().mongo;\n\n/**\n * @name imgTransforms\n * @constant {Array}\n * @property {string} name - transform name that will be used as GridFS name\n * @property {object|undefined} transform - object with image transform settings\n * @property {number} size - transform size, only one number needed for both width & height\n * @property {string} mod - transform modifier function call,\n * for example the `large` & `medium` image transforms want to preserve\n * the image's aspect ratio and resize based on the larger width or height\n * so we use the `max` Sharp modifier function.\n * Check out the {@link http://sharp.pixelplumbing.com/en/stable/|Sharp Docs} for more helper functions.\n * {@link http://sharp.pixelplumbing.com/en/stable/api-resize/#max|Sharp max()}\n * {@link http://sharp.pixelplumbing.com/en/stable/api-resize/#crop|Sharp crop()}\n * @property {string} format - output image format\n * @summary Defines all image transforms\n * Image files are resized to 4 different sizes:\n * 1. `large` - 1000px by 1000px - preserves aspect ratio\n * 2. `medium` - 600px by 600px - preserves aspect ratio\n * 3. `small` - 235px by 235px - crops to square - creates png version\n * 4. `thumbnail` - 100px by 100px - crops to square - creates png version\n */\nconst imgTransforms = [\n  { name: \"image\", transform: { size: 1600, mod: \"max\", format: \"jpg\", type: \"image/jpeg\" } },\n  { name: \"large\", transform: { size: 1000, mod: \"max\", format: \"jpg\", type: \"image/jpeg\" } },\n  { name: \"medium\", transform: { size: 600, mod: \"max\", format: \"jpg\", type: \"image/jpeg\" } },\n  { name: \"small\", transform: { size: 235, mod: \"crop\", format: \"png\", type: \"image/png\" } },\n  { name: \"thumbnail\", transform: { size: 100, mod: \"crop\", format: \"png\", type: \"image/png\" } }\n];\n\n/**\n * @function buildGFS\n * @param {object} imgTransform\n * @summary buildGFS returns a fresh GridFSStore instance from provided image transform settings.\n */\nconst buildGFS = ({ name, transform }) => (\n  new GridFSStore({\n    chunkSize: gridFSStoresChunkSize,\n    collectionPrefix: \"cfs_gridfs.\",\n    db,\n    mongodb,\n    name,\n    async transformWrite(fileRecord) {\n      if (!transform) return;\n\n      try {\n        await lazyLoadSharp();\n      } catch (error) {\n        Logger.warn(\"Problem lazy loading Sharp lib in image transformWrite\", error.message);\n      }\n\n      if (!sharp) {\n        Logger.warn(\"In transformWrite, sharp does not seem to be available\");\n        return;\n      }\n\n      const { size, mod, format, type } = transform;\n      // Need to update the content type and extension of the file info, too.\n      // The new size gets set correctly automatically by FileCollections package.\n      fileRecord.type(type, { store: name });\n      fileRecord.extension(format, { store: name });\n\n      // resizing image, adding mod, setting output format\n      return sharp().resize(size, size)[mod]().toFormat(format);\n    }\n  })\n);\n\n/**\n * @name stores\n * @constant {Array}\n * @summary Defines an array of GridFSStore by mapping the imgTransform settings over the buildGFS function\n */\nconst stores = imgTransforms.map(buildGFS);\n\n/**\n * @name tempStore\n * @type TempFileStore\n * @summary Defines the temporary store where chunked uploads from browsers go\n * initially, until the chunks are eventually combined into one complete file\n * which the worker will then store to the permanant stores.\n * @see https://github.com/reactioncommerce/reaction-file-collections\n */\nconst tempStore = new TempFileStore({\n  shouldAllowRequest(req) {\n    const { type } = req.uploadMetadata;\n    if (typeof type !== \"string\" || !type.startsWith(\"image/\")) {\n      Logger.info(`shouldAllowRequest received request to upload file of type \"${type}\" and denied it`);\n      return false;\n    }\n    return true;\n  }\n});\nWebApp.connectHandlers.use(\"/assets/uploads\", (req, res) => {\n  req.baseUrl = \"/assets/uploads\"; // tus relies on this being set, which is an Express thing\n  tempStore.connectHandler(req, res);\n});\n\n/**\n * @name Media\n * @type MeteorFileCollection\n * @summary Defines the Media FileCollection\n * To learn how to further manipulate images with Sharp, refer to\n * {@link http://sharp.pixelplumbing.com/en/stable/|Sharp Docs}\n * @see https://github.com/reactioncommerce/reaction-file-collections\n */\nexport const Media = new MeteorFileCollection(\"Media\", {\n  allowInsert: (userId, doc) => Security.can(userId).insert(doc).for(MediaRecords).check(),\n  allowUpdate: (userId, id, modifier) => Security.can(userId).update(id, modifier).for(MediaRecords).check(),\n  allowRemove: (userId, id) => Security.can(userId).remove(id).for(MediaRecords).check(),\n  check,\n  collection: MediaRecords,\n  DDP: Meteor,\n  allowGet: () => true, // add more security here if the files should not be public\n  stores,\n  tempStore\n});\n\n// For backward-compatibility with code relying on how CFS did it, we'll put a\n// reference to the backing MongoDB collection on Media.files property as well.\nMedia.files = MediaRecords;\n\n/**\n * @name downloadManager\n * @type FileDownloadManager\n * @summary Set up a URL for downloading the files\n * @see https://github.com/reactioncommerce/reaction-file-collections\n */\nconst downloadManager = new FileDownloadManager({\n  collections: [Media],\n  headers: {\n    get: {\n      \"Cache-Control\": \"public, max-age=31536000\"\n    }\n  }\n});\nWebApp.connectHandlers.use(\"/assets/files\", downloadManager.connectHandler);\n\n/**\n * @name remoteUrlWorker\n * @type RemoteUrlWorker\n * @summary Start a worker to watch for inserted remote URLs and stream them to all stores\n * @see https://github.com/reactioncommerce/reaction-file-collections\n */\nconst remoteUrlWorker = new RemoteUrlWorker({ fetch, fileCollections: [Media] });\nremoteUrlWorker.start();\n\n/**\n * @name fileWorker\n * @type TempFileStoreWorker\n * @summary Start a worker to watch for finished uploads, store them permanantly,\n * and then remove the temporary file\n * @see https://github.com/reactioncommerce/reaction-file-collections\n */\nconst fileWorker = new TempFileStoreWorker({ fileCollections: [Media] });\nfileWorker.start();\n"]},"sourceType":"script","hash":"145788797c05bedce7001c119f0898e067ee34b2"}
