{"metadata":{},"options":{"plugins":[{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$2","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":false}},{"key":"base$0$3","visitor":{"_exploded":{},"_verified":{},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}},{"key":"base$0$4","visitor":{"FunctionExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"ForInStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$6","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$0$1$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$1$2","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$2","visitor":{"ArrowFunctionExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$3","visitor":{"BlockStatement":{"enter":[null]},"SwitchCase":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$4","visitor":{"VariableDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"_exploded":true,"BlockStatement":{"enter":[null]},"SwitchStatement":{"enter":[null]},"Program":{"enter":[null]},"_verified":true,"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"base$0$0$5","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"base$0$0$6","visitor":{"ObjectExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"base$0$0$7","visitor":{"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"VariableDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"base$0$0$8","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"base$0$0$9","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$10","visitor":{"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$11","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]}},"options":{}},{"key":"base$0$0$12","visitor":{"ObjectMethod":{"enter":[null]},"ObjectProperty":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$13","visitor":{"ArrayExpression":{"enter":[null]},"CallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$14","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$15","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"base$0$0$16","visitor":{"UnaryExpression":{"enter":[null]},"_exploded":true,"_verified":true,"BlockStatement":{"enter":[null]},"CatchClause":{"enter":[null]},"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"Program":{"enter":[null]},"ObjectMethod":{"enter":[null]},"SwitchStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"ForOfStatement":{"enter":[null]},"ClassMethod":{"enter":[null]}},"options":{}},{"key":"base$0$0$17","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$18","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$19","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"base$0$0$20","visitor":{"ObjectProperty":{"exit":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$21","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$0$22","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$23","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"regenerator-transform","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{}}],"presets":[],"compact":false,"ast":true,"babelrc":false,"sourceFileName":"lib/api/catalog.js","filename":"lib/api/catalog.js","sourceMaps":true,"envName":"development","cwd":"/Users/estebandev/test-knowledge","passPerPreset":false,"parserOpts":{"sourceType":"module","sourceFileName":"lib/api/catalog.js","plugins":["dynamicImport","classProperties","jsx","jsx","flow","asyncGenerators","objectRestSpread","objectRestSpread","flow","asyncGenerators"]},"generatorOpts":{"filename":"lib/api/catalog.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"lib/api/catalog.js"}},"code":"var _max;\n\nmodule.watch(require(\"lodash/max\"), {\n  \"default\": function (v) {\n    _max = v;\n  }\n}, 0);\n\nvar _min;\n\nmodule.watch(require(\"lodash/min\"), {\n  \"default\": function (v) {\n    _min = v;\n  }\n}, 1);\nvar Products;\nmodule.watch(require(\"../collections\"), {\n  Products: function (v) {\n    Products = v;\n  }\n}, 2);\nvar ReactionProduct;\nmodule.watch(require(\"./index\"), {\n  ReactionProduct: function (v) {\n    ReactionProduct = v;\n  }\n}, 3);\nvar applyProductRevision;\nmodule.watch(require(\"./products\"), {\n  applyProductRevision: function (v) {\n    applyProductRevision = v;\n  }\n}, 4);\nmodule.exportDefault({\n  /**\n   * @method setProduct\n   * @memberof Catalog\n   * @summary method to set default/parameterized product variant\n   * @param {String} currentProductId - set current productId\n   * @param {String} currentVariantId - set current variantId\n   * @return {undefined} return nothing, sets in session\n   */\n  setProduct: function (currentProductId, currentVariantId) {\n    var productId = currentProductId;\n    var variantId = currentVariantId;\n\n    if (!productId.match(/^[A-Za-z0-9]{17}$/)) {\n      var product = Products.findOne({\n        handle: productId.toLowerCase()\n      });\n\n      if (product) {\n        productId = product._id;\n      }\n    }\n\n    ReactionProduct.setCurrentVariant(variantId);\n  },\n\n  /**\n   * @method getProductPriceRange\n   * @memberof Catalog\n   * @summary get price range of a product\n   * if only one price available, return it\n   * otherwise return a string range\n   * @todo move all this methods this to export function after 1.3\n   * @param {String} [productId] - current product _id\n   * @return {Object} range, min, max\n   */\n  getProductPriceRange: function (productId) {\n    var _this = this;\n\n    var product = applyProductRevision(Products.findOne(productId));\n\n    if (!product) {\n      return {\n        range: \"0\",\n        min: 0,\n        max: 0\n      };\n    }\n\n    var variants = this.getTopVariants(product._id); // if we have variants we have a price range.\n    // this processing will default on the server\n\n    var visibileVariant = variants.filter(function (variant) {\n      return variant.isVisible === true;\n    });\n\n    if (visibileVariant.length > 0) {\n      var variantPrices = [];\n      variants.forEach(function (variant) {\n        if (variant.isVisible === true) {\n          var range = _this.getVariantPriceRange(variant._id);\n\n          if (typeof range === \"string\") {\n            var firstPrice = parseFloat(range.substr(0, range.indexOf(\" \")));\n            var lastPrice = parseFloat(range.substr(range.lastIndexOf(\" \") + 1));\n            variantPrices.push(firstPrice, lastPrice);\n          } else {\n            variantPrices.push(range);\n          }\n        } else {\n          variantPrices.push(0, 0);\n        }\n      });\n\n      var priceMin = _min(variantPrices);\n\n      var priceMax = _max(variantPrices);\n\n      var priceRange = priceMin + \" - \" + priceMax; // if we don't have a range\n\n      if (priceMin === priceMax) {\n        priceRange = priceMin.toString();\n      }\n\n      return {\n        range: priceRange,\n        min: priceMin,\n        max: priceMax\n      };\n    }\n\n    if (!product.price) {\n      return {\n        range: \"0\",\n        min: 0,\n        max: 0\n      };\n    } // if we have no variants subscribed to (client)\n    // we'll get the price object previously from the product\n\n\n    return product.price;\n  },\n\n  /**\n   * @method getVariantPriceRange\n   * @memberof Catalog\n   * @summary get price range of a variant if it has child options.\n   * if no child options, return main price value\n   * @todo remove string return and replace with object\n   * @param {String} [variantId] - current variant _Id\n   * @return {String} formatted price or price range\n   */\n  getVariantPriceRange: function (variantId) {\n    var children = this.getVariants(variantId);\n    var visibleChildren = children.filter(function (child) {\n      return child.isVisible;\n    });\n\n    switch (visibleChildren.length) {\n      case 0:\n        {\n          var topVariant = applyProductRevision(Products.findOne(variantId)); // topVariant could be undefined when we removing last top variant\n\n          return topVariant && topVariant.price;\n        }\n\n      case 1:\n        {\n          return visibleChildren[0].price;\n        }\n\n      default:\n        {\n          var priceMin = Number.POSITIVE_INFINITY;\n          var priceMax = Number.NEGATIVE_INFINITY;\n          children.forEach(function (child) {\n            if (child.isVisible === true) {\n              if (child.price < priceMin) {\n                priceMin = child.price;\n              }\n\n              if (child.price > priceMax) {\n                priceMax = child.price;\n              }\n            }\n          });\n\n          if (priceMin === priceMax) {\n            // TODO check impact on i18n/formatPrice from moving return to string\n            return priceMin.toString();\n          }\n\n          return priceMin + \" - \" + priceMax;\n        }\n    }\n  },\n\n  /**\n   * @method getVariantQuantity\n   * @memberof Catalog\n   * @description calculate a sum of descendants `inventoryQuantity`\n   * @param {Object} variant - top-level variant\n   * @return {Number} summary of options quantity\n   */\n  getVariantQuantity: function (variant) {\n    var options = this.getVariants(variant._id);\n\n    if (options && options.length) {\n      return options.reduce(function (sum, option) {\n        return sum + parseInt(option.inventoryQuantity, 10) || 0;\n      }, 0);\n    }\n\n    return variant.inventoryQuantity || 0;\n  },\n\n  /**\n   * @method getPublishedOrRevision\n   * @memberof Catalog\n   * @description return top product revision if available\n   * @param {Object} product product or variant document\n   * @return {Object} product document\n   */\n  getPublishedOrRevision: function (product) {\n    return applyProductRevision(product);\n  },\n\n  /**\n  * @method getProduct\n  * @method\n  * @memberof ReactionProduct\n  * @summary Get product object. Could be useful for products and for top level variants\n  * @param {String} [id] - product _id\n  * @return {Object} Product data\n  */\n  getProduct: function (id) {\n    return Products.findOne(id);\n  },\n\n  /**\n   * @method getVariants\n   * @memberof Catalog\n   * @description Get all parent variants\n   * @summary could be useful for products and for top level variants\n   * @param {String} [id] - product _id\n   * @param {String} [type] - type of variant\n   * @return {Array} Parent variants or empty array\n   */\n  getVariants: function (id, type) {\n    return Products.find({\n      ancestors: {\n        $in: [id]\n      },\n      type: type || \"variant\"\n    }).map(this.getPublishedOrRevision);\n  },\n\n  /**\n   * @method getVariantParent\n   * @memberof Catalog\n   * @description Get direct parent variant\n   * @summary could be useful for lower level variants to get direct parents\n   * @param {Object} [variant] - product / variant object\n   * @return {Array} Parent variant or empty\n   */\n  getVariantParent: function (variant) {\n    var parent = Products.findOne({\n      _id: {\n        $in: variant.ancestors\n      },\n      type: \"variant\"\n    });\n    return this.getPublishedOrRevision(parent);\n  },\n\n  /**\n   * @method getSiblings\n   * @memberof Catalog\n   * @description Get all sibling variants - variants with the same ancestor tree\n   * @summary could be useful for child variants relationships with top-level variants\n   * @param {Object} [variant] - product / variant object\n   * @param {String} [type] - type of variant\n   * @param {Boolean} [includeSelf] - include current variant in results\n   * @return {Array} Sibling variants or empty array\n   */\n  getSiblings: function (variant, type) {\n    return Products.find({\n      ancestors: variant.ancestors,\n      type: type || \"variant\"\n    }).map(this.getPublishedOrRevision);\n  },\n\n  /**\n   * @method getTopVariants\n   * @memberof Catalog\n   * @description Get only product top level variants\n   * @param {String} [id] - product _id\n   * @return {Array} Product top level variants or empty array\n   */\n  getTopVariants: function (id) {\n    return Products.find({\n      ancestors: [id],\n      type: \"variant\"\n    }).map(this.getPublishedOrRevision);\n  }\n});","map":{"version":3,"sources":["lib/api/catalog.js"],"names":["_max","module","watch","require","v","_min","Products","ReactionProduct","applyProductRevision","exportDefault","setProduct","currentProductId","currentVariantId","productId","variantId","match","product","findOne","handle","toLowerCase","_id","setCurrentVariant","getProductPriceRange","range","min","max","variants","getTopVariants","visibileVariant","filter","variant","isVisible","length","variantPrices","forEach","getVariantPriceRange","firstPrice","parseFloat","substr","indexOf","lastPrice","lastIndexOf","push","priceMin","priceMax","priceRange","toString","price","children","getVariants","visibleChildren","child","topVariant","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","getVariantQuantity","options","reduce","sum","option","parseInt","inventoryQuantity","getPublishedOrRevision","getProduct","id","type","find","ancestors","$in","map","getVariantParent","parent","getSiblings"],"mappings":"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","sourcesContent":["import _ from \"lodash\";\nimport { Products } from \"/lib/collections\";\nimport { ReactionProduct } from \"/lib/api\";\nimport { applyProductRevision } from \"/lib/api/products\";\n\n/**\n * @file Catalog methods\n *\n * @namespace Catalog\n */\n\nexport default {\n  /**\n   * @method setProduct\n   * @memberof Catalog\n   * @summary method to set default/parameterized product variant\n   * @param {String} currentProductId - set current productId\n   * @param {String} currentVariantId - set current variantId\n   * @return {undefined} return nothing, sets in session\n   */\n  setProduct(currentProductId, currentVariantId) {\n    let productId = currentProductId;\n    const variantId = currentVariantId;\n    if (!productId.match(/^[A-Za-z0-9]{17}$/)) {\n      const product = Products.findOne({\n        handle: productId.toLowerCase()\n      });\n      if (product) {\n        productId = product._id;\n      }\n    }\n    ReactionProduct.setCurrentVariant(variantId);\n  },\n\n  /**\n   * @method getProductPriceRange\n   * @memberof Catalog\n   * @summary get price range of a product\n   * if only one price available, return it\n   * otherwise return a string range\n   * @todo move all this methods this to export function after 1.3\n   * @param {String} [productId] - current product _id\n   * @return {Object} range, min, max\n   */\n  getProductPriceRange(productId) {\n    const product = applyProductRevision(Products.findOne(productId));\n    if (!product) {\n      return {\n        range: \"0\",\n        min: 0,\n        max: 0\n      };\n    }\n\n    const variants = this.getTopVariants(product._id);\n    // if we have variants we have a price range.\n    // this processing will default on the server\n    const visibileVariant = variants.filter((variant) => variant.isVisible === true);\n\n    if (visibileVariant.length > 0) {\n      const variantPrices = [];\n      variants.forEach((variant) => {\n        if (variant.isVisible === true) {\n          const range = this.getVariantPriceRange(variant._id);\n          if (typeof range === \"string\") {\n            const firstPrice = parseFloat(range.substr(0, range.indexOf(\" \")));\n            const lastPrice = parseFloat(range.substr(range.lastIndexOf(\" \") + 1));\n            variantPrices.push(firstPrice, lastPrice);\n          } else {\n            variantPrices.push(range);\n          }\n        } else {\n          variantPrices.push(0, 0);\n        }\n      });\n      const priceMin = _.min(variantPrices);\n      const priceMax = _.max(variantPrices);\n      let priceRange = `${priceMin} - ${priceMax}`;\n      // if we don't have a range\n      if (priceMin === priceMax) {\n        priceRange = priceMin.toString();\n      }\n      return {\n        range: priceRange,\n        min: priceMin,\n        max: priceMax\n      };\n    }\n\n    if (!product.price) {\n      return {\n        range: \"0\",\n        min: 0,\n        max: 0\n      };\n    }\n\n    // if we have no variants subscribed to (client)\n    // we'll get the price object previously from the product\n    return product.price;\n  },\n\n  /**\n   * @method getVariantPriceRange\n   * @memberof Catalog\n   * @summary get price range of a variant if it has child options.\n   * if no child options, return main price value\n   * @todo remove string return and replace with object\n   * @param {String} [variantId] - current variant _Id\n   * @return {String} formatted price or price range\n   */\n  getVariantPriceRange(variantId) {\n    const children = this.getVariants(variantId);\n    const visibleChildren = children.filter((child) => child.isVisible);\n\n    switch (visibleChildren.length) {\n      case 0: {\n        const topVariant = applyProductRevision(Products.findOne(variantId));\n        // topVariant could be undefined when we removing last top variant\n        return topVariant && topVariant.price;\n      }\n      case 1: {\n        return visibleChildren[0].price;\n      }\n      default: {\n        let priceMin = Number.POSITIVE_INFINITY;\n        let priceMax = Number.NEGATIVE_INFINITY;\n\n        children.forEach((child) => {\n          if (child.isVisible === true) {\n            if (child.price < priceMin) {\n              priceMin = child.price;\n            }\n            if (child.price > priceMax) {\n              priceMax = child.price;\n            }\n          }\n        });\n\n        if (priceMin === priceMax) {\n          // TODO check impact on i18n/formatPrice from moving return to string\n          return priceMin.toString();\n        }\n        return `${priceMin} - ${priceMax}`;\n      }\n    }\n  },\n\n  /**\n   * @method getVariantQuantity\n   * @memberof Catalog\n   * @description calculate a sum of descendants `inventoryQuantity`\n   * @param {Object} variant - top-level variant\n   * @return {Number} summary of options quantity\n   */\n  getVariantQuantity(variant) {\n    const options = this.getVariants(variant._id);\n    if (options && options.length) {\n      return options.reduce((sum, option) =>\n        sum + parseInt(option.inventoryQuantity, 10) || 0, 0);\n    }\n    return variant.inventoryQuantity || 0;\n  },\n\n  /**\n   * @method getPublishedOrRevision\n   * @memberof Catalog\n   * @description return top product revision if available\n   * @param {Object} product product or variant document\n   * @return {Object} product document\n   */\n  getPublishedOrRevision(product) {\n    return applyProductRevision(product);\n  },\n\n  /**\n  * @method getProduct\n  * @method\n  * @memberof ReactionProduct\n  * @summary Get product object. Could be useful for products and for top level variants\n  * @param {String} [id] - product _id\n  * @return {Object} Product data\n  */\n  getProduct(id) {\n    return Products.findOne(id);\n  },\n\n  /**\n   * @method getVariants\n   * @memberof Catalog\n   * @description Get all parent variants\n   * @summary could be useful for products and for top level variants\n   * @param {String} [id] - product _id\n   * @param {String} [type] - type of variant\n   * @return {Array} Parent variants or empty array\n   */\n  getVariants(id, type) {\n    return Products.find({\n      ancestors: { $in: [id] },\n      type: type || \"variant\"\n    }).map(this.getPublishedOrRevision);\n  },\n\n  /**\n   * @method getVariantParent\n   * @memberof Catalog\n   * @description Get direct parent variant\n   * @summary could be useful for lower level variants to get direct parents\n   * @param {Object} [variant] - product / variant object\n   * @return {Array} Parent variant or empty\n   */\n  getVariantParent(variant) {\n    const parent = Products.findOne({\n      _id: { $in: variant.ancestors },\n      type: \"variant\"\n    });\n    return this.getPublishedOrRevision(parent);\n  },\n\n  /**\n   * @method getSiblings\n   * @memberof Catalog\n   * @description Get all sibling variants - variants with the same ancestor tree\n   * @summary could be useful for child variants relationships with top-level variants\n   * @param {Object} [variant] - product / variant object\n   * @param {String} [type] - type of variant\n   * @param {Boolean} [includeSelf] - include current variant in results\n   * @return {Array} Sibling variants or empty array\n   */\n  getSiblings(variant, type) {\n    return Products.find({\n      ancestors: variant.ancestors,\n      type: type || \"variant\"\n    }).map(this.getPublishedOrRevision);\n  },\n\n  /**\n   * @method getTopVariants\n   * @memberof Catalog\n   * @description Get only product top level variants\n   * @param {String} [id] - product _id\n   * @return {Array} Product top level variants or empty array\n   */\n  getTopVariants(id) {\n    return Products.find({\n      ancestors: [id],\n      type: \"variant\"\n    }).map(this.getPublishedOrRevision);\n  }\n};\n"]},"sourceType":"script","hash":"3a2caa9b02bcd6c01dbc7d182a275f8360692029"}
