{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$1$2","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"polyfill":false,"useBuiltIns":true}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"ast":true,"babelrc":false,"sourceFileName":"imports/plugins/included/connectors-shopify/server/methods/import/products.js","filename":"imports/plugins/included/connectors-shopify/server/methods/import/products.js","sourceMaps":true,"envName":"development","cwd":"/Users/estebandev/test-knowledge","passPerPreset":false,"presets":[],"parserOpts":{"sourceType":"module","sourceFileName":"imports/plugins/included/connectors-shopify/server/methods/import/products.js","plugins":["jsx","jsx","flow","flow","objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties"]},"generatorOpts":{"filename":"imports/plugins/included/connectors-shopify/server/methods/import/products.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"imports/plugins/included/connectors-shopify/server/methods/import/products.js"}},"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/builtin/interopRequireDefault\");\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/builtin/objectSpread\"));\n\nconst module1 = module;\nmodule1.export({\n  methods: () => methods\n});\nlet Shopify;\nmodule1.watch(require(\"shopify-api-node\"), {\n  default(v) {\n    Shopify = v;\n  }\n\n}, 0);\nlet Job;\nmodule1.watch(require(\"/imports/plugins/core/job-collection/lib\"), {\n  Job(v) {\n    Job = v;\n  }\n\n}, 1);\nlet Meteor;\nmodule1.watch(require(\"meteor/meteor\"), {\n  Meteor(v) {\n    Meteor = v;\n  }\n\n}, 2);\nlet Logger, Reaction;\nmodule1.watch(require(\"/server/api\"), {\n  Logger(v) {\n    Logger = v;\n  },\n\n  Reaction(v) {\n    Reaction = v;\n  }\n\n}, 3);\nlet check, Match;\nmodule1.watch(require(\"meteor/check\"), {\n  check(v) {\n    check = v;\n  },\n\n  Match(v) {\n    Match = v;\n  }\n\n}, 4);\nlet Products, Jobs, Tags;\nmodule1.watch(require(\"/lib/collections\"), {\n  Products(v) {\n    Products = v;\n  },\n\n  Jobs(v) {\n    Jobs = v;\n  },\n\n  Tags(v) {\n    Tags = v;\n  }\n\n}, 5);\nlet getApiInfo;\nmodule1.watch(require(\"../api/api\"), {\n  getApiInfo(v) {\n    getApiInfo = v;\n  }\n\n}, 6);\nlet connectorsRoles;\nmodule1.watch(require(\"../../lib/roles\"), {\n  connectorsRoles(v) {\n    connectorsRoles = v;\n  }\n\n}, 7);\nlet importImages;\nmodule1.watch(require(\"../../jobs/image-import\"), {\n  importImages(v) {\n    importImages = v;\n  }\n\n}, 8);\n\n/**\n * @file Shopify connector import product method\n *       contains methods and helpers for setting up and removing synchronization between\n *       a Shopify store and a Reaction shop\n * @module connectors-shopify\n */\n\n/**\n * Transforms a Shopify product into a Reaction product.\n * @private\n * @method createReactionProductFromShopifyProduct\n * @param  {object} options Options object\n * @param  {object} options.shopifyProduct the Shopify product object\n * @param  {string} options.shopId The shopId we're importing for\n * @param  {array} options.hashtags An array of hashtag strings that should be attached to this product.\n * @return {object} An object that fits the `Product` schema\n *\n * @todo consider abstracting private Shopify import helpers into a helpers file\n */\nfunction createReactionProductFromShopifyProduct(options) {\n  const {\n    shopifyProduct,\n    shopId,\n    hashtags\n  } = options;\n  const reactionProduct = {\n    ancestors: [],\n    createdAt: new Date(),\n    description: shopifyProduct.body_html.replace(/(<([^>]+)>)/ig, \"\"),\n    // Strip HTML\n    handle: shopifyProduct.handle,\n    hashtags,\n    isDeleted: false,\n    isVisible: false,\n    isSoldOut: false,\n    isLowQuantity: false,\n    isBackorder: false,\n    metafields: [],\n    pageTitle: shopifyProduct.pageTitle,\n    price: {\n      range: \"0\"\n    },\n    productType: shopifyProduct.product_type,\n    requiresShipping: true,\n    shopId,\n    // set shopId to active shopId;\n    shopifyId: shopifyProduct.id.toString(),\n    // save it here to make sync lookups cheaper\n    template: \"productDetailSimple\",\n    title: shopifyProduct.title,\n    type: \"simple\",\n    updatedAt: new Date(),\n    vendor: shopifyProduct.vendor,\n    workflow: {\n      status: \"new\",\n      workflow: [\"imported\"]\n    },\n    skipRevision: true\n  }; // Add shopify options to meta fields as is.\n\n  if (Array.isArray(shopifyProduct.options)) {\n    shopifyProduct.options.forEach(option => {\n      reactionProduct.metafields.push({\n        scope: \"shopify\",\n        key: option.name,\n        value: option.values.join(\", \"),\n        namespace: \"options\"\n      });\n    });\n  }\n\n  return reactionProduct;\n}\n/**\n * Transforms a Shopify variant into a Reaction variant.\n * @private\n * @method createReactionVariantFromShopifyVariant\n * @param  {object} options { shopifyVariant, variant, index, ancestors, shopId }\n * @return {object} An object that fits the `ProductVariant` schema\n */\n\n\nfunction createReactionVariantFromShopifyVariant(options) {\n  const {\n    shopifyVariant,\n    variant,\n    index,\n    ancestors,\n    shopId\n  } = options;\n  const reactionVariant = {\n    ancestors,\n    barcode: shopifyVariant.barcode,\n    compareAtPrice: shopifyVariant.compare_at_price,\n    createdAt: new Date(),\n    height: 0,\n    index,\n    inventoryManagement: true,\n    inventoryPolicy: shopifyVariant.inventory_policy === \"deny\",\n    inventoryQuantity: shopifyVariant.inventory_quantity >= 0 ? shopifyVariant.inventory_quantity : 0,\n    isDeleted: false,\n    isVisible: true,\n    length: 0,\n    lowInventoryWarningThreshold: 0,\n    metafields: [],\n    optionTitle: variant,\n    price: parseFloat(shopifyVariant.price),\n    requiresShipping: shopifyVariant.requires_shipping,\n    shopId,\n    shopifyId: shopifyVariant.id.toString(),\n    // Save for easy sync lookups\n    sku: shopifyVariant.sku,\n    taxable: true,\n    taxCode: \"0000\",\n    title: variant,\n    type: \"variant\",\n    updatedAt: new Date(),\n    weight: normalizeWeight(shopifyVariant.grams),\n    weightInGrams: shopifyVariant.grams,\n    width: 0,\n    workflow: {\n      status: \"synced\",\n      workflow: [\"imported\"]\n    },\n    skipRevision: true\n  };\n\n  if (shopifyVariant.inventory_management === null) {\n    reactionVariant.inventoryQuantity = 0;\n    reactionVariant.inventoryManagement = false;\n  }\n\n  return reactionVariant;\n}\n/**\n * Finds the images associated with a particular shopify variant\n * @private\n * @method findVariantImages\n * @param  {number} shopifyVariantId The variant `id` from shopify\n * @param  {array} images An array of image objects from a Shopify product\n * @return {array} Returns an array of image objects that match the passed shopifyVariantId\n */\n\n\nfunction findVariantImages(shopifyVariantId, images) {\n  return images.filter(imageObj => imageObj.variant_ids.indexOf(shopifyVariantId) !== -1);\n}\n/**\n * Finds the images associated with a particular shopify variant\n * @method findProductImages\n * @private\n * @param  {number} shopifyProductId The product `id` from shopify\n * @param  {array} images An array of image objects from a Shopify product\n * @return {array} Returns an array of image objects that match the passed shopifyProductId\n */\n\n\nfunction findProductImages(shopifyProductId, images) {\n  return images.filter(imageObj => imageObj.product_id === shopifyProductId);\n}\n/**\n * cache all existing tags to memory {slug => id} so that when we're importing products we can\n * lookup tags without a database call.\n * @method createTagCache\n * @private\n * @return {object} Dictionary of tag slugs mapping to the associated _id\n * @todo: For apps with large collections of tags (5k+), this may be less desirable than checking each tag against mongo\n *        That would cause each product tag we find to hit the database at least once. We could make this optional\n */\n\n\nfunction createTagCache() {\n  return Tags.find({}).fetch().reduce((cache, tag) => {\n    if (!cache[tag.slug]) {\n      cache[tag.slug] = tag._id;\n    }\n\n    return cache;\n  }, {});\n}\n/**\n * Finds and returns arrays of option values for each of Shopify's option layers\n * returns an object consisting of the following three values:\n * shopifyVariants representing the first option on the shopify product (`option1` in the variant)\n * shopifyOptions representing the second option on the shopify product (`option2` in the variant)\n * shopifyTernary representing the third option on the shopify product (`option3` in the variant)\n * any of these will return undefined if the product does not have an option at that layer.\n * @private\n * @method getShopifyVariantsAndOptions\n * @param  {object} shopifyProduct The shopify product we are importing\n * @return {object} returns an object consisting of shopifyVariants, shopifyOptions, and shopifyTernaryOptions\n */\n\n\nfunction getShopifyVariantsAndOptions(shopifyProduct) {\n  let shopifyVariants;\n  let shopifyOptions;\n  let shopifyTernaryOptions; // Get variant and option details\n\n  if (shopifyProduct.options && Array.isArray(shopifyProduct.options)) {\n    // This product has variants\n    if (shopifyProduct.options.length > 0) {\n      shopifyVariants = [...shopifyProduct.options[0].values];\n    } // This product has options\n\n\n    if (shopifyProduct.options.length > 1) {\n      shopifyOptions = [...shopifyProduct.options[1].values];\n    }\n\n    if (shopifyProduct.options.length > 2) {\n      shopifyTernaryOptions = [...shopifyProduct.options[2].values];\n    }\n  }\n\n  return {\n    shopifyVariants,\n    shopifyOptions,\n    shopifyTernaryOptions\n  };\n}\n/**\n * Transforms a weight in grams to a weight in the shop's default unitsOfMeasure\n * @private\n * @method normalizeWeight\n * @param  {number} weight weight of the product in grams\n * @return {number} weight of the product in the shop's default unitsOfMeasure\n * @todo get store unitsOfMeasure, convert to store unitsOfMeasure from grams, return converted weight\n */\n\n\nfunction normalizeWeight(weight) {\n  return weight;\n}\n/**\n * Creates a new job to save an image from a given url\n * Saves an image from a url to the Collection FS image storage location\n * (default: Mongo GridFS)\n * @private\n * @method saveImage\n * @param  {string}  url url of the image to save\n * @param  {object}  metadata metadata to save with the image\n * @return {undefined}\n */\n\n\nfunction saveImage(url, metadata) {\n  new Job(Jobs, \"connectors/shopify/import/image\", {\n    url,\n    metadata\n  }).priority(\"normal\").retry({\n    retries: 5,\n    wait: 5000,\n    backoff: \"exponential\" // delay by twice as long for each subsequent retry\n\n  }).save();\n}\n\nconst methods = {\n  /**\n   * Imports products for the active Reaction Shop from Shopify with the API credentials setup for that shop.\n   *\n   * @async\n   * @method connectors/shopify/import/products\n   * @param {object} options An object of options for the shopify API call. Available options here: https://help.shopify.com/api/reference/product#index\n   * @returns {array} An array of the Reaction product _ids (including variants and options) that were created.\n   */\n  \"connectors/shopify/import/products\"(options) {\n    return Promise.asyncApply(() => {\n      check(options, Match.Maybe(Object));\n\n      if (!Reaction.hasPermission(connectorsRoles)) {\n        throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n      }\n\n      const apiCreds = getApiInfo();\n      const shopify = new Shopify(apiCreds);\n      const shopId = Reaction.getShopId();\n      const limit = 50; // Shopify returns a maximum of 250 results per request\n\n      const tagCache = createTagCache();\n      const ids = [];\n      const opts = Object.assign({}, {\n        published_status: \"published\",\n        limit\n      }, (0, _objectSpread2.default)({}, options));\n\n      try {\n        const productCount = Promise.await(shopify.product.count());\n        const numPages = Math.ceil(productCount / limit);\n        const pages = [...Array(numPages).keys()];\n        Logger.info(`Shopify Connector is preparing to import ${productCount} products`);\n\n        for (const page of pages) {\n          Logger.debug(`Importing page ${page + 1} of ${numPages} - each page has ${limit} products`);\n          const shopifyProducts = Promise.await(shopify.product.list((0, _objectSpread2.default)({}, opts, {\n            page\n          }))); // eslint-disable-line no-await-in-loop\n\n          for (const shopifyProduct of shopifyProducts) {\n            if (!Products.findOne({\n              shopifyId: shopifyProduct.id\n            }, {\n              fields: {\n                _id: 1\n              }\n            })) {\n              Logger.debug(`Importing ${shopifyProduct.title}`);\n              const price = {\n                min: null,\n                max: null,\n                range: \"0.00\"\n              };\n              let isSoldOut = true;\n              let isBackorder = false; // Get tags from shopify and register them if they don't exist.\n              // push tag Id's into our hashtags array for use in the product\n              // We can't load all tags beforehand because Shopify doesn't have a tags API\n\n              const hashtags = [];\n              const shopifyTags = shopifyProduct.tags.split(\",\");\n\n              for (const tag of shopifyTags) {\n                if (tag !== \"\") {\n                  const normalizedTag = {\n                    name: tag,\n                    slug: Reaction.getSlug(tag),\n                    shopId,\n                    isTopLevel: false,\n                    updatedAt: new Date(),\n                    createdAt: new Date()\n                  }; // If we have a cached tag for this slug, we don't need to create a new one\n\n                  if (!tagCache[normalizedTag.slug]) {\n                    // this tag doesn't exist, create it, add it to our tag cache\n                    normalizedTag._id = Tags.insert(normalizedTag);\n                    tagCache[normalizedTag.slug] = normalizedTag._id;\n                  } // push the tag's _id into hashtags from the cache\n\n\n                  hashtags.push(tagCache[normalizedTag.slug]);\n                }\n              } // Get Shopify variants, options and ternary options\n\n\n              const {\n                shopifyVariants,\n                shopifyOptions,\n                shopifyTernaryOptions\n              } = getShopifyVariantsAndOptions(shopifyProduct); // Setup reaction product\n\n              const reactionProduct = createReactionProductFromShopifyProduct({\n                shopifyProduct,\n                shopId,\n                hashtags\n              }); // Insert product, save id\n\n              const reactionProductId = Products.insert(reactionProduct, {\n                selector: {\n                  type: \"simple\"\n                },\n                publish: true\n              });\n              ids.push(reactionProductId); // Save the primary image to the grid and as priority 0\n\n              saveImage(shopifyProduct.image.src, {\n                ownerId: Meteor.userId(),\n                productId: reactionProductId,\n                variantId: reactionProductId,\n                shopId,\n                priority: 0,\n                toGrid: 1\n              }); // Save all remaining product images to product\n\n              const productImages = findProductImages(shopifyProduct.id, shopifyProduct.images);\n\n              for (const productImage of productImages) {\n                if (shopifyProduct.image.id !== productImage.id) {\n                  saveImage(productImage.src, {\n                    ownerId: Meteor.userId(),\n                    productId: reactionProductId,\n                    variantId: reactionProductId,\n                    shopId,\n                    priority: productImage.position,\n                    // Shopify index positions starting at 1.\n                    toGrid: 0\n                  });\n                }\n              } // If variantLabel exists, we have at least one variant\n\n\n              if (shopifyVariants) {\n                Logger.debug(`Importing ${shopifyProduct.title} variants`);\n                shopifyVariants.forEach((variant, i) => {\n                  const shopifyVariant = shopifyProduct.variants.find(v => v.option1 === variant);\n\n                  if (shopifyVariant) {\n                    // create the Reaction variant\n                    const reactionVariant = createReactionVariantFromShopifyVariant({\n                      shopifyVariant,\n                      variant,\n                      index: i,\n                      ancestors: [reactionProductId],\n                      shopId\n                    }); // insert the Reaction variant\n\n                    const reactionVariantId = Products.insert(reactionVariant, {\n                      publish: true\n                    });\n                    ids.push(reactionVariantId); // If we have shopify options, create reaction options\n\n                    if (shopifyOptions) {\n                      Logger.debug(`Importing ${shopifyProduct.title} ${variant} options`);\n                      shopifyOptions.forEach((option, j) => {\n                        // Find the option that nests under our current variant.\n                        const shopifyOption = shopifyProduct.variants.find(o => o.option1 === variant && o.option2 === option);\n\n                        if (shopifyOption) {\n                          const reactionOption = createReactionVariantFromShopifyVariant({\n                            shopifyVariant: shopifyOption,\n                            variant: option,\n                            index: j,\n                            ancestors: [reactionProductId, reactionVariantId],\n                            shopId\n                          });\n                          const reactionOptionId = Products.insert(reactionOption, {\n                            type: \"variant\"\n                          });\n                          ids.push(reactionOptionId);\n                          Logger.debug(`Imported ${shopifyProduct.title} ${variant}/${option}`); // Update max price\n\n                          if (price.max === null || price.max < reactionOption.price) {\n                            price.max = reactionOption.price;\n                          } // Update min price\n\n\n                          if (price.min === null || price.min > reactionOption.price) {\n                            price.min = reactionOption.price;\n                          } // Update denormalized sold out status\n\n\n                          if (isSoldOut && reactionOption.inventoryQuantity > 0) {\n                            isSoldOut = false;\n                          } // Update denormalized backordered status\n                          // if at least one variant has inventoryPolicy = false, then the product isBackorder\n\n\n                          if (!isBackorder) {\n                            isBackorder = !reactionOption.inventoryPolicy;\n                          } // Save all relevant variant images to our option\n\n\n                          const optionImages = findVariantImages(shopifyOption.id, shopifyProduct.images);\n\n                          for (const [index, optionImage] of optionImages.entries()) {\n                            saveImage(optionImage.src, {\n                              ownerId: Meteor.userId(),\n                              productId: reactionProductId,\n                              variantId: reactionOptionId,\n                              shopId,\n                              priority: 1,\n                              toGrid: index === 0 ? 1 : 0 // We save the first of each variant image to the grid\n\n                            });\n                          } // THIS LOOP INSERTS PRODUCTS A LEVEL DEEPER THAN THE REACTION\n                          // UI CURRENTLY SUPPORTS. IF YOUR SHOPIFY STORE USES THREE OPTION\n                          // LEVELS, YOU WILL NEED TO BUILD UI SUPPORT FOR THAT.\n\n\n                          if (shopifyTernaryOptions) {\n                            Logger.warn(\"Importing shopify product with 3 options. The Reaction UI does not currently support this.\");\n                            Logger.debug(`Importing ${shopifyProduct.title} ${variant} ${option} options`);\n                            shopifyTernaryOptions.forEach((ternaryOption, k) => {\n                              // Find the option that nests under our current variant.\n                              const shopifyTernaryOption = shopifyProduct.variants.find(o => o.option1 === variant && o.option2 === option && o.option3 === ternaryOption); // eslint-disable-line max-len\n\n                              if (shopifyTernaryOption) {\n                                const reactionTernaryOption = createReactionVariantFromShopifyVariant({\n                                  shopifyVariant: shopifyTernaryOption,\n                                  variant: ternaryOption,\n                                  index: k,\n                                  ancestors: [reactionProductId, reactionVariantId, reactionOptionId],\n                                  shopId\n                                });\n                                const reactionTernaryOptionId = Products.insert(reactionTernaryOption, {\n                                  type: \"variant\"\n                                });\n                                ids.push(reactionTernaryOptionId);\n                                Logger.debug(`Imported ${shopifyProduct.title} ${variant}/${option}/${ternaryOption}`); // Update max price\n\n                                if (price.max === null || price.max < reactionTernaryOption.price) {\n                                  price.max = reactionTernaryOption.price;\n                                } // Update min price\n\n\n                                if (price.min === null || price.min > reactionTernaryOption.price) {\n                                  price.min = reactionTernaryOption.price;\n                                } // Update denormalized sold out status\n\n\n                                if (isSoldOut && reactionTernaryOption.inventoryQuantity > 0) {\n                                  isSoldOut = false;\n                                } // Update denormalized backordered status\n                                // if at least one variant has inventoryPolicy = false, then the product isBackorder\n\n\n                                if (!isBackorder) {\n                                  isBackorder = !reactionTernaryOption.inventoryPolicy;\n                                } // Save all relevant variant images to our option\n\n\n                                const ternaryOptionImages = findVariantImages(shopifyTernaryOption.id, shopifyProduct.images);\n\n                                for (const [index, ternaryOptionImage] of ternaryOptionImages.entries()) {\n                                  saveImage(ternaryOptionImage.src, {\n                                    ownerId: Meteor.userId(),\n                                    productId: reactionProductId,\n                                    variantId: reactionOptionId,\n                                    shopId,\n                                    priority: 1,\n                                    toGrid: index === 0 ? 1 : 0 // We save the first of each variant image to the grid\n\n                                  });\n                                } // So many close parens and brackets. Don't get lost.\n\n                              }\n                            }); // End shopifyTernaryOptions forEach loop\n                          }\n                        }\n                      }); // End shopifyOptions forEach loop\n                    } else {\n                      // Product does not have options, just variants\n                      // Update max price\n                      if (price.max === null || price.max < reactionVariant.price) {\n                        price.max = reactionVariant.price;\n                      } // Update min price\n\n\n                      if (price.min === null || price.min > reactionVariant.price) {\n                        price.min = reactionVariant.price;\n                      } // Update denormalized sold out status\n\n\n                      if (isSoldOut && reactionVariant.inventoryQuantity > 0) {\n                        isSoldOut = false;\n                      } // Update denormalized backordered status\n                      // if at least one variant has inventoryPolicy = false, then the product isBackorder\n\n\n                      if (!isBackorder) {\n                        isBackorder = !reactionVariant.inventoryPolicy;\n                      } // Save all relevant variant images to our variant.\n\n\n                      const variantImages = findVariantImages(shopifyVariant.id, shopifyProduct.images);\n\n                      for (const [index, variantImage] of variantImages.entries()) {\n                        saveImage(variantImage.src, {\n                          ownerId: Meteor.userId(),\n                          productId: reactionProductId,\n                          variantId: reactionVariantId,\n                          shopId,\n                          priority: 1,\n                          toGrid: index === 0 ? 1 : 0 // We save the first of each variant image to the grid\n\n                        });\n                      }\n\n                      Logger.debug(`Imported ${shopifyProduct.title} ${variant}`);\n                    }\n                  }\n                });\n              } // Set final product price\n\n\n              if (price.min !== price.max) {\n                price.range = `${price.min} - ${price.max}`;\n              } else {\n                price.range = `${price.max}`;\n              }\n\n              Products.update({\n                _id: reactionProductId\n              }, {\n                $set: {\n                  price,\n                  isSoldOut,\n                  isBackorder\n                }\n              }, {\n                selector: {\n                  type: \"simple\"\n                },\n                publish: true\n              });\n              Logger.debug(`Product ${shopifyProduct.title} added`);\n            } else {\n              // product already exists check\n              Logger.debug(`Product ${shopifyProduct.title} already exists`);\n            }\n          } // End product loop\n\n        } // End pages loop\n\n\n        Logger.info(`Reaction Shopify Connector has finished importing ${ids.length} products and variants`); // Run jobs to import all queued images;\n\n        importImages();\n        return ids;\n      } catch (error) {\n        Logger.error(\"There was a problem importing your products from Shopify\", error);\n        throw new Meteor.Error(\"There was a problem importing your products from Shopify\", error);\n      }\n    });\n  }\n\n};\nMeteor.methods(methods);","map":{"version":3,"sources":["imports/plugins/included/connectors-shopify/server/methods/import/products.js"],"names":["module1","module","export","methods","Shopify","watch","require","default","v","Job","Meteor","Logger","Reaction","check","Match","Products","Jobs","Tags","getApiInfo","connectorsRoles","importImages","createReactionProductFromShopifyProduct","options","shopifyProduct","shopId","hashtags","reactionProduct","ancestors","createdAt","Date","description","body_html","replace","handle","isDeleted","isVisible","isSoldOut","isLowQuantity","isBackorder","metafields","pageTitle","price","range","productType","product_type","requiresShipping","shopifyId","id","toString","template","title","type","updatedAt","vendor","workflow","status","skipRevision","Array","isArray","forEach","option","push","scope","key","name","value","values","join","namespace","createReactionVariantFromShopifyVariant","shopifyVariant","variant","index","reactionVariant","barcode","compareAtPrice","compare_at_price","height","inventoryManagement","inventoryPolicy","inventory_policy","inventoryQuantity","inventory_quantity","length","lowInventoryWarningThreshold","optionTitle","parseFloat","requires_shipping","sku","taxable","taxCode","weight","normalizeWeight","grams","weightInGrams","width","inventory_management","findVariantImages","shopifyVariantId","images","filter","imageObj","variant_ids","indexOf","findProductImages","shopifyProductId","product_id","createTagCache","find","fetch","reduce","cache","tag","slug","_id","getShopifyVariantsAndOptions","shopifyVariants","shopifyOptions","shopifyTernaryOptions","saveImage","url","metadata","priority","retry","retries","wait","backoff","save","Maybe","Object","hasPermission","Error","apiCreds","shopify","getShopId","limit","tagCache","ids","opts","assign","published_status","productCount","product","count","numPages","Math","ceil","pages","keys","info","page","debug","shopifyProducts","list","findOne","fields","min","max","shopifyTags","tags","split","normalizedTag","getSlug","isTopLevel","insert","reactionProductId","selector","publish","image","src","ownerId","userId","productId","variantId","toGrid","productImages","productImage","position","i","variants","option1","reactionVariantId","j","shopifyOption","o","option2","reactionOption","reactionOptionId","optionImages","optionImage","entries","warn","ternaryOption","k","shopifyTernaryOption","option3","reactionTernaryOption","reactionTernaryOptionId","ternaryOptionImages","ternaryOptionImage","variantImages","variantImage","update","$set","error"],"mappings":"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","sourcesContent":["/* eslint camelcase: 0 */\nimport Shopify from \"shopify-api-node\";\nimport { Job } from \"/imports/plugins/core/job-collection/lib\";\nimport { Meteor } from \"meteor/meteor\";\nimport { Logger, Reaction } from \"/server/api\";\nimport { check, Match } from \"meteor/check\";\nimport { Products, Jobs, Tags } from \"/lib/collections\";\nimport { getApiInfo } from \"../api/api\";\nimport { connectorsRoles } from \"../../lib/roles\";\nimport { importImages } from \"../../jobs/image-import\";\n\n/**\n * @file Shopify connector import product method\n *       contains methods and helpers for setting up and removing synchronization between\n *       a Shopify store and a Reaction shop\n * @module connectors-shopify\n */\n\n/**\n * Transforms a Shopify product into a Reaction product.\n * @private\n * @method createReactionProductFromShopifyProduct\n * @param  {object} options Options object\n * @param  {object} options.shopifyProduct the Shopify product object\n * @param  {string} options.shopId The shopId we're importing for\n * @param  {array} options.hashtags An array of hashtag strings that should be attached to this product.\n * @return {object} An object that fits the `Product` schema\n *\n * @todo consider abstracting private Shopify import helpers into a helpers file\n */\nfunction createReactionProductFromShopifyProduct(options) {\n  const { shopifyProduct, shopId, hashtags } = options;\n  const reactionProduct = {\n    ancestors: [],\n    createdAt: new Date(),\n    description: shopifyProduct.body_html.replace(/(<([^>]+)>)/ig, \"\"), // Strip HTML\n    handle: shopifyProduct.handle,\n    hashtags,\n    isDeleted: false,\n    isVisible: false,\n    isSoldOut: false,\n    isLowQuantity: false,\n    isBackorder: false,\n    metafields: [],\n    pageTitle: shopifyProduct.pageTitle,\n    price: { range: \"0\" },\n    productType: shopifyProduct.product_type,\n    requiresShipping: true,\n    shopId, // set shopId to active shopId;\n    shopifyId: shopifyProduct.id.toString(), // save it here to make sync lookups cheaper\n    template: \"productDetailSimple\",\n    title: shopifyProduct.title,\n    type: \"simple\",\n    updatedAt: new Date(),\n    vendor: shopifyProduct.vendor,\n    workflow: {\n      status: \"new\",\n      workflow: [\"imported\"]\n    },\n    skipRevision: true\n  };\n\n  // Add shopify options to meta fields as is.\n  if (Array.isArray(shopifyProduct.options)) {\n    shopifyProduct.options.forEach((option) => {\n      reactionProduct.metafields.push({\n        scope: \"shopify\",\n        key: option.name,\n        value: option.values.join(\", \"),\n        namespace: \"options\"\n      });\n    });\n  }\n\n  return reactionProduct;\n}\n\n/**\n * Transforms a Shopify variant into a Reaction variant.\n * @private\n * @method createReactionVariantFromShopifyVariant\n * @param  {object} options { shopifyVariant, variant, index, ancestors, shopId }\n * @return {object} An object that fits the `ProductVariant` schema\n */\nfunction createReactionVariantFromShopifyVariant(options) {\n  const { shopifyVariant, variant, index, ancestors, shopId } = options;\n  const reactionVariant = {\n    ancestors,\n    barcode: shopifyVariant.barcode,\n    compareAtPrice: shopifyVariant.compare_at_price,\n    createdAt: new Date(),\n    height: 0,\n    index,\n    inventoryManagement: true,\n    inventoryPolicy: shopifyVariant.inventory_policy === \"deny\",\n    inventoryQuantity: shopifyVariant.inventory_quantity >= 0 ? shopifyVariant.inventory_quantity : 0,\n    isDeleted: false,\n    isVisible: true,\n    length: 0,\n    lowInventoryWarningThreshold: 0,\n    metafields: [],\n    optionTitle: variant,\n    price: parseFloat(shopifyVariant.price),\n    requiresShipping: shopifyVariant.requires_shipping,\n    shopId,\n    shopifyId: shopifyVariant.id.toString(), // Save for easy sync lookups\n    sku: shopifyVariant.sku,\n    taxable: true,\n    taxCode: \"0000\",\n    title: variant,\n    type: \"variant\",\n    updatedAt: new Date(),\n    weight: normalizeWeight(shopifyVariant.grams),\n    weightInGrams: shopifyVariant.grams,\n    width: 0,\n    workflow: {\n      status: \"synced\",\n      workflow: [\"imported\"]\n    },\n    skipRevision: true\n  };\n\n  if (shopifyVariant.inventory_management === null) {\n    reactionVariant.inventoryQuantity = 0;\n    reactionVariant.inventoryManagement = false;\n  }\n\n  return reactionVariant;\n}\n\n/**\n * Finds the images associated with a particular shopify variant\n * @private\n * @method findVariantImages\n * @param  {number} shopifyVariantId The variant `id` from shopify\n * @param  {array} images An array of image objects from a Shopify product\n * @return {array} Returns an array of image objects that match the passed shopifyVariantId\n */\nfunction findVariantImages(shopifyVariantId, images) {\n  return images.filter((imageObj) => imageObj.variant_ids.indexOf(shopifyVariantId) !== -1);\n}\n\n/**\n * Finds the images associated with a particular shopify variant\n * @method findProductImages\n * @private\n * @param  {number} shopifyProductId The product `id` from shopify\n * @param  {array} images An array of image objects from a Shopify product\n * @return {array} Returns an array of image objects that match the passed shopifyProductId\n */\nfunction findProductImages(shopifyProductId, images) {\n  return images.filter((imageObj) => imageObj.product_id === shopifyProductId);\n}\n\n\n/**\n * cache all existing tags to memory {slug => id} so that when we're importing products we can\n * lookup tags without a database call.\n * @method createTagCache\n * @private\n * @return {object} Dictionary of tag slugs mapping to the associated _id\n * @todo: For apps with large collections of tags (5k+), this may be less desirable than checking each tag against mongo\n *        That would cause each product tag we find to hit the database at least once. We could make this optional\n */\nfunction createTagCache() {\n  return Tags.find({}).fetch().reduce((cache, tag) => {\n    if (!cache[tag.slug]) {\n      cache[tag.slug] = tag._id;\n    }\n    return cache;\n  }, {});\n}\n\n\n/**\n * Finds and returns arrays of option values for each of Shopify's option layers\n * returns an object consisting of the following three values:\n * shopifyVariants representing the first option on the shopify product (`option1` in the variant)\n * shopifyOptions representing the second option on the shopify product (`option2` in the variant)\n * shopifyTernary representing the third option on the shopify product (`option3` in the variant)\n * any of these will return undefined if the product does not have an option at that layer.\n * @private\n * @method getShopifyVariantsAndOptions\n * @param  {object} shopifyProduct The shopify product we are importing\n * @return {object} returns an object consisting of shopifyVariants, shopifyOptions, and shopifyTernaryOptions\n */\nfunction getShopifyVariantsAndOptions(shopifyProduct) {\n  let shopifyVariants;\n  let shopifyOptions;\n  let shopifyTernaryOptions;\n  // Get variant and option details\n  if (shopifyProduct.options && Array.isArray(shopifyProduct.options)) {\n    // This product has variants\n    if (shopifyProduct.options.length > 0) {\n      shopifyVariants = [...shopifyProduct.options[0].values];\n    }\n\n    // This product has options\n    if (shopifyProduct.options.length > 1) {\n      shopifyOptions = [...shopifyProduct.options[1].values];\n    }\n\n    if (shopifyProduct.options.length > 2) {\n      shopifyTernaryOptions = [...shopifyProduct.options[2].values];\n    }\n  }\n  return { shopifyVariants, shopifyOptions, shopifyTernaryOptions };\n}\n\n\n/**\n * Transforms a weight in grams to a weight in the shop's default unitsOfMeasure\n * @private\n * @method normalizeWeight\n * @param  {number} weight weight of the product in grams\n * @return {number} weight of the product in the shop's default unitsOfMeasure\n * @todo get store unitsOfMeasure, convert to store unitsOfMeasure from grams, return converted weight\n */\nfunction normalizeWeight(weight) {\n  return weight;\n}\n\n/**\n * Creates a new job to save an image from a given url\n * Saves an image from a url to the Collection FS image storage location\n * (default: Mongo GridFS)\n * @private\n * @method saveImage\n * @param  {string}  url url of the image to save\n * @param  {object}  metadata metadata to save with the image\n * @return {undefined}\n */\nfunction saveImage(url, metadata) {\n  new Job(Jobs, \"connectors/shopify/import/image\", { url, metadata })\n    .priority(\"normal\")\n    .retry({\n      retries: 5,\n      wait: 5000,\n      backoff: \"exponential\" // delay by twice as long for each subsequent retry\n    }).save();\n}\n\nexport const methods = {\n  /**\n   * Imports products for the active Reaction Shop from Shopify with the API credentials setup for that shop.\n   *\n   * @async\n   * @method connectors/shopify/import/products\n   * @param {object} options An object of options for the shopify API call. Available options here: https://help.shopify.com/api/reference/product#index\n   * @returns {array} An array of the Reaction product _ids (including variants and options) that were created.\n   */\n  async \"connectors/shopify/import/products\"(options) {\n    check(options, Match.Maybe(Object));\n    if (!Reaction.hasPermission(connectorsRoles)) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    const apiCreds = getApiInfo();\n    const shopify = new Shopify(apiCreds);\n    const shopId = Reaction.getShopId();\n    const limit = 50; // Shopify returns a maximum of 250 results per request\n    const tagCache = createTagCache();\n    const ids = [];\n    const opts = Object.assign({}, {\n      published_status: \"published\",\n      limit\n    }, { ...options });\n\n    try {\n      const productCount = await shopify.product.count();\n      const numPages = Math.ceil(productCount / limit);\n      const pages = [...Array(numPages).keys()];\n      Logger.info(`Shopify Connector is preparing to import ${productCount} products`);\n\n      for (const page of pages) {\n        Logger.debug(`Importing page ${page + 1} of ${numPages} - each page has ${limit} products`);\n        const shopifyProducts = await shopify.product.list({ ...opts, page }); // eslint-disable-line no-await-in-loop\n        for (const shopifyProduct of shopifyProducts) {\n          if (!Products.findOne({ shopifyId: shopifyProduct.id }, { fields: { _id: 1 } })) {\n            Logger.debug(`Importing ${shopifyProduct.title}`);\n            const price = { min: null, max: null, range: \"0.00\" };\n            let isSoldOut = true;\n            let isBackorder = false;\n\n            // Get tags from shopify and register them if they don't exist.\n            // push tag Id's into our hashtags array for use in the product\n            // We can't load all tags beforehand because Shopify doesn't have a tags API\n            const hashtags = [];\n            const shopifyTags = shopifyProduct.tags.split(\",\");\n            for (const tag of shopifyTags) {\n              if (tag !== \"\") {\n                const normalizedTag = {\n                  name: tag,\n                  slug: Reaction.getSlug(tag),\n                  shopId,\n                  isTopLevel: false,\n                  updatedAt: new Date(),\n                  createdAt: new Date()\n                };\n\n                // If we have a cached tag for this slug, we don't need to create a new one\n                if (!tagCache[normalizedTag.slug]) {\n                  // this tag doesn't exist, create it, add it to our tag cache\n                  normalizedTag._id = Tags.insert(normalizedTag);\n                  tagCache[normalizedTag.slug] = normalizedTag._id;\n                }\n                // push the tag's _id into hashtags from the cache\n                hashtags.push(tagCache[normalizedTag.slug]);\n              }\n            }\n\n            // Get Shopify variants, options and ternary options\n            const { shopifyVariants, shopifyOptions, shopifyTernaryOptions } = getShopifyVariantsAndOptions(shopifyProduct);\n\n            // Setup reaction product\n            const reactionProduct = createReactionProductFromShopifyProduct({ shopifyProduct, shopId, hashtags });\n\n            // Insert product, save id\n            const reactionProductId = Products.insert(reactionProduct, { selector: { type: \"simple\" }, publish: true });\n            ids.push(reactionProductId);\n\n            // Save the primary image to the grid and as priority 0\n            saveImage(shopifyProduct.image.src, {\n              ownerId: Meteor.userId(),\n              productId: reactionProductId,\n              variantId: reactionProductId,\n              shopId,\n              priority: 0,\n              toGrid: 1\n            });\n\n            // Save all remaining product images to product\n            const productImages = findProductImages(shopifyProduct.id, shopifyProduct.images);\n            for (const productImage of productImages) {\n              if (shopifyProduct.image.id !== productImage.id) {\n                saveImage(productImage.src, {\n                  ownerId: Meteor.userId(),\n                  productId: reactionProductId,\n                  variantId: reactionProductId,\n                  shopId,\n                  priority: productImage.position, // Shopify index positions starting at 1.\n                  toGrid: 0\n                });\n              }\n            }\n\n            // If variantLabel exists, we have at least one variant\n            if (shopifyVariants) {\n              Logger.debug(`Importing ${shopifyProduct.title} variants`);\n\n              shopifyVariants.forEach((variant, i) => {\n                const shopifyVariant = shopifyProduct.variants.find((v) => v.option1 === variant);\n\n                if (shopifyVariant) {\n                  // create the Reaction variant\n                  const reactionVariant = createReactionVariantFromShopifyVariant({\n                    shopifyVariant,\n                    variant,\n                    index: i,\n                    ancestors: [reactionProductId],\n                    shopId\n                  });\n\n                  // insert the Reaction variant\n                  const reactionVariantId = Products.insert(reactionVariant, { publish: true });\n                  ids.push(reactionVariantId);\n\n                  // If we have shopify options, create reaction options\n                  if (shopifyOptions) {\n                    Logger.debug(`Importing ${shopifyProduct.title} ${variant} options`);\n                    shopifyOptions.forEach((option, j) => {\n                      // Find the option that nests under our current variant.\n                      const shopifyOption = shopifyProduct.variants.find((o) => o.option1 === variant && o.option2 === option);\n\n                      if (shopifyOption) {\n                        const reactionOption = createReactionVariantFromShopifyVariant({\n                          shopifyVariant: shopifyOption,\n                          variant: option,\n                          index: j,\n                          ancestors: [reactionProductId, reactionVariantId],\n                          shopId\n                        });\n\n                        const reactionOptionId = Products.insert(reactionOption, { type: \"variant\" });\n                        ids.push(reactionOptionId);\n                        Logger.debug(`Imported ${shopifyProduct.title} ${variant}/${option}`);\n\n                        // Update max price\n                        if (price.max === null || price.max < reactionOption.price) {\n                          price.max = reactionOption.price;\n                        }\n\n                        // Update min price\n                        if (price.min === null || price.min > reactionOption.price) {\n                          price.min = reactionOption.price;\n                        }\n\n                        // Update denormalized sold out status\n                        if (isSoldOut && reactionOption.inventoryQuantity > 0) {\n                          isSoldOut = false;\n                        }\n\n                        // Update denormalized backordered status\n                        // if at least one variant has inventoryPolicy = false, then the product isBackorder\n                        if (!isBackorder) {\n                          isBackorder = !reactionOption.inventoryPolicy;\n                        }\n\n                        // Save all relevant variant images to our option\n                        const optionImages = findVariantImages(shopifyOption.id, shopifyProduct.images);\n                        for (const [index, optionImage] of optionImages.entries()) {\n                          saveImage(optionImage.src, {\n                            ownerId: Meteor.userId(),\n                            productId: reactionProductId,\n                            variantId: reactionOptionId,\n                            shopId,\n                            priority: 1,\n                            toGrid: index === 0 ? 1 : 0 // We save the first of each variant image to the grid\n                          });\n                        }\n\n                        // THIS LOOP INSERTS PRODUCTS A LEVEL DEEPER THAN THE REACTION\n                        // UI CURRENTLY SUPPORTS. IF YOUR SHOPIFY STORE USES THREE OPTION\n                        // LEVELS, YOU WILL NEED TO BUILD UI SUPPORT FOR THAT.\n                        if (shopifyTernaryOptions) {\n                          Logger.warn(\"Importing shopify product with 3 options. The Reaction UI does not currently support this.\");\n                          Logger.debug(`Importing ${shopifyProduct.title} ${variant} ${option} options`);\n                          shopifyTernaryOptions.forEach((ternaryOption, k) => {\n                            // Find the option that nests under our current variant.\n                            const shopifyTernaryOption = shopifyProduct.variants.find((o) => o.option1 === variant && o.option2 === option && o.option3 === ternaryOption); // eslint-disable-line max-len\n\n                            if (shopifyTernaryOption) {\n                              const reactionTernaryOption = createReactionVariantFromShopifyVariant({\n                                shopifyVariant: shopifyTernaryOption,\n                                variant: ternaryOption,\n                                index: k,\n                                ancestors: [reactionProductId, reactionVariantId, reactionOptionId],\n                                shopId\n                              });\n\n                              const reactionTernaryOptionId = Products.insert(reactionTernaryOption, { type: \"variant\" });\n                              ids.push(reactionTernaryOptionId);\n                              Logger.debug(`Imported ${shopifyProduct.title} ${variant}/${option}/${ternaryOption}`);\n\n                              // Update max price\n                              if (price.max === null || price.max < reactionTernaryOption.price) {\n                                price.max = reactionTernaryOption.price;\n                              }\n\n                              // Update min price\n                              if (price.min === null || price.min > reactionTernaryOption.price) {\n                                price.min = reactionTernaryOption.price;\n                              }\n\n                              // Update denormalized sold out status\n                              if (isSoldOut && reactionTernaryOption.inventoryQuantity > 0) {\n                                isSoldOut = false;\n                              }\n\n                              // Update denormalized backordered status\n                              // if at least one variant has inventoryPolicy = false, then the product isBackorder\n                              if (!isBackorder) {\n                                isBackorder = !reactionTernaryOption.inventoryPolicy;\n                              }\n\n                              // Save all relevant variant images to our option\n                              const ternaryOptionImages = findVariantImages(shopifyTernaryOption.id, shopifyProduct.images);\n                              for (const [index, ternaryOptionImage] of ternaryOptionImages.entries()) {\n                                saveImage(ternaryOptionImage.src, {\n                                  ownerId: Meteor.userId(),\n                                  productId: reactionProductId,\n                                  variantId: reactionOptionId,\n                                  shopId,\n                                  priority: 1,\n                                  toGrid: index === 0 ? 1 : 0 // We save the first of each variant image to the grid\n                                });\n                              } // So many close parens and brackets. Don't get lost.\n                            }\n                          }); // End shopifyTernaryOptions forEach loop\n                        }\n                      }\n                    }); // End shopifyOptions forEach loop\n                  } else {\n                    // Product does not have options, just variants\n                    // Update max price\n                    if (price.max === null || price.max < reactionVariant.price) {\n                      price.max = reactionVariant.price;\n                    }\n\n                    // Update min price\n                    if (price.min === null || price.min > reactionVariant.price) {\n                      price.min = reactionVariant.price;\n                    }\n\n                    // Update denormalized sold out status\n                    if (isSoldOut && reactionVariant.inventoryQuantity > 0) {\n                      isSoldOut = false;\n                    }\n\n                    // Update denormalized backordered status\n                    // if at least one variant has inventoryPolicy = false, then the product isBackorder\n                    if (!isBackorder) {\n                      isBackorder = !reactionVariant.inventoryPolicy;\n                    }\n\n                    // Save all relevant variant images to our variant.\n                    const variantImages = findVariantImages(shopifyVariant.id, shopifyProduct.images);\n                    for (const [index, variantImage] of variantImages.entries()) {\n                      saveImage(variantImage.src, {\n                        ownerId: Meteor.userId(),\n                        productId: reactionProductId,\n                        variantId: reactionVariantId,\n                        shopId,\n                        priority: 1,\n                        toGrid: index === 0 ? 1 : 0 // We save the first of each variant image to the grid\n                      });\n                    }\n                    Logger.debug(`Imported ${shopifyProduct.title} ${variant}`);\n                  }\n                }\n              });\n            }\n\n            // Set final product price\n            if (price.min !== price.max) {\n              price.range = `${price.min} - ${price.max}`;\n            } else {\n              price.range = `${price.max}`;\n            }\n            Products.update({\n              _id: reactionProductId\n            }, {\n              $set: {\n                price,\n                isSoldOut,\n                isBackorder\n              }\n            }, { selector: { type: \"simple\" }, publish: true });\n\n            Logger.debug(`Product ${shopifyProduct.title} added`);\n          } else { // product already exists check\n            Logger.debug(`Product ${shopifyProduct.title} already exists`);\n          }\n        } // End product loop\n      } // End pages loop\n      Logger.info(`Reaction Shopify Connector has finished importing ${ids.length} products and variants`);\n\n      // Run jobs to import all queued images;\n      importImages();\n      return ids;\n    } catch (error) {\n      Logger.error(\"There was a problem importing your products from Shopify\", error);\n      throw new Meteor.Error(\"There was a problem importing your products from Shopify\", error);\n    }\n  }\n};\n\nMeteor.methods(methods);\n"]},"sourceType":"script","hash":"78b27f4ebc6064572270d22aa9447ef7315ef161"}
